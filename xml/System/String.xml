<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="String.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-efd8310" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5e05b5b2-d481-4262-b7b7-7de7ac2afe074993ba4e4e7b00c32ea64457950617c2fdb97160.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4993ba4e4e7b00c32ea64457950617c2fdb97160</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">df6cf590aa3087f6c7c202712eee781c6a3c8f96</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/07/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Represents text as a sequence of UTF-16 code units.</source>
          <target state="translated">Представляет текст как последовательность из частей кода UTF-16.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A string is a sequential collection of characters that is used to represent text.</source>
          <target state="translated">Строка — это упорядоченная коллекция символов, используемая для представления текста.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A <ph id="ph1">&lt;xref:System.String&gt;</ph> object is a sequential collection of <ph id="ph2">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph> objects that represent a string; a <ph id="ph3">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph> object corresponds to a UTF-16 code unit.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.String&gt;</ph> объект является упорядоченной коллекции <ph id="ph2">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph> объекты, представляющие строку; с помощью <ph id="ph3">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph> соответствует Единица кода в кодировке UTF-16.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The value of the <ph id="ph1">&lt;xref:System.String&gt;</ph> object is the content of the sequential collection of <ph id="ph2">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph> objects, and that value is immutable (that is, it is read-only).</source>
          <target state="translated">Значение <ph id="ph1">&lt;xref:System.String&gt;</ph> объект является содержимое упорядоченной коллекции <ph id="ph2">&lt;xref:System.Char?displayProperty=nameWithType&gt;</ph> объекты, и что значение является неизменяемым (то есть, это только для чтения).</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information about the immutability of strings, see the <bpt id="p1">[</bpt>Immutability and the StringBuilder class<ept id="p1">](#Immutability)</ept> section later in this topic.</source>
          <target state="translated">Дополнительные сведения о неизменность строк см. в разделе <bpt id="p1">[</bpt>неизменность и класса StringBuilder<ept id="p1">](#Immutability)</ept> далее в этом разделе.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The maximum size of a <ph id="ph1">&lt;xref:System.String&gt;</ph> object in memory is 2GB, or about 1 billion characters.</source>
          <target state="translated">Максимальный размер <ph id="ph1">&lt;xref:System.String&gt;</ph> объект в памяти — 2 ГБ или около 1 миллиарда символов.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In this section:</source>
          <target state="translated">Содержание</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Instantiating a String object<ept id="p1">](#Instantiation)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>При создании экземпляра объекта String<ept id="p1">](#Instantiation)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Char objects and Unicode characters<ept id="p1">](#Characters)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Char-объекты и символы Юникода<ept id="p1">](#Characters)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Strings and The Unicode Standard<ept id="p1">](#Unicode)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Строки и в стандарте Юникода<ept id="p1">](#Unicode)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Strings and embedded null characters<ept id="p1">](#EmbeddedNulls)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Строки и внедренные символы null<ept id="p1">](#EmbeddedNulls)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Strings and indexes<ept id="p1">](#Indexes)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Строки и индексы<ept id="p1">](#Indexes)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Null strings and empty strings<ept id="p1">](#Nulls)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Строки NULL и пустые строки<ept id="p1">](#Nulls)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Immutability and the StringBuilder class<ept id="p1">](#Immutability)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Неизменность и класса StringBuilder<ept id="p1">](#Immutability)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Ordinal vs. culture-sensitive operations<ept id="p1">](#CultureSensitive)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Порядковый номер и операций с учетом языка и региональных параметров<ept id="p1">](#CultureSensitive)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Normalization<ept id="p1">](#Normalization)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Нормализация<ept id="p1">](#Normalization)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>String operations by category<ept id="p1">](#ByCategory)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Операции со строками по категориям<ept id="p1">](#ByCategory)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Instantiating a String object</source>
          <target state="translated">При создании экземпляра объекта String</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.String&gt;</ph> object in the following ways:</source>
          <target state="translated">Можно создать экземпляр <ph id="ph1">&lt;xref:System.String&gt;</ph> объекта одним из следующих способов:</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By assigning a string literal to a <ph id="ph1">&lt;xref:System.String&gt;</ph> variable.</source>
          <target state="translated">Назначив строковый литерал в <ph id="ph1">&lt;xref:System.String&gt;</ph> переменной.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is the most commonly used method for creating a string.</source>
          <target state="translated">Это наиболее часто используемый вариант для создания строки.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses assignment to create several strings.</source>
          <target state="translated">В следующем примере назначения для создания нескольких строк.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that in C#, because the backslash (<ph id="ph1">\\</ph>) is an escape character, literal backslashes in a string must be escaped or the entire string must be <ph id="ph2">@-quoted</ph>.</source>
          <target state="translated">Обратите внимание, что в C#, так как обратная косая черта (<ph id="ph1">\\</ph>) является escape-символом, необходимо экранировать литерала символы обратной косой черты в строке или всю строку должен быть <ph id="ph2">@-quoted</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By calling a <ph id="ph1">&lt;xref:System.String&gt;</ph> class constructor.</source>
          <target state="translated">Путем вызова <ph id="ph1">&lt;xref:System.String&gt;</ph> конструктора класса.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example instantiates strings by calling several class constructors.</source>
          <target state="translated">В следующем примере создается строки, вызвав несколько конструкторов класса.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that some of the constructors include pointers to character arrays or signed byte arrays as parameters.</source>
          <target state="translated">Обратите внимание, что некоторые конструкторы включает указатели на массивы символов или байт со знаком массивов в качестве параметров.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Visual Basic does not support calls to these constructors.</source>
          <target state="translated">Visual Basic не поддерживает вызовы этих конструкторов.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For detailed information about <ph id="ph1">&lt;xref:System.String&gt;</ph> constructors, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">&lt;xref:System.String&gt;</ph> конструкторы, в разделе <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> конструктор сводки.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By using the string concatenation operator (+ in C# and &amp; or + in Visual Basic) to create a single string from any combination of <ph id="ph1">&lt;xref:System.String&gt;</ph> instances and string literals.</source>
          <target state="translated">С помощью оператор объединения строк (+ в C# и &amp; или + в Visual Basic) для создания одной строки из любое сочетание <ph id="ph1">&lt;xref:System.String&gt;</ph> экземпляров и строковых литералов.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the use of the string concatenation operator.</source>
          <target state="translated">Следующий пример иллюстрирует использование оператор объединения строк.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By retrieving a property or calling a method that returns a string.</source>
          <target state="translated">Путем получения свойства или вызов метода, который возвращает строку.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses the methods of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class to extract a substring from a larger string.</source>
          <target state="translated">Следующий пример использует методы <ph id="ph1">&lt;xref:System.String&gt;</ph> класс для извлечения подстроки из большего размера строки.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By calling a formatting method to convert a value or object to its string representation.</source>
          <target state="translated">Путем вызова метода форматирования для преобразования значения или объекта в строковое представление.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses the                <bpt id="p1">[</bpt>composite formatting<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> feature to embed the string representation of two objects into a string.</source>
          <target state="translated">В следующем примере используется <bpt id="p1">[</bpt>составное форматирование<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> позволяет внедрить строковую презентацию два объекта в строку.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Char objects and Unicode characters</source>
          <target state="translated">Char-объекты и символы Юникода</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each character in a string is defined by a Unicode scalar value, also called a Unicode code point or the ordinal (numeric) value of the Unicode character.</source>
          <target state="translated">Каждый символ в строке определяется скалярное значение Юникода, которые также называют кодовую точку Юникода или порядковый номер (числовое) значение символа Юникода.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each code point is encoded by using UTF-16 encoding, and the numeric value of each element of the encoding is represented by a <ph id="ph1">&lt;xref:System.Char&gt;</ph> object.</source>
          <target state="translated">Каждая кодовая точка кодируется с использованием кодировки UTF-16, и числовое значение каждого элемента кодировки представлена <ph id="ph1">&lt;xref:System.Char&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that, because a <ph id="ph1">&lt;xref:System.String&gt;</ph> instance consists of a sequential collection of UTF-16 code units, it is possible to create a <ph id="ph2">&lt;xref:System.String&gt;</ph> object that is not a well-formed Unicode string.</source>
          <target state="translated">Обратите внимание, что, поскольку <ph id="ph1">&lt;xref:System.String&gt;</ph> экземпляра состоит из упорядоченной коллекции частей кода UTF-16, можно создать <ph id="ph2">&lt;xref:System.String&gt;</ph> объекта, который не является корректным строки в Юникоде.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, it is possible to create a string that has a low surrogate without a corresponding high surrogate.</source>
          <target state="translated">Например можно создать строки, которая содержит младший символ-заместитель без соответствующего старшим символом-заместителем.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Although some methods, such as the methods of encoding and decoding objects in the <ph id="ph1">&lt;xref:System.Text&gt;</ph> namespace, may performs checks to ensure that strings are well-formed, <ph id="ph2">&lt;xref:System.String&gt;</ph> class members don't ensure that a string is well-formed.</source>
          <target state="translated">Несмотря на то что некоторые методы, например методы кодирования и декодирования объектов в <ph id="ph1">&lt;xref:System.Text&gt;</ph> пространства имен может выполняет проверку, чтобы обеспечить правильный формат строки <ph id="ph2">&lt;xref:System.String&gt;</ph> члены класса не гарантируют, что строка является корректным.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A single <ph id="ph1">&lt;xref:System.Char&gt;</ph> object usually represents a single code point; that is, the numeric value of the <ph id="ph2">&lt;xref:System.Char&gt;</ph> equals the code point.</source>
          <target state="translated">Один <ph id="ph1">&lt;xref:System.Char&gt;</ph> объект обычно представляет отдельный кодовую точку, то есть числовое значение <ph id="ph2">&lt;xref:System.Char&gt;</ph> равно кодовой точке.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the code point for the character "a" is U+0061.</source>
          <target state="translated">Например, кодовая точка для символа «»-U + 0061.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, a code point might require more than one encoded element (more than one <ph id="ph1">&lt;xref:System.Char&gt;</ph> object).</source>
          <target state="translated">Однако кодовую точку может потребоваться более одного элемента кодировки (несколько <ph id="ph1">&lt;xref:System.Char&gt;</ph> объекта).</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The Unicode standard defines two types of characters that correspond to multiple <ph id="ph1">&lt;xref:System.Char&gt;</ph> objects: graphemes, and Unicode supplementary code points that correspond to characters in the Unicode supplementary planes.</source>
          <target state="translated">Стандарт Юникод определяет два типа символов, которые соответствуют нескольким <ph id="ph1">&lt;xref:System.Char&gt;</ph> объектов: graphemes и добавочные кодовые точки в Юникоде, соответствующих символов в дополнительных панелей Юникода.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A grapheme is represented by a base character followed by one or more combining characters.</source>
          <target state="translated">Графем представлен базового символа, за которыми следует один или несколько символов объединения.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the character ä is represented by a <ph id="ph1">&lt;xref:System.Char&gt;</ph> object whose code point is U+0061 followed by a <ph id="ph2">&lt;xref:System.Char&gt;</ph> object whose code point is U+0308.</source>
          <target state="translated">Например, символ ä представляется одним a <ph id="ph1">&lt;xref:System.Char&gt;</ph> объект которого кодовая точка U + 0061 следуют a <ph id="ph2">&lt;xref:System.Char&gt;</ph> объект которого кодовая точка U + 0308.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This character can also be defined by a single <ph id="ph1">&lt;xref:System.Char&gt;</ph> object that has a code point of U+00E4.</source>
          <target state="translated">Этот символ также можно задать одним <ph id="ph1">&lt;xref:System.Char&gt;</ph> объект с кодовой точкой U + 00E4.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>As the following example shows, a culture-sensitive comparison for equality indicates that these two representations are equal, although an ordinary ordinal comparison does not.</source>
          <target state="translated">Как в следующем примере показано, сравнение с учетом языка и региональных параметров на равенство указывает, что эти два типа представления равны, несмотря на то, что обычные порядковое сравнение не.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, if the two strings are normalized, an ordinal comparison also indicates that they are equal.</source>
          <target state="translated">Однако если нормализуются две строки, порядковое сравнение также указывает, что они равны.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(For more information on normalizing strings, see the <bpt id="p1">[</bpt>Normalization<ept id="p1">](#Normalization)</ept> section.)</source>
          <target state="translated">(Дополнительные сведения о нормализации строк см. в разделе <bpt id="p1">[</bpt>нормализации<ept id="p1">](#Normalization)</ept> раздел.)</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A Unicode supplementary code point (a surrogate pair) is represented by a <ph id="ph1">&lt;xref:System.Char&gt;</ph> object whose code point is a high surrogate followed by a <ph id="ph2">&lt;xref:System.Char&gt;</ph> object whose code point is a low surrogate.</source>
          <target state="translated">Юникод, представленный дополнительная кодовая точка (суррогатная пара) <ph id="ph1">&lt;xref:System.Char&gt;</ph> которого кодовая точка является старшим символом-заместителем объекта, за которым следует <ph id="ph2">&lt;xref:System.Char&gt;</ph> объект которого кодовая точка является младшим символом-заместителем.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The code units of high surrogates range from U+D800 to U+DBFF.</source>
          <target state="translated">Единицы кода высокой суррогаты лежат в диапазоне от U + D800 до U + DBFF.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The code units of low surrogates range from U+DC00 to U+DFFF.</source>
          <target state="translated">Единицы кода низкий суррогаты лежат в диапазоне от U + DC00 до U + DFFF.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Surrogate pairs are used to represent characters in the 16 Unicode supplementary planes.</source>
          <target state="translated">Суррогатные пары, используются для представления символов в 16 дополнительных панелей Юникода.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example creates a surrogate character and passes it to the <ph id="ph1">&lt;xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph> method to determine whether it is a surrogate pair.</source>
          <target state="translated">В следующем примере создается символов-заместителей и передает его <ph id="ph1">&lt;xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph> метод, чтобы определить, является ли он суррогатную пару.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Strings and The Unicode Standard</source>
          <target state="translated">Строки и в стандарте Юникода</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Characters in a string are represented by UTF-16 encoded code units, which correspond to <ph id="ph1">&lt;xref:System.Char&gt;</ph> values.</source>
          <target state="translated">Символы в строке, представляются частей кода в кодировке UTF-16, которые соответствуют <ph id="ph1">&lt;xref:System.Char&gt;</ph> значения.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each character in a string has an associated Unicode character category, which is represented in the .NET Framework by the <ph id="ph1">&lt;xref:System.Globalization.UnicodeCategory&gt;</ph> enumeration.</source>
          <target state="translated">Каждый символ в строке имеет связанные символы Юникода категории, которая представлена в .NET Framework по <ph id="ph1">&lt;xref:System.Globalization.UnicodeCategory&gt;</ph> перечисления.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The category of a character or a surrogate pair can be determined by calling the <ph id="ph1">&lt;xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Категория символ или суррогатную пару можно определить путем вызова <ph id="ph1">&lt;xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET maintains its own table of characters and their corresponding categories, which ensures that a specific version of a .NET implementation running on different platforms returns identical character category information.</source>
          <target state="translated">.NET поддерживает собственную таблицу символов и их соответствующих категорий, который гарантирует, что определенной версии .NET реализацию, работающими на различных платформах возвращает сведения о категории идентичные символ.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following table lists .NET versions and the versions of the Unicode Standard on which their character categories are based.</source>
          <target state="translated">В следующей таблице перечислены версии платформы .NET и версии стандарта Юникод, на котором основаны их категории символов.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET Framework version</source>
          <target state="translated">Версия платформы .NET Framework</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Version of the Unicode Standard</source>
          <target state="translated">Версия стандарта Юникод</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 4.0.0<ept id="p1">](https://www.unicode.org/versions/Unicode4.0.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>В стандарте Юникода версии 4.0.0<ept id="p1">](https://www.unicode.org/versions/Unicode4.0.0/)</ept></target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework 2.0</source>
          <target state="translated">В .NET Framework 2.0</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>В стандарте Юникода версии 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>В стандарте Юникода версии 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>В стандарте Юникода версии 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>В стандарте Юникода версии 6.3.0<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>В стандарте Юникода версии 6.3.0<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>В стандарте Юникода версии 6.3.0<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>В стандарте Юникода версии 6.3.0<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>В стандарте Юникода версии 6.3.0<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 8.0.0<ept id="p1">](https://www.unicode.org/versions/Unicode8.0.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>В стандарте Юникода версии 8.0.0<ept id="p1">](https://www.unicode.org/versions/Unicode8.0.0/)</ept></target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET Core (all versions)</source>
          <target state="translated">.NET core (все версии)</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 8.0.0<ept id="p1">](https://www.unicode.org/versions/Unicode8.0.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>В стандарте Юникода версии 8.0.0<ept id="p1">](https://www.unicode.org/versions/Unicode8.0.0/)</ept></target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In addition, the .NET Framework supports string comparison and sorting based on the Unicode standard.</source>
          <target state="translated">Кроме того платформа .NET Framework поддерживает сравнения строк и сортировку на основе стандарта Юникода.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In versions of the .NET Framework through the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the .NET Framework maintains its own table of string data.</source>
          <target state="translated">В версиях .NET Framework с помощью <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, .NET Framework поддерживает собственную таблицу строки данных.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is also true of versions of the .NET Framework starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> running on Windows 7.</source>
          <target state="translated">Это также верно для версий платформы .NET Framework, начиная с <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> под управлением Windows 7.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> running on Window 8 and later versions of the Windows operating system, the runtime delegates string comparison and sorting operations to the operating system.</source>
          <target state="translated">Начиная с <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> под управлением Windows 8 и более поздних версиях операционной системы Windows, делегаты среды выполнения строка сравнения и сортировки в операционную систему.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following table lists the versions of the .NET Framework and the versions of the Unicode Standard on which character comparison and sorting are based.</source>
          <target state="translated">В следующей таблице перечислены версии .NET Framework и стандарта Юникод, на какой символ основаны сравнение и сортировка.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET Framework version</source>
          <target state="translated">Версия платформы .NET Framework</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Version of the Unicode Standard</source>
          <target state="translated">Версия стандарта Юникод</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 4.0.0<ept id="p1">](https://www.unicode.org/versions/Unicode4.0.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>В стандарте Юникода версии 4.0.0<ept id="p1">](https://www.unicode.org/versions/Unicode4.0.0/)</ept></target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework 2.0</source>
          <target state="translated">В .NET Framework 2.0</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>В стандарте Юникода версии 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>В стандарте Юникода версии 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>В стандарте Юникода версии 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> and later on Windows 7</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> и более поздних версий в Windows 7</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>В стандарте Юникода версии 5.0.0<ept id="p1">](http://www.unicode.org/versions/Unicode5.0.0)</ept></target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> and later on Windows 8 and later Windows operating systems</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> и более поздних версий в Windows 8 и более поздних операционных системах Windows</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Unicode Standard, Version 6.3.0<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>В стандарте Юникода версии 6.3.0<ept id="p1">](https://www.unicode.org/versions/Unicode6.3.0/)</ept></target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In .NET Core, sorting and comparison operations are based on <bpt id="p1">[</bpt>Version 8.0.0 of the Unicode Standard<ept id="p1">](https://www.unicode.org/versions/Unicode8.0.0/)</ept>.</source>
          <target state="translated">В .NET Core на основе операций сортировки и сравнения <bpt id="p1">[</bpt>стандарт Юникод версии 8.0.0<ept id="p1">](https://www.unicode.org/versions/Unicode8.0.0/)</ept>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Strings and embedded null characters</source>
          <target state="translated">Строки и внедренные символы null</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In the .NET Framework, a <ph id="ph1">&lt;xref:System.String&gt;</ph> object can include embedded null characters, which count as a part of the string's length.</source>
          <target state="translated">В платформе .NET Framework <ph id="ph1">&lt;xref:System.String&gt;</ph> объект может содержать внедренные символы null, которые считаются частью длину строки.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, in some languages such as C and C++, a null character indicates the end of a string;it is not considered a part of the string and is not counted as part of the string's length.</source>
          <target state="translated">Однако в некоторых языках, таких как C и C++, символ null указывает на конец строки, он не является частью строки и не считается частью длину строки.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This means that the following common assumptions that C and C++ programmers or libraries written in C or C++ might make about strings are not necessarily valid when applied to <ph id="ph1">&lt;xref:System.String&gt;</ph> objects:</source>
          <target state="translated">Это означает, что указанные ниже типичные предположения, которые программисты C и C++ и библиотеки, написанные на C или C++ могут быть сведения о строках недопустимы обязательно при применении к <ph id="ph1">&lt;xref:System.String&gt;</ph> объектов:</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The value returned by the <ph id="ph1">`strlen`</ph> or <ph id="ph2">`wcslen`</ph> functions does not necessarily equal <ph id="ph3">&lt;xref:System.String.Length%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Значение, возвращаемое <ph id="ph1">`strlen`</ph> или <ph id="ph2">`wcslen`</ph> функции не обязательно равно <ph id="ph3">&lt;xref:System.String.Length%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The string created by the <ph id="ph1">`strcpy_s`</ph> or <ph id="ph2">`wcscpy_s`</ph> functions is not necessarily identical to the string created by the <ph id="ph3">&lt;xref:System.String.Copy%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Строка, созданная <ph id="ph1">`strcpy_s`</ph> или <ph id="ph2">`wcscpy_s`</ph> функции не обязательно совпадает строку, созданную путем <ph id="ph3">&lt;xref:System.String.Copy%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You should ensure that native C and C++ code that instantiates <ph id="ph1">&lt;xref:System.String&gt;</ph> objects, and code that is passed <ph id="ph2">&lt;xref:System.String&gt;</ph> objects through platform invoke, don't assume that an embedded null character marks the end of the string.</source>
          <target state="translated">Следует убедиться, что машинного кода C и C++, создает <ph id="ph1">&lt;xref:System.String&gt;</ph> объектов и код, который передается <ph id="ph2">&lt;xref:System.String&gt;</ph> объектов посредством вызова неуправляемого кода, нельзя предполагать, что внедренный символ null отмечает конец строки.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Embedded null characters in a string are also treated differently when a string is sorted (or compared) and when a string is searched.</source>
          <target state="translated">Когда строка сортировки (или сравнении) и при поиске строки внедренных символов null в строке также обрабатываются по-разному.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Null characters are ignored when performing culture-sensitive comparisons between two strings, including comparisons using the invariant culture.</source>
          <target state="translated">Символы NULL учитываются при выполнении сравнений с учетом языка и региональных параметров между двумя строками, включая сравнение с использованием инвариантных региональных параметров.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>They are considered only for ordinal or case-insensitive ordinal comparisons.</source>
          <target state="translated">Они учитываются только порядковые сравнения порядковыми, так и без учета регистра.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On the other hand, embedded null characters are always considered when searching a string with methods such as <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.StartsWith%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.String.IndexOf%2A&gt;</ph>.</source>
          <target state="translated">С другой стороны, внедренные символы null всегда считаются при поиске строку с помощью методов, таких как <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.StartsWith%2A&gt;</ph>, и <ph id="ph3">&lt;xref:System.String.IndexOf%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Strings and indexes</source>
          <target state="translated">Строки и индексы</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An index is the position of a <ph id="ph1">&lt;xref:System.Char&gt;</ph> object (not a Unicode character) in a <ph id="ph2">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">Индекс — это положение <ph id="ph1">&lt;xref:System.Char&gt;</ph> объекта (а не знак Юникода) в <ph id="ph2">&lt;xref:System.String&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An index is a zero-based, nonnegative number that starts from the first position in the string, which is index position zero.</source>
          <target state="translated">Индекс является неотрицательным число, которое начинается с первой позиции в строке, равно нулю.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A number of search methods, such as <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, return the index of a character or substring in the string instance.</source>
          <target state="translated">Ряд методов поиска такие как <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, индекс символа или подстроки в экземпляре строки.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> property lets you access individual <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects by their index position in the string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> Свойство позволяет получить доступ к отдельным <ph id="ph2">&lt;xref:System.Char&gt;</ph> объектов согласно их позиции индекса в строке.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the <ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> property is the default property (in Visual Basic) or the indexer (in C#), you can access the individual <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects in a string by using code such as the following.</source>
          <target state="translated">Поскольку <ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> свойство является свойством по умолчанию (в Visual Basic) или индексатором (в C#), можно получить доступ к отдельные <ph id="ph2">&lt;xref:System.Char&gt;</ph> объектов в строке с помощью кода примерно следующего вида.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This code looks for white space or punctuation characters in a string to determine how many words the string contains.</source>
          <target state="translated">Этот код осуществляет поиск пробелы или знаки препинания в строку, чтобы определить, сколько слов, строка содержит.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the <ph id="ph1">&lt;xref:System.String&gt;</ph> class implements the <ph id="ph2">&lt;xref:System.Collections.IEnumerable&gt;</ph> interface, you can also iterate through the <ph id="ph3">&lt;xref:System.Char&gt;</ph> objects in a string by using a <ph id="ph4">`foreach`</ph> construct, as the following example shows.</source>
          <target state="translated">Поскольку <ph id="ph1">&lt;xref:System.String&gt;</ph> класс реализует <ph id="ph2">&lt;xref:System.Collections.IEnumerable&gt;</ph> интерфейса, можно также выполнить итерацию <ph id="ph3">&lt;xref:System.Char&gt;</ph> объектов в строки с помощью <ph id="ph4">`foreach`</ph> конструкцию, как показано в следующем примере.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Consecutive index values might not correspond to consecutive Unicode characters, because a Unicode character might be encoded as more than one <ph id="ph1">&lt;xref:System.Char&gt;</ph> object.</source>
          <target state="translated">Номер индекса может не соответствовать последовательных символов Юникода, так как знак Юникода может быть закодирован несколькими <ph id="ph1">&lt;xref:System.Char&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In particular, a string may contain multi-character units of text that are formed by a base character followed by one or more combining characters or by surrogate pairs.</source>
          <target state="translated">В частности строка может содержать Многосимвольная единиц текста, которые образуются базового символа и одного или более несамостоятельных знаков или суррогатные пары.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To work with Unicode characters instead of <ph id="ph1">&lt;xref:System.Char&gt;</ph> objects, use the <ph id="ph2">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Globalization.TextElementEnumerator&gt;</ph> classes.</source>
          <target state="translated">Для работы с символами Юникода, а не <ph id="ph1">&lt;xref:System.Char&gt;</ph> объекты, используют <ph id="ph2">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph> и <ph id="ph3">&lt;xref:System.Globalization.TextElementEnumerator&gt;</ph> классы.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the difference between code that works with <ph id="ph1">&lt;xref:System.Char&gt;</ph> objects and code that works with Unicode characters.</source>
          <target state="translated">В следующем примере показано различие между кодом, который работает с <ph id="ph1">&lt;xref:System.Char&gt;</ph> объекты и код, который работает с символами Юникода.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It compares the number of characters or text elements in each word of a sentence.</source>
          <target state="translated">Затем он сравнивает число символов или текстовых элементов в каждое слово предложения.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The string includes two sequences of a base character followed by a combining character.</source>
          <target state="translated">Строка содержит две последовательности базового символа, за которым следует символ объединения.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This example works with text elements by using the <ph id="ph1">&lt;xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Globalization.TextElementEnumerator&gt;</ph> class to enumerate all the text elements in a string.</source>
          <target state="translated">Этот пример работает с элементами текста с помощью <ph id="ph1">&lt;xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType&gt;</ph> метод и <ph id="ph2">&lt;xref:System.Globalization.TextElementEnumerator&gt;</ph> класса для перечисления всех текстовых элементов в строке.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also retrieve an array that contains the starting index of each text element by calling the <ph id="ph1">&lt;xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Вы также можете получить массив, содержащий начальный индекс каждого элемента текста, вызвав <ph id="ph1">&lt;xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information about working with units of text rather than individual <ph id="ph1">&lt;xref:System.Char&gt;</ph> values, see the <ph id="ph2">&lt;xref:System.Globalization.StringInfo&gt;</ph> class.</source>
          <target state="translated">Дополнительные сведения о работе с единиц текста, а не отдельных <ph id="ph1">&lt;xref:System.Char&gt;</ph> значения, в разделе <ph id="ph2">&lt;xref:System.Globalization.StringInfo&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Null strings and empty strings</source>
          <target state="translated">Строки NULL и пустые строки</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A string that has been declared but has not been assigned a value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Строка, который был объявлен, но не было присвоено значение <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Attempting to call methods on that string throws a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>.</source>
          <target state="translated">Попытка вызова методов для этой строки вызывает <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A null string is different from an empty string, which is a string whose value is "" or <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Пустая строка отличается от пустую строку, которая представляет собой строку, значение которого равно «» или <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In some cases, passing either a null string or an empty string as an argument in a method call throws an exception.</source>
          <target state="translated">В некоторых случаях передача строку null или пустую строку в качестве аргумента в вызове метода создает исключение.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, passing a null string to the <ph id="ph1">&lt;xref:System.Int32.Parse%2A?displayProperty=nameWithType&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph>, and passing an empty string throws a <ph id="ph3">&lt;xref:System.FormatException&gt;</ph>.</source>
          <target state="translated">Например, передав строку null для <ph id="ph1">&lt;xref:System.Int32.Parse%2A?displayProperty=nameWithType&gt;</ph> вызывает исключение <ph id="ph2">&lt;xref:System.ArgumentNullException&gt;</ph>и передать пустую строку, возникает исключение <ph id="ph3">&lt;xref:System.FormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In other cases, a method argument can be either a null string or an empty string.</source>
          <target state="translated">В других случаях аргумент метода может быть пустой строкой или пустой строкой.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, if you are providing an <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> implementation for a class, you want to equate both a null string and an empty string with the general ("G") format specifier.</source>
          <target state="translated">Например, если вы указываете <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> реализацию для класса требуется результатом является пустой строкой и пустой строкой с Описатель общего формата («G»).</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class includes the following two convenience methods that enable you to test whether a string is <ph id="ph2">`null`</ph> or empty:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String&gt;</ph> Класс включает следующие два удобных методов, которые позволяют проверить, является ли строка <ph id="ph2">`null`</ph> или пустым:</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph>, which indicates whether a string is either <ph id="ph2">`null`</ph> or is equal to  <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph>, указывающее, является ли строка либо <ph id="ph2">`null`</ph> или равен <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This method eliminates the need to use code such as the following:</source>
          <target state="translated">Этот метод исключает необходимость использовать следующий код:</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph>, which indicates whether a string is <ph id="ph2">`null`</ph>, equals <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, or consists exclusively of white-space characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph>, который указывает, является ли строка <ph id="ph2">`null`</ph>, равно <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, или содержит только пробелы.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This method eliminates the need to use code such as the following:</source>
          <target state="translated">Этот метод исключает необходимость использовать следующий код:</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> method in the <ph id="ph2">&lt;xref:System.IFormattable.ToString%2A?displayProperty=nameWithType&gt;</ph> implementation of a custom <ph id="ph3">`Temperature`</ph> class.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> метод в <ph id="ph2">&lt;xref:System.IFormattable.ToString%2A?displayProperty=nameWithType&gt;</ph> реализация пользовательского <ph id="ph3">`Temperature`</ph> класса.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The method supports the "G", "C", "F", and "K" format strings.</source>
          <target state="translated">Метод поддерживает строки формата «G», «C», «F» и «K».</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If an empty format string or a format string whose value is <ph id="ph1">`null`</ph> is passed to the method, its value is changed to the "G" format string.</source>
          <target state="translated">Если пустой строкой формата, или в формате string, значение которого является <ph id="ph1">`null`</ph> передается в метод, его значение изменяется в строку формата «G».</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Immutability and the StringBuilder class</source>
          <target state="translated">Неизменность и класса StringBuilder</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A <ph id="ph1">&lt;xref:System.String&gt;</ph> object is called immutable (read-only), because its value cannot be modified after it has been created.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.String&gt;</ph> объект называется неизменяемый (только для чтения), так как его значение нельзя изменить после его создания.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Methods that appear to modify a <ph id="ph1">&lt;xref:System.String&gt;</ph> object actually return a new <ph id="ph2">&lt;xref:System.String&gt;</ph> object that contains the modification.</source>
          <target state="translated">Методы, используемые для изменения <ph id="ph1">&lt;xref:System.String&gt;</ph> объекта на самом деле возвращается новый <ph id="ph2">&lt;xref:System.String&gt;</ph> объект, содержащий изменения.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because strings are immutable, string manipulation routines that perform repeated additions or deletions to what appears to be a single string can exact a significant performance penalty.</source>
          <target state="translated">Поскольку строки являются неизменяемыми, подпрограммы обработки строки, которые выполняют повторяющиеся добавлений или удалений, чтобы в одну строку можно точные к значительному снижению производительности.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the following code uses a random number generator to create a string with 1000 characters in the range 0x0001 to 0x052F.</source>
          <target state="translated">Например следующий код использует генератора случайных чисел для создания строки с 1000 символов в диапазоне 0x0001 для 0x052F.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Although the code appears to use string concatenation to append a new character to the existing string named <ph id="ph1">`str`</ph>, it actually creates a new <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each concatenation operation.</source>
          <target state="translated">Несмотря на то, что код, по-видимому, использовать объединение строк для добавления нового символа в существующую строку с именем <ph id="ph1">`str`</ph>, фактически создает новый <ph id="ph2">&lt;xref:System.String&gt;</ph> объект для каждой операции объединения.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can use the <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> class instead of the <ph id="ph2">&lt;xref:System.String&gt;</ph> class for operations that make multiple changes to the value of a string.</source>
          <target state="translated">Можно использовать <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> вместо класса <ph id="ph2">&lt;xref:System.String&gt;</ph> класс для операций, которые внести несколько изменений значения строки.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Unlike instances of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class, <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> objects are mutable; when you concatenate, append, or delete substrings from a string, the operations are performed on a single string.</source>
          <target state="translated">В отличие от экземпляров <ph id="ph1">&lt;xref:System.String&gt;</ph> класса <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> объектов может изменяться; при объединить, добавить или удалить подстрок из строки, что операции выполняются на одну строку.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When you have finished modifying the value of a <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> object, you can call its <ph id="ph2">&lt;xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType&gt;</ph> method to convert it to a string.</source>
          <target state="translated">Завершив изменение значения <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> объекта, можно вызвать его <ph id="ph2">&lt;xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType&gt;</ph> метод для преобразования в строку.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example replaces the <ph id="ph1">&lt;xref:System.String&gt;</ph> used in the previous example to concatenate 1000 random characters in the range to  0x0001 to 0x052F with a <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> object.</source>
          <target state="translated">В следующем примере заменяется <ph id="ph1">&lt;xref:System.String&gt;</ph> используется в предыдущем примере для объединения 1000 случайных символов в диапазоне, в 0x0001, чтобы 0x052F с <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Ordinal vs. culture-sensitive operations</source>
          <target state="translated">Порядковый номер и операций с учетом языка и региональных параметров</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Members of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class perform either ordinal or culture-sensitive (linguistic) operations on a <ph id="ph2">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated">Члены <ph id="ph1">&lt;xref:System.String&gt;</ph> класс оперируют порядковый номер или язык и региональные параметры (лингвистические) <ph id="ph2">&lt;xref:System.String&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal operation acts on the numeric value of each <ph id="ph1">&lt;xref:System.Char&gt;</ph> object.</source>
          <target state="translated">Порядковые операции выполняются над числовыми значениями каждого <ph id="ph1">&lt;xref:System.Char&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A culture-sensitive operation acts on the value of the <ph id="ph1">&lt;xref:System.String&gt;</ph> object, and takes culture-specific casing, sorting, formatting, and parsing rules into account.</source>
          <target state="translated">Операция с учетом культуры действует на значении <ph id="ph1">&lt;xref:System.String&gt;</ph> объекта и принимает о регистре, сортировку, форматирование и правила синтаксического анализа в учетную запись.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Culture-sensitive operations execute in the context of an explicitly declared culture or the implicit current culture.</source>
          <target state="translated">Операции с учетом языка и региональных параметров, выполняются в контексте явно объявленный языка и региональных параметров или неявное текущего языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The two kinds of operations can produce very different results when they are performed on the same string.</source>
          <target state="translated">Два вида операций может дать очень разные результаты, если они выполняются на ту же строку.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework also supports culture-insensitive linguistic string operations by using the invariant culture (<ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>), which is loosely based on the culture settings of the English language independent of region.</source>
          <target state="translated">Платформа .NET Framework также поддерживает операции со строками без учета языка и региональных параметров лингвистические с помощью инвариантного языка и региональных параметров (<ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>), слабо основанный на настройках языка и региональных параметров английский язык, вне зависимости от региона.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Unlike other <ph id="ph1">&lt;xref:System.Globalization.CultureInfo?displayProperty=nameWithType&gt;</ph> settings, the settings of the invariant culture are guaranteed to remain consistent on a single computer, from system to system, and across versions of the .NET Framework.</source>
          <target state="translated">В отличие от других <ph id="ph1">&lt;xref:System.Globalization.CultureInfo?displayProperty=nameWithType&gt;</ph> параметры, параметры инвариантного языка и региональных параметров гарантируется согласованность на одном компьютере, из системы для системы и всех версий платформы .NET Framework.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The invariant culture can be seen as a kind of black box that ensures stability of string comparisons and ordering across all cultures.</source>
          <target state="translated">Во всех языков и региональных параметров инвариантный язык и региональные параметры могут быть замеченный как тип "черного ящика", обеспечивает стабильность сравнения строк и порядка сортировки.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If your application makes a security decision about a symbolic identifier such as a file name or named pipe, or about persisted data such as the text-based data in an XML file, the operation should use an ordinal comparison instead of a culture-sensitive comparison.</source>
          <target state="translated">Если приложение принимает решение безопасности в отношении символьного идентификатора, такие как имя файла или именованного канала, или о материализованных данных, такие как текстовые данные в XML-файл, операцию следует использовать порядковое сравнение, вместо сравнения с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is because a culture-sensitive comparison can yield different results depending on the culture in effect, whereas an ordinal comparison depends solely on the binary value of the compared characters.</source>
          <target state="translated">Это так, как сравнение с учетом языка и региональных параметров могут выдавать различные результаты в зависимости от языка и региональных параметров, тогда как порядковое сравнение зависит только от двоичное значение сравниваемых символов.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Most methods that perform string operations include an overload that has a parameter of type <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph>, which enables you to specify whether the method performs an ordinal or culture-sensitive operation.</source>
          <target state="translated">Большинство методов, которые выполняют операции со строками включают перегрузку, имеющую параметр типа <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph>, который позволяет указать, выполняет ли метод операцию, порядковый номер или язык и региональные параметры.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In general, you should call this overload to make the intent of your method call clear.</source>
          <target state="translated">В общем случае следует вызывать эту перегрузку, чтобы сделать ясным смысл вызова метода.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For best practices and guidance for using ordinal and culture-sensitive operations on strings, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Советы и рекомендации по использованию порядковый номер языка и региональных параметров операций над строками, в разделе <bpt id="p1">[</bpt>советы и рекомендации по использованию строк<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Operations for <bpt id="p1">[</bpt>casing<ept id="p1">](#casing)</ept>, <bpt id="p2">[</bpt>parsing and formatting<ept id="p2">](#parsing)</ept>, <bpt id="p3">[</bpt>comparison and sorting<ept id="p3">](#comparison)</ept>, and <bpt id="p4">[</bpt>testing for equality<ept id="p4">](#equality)</ept> can be either ordinal or culture-sensitive.</source>
          <target state="translated">Операции для <bpt id="p1">[</bpt>регистр<ept id="p1">](#casing)</ept>, <bpt id="p2">[</bpt>синтаксического анализа и форматирования<ept id="p2">](#parsing)</ept>, <bpt id="p3">[</bpt>сравнение и сортировка<ept id="p3">](#comparison)</ept>, и <bpt id="p4">[</bpt>проверки на равенство<ept id="p4">](#equality)</ept> можно использовать порядковый номер или язык и региональные параметры.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following sections discuss each category of operation.</source>
          <target state="translated">В следующих разделах рассматриваются каждой категории операции.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You should always call a method overload that makes the intent of your method call clear.</source>
          <target state="translated">Следует всегда вызывать перегрузку метода, которая делает ясным смысл вызова метода.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, instead of calling the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph> method to perform a culture-sensitive comparison of two strings by using the conventions of the current culture, you should call the <ph id="ph2">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method with a value of <ph id="ph3">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph> for the <ph id="ph4">`comparisonType`</ph> argument.</source>
          <target state="translated">Например, вместо вызова метода <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph> метода выполняют сравнение с учетом языка и региональных параметров двух строк с использованием правил текущего языка и региональных параметров, необходимо вызвать <ph id="ph2">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> метода со значением <ph id="ph3">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph> для <ph id="ph4">`comparisonType`</ph> аргумент.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Рекомендации по использованию строк<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Casing</source>
          <target state="translated">Регистр</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Casing rules determine how to change the capitalization of a Unicode character; for example, from lowercase to uppercase.</source>
          <target state="translated">Правила определения регистра для определения способа изменить верхний регистр символа Юникода; например из нижнего регистра в верхний регистр.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Often, a casing operation is performed before a string comparison.</source>
          <target state="translated">Часто регистр операции перед сравнения строк.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, a string might be converted to uppercase so that it can be compared with another uppercase string.</source>
          <target state="translated">Например строки могут быть преобразованы в верхний регистр, чтобы его можно сравнивать с другой строку в верхнем регистре.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can convert the characters in a string to lowercase by calling the <ph id="ph1">&lt;xref:System.String.ToLower%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> method, and you can convert them to uppercase by calling the <ph id="ph3">&lt;xref:System.String.ToUpper%2A&gt;</ph> or <ph id="ph4">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
          <target state="translated">Вы можете преобразовать символы в строке в нижний регистр, вызвав <ph id="ph1">&lt;xref:System.String.ToLower%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> метод и их можно преобразовать в верхний регистр, вызвав <ph id="ph3">&lt;xref:System.String.ToUpper%2A&gt;</ph> или <ph id="ph4">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In addition, you can use the <ph id="ph1">&lt;xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType&gt;</ph> method to convert a string to title case.</source>
          <target state="translated">Кроме того, можно использовать <ph id="ph1">&lt;xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType&gt;</ph> метод для преобразования строки в прописные.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Casing operations can be based on the rules of the current culture, a specified culture, or the invariant culture.</source>
          <target state="translated">Регистр операций могут определяться правилами текущего языка и региональных параметров, заданных региональных параметров или инвариантного языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because case mappings can vary depending on the culture used, the result of casing operations can vary based on culture.</source>
          <target state="translated">Поскольку сопоставление регистра может меняться в зависимости от используемых региональных параметров, результат операций регистр символов может отличаться в зависимости от языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The actual differences in casing are of three kinds:</source>
          <target state="translated">Фактический различия в регистре могут быть трех типов:</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Differences in the case mapping of LATIN CAPITAL LETTER I (U+0049), LATIN SMALL LETTER I (U+0069), LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130), and LATIN SMALL LETTER DOTLESS I (U+0131).</source>
          <target state="translated">Различия в сопоставления LATIN CAPITAL LETTER I (U + 0049), ЛАТИНИЦА НЕБОЛЬШОЙ буквы I (U + 0069), LATIN CAPITAL LETTER I с ТОЧКОЙ выше (U + 0130) и LATIN НЕБОЛЬШОЙ буквы без ТОЧКИ I (U + 0131).</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In the tr-TR (Turkish (Turkey)) and az-Latn-AZ (Azerbaijan, Latin) cultures, and in the tr, az, and az-Latn neutral cultures, the lowercase equivalent of LATIN CAPITAL LETTER I is LATIN SMALL LETTER DOTLESS I, and the uppercase equivalent of LATIN SMALL LETTER I is LATIN CAPITAL LETTER I WITH DOT ABOVE.</source>
          <target state="translated">Tr-TR (турецкий (Турция)) и az-Latn-AZ (Азербайджан, латиница) языков и региональных параметров и tr, az и az Latn нейтральные языки и региональные параметры эквивалент LATIN CAPITAL LETTER I в нижнем регистре — LATIN НЕБОЛЬШОЙ буквы без ТОЧКИ I и эквивалент LATIN НЕБОЛЬШОЙ буквы I в верхнем регистре превышает LATIN CAPITAL LETTER I с ТОЧКОЙ.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In all other cultures, including the invariant culture, LATIN SMALL LETTER I and LATIN CAPITAL LETTER I are lowercase and uppercase equivalents.</source>
          <target state="translated">В других языках включая инвариантных региональных параметров, ЛАТИНИЦА НЕБОЛЬШОЙ буквы I и LATIN CAPITAL LETTER я являются эквивалентами строчные и прописные.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example demonstrates how a string comparison designed to prevent file system access can fail if it relies on a culture-sensitive casing comparison.</source>
          <target state="translated">В следующем примере показано как сравнения строк предназначен для предотвращения доступа к файловой системе может завершиться ошибкой, если он основывается на сравнении язык и региональные параметры учета регистра.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(The casing conventions of the invariant culture should have been used.)</source>
          <target state="translated">(Правила регистра инвариантного языка и региональных параметров должно быть использовано.)</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Differences in case mappings between the invariant culture and all other cultures.</source>
          <target state="translated">Различия в сопоставление регистра инвариантного языка и региональных параметров и всех других языков и региональных параметров.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In these cases, using the casing rules of the invariant culture to change a character to uppercase or lowercase returns the same character.</source>
          <target state="translated">Таким образом используя правила учета регистра инвариантного языка и региональных параметров для изменения символов в верхний или нижний возвращает тот же символ.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For all other cultures, it returns a different character.</source>
          <target state="translated">Для всех других языков и региональных параметров он возвращает другой символ.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Some of the affected characters are listed in the following table.</source>
          <target state="translated">Затронутые символов приведены в следующей таблице.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Character</source>
          <target state="translated">Знак</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If changed to</source>
          <target state="translated">Если изменяется</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Returns</source>
          <target state="translated">Returns</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>MICRON SIGN (U+00B5)</source>
          <target state="translated">МКМ ЗНАКА (U + 00B5)</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Uppercase</source>
          <target state="translated">Прописные буквы</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>GREEK CAPITAL LETTER MU (U+-39C)</source>
          <target state="translated">ГРЕЧЕСКИЙ ЗАГЛАВНАЯ БУКВА ЦЕНТР ОБНОВЛЕНИЯ МАЙКРОСОФТ (U +-39C)</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130)</source>
          <target state="translated">ПРОПИСНЫЕ ЛАТИНСКИЕ БУКВЫ I С ТОЧКОЙ ВЫШЕ (U + 0130)</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Lowercase</source>
          <target state="translated">Строчные буквы</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN SMALL LETTER I (U+0069)</source>
          <target state="translated">ЛАТИНИЦА МАЛЫХ БУКВЫ I (U + 0069)</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN SMALL LETTER DOTLESS I (U+0131)</source>
          <target state="translated">ЛАТИНСКАЯ СТРОЧНАЯ БУКВА БЕЗ ТОЧКИ I (U + 0131)</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Uppercase</source>
          <target state="translated">Прописные буквы</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN CAPITAL LETTER I (U+0049)</source>
          <target state="translated">ПРОПИСНЫЕ ЛАТИНСКИЕ БУКВЫ I (U + 0049)</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN SMALL LETTER LONG S (U+017F)</source>
          <target state="translated">ЛАТИНСКАЯ СТРОЧНАЯ БУКВА LONG S (U + 017F)</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Uppercase</source>
          <target state="translated">Прописные буквы</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN CAPITAL LETTER S (U+0053)</source>
          <target state="translated">ПРОПИСНАЯ ЛАТИНСКАЯ БУКВА S (U + 0053)</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON (U+01C5)</source>
          <target state="translated">ПРОПИСНАЯ ЛАТИНСКАЯ БУКВА D С СТРОЧНАЯ БУКВА Z С ГАЛОЧКОЙ (U + 01C 5)</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Lowercase</source>
          <target state="translated">Строчные буквы</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>LATIN SMALL LETTER DZ WITH CARON (U+01C6)</source>
          <target state="translated">ЛАТИНСКАЯ СТРОЧНАЯ БУКВА DZ С ГАЛОЧКОЙ (U + 01C 6)</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>COMBINING GREEK YPOGEGRAMMENI (U+0345)</source>
          <target state="translated">ГРЕЧЕСКИЙ YPOGEGRAMMENI ОБЪЕДИНЕНИЯ (U + 0345)</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Uppercase</source>
          <target state="translated">Прописные буквы</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>GREEK CAPITAL LETTER IOTA (U+0399)</source>
          <target state="translated">ГРЕЧЕСКИЙ ЗАГЛАВНАЯ БУКВА IOTA (U + 0399)</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Differences in case mappings of two-letter mixed-case pairs in the ASCII character range.</source>
          <target state="translated">Различия в вариантах сопоставления пары регистра букв в диапазоне символов ASCII.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In most cultures, a two-letter mixed-case pair is equal to the equivalent two-letter uppercase or lowercase pair.</source>
          <target state="translated">В большинстве случаев пару регистра букв равно эквивалентные пар верхнего или нижнего регистра букв.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is not true for the following two-letter pairs in the following cultures, because in each case they are compared to a digraph:</source>
          <target state="translated">Это не относится к следующие пары букв в следующих языков и региональных параметров, поскольку в каждом случае они сравниваются диграф:</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"lJ" and "nJ" in the hr-HR (Croatian (Croatia)) culture.</source>
          <target state="translated">«lJ» и «Нж» в культуре hr-HR (Хорватский (Хорватия)).</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"cH" in the cs-CZ (Czech (Czech Republic)) and sk-SK (Slovak (Slovakia)) cultures.</source>
          <target state="translated">«cH» в cs-CZ (чешский (Чешская Республика)) и sk-SK (словацкий (Словакия)) языков и региональных параметров.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"aA" in the da-DK (Danish (Denmark)) culture.</source>
          <target state="translated">«aA» в культуре da-DK (датский (Дания)).</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"cS", "dZ", "dZS", "nY", "sZ", "tY", and "zS" in the hu-HU (Hungarian (Hungary)) culture.</source>
          <target state="translated">«cS», «dZ», «dZS», «nY», «sZ», «tY» и «zS» в культуре hu-HU (Венгерский (Венгрия)).</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"cH" and "lL" in the es-ES_tradnl (Spanish (Spain, Traditional Sort)) culture.</source>
          <target state="translated">«cH» и «все» в язык и региональные параметры es-ES_tradnl (испанский (Испания, традиционная сортировка)).</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>"cH", "gI", "kH", "nG" "nH", "pH", "qU', "tH", and "tR" in the vi-VN (Vietnamese (Vietnam)) culture.</source>
          <target state="translated">«cH», «gI», «kH», «nG», «nH», «pH», «qU ", «tH» и «tR» в языке vi-VN (вьетнамский (Вьетнам)).</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, it is unusual to encounter a situation in which a culture-sensitive comparison of these pairs creates problems, because these pairs are uncommon in fixed strings or identifiers.</source>
          <target state="translated">Тем не менее чем-то необычным возникают ситуации, в которой сравнение эти пары с учетом языка и региональных параметров, создают проблемы, так как эти пары не распространены в фиксированных строк или идентификаторов.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates some of the differences in casing rules between cultures when converting strings to uppercase.</source>
          <target state="translated">В следующем примере показано некоторые различия в правила определения регистра для языков и региональных параметров при преобразовании строки в верхний регистр.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Parsing and formatting</source>
          <target state="translated">Синтаксический анализ и форматирование</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Formatting and parsing are inverse operations.</source>
          <target state="translated">Форматирование и анализ — это обратная операции.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Formatting rules determine how to convert a value, such as a date and time or a number, to its string representation, whereas parsing rules determine how to convert a string representation to a value such as a date and time.</source>
          <target state="translated">Правила форматирования определяют способ преобразования значения, например даты и времени или номер, в строковое представление, а правила анализа определяют, как преобразовать строковое представление значения, такие как дата и время.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Both formatting and parsing rules are dependent on cultural conventions.</source>
          <target state="translated">Правила синтаксического анализа и форматирования, зависят от национальные стандарты.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the ambiguity that can arise when interpreting a culture-specific date string.</source>
          <target state="translated">В следующем примере демонстрируется неоднозначность, могут возникнуть при интерпретации строки даты конкретного языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Without knowing the conventions of the culture that was used to produce a date string, it is not possible to know whether 03/01/2011, 3/1/2011, and 01/03/2011 represent January 3, 2011 or March 1, 2011.</source>
          <target state="translated">Не зная соглашения языка и региональных параметров, который использовался для создания строки даты, не невозможно знать 03, 01/2011, 3 1 сентября и 01/03/2011 представляют ли 3 января 2011 г. и 1 марта 2011 г.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Similarly, as the following example shows, a single string can produce different dates depending on the culture whose conventions are used in the parsing operation.</source>
          <target state="translated">Точно так же как показано в следующем примере, одну строку может привести к разные даты в зависимости от языка и региональных параметров, чьи правила используются в операции анализа.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String comparison and sorting</source>
          <target state="translated">Сравнение и сортировка строк</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Conventions for comparing and sorting strings vary from culture to culture.</source>
          <target state="translated">Соглашения для сравнения и сортировки строк зависят от языка и региональных параметров для языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the sort order may be based on phonetics or on the visual representation of characters.</source>
          <target state="translated">Например порядок сортировки может основываться на Фонетическое имя или визуального представления символов.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In East Asian languages, characters are sorted by the stroke and radical of ideographs.</source>
          <target state="translated">В языках Восточной Азии символы являются сортируется по штриха и корнями идеограмм.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Sorting also depends on the order languages and cultures use for the alphabet.</source>
          <target state="translated">Также сортировки зависит от языков порядке и использовать языки и региональные параметры для алфавита.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the Danish language has an "Æ" character that it sorts after "Z" in the alphabet.</source>
          <target state="translated">Например датского языка содержит символ «Æ», который в алфавите после «Z».</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In addition, comparisons can be case-sensitive or case-insensitive, and in some cases casing rules also differ by culture.</source>
          <target state="translated">Кроме того сравнение может проводиться с учетом регистра и без учета регистра, и в некоторых случаях правила определения регистра также различаются языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Ordinal comparison, on the other hand, uses the Unicode code points of individual characters in a string when comparing and sorting strings.</source>
          <target state="translated">Порядковое сравнение, с другой стороны, использует кодовые точки Юникода отдельных символов в строке, когда сравнения и сортировки строк.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Sort rules determine the alphabetic order of Unicode characters and how two strings compare to each other.</source>
          <target state="translated">Правила сортировки определяют алфавитный порядок символов в кодировке Юникод и как две строки, сравнивать друг с другом.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType&gt;</ph> method compares two strings based on the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> parameter.</source>
          <target state="translated">Например <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType&gt;</ph> метод сравнивает две строки, на основе <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> параметра.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the parameter value is <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>, the method performs a linguistic comparison that uses the conventions of the current culture; if the parameter value is <ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph>, the method performs an ordinal comparison.</source>
          <target state="translated">Если значение параметра <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>, этот метод выполняет лингвистическое сравнение, используются соглашения текущих региональных параметров; Если значение параметра <ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph>, этот метод выполняет порядковое сравнение.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Consequently, as the following example shows, if the current culture is U.S. English, the first call to the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType&gt;</ph> method (using culture-sensitive comparison) considers "a" less than "A", but the second call to the same method (using ordinal comparison) considers "a" greater than "A".</source>
          <target state="translated">Таким образом как показано в следующем примере, если текущий язык — американский английский Английский, первый вызов <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType&gt;</ph> метод (с помощью сравнения с учетом языка и региональных параметров) рассматривает «» меньше «A», но второй вызов (с помощью порядкового сравнения) и тот же метод считает, что «a» больше «A».</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework supports word, string, and ordinal sort rules:</source>
          <target state="translated">Платформа .NET Framework поддерживает слова, строки и правила сортировки по порядковому номеру:</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A word sort performs a culture-sensitive comparison of strings in which certain nonalphanumeric Unicode characters might have special weights assigned to them.</source>
          <target state="translated">При сортировке по словам выполняет сравнение с учетом языка и региональных параметров строки, в котором некоторые символы Юникода могут иметь особые весовые коэффициенты.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the hyphen (-) might have a very small weight assigned to it so that "coop" and "co-op" appear next to each other in a sorted list.</source>
          <target state="translated">Например дефис (-) может иметь очень низкий весовой слова «coop» и «совместную» отображаются рядом друг с другом в отсортированном списке.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For a list of the <ph id="ph1">&lt;xref:System.String&gt;</ph> methods that compare two strings using word sort rules, see the <bpt id="p1">[</bpt>String operations by category<ept id="p1">](#ByCategory)</ept> section.</source>
          <target state="translated">Список <ph id="ph1">&lt;xref:System.String&gt;</ph> см. методы, которые сравнивают две строки с использованием правил сортировки по словам, <bpt id="p1">[</bpt>строковые операции по категориям<ept id="p1">](#ByCategory)</ept> раздела.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A string sort also performs a culture-sensitive comparison.</source>
          <target state="translated">Сортировка по строкам также выполняет сравнение с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It is similar to a word sort, except that there are no special cases, and all nonalphanumeric symbols come before all alphanumeric Unicode characters.</source>
          <target state="translated">Она аналогична сортировке по словам, за исключением того, что нет особых случаев нет и все следуют после остальных все алфавитно-цифровые символы Юникода.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Two strings can be compared using string sort rules by calling the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType&gt;</ph> method overloads that have an <ph id="ph2">`options`</ph> parameter that is supplied a value of <ph id="ph3">&lt;xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Можно сравнить две эти строки с помощью правила сортировки строк путем вызова <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType&gt;</ph> перегрузки метода, которые имеют <ph id="ph2">`options`</ph> параметр, который имеет указанное значение <ph id="ph3">&lt;xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that this is the only method that the .NET Framework provides to compare two strings using string sort rules.</source>
          <target state="translated">Обратите внимание, что это единственный метод, который платформа .NET Framework предоставляет для сравнения двух строк, используя правила сортировки строк.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal sort compares strings based on the numeric value of each <ph id="ph1">&lt;xref:System.Char&gt;</ph> object in the string.</source>
          <target state="translated">Сортировке по порядковому номеру строки сравниваются на основе числовых значений каждого <ph id="ph1">&lt;xref:System.Char&gt;</ph> объект в строку.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal comparison is automatically case-sensitive because the lowercase and uppercase versions of a character have different code points.</source>
          <target state="translated">Порядковое сравнение автоматически с учетом регистра, так как в нижнем и верхнем регистре символа имеют различные кодовые точки.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, if case is not important, you can specify an ordinal comparison that ignores case.</source>
          <target state="translated">Тем не менее если регистр не важен, можно указать порядковое сравнение, не учитывающее регистр.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is equivalent to converting the string to uppercase by using the invariant culture and then performing an ordinal comparison on the result.</source>
          <target state="translated">Это эквивалентно преобразование строки в верхний регистр с помощью инвариантного языка и региональных параметров и выполнению порядковое сравнение результат.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For a list of the <ph id="ph1">&lt;xref:System.String&gt;</ph> methods that compare two strings using ordinal sort rules, see the <bpt id="p1">[</bpt>String operations by category<ept id="p1">](#ByCategory)</ept> section.</source>
          <target state="translated">Список <ph id="ph1">&lt;xref:System.String&gt;</ph> см. методы, которые сравнивают две строки, используя правила сортировки по порядковому номеру <bpt id="p1">[</bpt>строковые операции по категориям<ept id="p1">](#ByCategory)</ept> раздела.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A culture-sensitive comparison is any comparison that explicitly or implicitly uses a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object, including the invariant culture that is specified by the <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Сравнение с учетом языка и региональных параметров является любого сравнения, явно или неявно использующая <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> объекта, включая инвариантных региональных параметров, который задается параметром <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The implicit culture is the current culture, which is specified by the <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">Неявные языка и региональных параметров является текущим языком, который задается <ph id="ph1">&lt;xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>There is considerable variation in the sort order of alphabetic characters (that is, characters for which the <ph id="ph1">&lt;xref:System.Char.IsLetter%2A?displayProperty=nameWithType&gt;</ph> property returns <ph id="ph2">`true`</ph>) across cultures.</source>
          <target state="translated">Есть много вариантов в порядке сортировки букв (то есть символы, для которого <ph id="ph1">&lt;xref:System.Char.IsLetter%2A?displayProperty=nameWithType&gt;</ph> возвращает <ph id="ph2">`true`</ph>) различных региональных параметров.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can specify a culture-sensitive comparison that uses the conventions of a specific culture by supplying a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object to a string comparison method such as <ph id="ph2">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph>.</source>
          <target state="translated">Можно указать язык и региональные параметры сравнение, которое использует правила конкретного языка и региональных параметров, указав <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> объекта метод сравнения строк, например <ph id="ph2">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can specify a culture-sensitive comparison that uses the conventions of the current culture by supplying <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>, or any member of the <ph id="ph3">&lt;xref:System.Globalization.CompareOptions&gt;</ph> enumeration other than <ph id="ph4">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph5">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> to an appropriate overload of the <ph id="ph6">&lt;xref:System.String.Compare%2A&gt;</ph> method.</source>
          <target state="translated">Можно указать сравнение с учетом языка и региональных параметров, используются соглашения текущих региональных параметров, указав <ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>, или любой член <ph id="ph3">&lt;xref:System.Globalization.CompareOptions&gt;</ph> перечисления, отличное от <ph id="ph4">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph> или <ph id="ph5">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> в соответствующую перегрузку <ph id="ph6">&lt;xref:System.String.Compare%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A culture-sensitive comparison is generally appropriate for sorting whereas an ordinal comparison is not.</source>
          <target state="translated">Сравнение с учетом языка и региональных параметров обычно подходит для сортировки, тогда как порядковое сравнение — нет.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal comparison is generally appropriate for determining whether two strings are equal (that is, for determining identity) whereas a culture-sensitive comparison is not.</source>
          <target state="translated">Порядковое сравнение, как правило, подходит для определения того, равны ли две строки (то есть, для определения идентификаторов), тогда как сравнение с учетом языка и региональных параметров не является.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the difference between culture-sensitive and ordinal comparison.</source>
          <target state="translated">В следующем примере показано различие между сравнения с учетом языка и региональных параметров и порядковый номер.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The example evaluates three strings, "Apple", "Æble", and "AEble", using ordinal comparison and the conventions of the da-DK and en-US cultures (each of which is the default culture at the time the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method is called).</source>
          <target state="translated">Пример возвращает три строки, «Apple», «Æble» и «AEble», используя порядковое сравнение и соглашения о языков и региональных параметров da-DK и en US (каждый из которых является культуры по умолчанию во время <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> вызывается метод).</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the Danish language treats the character "Æ" as an individual letter and sorts it after "Z" in the alphabet, the string "Æble" is greater than "Apple".</source>
          <target state="translated">Поскольку датского языка считает символ «Æ» отдельной буквой и он сортируется в алфавите после «Z», строка «Æble» больше «Apple».</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, "Æble" is not considered equivalent to "AEble", so "Æble" is also greater than "AEble".</source>
          <target state="translated">Однако «Æble» не считаются эквивалентными, «AEble», поэтому «Æble» также больше, чем «AEble».</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The en-US culture doesn't include the letter"Æ" but treats it as equivalent to "AE", which explains why  "Æble" is less than "Apple" but equal to "AEble".</source>
          <target state="translated">Не содержит букву «Æ» en-US, но считает, что эквивалентно «AE», объясняется, почему «Æble» меньше, чем «Apple», но равно «AEble».</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Ordinal comparison, on the other hand, considers "Apple" to be less than "Æble", and "Æble" to be greater than "AEble".</source>
          <target state="translated">Порядковое сравнение, с другой стороны, считает, что «Apple» должно быть меньше чем «Æble» и «Æble» должно быть больше «AEble».</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Use the following general guidelines to choose an appropriate sorting or string comparison method:</source>
          <target state="translated">Используйте следующие общие рекомендации для выбора соответствующего метода сравнения сортировки или строки:</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you want the strings to be ordered based on the user's culture, you should order them based on the conventions of the current culture.</source>
          <target state="translated">Если вы хотите строки располагаются в зависимости от языка и региональных параметров пользователя, следует упорядочивает их исходя из соглашений текущего языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the user's culture changes, the order of sorted strings will also change accordingly.</source>
          <target state="translated">Изменение языка и региональных параметров пользователя, порядок сортировки строк также изменится соответствующим образом.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, a thesaurus application should always sort words based on the user's culture.</source>
          <target state="translated">Например приложения тезауруса всегда следует отсортировать слова, в зависимости от языка и региональных параметров пользователя.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you want the strings to be ordered based on the conventions of a specific culture, you should order them by supplying a <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object that represents that culture to a comparison method.</source>
          <target state="translated">Если вы хотите строки упорядоченный зависимости от соглашений для определенного языка и региональных параметров, следует расположите их, указав <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> объект, представляющий этот язык для метода сравнения.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, in an application designed to teach students a particular language, you want strings to be ordered based on the conventions of one of the cultures that speaks that language.</source>
          <target state="translated">Например в приложение, предназначенное для обучения на конкретном языке, необходимо строк в порядке зависимости от соглашения одного из языков, в которых говорит этого языка.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you want the order of strings to remain unchanged across cultures, you should order them based on the conventions of the invariant culture or use an ordinal comparison.</source>
          <target state="translated">Если требуется, чтобы порядок строк в остаются неизменными в разных языках, следует согласно соглашения инвариантных региональных параметров или использовать порядковое сравнение.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, you would use an ordinal sort to organize the names of files, processes, mutexes, or named pipes.</source>
          <target state="translated">Например будет производить упорядочить имена файлов, процессы, мьютексы сортировке по порядковому номеру или именованных каналов.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For a comparison that involves a security decision (such as whether a username is valid), you should always perform an ordinal test for equality by calling an overload of the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Сравнение, которое включает в себя решение, влияющее на безопасность (например, допустим ли имя пользователя), следует всегда выполнять порядковый номер проверка на равенство путем вызова перегрузки <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The culture-sensitive sorting and casing rules used in string comparison depend on the version of the .NET Framework.</source>
          <target state="translated">Язык и региональные параметры сортировки и правила, используемые при сравнении строк регистр зависят от версии платформы .NET Framework.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In the .NET Framework <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> running on the <ph id="ph2">[!INCLUDE[win8](~/includes/win8-md.md)]</ph> operating system, sorting, casing, normalization, and Unicode character information conforms to the Unicode 6.0 standard.</source>
          <target state="translated">В платформе .NET Framework <ph id="ph1">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> на <ph id="ph2">[!INCLUDE[win8](~/includes/win8-md.md)]</ph> операционной системой, сортировки, регистр, нормализация и информация о символе Юникода соответствует стандарту Юникод 6.0.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On other operating systems, it conforms to the Unicode 5.0 standard.</source>
          <target state="translated">В других операционных системах его в соответствии со стандартом Unicode 5.0.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information about word, string, and ordinal sort rules, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> topic.</source>
          <target state="translated">Дополнительные сведения о слова, строки и правила сортировки по порядковому номеру. в разделе <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> раздела.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For additional recommendations on when to use each rule, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Дополнительные рекомендации по использованию каждого правила см. в разделе <bpt id="p1">[</bpt>советы и рекомендации по использованию строк<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Ordinarily, you don't call string comparison methods such as <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> directly to determine the sort order of strings.</source>
          <target state="translated">Как правило, вы не вызываете строковое сравнение методов, таких как <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> напрямую, чтобы определить порядок сортировки строк.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Instead, comparison methods are called by sorting methods such as <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Вместо этого сравнения методы вызываются при сортировке методы, такие как <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example performs four different sorting operations (word sort using the current culture, word sort using the invariant culture, ordinal sort, and string sort using the invariant culture) without explicitly calling a string comparison method, although they do specify the type of comparison to use.</source>
          <target state="translated">В следующем примере выполняется четыре различных сортировки операций (word сортировка с использованием текущего языка и региональных параметров, с помощью инвариантного языка и региональных параметров при сортировке по словам, порядковый номер сортировки и сортировка по строкам с помощью инвариантного языка и региональных параметров) без явного вызова метод сравнения строк, несмотря на то, что они указывают тип сравнения.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that each type of sort produces a unique ordering of strings in its array.</source>
          <target state="translated">Обратите внимание, что каждый тип сортировки создает уникальный порядок строк в массиве его.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Internally, the.NET Framework uses sort keys to support culturallysensitive string comparison.</source>
          <target state="translated">На внутреннем уровне платформы.NET Framework использует ключи сортировки для поддержки culturallysensitive сравнения строк.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each character in a string is given several categories of sort weights, including alphabetic, case, and diacritic.</source>
          <target state="translated">Каждый символ в строке присваивается несколько категорий весовых коэффициентов для сортировки, включая буквы, регистра и диакритических знаков.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A sort key, represented by the <ph id="ph1">&lt;xref:System.Globalization.SortKey&gt;</ph> class, provides a repository of these weights for a particular string.</source>
          <target state="translated">Ключ сортировки, представленного <ph id="ph1">&lt;xref:System.Globalization.SortKey&gt;</ph> класса, предоставляет хранилищем этих весовых коэффициентов для конкретной строки.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If your app performs a large number of searching or sorting operations on the same set of strings, you can improve its performance by generating and storing sort keys for all the strings that it uses.</source>
          <target state="translated">Если приложение выполняет большое количество поиска или сортировки операций на том же наборе строк, можно повысить его производительность путем создания и хранения ключей сортировки для всех строк, которые он использует.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When a sort or comparison operation is required, you use the sort keys instead of the strings.</source>
          <target state="translated">Если операция сортировки или сравнения требуется, вместо строк используется ключи сортировки.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Globalization.SortKey&gt;</ph> class.</source>
          <target state="translated">Дополнительные сведения см. в описании класса <ph id="ph1">&lt;xref:System.Globalization.SortKey&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you don't specify a string comparison convention, sorting methods such as <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType&gt;</ph> perform a culture-sensitive, case-sensitive sort on strings.</source>
          <target state="translated">Если не указать соглашение строковое сравнение, сортировка методы такие как <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType&gt;</ph> выполнения сортировки язык и региональные параметры, с учетом регистра для строк.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates how changing the current culture affects the order of sorted strings in an array.</source>
          <target state="translated">В следующем примере показано, как изменение текущего языка и региональных параметров влияет на порядок сортировки строк в массиве.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It creates an array of three strings.</source>
          <target state="translated">Он создает массив из трех строк.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>First, it sets the <ph id="ph1">`System.Threading.Thread.CurrentThread.CurrentCulture`</ph> property to en-US and calls the <ph id="ph2">&lt;xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Во-первых, он задает <ph id="ph1">`System.Threading.Thread.CurrentThread.CurrentCulture`</ph> свойство en US и вызовы <ph id="ph2">&lt;xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The resulting sort order is based on sorting conventions for the English (United States) culture.</source>
          <target state="translated">Полученный порядок сортировки основан на правилах сортировки для английского языка (США).</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Next, the example sets the <ph id="ph1">`System.Threading.Thread.CurrentThread.CurrentCulture`</ph> property to da-DK and calls the <ph id="ph2">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph> method again.</source>
          <target state="translated">Далее в этом примере <ph id="ph1">`System.Threading.Thread.CurrentThread.CurrentCulture`</ph> свойство da-DK и вызовы <ph id="ph2">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph> метод снова.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Notice how the resulting sort order differs from the en-US results because it uses the sorting conventions for Danish (Denmark).</source>
          <target state="translated">Обратите внимание на то, как полученный порядок сортировки отличается от результатов en US, так как он использует правила сортировки для датский (Дания).</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If your primary purpose in comparing strings is to determine whether they are equal, you should call the <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Если ваш основной целью при сравнении строк — определить, равны ли они, следует вызывать <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Typically, you should use <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> to perform an ordinal comparison.</source>
          <target state="translated">Как правило, следует использовать <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> для выполняют порядковое сравнение.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> method is intended primarily to sort strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> Метод предназначен главным образом для сортировки строк.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String search methods, such as <ph id="ph1">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, also can perform culture-sensitive or ordinal string comparisons.</source>
          <target state="translated">Строка методов поиска, такие как <ph id="ph1">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, также можно выполнить сравнения строк с учетом языка и региональных параметров или порядковый номер.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the differences between ordinal and culture-sensitive comparisons using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере различий между порядковым сравнением и учетом языка и региональных параметров сравнения с использованием <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A culture-sensitive search in which the current culture is English (United States) considers the substring "oe" to match the ligature "œ".</source>
          <target state="translated">Язык и региональные параметры поиска, в котором текущий язык — Русский (Россия) считает, что подстрока «обозревателя объектов» для сопоставления лигатуры «œ».</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because a soft hyphen (U+00AD) is a zero-width character, the search treats the soft hyphen as equivalent to <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> and finds a match at the beginning of the string.</source>
          <target state="translated">Поскольку мягкий перенос (U + 00AD) является символ нулевой ширины, поиск считает мягкий перенос эквивалентно <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> и обнаруживает совпадение в начале строки.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal search, on the other hand, does not find a match in either case.</source>
          <target state="translated">Поиск по порядковым номерам, с другой стороны, не найден в любом случае.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Searching Strings</source>
          <target state="translated">Поиск строк</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String search methods, such as <ph id="ph1">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, also can perform culture-sensitive or ordinal string comparisons to determine whether a character or substring is found in a specified string.</source>
          <target state="translated">Строка методов поиска, такие как <ph id="ph1">&lt;xref:System.String.StartsWith%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.String.IndexOf%2A?displayProperty=nameWithType&gt;</ph>, также можно выполнить от культуры или сравнения строк по порядковому номеру, чтобы определить, является ли символ или подстрока находится в указанной строке.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The search methods in the <ph id="ph1">&lt;xref:System.String&gt;</ph> class that search for an individual character, such as the <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> method, or one of a set of characters,   such as the <ph id="ph3">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, all perform an ordinal search.</source>
          <target state="translated">Методы поиска в <ph id="ph1">&lt;xref:System.String&gt;</ph> класс, поиск отдельный символ, такой как <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> метода или одного из набора символов, таких как <ph id="ph3">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> метод, все выполнить поиск по порядковым номерам.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To perform a culture-sensitive search for a character, you must call a <ph id="ph1">&lt;xref:System.Globalization.CompareInfo&gt;</ph> method such as <ph id="ph2">&lt;xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Чтобы выполнить поиск с учетом языка и региональных параметров для символа, необходимо вызвать <ph id="ph1">&lt;xref:System.Globalization.CompareInfo&gt;</ph> метода, такие как <ph id="ph2">&lt;xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph> или <ph id="ph3">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that the results of searching for a character using ordinal and culture-sensitive comparison can be very different.</source>
          <target state="translated">Обратите внимание, что результаты поиска символа, используя порядковый номер языка и региональных параметров сравнения может быть очень другим.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, a search for a precomposed Unicode character such as the ligature "Æ" (U+00C6) might match any occurrence of its components in the correct sequence, such as "AE" (U+041U+0045), depending on the culture.</source>
          <target state="translated">Например, при поиске составной знак Юникода, например лигатуры «Æ» (U + 00 C 6) может совпадать с любого вхождения его компонентов в правильной последовательности, например «AE» (U + 041U + 0045), в зависимости от языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the difference between the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph> methods when searching for an individual character.</source>
          <target state="translated">В следующем примере показано различие между <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType&gt;</ph> методов при поиске отдельному символу.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The ligature "æ" (U+00E6) is found in the string "aerial" when using the conventions of the en-US culture, but not when using the conventions of the da-DK culture or when performing an ordinal comparison.</source>
          <target state="translated">Лигатуры «æ» (U + 00E6) находится в строке «воздушный» при использовании соглашения о региональных параметров en US, но не при использовании правил языка da-DK или при выполнении порядкового сравнения.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On the other hand, <ph id="ph1">&lt;xref:System.String&gt;</ph> class methods that search for a string rather than a character perform a culture-sensitive search if search options are not explicitly specified by a parameter of type <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph>.</source>
          <target state="translated">С другой стороны <ph id="ph1">&lt;xref:System.String&gt;</ph> методы, которые поиск в строке, а не знак выполнения поиска с учетом языка и региональных параметров, если параметры поиска не заданы явным образом, параметр типа класса <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The sole exception is <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, which performs an ordinal search.</source>
          <target state="translated">Единственным исключением является <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, который выполняет поиск по порядковым номерам.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Testing for equality</source>
          <target state="translated">Тестирование на равенство</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Use the <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> method to determine the relationship of two strings in the sort order.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы определить связь между двумя строками в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Typically, this is a culture-sensitive operation.</source>
          <target state="translated">Как правило это операция с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In contrast, call the <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> method to test for equality.</source>
          <target state="translated">Напротив, вызовите <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> метод для проверки на равенство.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the test for equality usually compares user input with some known string, such as a valid user name, a password, or a file system path, it is typically an ordinal operation.</source>
          <target state="translated">Поскольку проверка на равенство обычно сравнивает ввода данных пользователем с некоторые известные строку, такую как допустимое имя пользователя, пароль или путь в файловой системе, обычно это порядковые операции.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It is possible to test for equality by calling the <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> method and determining whether the return value is zero.</source>
          <target state="translated">Существует возможность проверки на равенство, вызвав <ph id="ph1">&lt;xref:System.String.Compare%2A?displayProperty=nameWithType&gt;</ph> метод и определить, является ли возвращаемое значение ноль.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, this practice is not recommended.</source>
          <target state="translated">Однако это не рекомендуется.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To determine whether two strings are equal, you should call one of the overloads of the <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Чтобы определить, равны ли две строки, следует вызвать один из перегруженных версий <ph id="ph1">&lt;xref:System.String.Equals%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The preferred overload to call is either the instance <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph> method or the static <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, because both methods include a <ph id="ph3">&lt;xref:System.StringComparison?displayProperty=nameWithType&gt;</ph> parameter that explicitly specifies the type of comparison.</source>
          <target state="translated">Предпочтительная перегрузка для вызова является либо экземпляром по <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph> метод или статическое <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> метод, так как оба метода содержат <ph id="ph3">&lt;xref:System.StringComparison?displayProperty=nameWithType&gt;</ph> параметра, которая явно задает тип сравнения.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example illustrates the danger of performing a culture-sensitive comparison for equality when an ordinal one should be used instead.</source>
          <target state="translated">В следующем примере демонстрируется опасности выполнения сравнения с учетом языка и региональных параметров на равенство, если один из них следует использовать вместо этого порядкового номера.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In this case, the intent of the code is to prohibit file system access from URLs that begin with "FILE://" or "file://" by performing a case-insensitive comparison of the beginning of a URL with the string "FILE://".</source>
          <target state="translated">В этом случае назначение кода — запретить доступ к файловой системе из URL-адреса, начинающиеся с «FILE://» или «file://», выполняя сравнение без учета регистра и начинается URL-адреса со строкой «FILE://».</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, if a culture-sensitive comparison is performed using the Turkish (Turkey) culture on a URL that begins with "file://", the comparison for equality fails, because the Turkish uppercase equivalent of the lowercase "i" is "İ" instead of "I".</source>
          <target state="translated">Тем не менее если выполняется сравнение с учетом языка и региональных параметров, используется культура турецкий (Турция) на URL-адрес, который начинается с «file://», сравнения на равенство завершается ошибкой, поскольку турецкого заглавный эквивалент нижнего регистра «i» — «İ» вместо «I».</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>As a result, file system access is inadvertently permitted.</source>
          <target state="translated">В результате непреднамеренного разрешен доступ к файловой системе.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On the other hand, if an ordinal comparison is performed, the comparison for equality succeeds, and file system access is denied.</source>
          <target state="translated">С другой стороны Если выполняется порядковое сравнение, сравнение на равенство успешно и запрещен доступ к файловой системе.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Normalization</source>
          <target state="translated">Нормализация</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Some Unicode characters have multiple representations.</source>
          <target state="translated">Некоторые символы Юникода имеют несколько представлений.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, any of the following code points can represent the letter "ắ":</source>
          <target state="translated">Например любой из следующих кодовых точек может представлять собой букву символа «ắ»:</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>U+1EAF</source>
          <target state="translated">U + 1EAF</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>U+0103 U+0301</source>
          <target state="translated">U + 0103 U + 0301</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>U+0061 U+0306 U+0301</source>
          <target state="translated">U+0061 U+0306 U+0301</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Multiple representations for a single character complicate searching, sorting, matching, and other string operations.</source>
          <target state="translated">Несколько представлений одного символа усложнить поиск, сортировка, сопоставления и других операций со строками.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The Unicode standard defines a process called normalization that returns one binary representation of a Unicode character for any of its equivalent binary representations.</source>
          <target state="translated">В стандарте Юникода определен процесс, называемый нормализацией, который возвращает одно двоичное представление символа Юникода для любого из его эквивалентных представлений.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Normalization can use several algorithms, called normalization forms, that follow different rules.</source>
          <target state="translated">Нормализация можно использовать несколько алгоритмов, называются формами нормализации, следующие за различные правила.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework supports Unicode normalization forms C, D, KC, and KD.</source>
          <target state="translated">Платформа .NET Framework поддерживает формы нормализации Юникода C, D, КС и KD.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When strings have been normalized to the same normalization form, they can be compared by using ordinal comparison.</source>
          <target state="translated">Когда строки были нормализованы по одной и той же форме нормализации, они могут сравниваться с помощью порядкового сравнения.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An ordinal comparison is a binary comparison of the Unicode scalar value of corresponding <ph id="ph1">&lt;xref:System.Char&gt;</ph> objects in each string.</source>
          <target state="translated">Порядковое сравнение представляет собой двоичное сравнение скалярного значения Юникода, соответствующего <ph id="ph1">&lt;xref:System.Char&gt;</ph> объектов в каждой строке.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class includes a number of methods that can perform an ordinal comparison, including the following:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String&gt;</ph> Класс содержит несколько методов, которые можно выполнить порядковое сравнение, включая следующие:</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Any overload of the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.Equals%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.String.StartsWith%2A&gt;</ph>,  <ph id="ph4">&lt;xref:System.String.EndsWith%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.String.IndexOf%2A&gt;</ph>, and <ph id="ph6">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> methods that includes a <ph id="ph7">&lt;xref:System.StringComparison&gt;</ph> parameter.</source>
          <target state="translated">Любой перегрузки <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.Equals%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.String.StartsWith%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.String.EndsWith%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.String.IndexOf%2A&gt;</ph>, и <ph id="ph6">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> методов, включая <ph id="ph7">&lt;xref:System.StringComparison&gt;</ph> параметра.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The method performs an ordinal comparison if you supply a value of <ph id="ph1">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.StringComparison.OrdinalIgnoreCase&gt;</ph> for this parameter.</source>
          <target state="translated">Этот метод выполняет порядковое сравнение, если указать значение <ph id="ph1">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.StringComparison.OrdinalIgnoreCase&gt;</ph> для этого параметра.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> method.</source>
          <target state="translated">Перегруженные версии <ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Methods that use ordinal comparison by default, such as <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.Replace%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.String.Split%2A&gt;</ph>.</source>
          <target state="translated">Методы, которые используют порядковое сравнение по умолчанию, таких как <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.Replace%2A&gt;</ph>, и <ph id="ph3">&lt;xref:System.String.Split%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Methods that search for a <ph id="ph1">&lt;xref:System.Char&gt;</ph> value or for the elements in a <ph id="ph2">&lt;xref:System.Char&gt;</ph> array in a string instance.</source>
          <target state="translated">Методы, которые выполняют поиск <ph id="ph1">&lt;xref:System.Char&gt;</ph> значение или для элементов в <ph id="ph2">&lt;xref:System.Char&gt;</ph> массива в экземпляр строки.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Such methods include <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29&gt;</ph> and <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph>.</source>
          <target state="translated">Такие методы включают <ph id="ph1">&lt;xref:System.String.IndexOf%28System.Char%29&gt;</ph> и <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can determine whether a string is normalized to normalization form C by calling the <ph id="ph1">&lt;xref:System.String.IsNormalized?displayProperty=nameWithType&gt;</ph> method, or you can call the <ph id="ph2">&lt;xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType&gt;</ph> method to determine whether a string is normalized to a specified normalization form.</source>
          <target state="translated">Можно определить, является ли строка в форме нормализации Юникода C нормализуется путем вызова <ph id="ph1">&lt;xref:System.String.IsNormalized?displayProperty=nameWithType&gt;</ph> можно вызвать метод, или <ph id="ph2">&lt;xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType&gt;</ph> метод, чтобы определить, является ли строка нормализованным в форму нормализации, указанной.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also call the <ph id="ph1">&lt;xref:System.String.Normalize?displayProperty=nameWithType&gt;</ph> method to convert a string to normalization form C, or you can call the <ph id="ph2">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType&gt;</ph> method to convert a string to a specified normalization form.</source>
          <target state="translated">Можно также вызвать <ph id="ph1">&lt;xref:System.String.Normalize?displayProperty=nameWithType&gt;</ph> можно вызвать метод для преобразования строки в форме нормализации Юникода C, или <ph id="ph2">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType&gt;</ph> метод для преобразования строки в указанной форму.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For step-by-step information about normalizing and comparing strings, see the <ph id="ph1">&lt;xref:System.String.Normalize&gt;</ph> and <ph id="ph2">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29&gt;</ph> methods.</source>
          <target state="translated">Пошаговые инструкции о нормализации и сравнения строк см. в разделе <ph id="ph1">&lt;xref:System.String.Normalize&gt;</ph> и <ph id="ph2">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following simple example illustrates string normalization.</source>
          <target state="translated">В следующем простом примере показан нормализации строк.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It defines the letter "ố" in three different ways in three different strings, and uses an ordinal comparison for equality to determine that each string differs from the other two strings.</source>
          <target state="translated">Он определяет букву «ố» тремя разными способами в трех разных строках и использует порядковое сравнение на равенство, чтобы определить, что каждая строка отличается от других двух строк.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It then converts each string to the supported normalization forms, and again performs an ordinal comparison of each string in a specified normalization form.</source>
          <target state="translated">Затем преобразует каждую строку в формах нормализации, поддерживаемых и снова выполняет порядковое сравнение каждой строки в указанной нормализованной форме.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In each case, the second test for equality shows that the strings are equal.</source>
          <target state="translated">В каждом случае второй тест для проверки равенства показывает строки равны.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information about normalization and normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>, as well as <bpt id="p1">[</bpt>Unicode Standard Annex #15: Unicode Normalization Forms<ept id="p1">](https://unicode.org/reports/tr15/)</ept> and the <bpt id="p2">[</bpt>Normalization FAQ<ept id="p2">](https://www.unicode.org/faq/normalization.html)</ept> on the unicode.org website.</source>
          <target state="translated">Дополнительные сведения о нормализации и формы нормализации см. в разделе <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>, а также <bpt id="p1">[</bpt>Unicode Standard Annex #15: формы нормализации Юникода<ept id="p1">](https://unicode.org/reports/tr15/)</ept> и <bpt id="p2">[</bpt>нормализация часто задаваемые вопросы о<ept id="p2">](https://www.unicode.org/faq/normalization.html)</ept> на кодовые веб-сайт.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String operations by category</source>
          <target state="translated">Операции со строками по категориям</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class provides members for comparing strings, testing strings for equality, finding characters or substrings in a string, modifying a string, extracting substrings from a string, combining strings, formatting values, copying a string, and normalizing a string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String&gt;</ph> Класс содержит члены для сравнения строк, проверка строк на равенство, поиск символов или подстроки в строке, изменив строку, извлечение подстрок из строки, объединение строк, форматирование значений, копируя строки и нормализации строки.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Comparing strings</source>
          <target state="translated">Сравнение строк</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can compare strings to determine their relative position in the sort order by using the following <ph id="ph1">&lt;xref:System.String&gt;</ph> methods:</source>
          <target state="translated">Может сравнивать строки, чтобы определить их относительное положение в порядке сортировки, с помощью следующих <ph id="ph1">&lt;xref:System.String&gt;</ph> методов:</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> returns an integer that indicates the relationship of one string to a second string in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> Возвращает целое число, показывающее связь между одну строку для второй строки в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> returns an integer that indicates the relationship of one string to a second string based on a comparison of their code points.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> Возвращает целое число, показывающее связь между одну строку для второй строки на основе сравнения их кодовыми точками.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> returns an integer that indicates the relationship of the current string instance to a second string in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> Возвращает целое число, показывающее связь между текущего экземпляра строки на второй строки в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> method provides the <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> and <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> implementations for the <ph id="ph4">&lt;xref:System.String&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.CompareTo%28System.String%29&gt;</ph> Предоставляет метод <ph id="ph2">&lt;xref:System.IComparable&gt;</ph> и <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> реализации для <ph id="ph4">&lt;xref:System.String&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Testing strings for equality</source>
          <target state="translated">Проверка строк на равенство</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method to determine whether two strings are equal.</source>
          <target state="translated">Вызывается <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> метод, чтобы определить, равны ли две строки.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The instance <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> and the static <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph> overloads let you specify whether the comparison is culture-sensitive or ordinal, and whether case is considered or ignored.</source>
          <target state="translated">Экземпляр <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> и статический <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph> перегрузки позволяют задать ли сравнение с учетом или порядковый номер, и считается или учитывается регистр.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Most tests for equality are ordinal, and comparisons for equality that determine access to a system resource (such as a file system object) should always be ordinal.</source>
          <target state="translated">Многие тесты на равенство является порядковым и сравнения на равенство, которые определяют доступ к ресурсу системы (например, объект файловой системы) всегда должен быть порядковым номерам.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Finding characters in a string</source>
          <target state="translated">Поиск символов в строке</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class includes two kinds of search methods:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String&gt;</ph> Класс содержит два вида методов поиска:</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Methods that return a <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> value to indicate whether a particular substring is present in a string instance.</source>
          <target state="translated">Методы, возвращающие <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> значение, указывающее, присутствует ли в экземпляре строка определенной подстрокой.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>These include the <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.EndsWith%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.String.StartsWith%2A&gt;</ph> methods.</source>
          <target state="translated">К ним относятся <ph id="ph1">&lt;xref:System.String.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.EndsWith%2A&gt;</ph>, и <ph id="ph3">&lt;xref:System.String.StartsWith%2A&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Methods that indicate the starting position of a substring in a string instance.</source>
          <target state="translated">Методы, которые указывают Начальная позиция подстроки в экземпляр строки.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>These include the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph> methods.</source>
          <target state="translated">К ним относятся <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, и <ph id="ph4">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you want to search a string for a particular pattern rather than a specific substring, you should use regular expressions.</source>
          <target state="translated">Если вы хотите искать строку для определенного шаблона, а не конкретной подстроки, следует использовать регулярные выражения.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Регулярные выражения в .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Modifying a string</source>
          <target state="translated">Изменение строки</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class includes the following methods that appear to modify the value of a string:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String&gt;</ph> Класс содержит следующие методы, используемые для изменения значения строки:</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Insert%2A&gt;</ph> inserts a string into the current <ph id="ph2">&lt;xref:System.String&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Insert%2A&gt;</ph> Вставляет строку в текущую <ph id="ph2">&lt;xref:System.String&gt;</ph> экземпляра.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> inserts one or more occurrences of a specified character at the beginning of a string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> Вставляет один или несколько вхождений указанный символ в начале строки.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> inserts one or more occurrences of a specified character at the end of a string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> Вставляет один или несколько вхождения указанного символа в конце строки.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Remove%2A&gt;</ph> deletes a substring from the current <ph id="ph2">&lt;xref:System.String&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Remove%2A&gt;</ph> Удаляет из текущего подстроки <ph id="ph2">&lt;xref:System.String&gt;</ph> экземпляра.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> replaces a substring with another substring in the current <ph id="ph2">&lt;xref:System.String&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> заменяет подстроку другой подстрокой в текущем <ph id="ph2">&lt;xref:System.String&gt;</ph> экземпляра.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.ToLower%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> convert all the characters in a string to lowercase.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.ToLower%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> преобразования всех символов в строке в нижний регистр.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> convert all the characters in a string to uppercase.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> преобразования всех символов в строке в верхний регистр.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> removes all occurrences of a character from the beginning and end of a string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> Удаляет все вхождения символа в начале и конце строки.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> removes all occurrences of a character from the end of a string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> Удаляет все вхождения символа из конца строки.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> removes all occurrences of a character from the beginning of a string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> Удаляет все вхождения символа с начала строки.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All string modification methods return a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated">Все методы изменения строк возвращают новый <ph id="ph1">&lt;xref:System.String&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>They don't modify the value of the current instance.</source>
          <target state="translated">Они не следует изменять значение текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Extracting substrings from a string</source>
          <target state="translated">Извлечение подстрок из строки</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> method separates a single string into multiple strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> Метод разделяет одну строку на несколько строк.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Overloads of the method allow you to specify multiple delimiters, to determine the maximum number of substrings that the method extracts, and to determine whether empty strings (which occur when delimiters are adjacent) are included among the returned strings.</source>
          <target state="translated">Перегрузки метода позволяют указать несколько разделители, чтобы определить максимальное число подстрок, метод извлекает и определить, включаются ли пустые строки (которые возникают при разделителя являются смежными) между возвращаемой строки.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Combining strings</source>
          <target state="translated">Объединение строк</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following <ph id="ph1">&lt;xref:System.String&gt;</ph> methods can be used for string concatenation:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.String&gt;</ph> методы можно использовать для объединения строк:</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> combines one or more substrings into a single string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> объединяет один или несколько подстрок в одну строку.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Join%2A&gt;</ph> concatenates one or more substrings into a single element and adds a separator between each substring.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Join%2A&gt;</ph> объединяет один или несколько подстрок в один элемент и добавляет разделитель между каждой подстроке.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Formatting values</source>
          <target state="translated">Значения форматирования</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> method uses the composite formatting feature to replace one or more placeholders in a string with the string representation of some object or value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> Метод используется составное форматирование для замены одного или нескольких заполнителей в строке строковым представлением некоторые объекты или значения.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method is often used to do the following:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> Метод часто используется для выполнения следующих:</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To embed the string representation of a numeric value in a string.</source>
          <target state="translated">Для внедрения строковое представление числового значения в строке.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To embed the string representation of a date and time value in a string.</source>
          <target state="translated">Для внедрения строковое представление значения даты и времени в строке.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To embed the string representation of an enumeration value in a string.</source>
          <target state="translated">Для внедрения строковое представление значения перечисления в строке.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To embed the string representation of some object that supports the <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> interface in a string.</source>
          <target state="translated">Строковое представление какой-либо объект, который поддерживает внедрение <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> интерфейса в строке.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To right-justify or left-justify a substring in a field within a larger string.</source>
          <target state="translated">Выровняйте по правому или левому краю подстроки в поле в длинной строке.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For detailed information about formatting operations and examples, see the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> overload summary.</source>
          <target state="translated">Подробные сведения о форматировании операций и примеры см. в разделе <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> перегрузки Сводка.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Copying a string</source>
          <target state="translated">Копирование строки</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can call the following <ph id="ph1">&lt;xref:System.String&gt;</ph> methods to make a copy of a string:</source>
          <target state="translated">Вы можете вызвать следующий <ph id="ph1">&lt;xref:System.String&gt;</ph> методов, чтобы скопировать строки:</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Clone%2A&gt;</ph> returns a reference to an existing <ph id="ph2">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Clone%2A&gt;</ph> Возвращает ссылку на существующую <ph id="ph2">&lt;xref:System.String&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> creates a copy of an existing string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> Создает копию существующей строки.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.CopyTo%2A&gt;</ph> copies a portion of a string to a character array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.CopyTo%2A&gt;</ph> копирует часть строки на массив символов.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Normalizing a string</source>
          <target state="translated">Нормализация строки</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In Unicode, a single character can have multiple code points.</source>
          <target state="translated">В кодировке Юникод один символ может иметь несколько точек кода.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Normalization converts these equivalent characters into the same binary representation.</source>
          <target state="translated">Нормализации преобразует эти символы эквивалент в одном двоичное представление.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Normalize%2A?displayProperty=nameWithType&gt;</ph> method performs the normalization, and the <ph id="ph2">&lt;xref:System.String.IsNormalized%2A?displayProperty=nameWithType&gt;</ph> method determines whether a string is normalized.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Normalize%2A?displayProperty=nameWithType&gt;</ph> Метод выполняет, нормализация и <ph id="ph2">&lt;xref:System.String.IsNormalized%2A?displayProperty=nameWithType&gt;</ph> метод определяет, является ли строка нормализованным.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information and an example, see the <bpt id="p1">[</bpt>Normalization<ept id="p1">](#Normalization)</ept> section earlier in this topic.</source>
          <target state="translated">Дополнительные сведения и пример см. в разделе <bpt id="p1">[</bpt>нормализации<ept id="p1">](#Normalization)</ept> ранее в этом разделе.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This type is thread safe.</source>
          <target state="translated">Данный тип потокобезопасен.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In this section:</source>
          <target state="translated">Содержание</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Overloaded constructor syntax<ept id="p1">](#Syntax)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Синтаксис перегруженного конструктора<ept id="p1">](#Syntax)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Parameters<ept id="p1">](#Params)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Параметры<ept id="p1">](#Params)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Exceptions<ept id="p1">](#Exceptions)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Исключения<ept id="p1">](#Exceptions)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Which method do I call?<ept id="p1">](#Tasks)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Какой метод нужно вызывать?<ept id="p1">](#Tasks)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Creating strings<ept id="p1">](#Creating_Strings)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Создание строк<ept id="p1">](#Creating_Strings)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Handling repetitive strings<ept id="p1">](#Repetitive)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Обработка повторяющихся строк<ept id="p1">](#Repetitive)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Examples of instantiating strings:</source>
          <target state="translated">Примеры создания экземпляров строк:</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using string assignment<ept id="p1">](#Ctor1_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Назначение строки<ept id="p1">](#Ctor1_Example)</ept></target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using a character array<ept id="p1">](#Ctor2_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>С помощью массива знаков<ept id="p1">](#Ctor2_Example)</ept></target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using a portion of a character array and repeating a single character<ept id="p1">](#Ctor3_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Используя часть массив символов и повторив один символ<ept id="p1">](#Ctor3_Example)</ept></target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using a pointer to a character array<ept id="p1">](#Ctor4_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>С помощью указателя на массив символов<ept id="p1">](#Ctor4_Example)</ept></target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using  a pointer and a range of an array<ept id="p1">](#Ctor5_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>С помощью указателя и диапазона массива<ept id="p1">](#Ctor5_Example)</ept></target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Using a pointer to a signed byte array<ept id="p1">](#Ctor6_Example)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>С помощью указателя на массив байтов со знаком<ept id="p1">](#Ctor6_Example)</ept></target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Version information<ept id="p1">](#Versions)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Сведения о версии<ept id="p1">](#Versions)</ept></target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Overloaded constructor syntax</source>
          <target state="translated">Синтаксис перегруженного конструктора</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String constructors fall into two categories: those without pointer parameters, and those with pointer parameters.</source>
          <target state="translated">Строка конструкторы делятся на две категории: без параметров-указателей, так и с помощью параметров-указателей.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The constructors that use pointers are not CLS-compliant.</source>
          <target state="translated">Конструкторы, которые используют указателей не являются CLS-совместимыми.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In addition, Visual Basic does not support the use of pointers, and C# requires code that uses pointers to run in an unsafe context.</source>
          <target state="translated">Кроме того Visual Basic не поддерживает использование указателей и C# входит требование типобезопасности кода, который использует указатели для выполнения в небезопасном контексте.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>unsafe<ept id="p1">](~/docs/csharp/language-reference/keywords/unsafe.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>unsafe<ept id="p1">](~/docs/csharp/language-reference/keywords/unsafe.md)</ept>.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For additional guidance on choosing an overload, see <bpt id="p1">[</bpt>Which method do I call?<ept id="p1">](#Tasks)</ept></source>
          <target state="translated">Дополнительные рекомендации по выбору перегрузку см. в разделе <bpt id="p1">[</bpt>какой метод обратиться?<ept id="p1">](#Tasks)</ept></target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Initializes the new instance to the value indicated by an array of Unicode characters.</source>
          <target state="translated">Инициализирует новый экземпляр значением, заданным массивом знаков Юникода.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This constructor copies Unicode characters(<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor2_Example)</ept>).</source>
          <target state="translated">Этот конструктор копирует символов Юникода (<bpt id="p1">[</bpt>пример<ept id="p1">](#Ctor2_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Initializes the new instance to the value indicated by an array of Unicode characters, a starting character position within that array, and a length (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor3_Example)</ept>).</source>
          <target state="translated">Инициализирует новый экземпляр значением, заданным массивом знаков Юникода, начальной позицией знака в пределах данного массива и длиной (<bpt id="p1">[</bpt>пример<ept id="p1">](#Ctor3_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Initializes the new instance to the value indicated by a specified Unicode character repeated a specified number of times (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor3_Example)</ept>).</source>
          <target state="translated">Выполняет инициализацию нового экземпляра, значение обозначается указанного символа Юникода повторяется заданное число раз (<bpt id="p1">[</bpt>пример<ept id="p1">](#Ctor3_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">**</bpt>(Not CLS-compliant)<ept id="p1">**</ept> Initializes the new instance to the value indicated by a pointer to an array of Unicode characters that is terminated by a null character (U+0000 or '\0').</source>
          <target state="translated"><bpt id="p1">**</bpt>(Не является CLS-совместимым) <ept id="p1">**</ept> Инициализирует новый экземпляр значением, определенным указателем на массив знаков Юникода, оканчивается символом null (U + 0000 или «\0»).</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor4_Example)</ept>).</source>
          <target state="translated">(<bpt id="p1">[</bpt>пример<ept id="p1">](#Ctor4_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Permission: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, requires full trust for the immediate caller.</source>
          <target state="translated">Разрешение: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">**</bpt>(Not CLS-compliant)<ept id="p1">**</ept> Initializes the new instance to the value indicated by a pointer to an array of Unicode characters, a starting character position within that array, and a length.</source>
          <target state="translated"><bpt id="p1">**</bpt>(Не является CLS-совместимым) <ept id="p1">**</ept> Инициализирует новый экземпляр значением, определенным указателем на массив знаков Юникода, начальной позицией знака в пределах данного массива и длиной.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The constructor copies the Unicode characters from <ph id="ph1">`value`</ph> starting at index <ph id="ph2">`startIndex`</ph> and ending at index <ph id="ph3">`startIndex`</ph><ph id="ph4"> + </ph><ph id="ph5">`length`</ph> – 1 (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor5_Example)</ept>).</source>
          <target state="translated">Конструктор копирует символы Юникода от <ph id="ph1">`value`</ph> начиная с индекса <ph id="ph2">`startIndex`</ph> и заканчивая индекс <ph id="ph3">`startIndex`</ph> <ph id="ph4"> + </ph> <ph id="ph5">`length`</ph> – 1 (<bpt id="p1">[</bpt>пример<ept id="p1">](#Ctor5_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Permission: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, requires full trust for the immediate caller.</source>
          <target state="translated">Разрешение: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">**</bpt>(Not CLS-compliant)<ept id="p1">**</ept> Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers.</source>
          <target state="translated"><bpt id="p1">**</bpt>(Не является CLS-совместимым) <ept id="p1">**</ept> Инициализирует новый экземпляр значением, определенным указателем на массив 8-разрядных целых чисел со знаком.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">Массив предполагается представляет строку, закодированную с помощью текущей кодовой страницы системы (то есть кодировку, заданную параметром <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The constructor processes characters from <ph id="ph1">`value`</ph> starting from the location specified by the pointer until a null character (0x00) is reached (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor6_Example)</ept>).</source>
          <target state="translated">Конструктор обрабатывает знаки из <ph id="ph1">`value`</ph> начиная с позиции, определяемой заданным указателем, до достижения нуля (0x00) (<bpt id="p1">[</bpt>пример<ept id="p1">](#Ctor6_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Permission: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, requires full trust for the immediate caller.</source>
          <target state="translated">Разрешение: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">**</bpt>(Not CLS-compliant)<ept id="p1">**</ept> Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</source>
          <target state="translated"><bpt id="p1">**</bpt>(Не является CLS-совместимым) <ept id="p1">**</ept> Инициализирует новый экземпляр значением, определенным указателем на массив 8-разрядных целых чисел со знаком, начальной позицией в пределах данного массива и длиной.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">Массив предполагается представляет строку, закодированную с помощью текущей кодовой страницы системы (то есть кодировку, заданную параметром <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The constructor processes characters from value starting at <ph id="ph1">`startIndex`</ph> and ending at <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`length`</ph> – 1 (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor6_Example)</ept>).</source>
          <target state="translated">Конструктор обрабатывает символы из значения, начиная с <ph id="ph1">`startIndex`</ph> и заканчивая <ph id="ph2">`startIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`length`</ph> – 1 (<bpt id="p1">[</bpt>пример<ept id="p1">](#Ctor6_Example)</ept>).</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Permission: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, requires full trust for the immediate caller.</source>
          <target state="translated">Разрешение: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">**</bpt>(Not CLS-compliant)<ept id="p1">**</ept> Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object.</source>
          <target state="translated"><bpt id="p1">**</bpt>(Не является CLS-совместимым) <ept id="p1">**</ept> Инициализирует новый экземпляр значением, определенным указателем на массив 8-разрядных целых чисел со знаком, начальной позицией в пределах этого массива, длиной и объектом <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Permission: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, requires full trust for the immediate caller.</source>
          <target state="translated">Разрешение: <ph id="ph1">&lt;xref:System.Security.SecurityCriticalAttribute&gt;</ph>, требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Parameters</source>
          <target state="translated">Параметры</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here is a complete list of parameters used by <ph id="ph1">&lt;xref:System.String&gt;</ph> constructors that don't include a pointer parameter.</source>
          <target state="translated">Ниже приведен полный список параметров, используемых <ph id="ph1">&lt;xref:System.String&gt;</ph> конструкторы, которые не содержат параметр-указатель.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For the parameters used by each overload, see the overload syntax above.</source>
          <target state="translated">Параметры, используемые каждой перегрузке см. выше синтаксис перегрузки.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Parameter</source>
          <target state="translated">Параметр</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Type</source>
          <target state="translated">Тип</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.Char&gt;</ph>[]</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Char&gt;</ph>[]</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An array of Unicode characters.</source>
          <target state="translated">Массив знаков Юникода.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A Unicode character.</source>
          <target state="translated">Знак Юникода.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The starting position in <ph id="ph1">`value`</ph> of the first character in the new string.</source>
          <target state="translated">Начальная позиция в <ph id="ph1">`value`</ph> первого символа в новой строке.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Default value: 0</source>
          <target state="translated">Значение по умолчанию: 0</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The number of characters in <ph id="ph1">`value`</ph> to include in the new string.</source>
          <target state="translated">Число символов в <ph id="ph1">`value`</ph> для включения в новую строку.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Default value: <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">Значение по умолчанию: <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The number of times the character <ph id="ph1">`c`</ph> is repeated in the new string.</source>
          <target state="translated">Количество времени символ <ph id="ph1">`c`</ph> повторяется в новой строке.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If <ph id="ph1">`count`</ph> is zero, the value of the new object is <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Если <ph id="ph1">`count`</ph> равен нулю, значение нового объекта <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here is a complete list of parameters used by <ph id="ph1">&lt;xref:System.String&gt;</ph> constructors that include a pointer parameter.</source>
          <target state="translated">Ниже приведен полный список параметров, используемых <ph id="ph1">&lt;xref:System.String&gt;</ph> конструкторы, которые включают параметр указателя.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For the parameters used by each overload, see the overload syntax above.</source>
          <target state="translated">Параметры, используемые каждой перегрузке см. выше синтаксис перегрузки.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Parameter</source>
          <target state="translated">Параметр</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Type</source>
          <target state="translated">Тип</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A pointer to a null-terminated array of Unicode characters or an array of 8-bit signed integers.</source>
          <target state="translated">Указатель на завершающуюся нулевым значением символов Юникода или массив 8-разрядных целых чисел со знаком.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If <ph id="ph1">`value`</ph> is <ph id="ph2">`null`</ph> or an empty array, the value of the new string is <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> — <ph id="ph2">`null`</ph> или пустой массив, значение новой строки является <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The index of the array element that defines the first character in the new string.</source>
          <target state="translated">Индекс элемента массива, который определяет первый символ в новой строке.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Default value: 0</source>
          <target state="translated">Значение по умолчанию: 0</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The number of array elements to use to create the new string.</source>
          <target state="translated">Число элементов массива, используемый для создания новой строки.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If length is zero, the constructor creates a string whose value is <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Если длина равна нулю, конструктор создает строку, значение которого является <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Default value: <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated">Значение по умолчанию: <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>An object that specifies how the <ph id="ph1">`value`</ph> array is encoded.</source>
          <target state="translated">Объект, задающий как <ph id="ph1">`value`</ph> кодированием array.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Default value: <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>, or the system's current ANSI code page</source>
          <target state="translated">Значение по умолчанию: <ph id="ph1">&lt;xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType&gt;</ph>, или текущей системной кодовой страницы ANSI</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Exceptions</source>
          <target state="translated">Исключения</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here's a list of exceptions thrown by constructors that don't include pointer parameters.</source>
          <target state="translated">Ниже приведен список исключений, вызванных конструкторы, которые не содержат параметров-указателей.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Exception</source>
          <target state="translated">Исключение</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Condition</source>
          <target state="translated">Условие</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Thrown by</source>
          <target state="translated">Вызванное</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`value`</ph> is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">`value`</ph> имеет значение <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`startIndex`</ph>,<ph id="ph2">`length`</ph>, or <ph id="ph3">`count`</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">`startIndex`</ph>,<ph id="ph2">`length`</ph>, или <ph id="ph3">`count`</ph> меньше нуля.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The sum of <ph id="ph1">`startIndex`</ph> and <ph id="ph2">`length`</ph> is greater than the number of elements in <ph id="ph3">`value`</ph>.</source>
          <target state="translated">Сумма значений параметров <ph id="ph1">`startIndex`</ph> и <ph id="ph2">`length`</ph> превышает количество элементов в <ph id="ph3">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`count`</ph> is less than zero.</source>
          <target state="translated">Значение параметра <ph id="ph1">`count`</ph> меньше нуля.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here's a list of exceptions thrown by constructors that include pointer parameters.</source>
          <target state="translated">Ниже приведен список исключений, вызванных конструкторов, содержащих параметры-указатели.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Exception</source>
          <target state="translated">Исключение</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Condition</source>
          <target state="translated">Условие</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Thrown by</source>
          <target state="translated">Вызванное</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`value`</ph> specifies an array that contains an invalid Unicode character.</source>
          <target state="translated"><ph id="ph1">`value`</ph> Указывает массив, содержащий недопустимый символ Юникода.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`value`</ph> or <ph id="ph2">`value`</ph><ph id="ph3"> + </ph><ph id="ph4">`startIndex`</ph> specifies an address that is less than 64K.</source>
          <target state="translated"><ph id="ph1">`value`</ph> или <ph id="ph2">`value`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`startIndex`</ph> определяет адрес меньше 64 КБ.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A new <ph id="ph1">&lt;xref:System.String&gt;</ph> instance could not be initialized from the <ph id="ph2">`value`</ph> byte array because <ph id="ph3">`value`</ph> does not use the default code page encoding.</source>
          <target state="translated">Новый <ph id="ph1">&lt;xref:System.String&gt;</ph> не удалось инициализировать экземпляр из <ph id="ph2">`value`</ph> байтового массива, так как <ph id="ph3">`value`</ph> не использовать кодировку по умолчанию код страницы.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All constructors with pointers.</source>
          <target state="translated">Все конструкторы с указателями.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`value`</ph> is null.</source>
          <target state="translated">Параметр <ph id="ph1">`value`</ph> имеет значение null.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The current process does not have read access to all the addressed characters.</source>
          <target state="translated">Текущий процесс не имеет доступа на чтение ко всем рассматриваемым символам.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`startIndex`</ph> or <ph id="ph2">`length`</ph> is less than zero, <ph id="ph3">`value`</ph><ph id="ph4"> + </ph><ph id="ph5">`startIndex`</ph> cause a pointer overflow, or the current process does not have read access to all the addressed characters.</source>
          <target state="translated"><ph id="ph1">`startIndex`</ph> или <ph id="ph2">`length`</ph> меньше нуля, <ph id="ph3">`value`</ph><ph id="ph4"> + </ph><ph id="ph5">`startIndex`</ph> приводит к переполнению указателя, или текущий процесс не имеет доступа на чтение ко всем адресуемым символам.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The length of the new string is too large to allocate.</source>
          <target state="translated">Длина новой строки слишком велика для выделения.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All constructors with pointers.</source>
          <target state="translated">Все конструкторы с указателями.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`value`</ph>, or <ph id="ph2">`value`</ph><ph id="ph3"> + </ph><ph id="ph4">`startIndex`</ph><ph id="ph5"> + </ph><ph id="ph6">`length`</ph> – 1, specifies an invalid address.</source>
          <target state="translated"><ph id="ph1">`value`</ph>, или <ph id="ph2">`value`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`startIndex`</ph> <ph id="ph5"> + </ph> <ph id="ph6">`length`</ph> – 1, указывает недопустимый адрес.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Which method do I call?</source>
          <target state="translated">Какой метод нужно вызывать?</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To</source>
          <target state="translated">Кому</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Call or use</source>
          <target state="translated">Вызов или используйте</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string.</source>
          <target state="translated">Создайте строку.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Assignment from a string literal or an existing string (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor1_Example)</ept>)</source>
          <target state="translated">Назначение из строкового литерала или существующей строки (<bpt id="p1">[</bpt>пример<ept id="p1">](#Ctor1_Example)</ept>)</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string from an entire character array.</source>
          <target state="translated">Создайте строку из массива целого символа.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph> (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor2_Example)</ept>)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph> (<bpt id="p1">[</bpt>пример<ept id="p1">](#Ctor2_Example)</ept>)</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Createa string from a portion of a character array.</source>
          <target state="translated">Создать строку из фрагмента массива символов.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor3_Example)</ept>)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> (<bpt id="p1">[</bpt>пример<ept id="p1">](#Ctor3_Example)</ept>)</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string that repeats the same character multiple times.</source>
          <target state="translated">Создайте строку, которая повторяется несколько раз и тот же символ.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29&gt;</ph> (<bpt id="p1">[</bpt>example<ept id="p1">](#Ctor3_Example)</ept>)</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29&gt;</ph> (<bpt id="p1">[</bpt>пример<ept id="p1">](#Ctor3_Example)</ept>)</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string from a pointer to a Unicode or wide character array.</source>
          <target state="translated">Создайте строку из указателя в Юникод или массив расширенных символов.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string from a portion of a Unicode or wide character array by using its pointer.</source>
          <target state="translated">Создайте строку из части Юникода или массив расширенных символов с помощью его указателя.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string from a C++ <ph id="ph1">`char`</ph> array.</source>
          <target state="translated">Создание строки из C++ <ph id="ph1">`char`</ph> массива.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph>, <ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph>, <ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph></target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a string from ASCII characters.</source>
          <target state="translated">Создайте строку из символов ASCII.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Creating strings</source>
          <target state="translated">Создание строк</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The most commonly used technique for creating strings programmatically is simple assignment, as illustrated in <bpt id="p1">[</bpt>this example<ept id="p1">](#Ctor1_Example)</ept>.</source>
          <target state="translated">Наиболее часто используемые прием для программного создания строки — простое присваивание, как показано в <bpt id="p1">[</bpt>в этом примере<ept id="p1">](#Ctor1_Example)</ept>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String&gt;</ph> class also includes four types of constructor overloads that let you create strings from the following values:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String&gt;</ph> Класс также содержит четыре типа перегрузки конструктора, которые позволяют создавать строки из следующих значений:</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>From a character array (an array of UTF-16-encoded characters).</source>
          <target state="translated">Из массива символов (массив символов в кодировке UTF-16).</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can create a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object from the characters in the entire array or a portion of it.</source>
          <target state="translated">Можно создать новую <ph id="ph1">&lt;xref:System.String&gt;</ph> объект из символов в массиве целиком или его части.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph> constructor copies all the characters in the array to the new string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph> Конструктор копирует все символы новой строки в массиве.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor copies the characters from index <ph id="ph2">`startIndex`</ph> to index <ph id="ph3">`startIndex`</ph><ph id="ph4"> + </ph><ph id="ph5">`length`</ph> – 1 to the new string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> Конструктор копирует знаки из индекса <ph id="ph2">`startIndex`</ph> индекс <ph id="ph3">`startIndex`</ph> <ph id="ph4"> + </ph> <ph id="ph5">`length`</ph> – 1 и новую строку.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If <ph id="ph1">`length`</ph> is zero, the value of the new string is <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Если <ph id="ph1">`length`</ph> равен нулю, значение новой строки — <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If your code repeatedly instantiates strings that have the same value, you can improve application performance by using an alternate means of creating strings.</source>
          <target state="translated">Если код повторно создает строки, которые имеют одинаковое значение, можно повысить производительность приложения с помощью альтернативный способ создания строки.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>Handling repetitive strings<ept id="p1">](#Repetitive)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>обработке повторяющихся строк<ept id="p1">](#Repetitive)</ept>.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>From a single character that is duplicated zero, one, or more times, by using the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">С одного знака, повторяющиеся нуля, одной или более раз, с помощью <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If <ph id="ph1">`count`</ph> is zero, the value of the new string is <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Если <ph id="ph1">`count`</ph> равен нулю, значение новой строки — <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>From a pointer to a null-terminated character array, by using the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph> or <ph id="ph2">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">Из указателя на массив символов с завершающим нулем, с помощью <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph> или <ph id="ph2">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Either the entire array or a specified range can be used to initialize the string.</source>
          <target state="translated">Ко всему массиву или указанный диапазон можно использовать для инициализации строки.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The constructor copies a sequence of Unicode characters starting from the specified pointer or from the specified pointer plus <ph id="ph1">`startIndex`</ph> and continuing to the end of the array or for <ph id="ph2">`length`</ph> characters.</source>
          <target state="translated">Конструктор копирует последовательность знаков Юникода, начиная с заданного указателя или с заданного указателя плюс <ph id="ph1">`startIndex`</ph> и до конца массива, либо для <ph id="ph2">`length`</ph> символов.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If <ph id="ph1">`value`</ph> is a null pointer or <ph id="ph2">`length`</ph> is zero, the constructor creates a string whose value is <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> является пустым указателем или <ph id="ph2">`length`</ph> равен нулю, конструктор создает строку, значение которого является <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the copy operation proceeds to the end of the array and the array is not null-terminated, the constructor behavior is system-dependent.</source>
          <target state="translated">Если операция копирования продолжается до конца массива, и массив не является символом null, поведение конструктора зависит от системы.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Such a condition might cause an access violation.</source>
          <target state="translated">Таких условий может вызвать нарушение прав доступа.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the array contains any embedded null characters (U+0000 or '\0') and the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is called, the string instance contains <ph id="ph2">`length`</ph> characters including any embedded nulls.</source>
          <target state="translated">Если в массиве содержатся все внедренные символы null (U + 0000 или «\0») и <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> вызывается перегрузка, содержит экземпляр строки <ph id="ph2">`length`</ph> символов, включая все внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated">В следующем примере показано, что произойдет, если передается указатель на массив из 10 элементов, включающий двумя символами null <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls.</source>
          <target state="translated">Поскольку адрес первого элемента массива и все элементы в массиве, должны быть добавлены к строке, конструктор создает строка с 10 символов, включая два внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On the other hand, if the same array is passed to the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph> constructor, the result is a four-character string that does not include the first null character.</source>
          <target state="translated">С другой стороны, если передается тот же массив <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph> конструктор, результатом является 4 символьная строка, которая не включает первый символ null.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The array must contain Unicode characters.</source>
          <target state="translated">Этот массив должен содержать символы Юникода.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In C++, this means that the character array must be defined either as the managed <ph id="ph1">&lt;xref:System.Char&gt;</ph>[] type or the unmanaged<ph id="ph2">`wchar_t`</ph>[] type.</source>
          <target state="translated">В C++, это означает, что массив символов должен быть определен как управляемую <ph id="ph1">&lt;xref:System.Char&gt;</ph>[] типа или неуправляемой<ph id="ph2">`wchar_t`</ph>[] типа.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph> overload is called and the array is not null-terminated, or if the <ph id="ph2">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is called and <ph id="ph3">`startIndex`</ph><ph id="ph4"> + </ph><ph id="ph5">`length`</ph>-1 includes a range that it outside the memory allocated for the sequence of characters, the behavior of the constructor is system-dependent, and an access violation may occur.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%29&gt;</ph> перегрузка вызывается и массив не является нулевым байтом, или если <ph id="ph2">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> перегрузка вызывается и <ph id="ph3">`startIndex`</ph> <ph id="ph4"> + </ph> <ph id="ph5">`length`</ph>-1 включает диапазон вне памяти выделенную для последовательности символов, поведение конструктора зависит от системы и может возникнуть нарушение прав доступа.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In addition, on the Intel Itanium processor, calls to the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor may throw a <ph id="ph2">&lt;xref:System.DataMisalignedException&gt;</ph> exception.</source>
          <target state="translated">Кроме того, на процессоре Intel Itanium вызывает <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> конструктор может вызывать <ph id="ph2">&lt;xref:System.DataMisalignedException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If this occurs, call the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> instead.</source>
          <target state="translated">В этом случае вызов <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> вместо него.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>From a pointer to a signed byte array.</source>
          <target state="translated">Из указателя на массив байтов со знаком.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Either the entire array or a specified range can be used to initialize the string.</source>
          <target state="translated">Ко всему массиву или указанный диапазон можно использовать для инициализации строки.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The sequence of bytes can be interpreted by using the default code page encoding, or an encoding can be specified in the constructor call.</source>
          <target state="translated">Последовательность байтов, могут интерпретироваться с помощью кодирования кодовой страницей по умолчанию или кодировка может быть указана в вызове конструктора.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the constructor tries to instantiate a string from an entire array that is not null-terminated, or if the range of the array from <ph id="ph1">`value`</ph><ph id="ph2"> + </ph><ph id="ph3">`startIndex`</ph> to <ph id="ph4">`value`</ph><ph id="ph5"> + </ph><ph id="ph6">`startIndex`</ph><ph id="ph7"> + </ph><ph id="ph8">`length`</ph> -1 is outside of the memory allocated for the array, the behavior of this constructor is system-dependent, and an access violation may occur.</source>
          <target state="translated">Если конструктор пытается создать экземпляры строки из всего массива, не оканчивающаяся нулем, или если диапазона массива из <ph id="ph1">`value`</ph> <ph id="ph2"> + </ph> <ph id="ph3">`startIndex`</ph> для <ph id="ph4">`value`</ph> <ph id="ph5"> + </ph> <ph id="ph6">`startIndex`</ph> <ph id="ph7"> + </ph> <ph id="ph8">`length`</ph> -1 выходит за пределы памяти, выделенной для массива, поведение этого конструктора зависит от системы и может возникнуть нарушение прав доступа.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The three constructors that include a signed byte array as a parameter are designed primarily to convert a C++ <ph id="ph1">`char`</ph> array to a string, as shown in this example:</source>
          <target state="translated">Три конструктора, включающие знаком байтовый массив в качестве параметра, предназначены в основном для преобразования C++ <ph id="ph1">`char`</ph> массива в строку, как показано в следующем примере:</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the array contains any null characters ('\0') or bytes whose value is 0 and the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload is called, the string instance contains <ph id="ph2">`length`</ph> characters including any embedded nulls.</source>
          <target state="translated">Если в массиве содержатся символы null («\0») или байт, значение которого равно 0 и <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> вызывается перегрузка, содержит экземпляр строки <ph id="ph2">`length`</ph> символов, включая все внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated">В следующем примере показано, что произойдет, если передается указатель на массив из 10 элементов, включающий двумя символами null <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls.</source>
          <target state="translated">Поскольку адрес первого элемента массива и все элементы в массиве, должны быть добавлены к строке, конструктор создает строка с 10 символов, включая два внедренные значения NULL.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>On the other hand, if the same array is passed to the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph> constructor, the result is a four-character string that does not include the first null character.</source>
          <target state="translated">С другой стороны, если передается тот же массив <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph> конструктор, результатом является 4 символьная строка, которая не включает первый символ null.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph> and <ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructors interpret <ph id="ph3">`value`</ph> by using the default ANSI code page, calling these constructors with identical byte arrays may create strings that have different values on different systems.</source>
          <target state="translated">Поскольку <ph id="ph1">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph> и <ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> интерпретировать конструкторы <ph id="ph3">`value`</ph> кодовую страницу ANSI по умолчанию вызова этих конструкторов с одинаковыми байтовыми массивами может создать, строки, которые имеют различные значения в различных системах.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Handling repetitive strings</source>
          <target state="translated">Обработка повторяющихся строк</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Apps that parse or decode streams of text often use the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor or the <ph id="ph2">&lt;xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to convert sequences of characters into a string.</source>
          <target state="translated">Приложения, которые проанализировать или декодировать потоки текста, часто используют <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> конструктор или <ph id="ph2">&lt;xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> метода для преобразования последовательности символов в строку.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Repeatedly creating new strings with the same value instead of creating and reusing one string wastes memory.</source>
          <target state="translated">Несколько раз создание новых строк с тем же значением, вместо создания и использования одной строки много памяти.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you are likely to create the same string value repeatedly by calling the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor, even if you don't know in advance what those identical string values may be, you can use a lookup table instead.</source>
          <target state="translated">Если вы будете многократно создать одно и то же значение строки, вызвав <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> конструктор, даже если вы не знаете в переместить эти идентичные строковые значения, которые могут быть, вместо этого можно использовать таблицу уточняющих запросов.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, suppose you read and parse a stream of characters from a file that contains XML tags and attributes.</source>
          <target state="translated">Например предположим, прочитать и проанализировать поток символов из файла, который содержит XML-теги и атрибуты.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When you parse the stream, you repeatedly encounter certain tokens (that is, sequences of characters that have a symbolic meaning).</source>
          <target state="translated">При анализе этого потока постоянно встречаются определенные лексемы (то есть последовательности символов, имеющих определенное значение).</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Tokens equivalent to the strings "0", "1", "true", and "false" are likely to occur frequently in an XML stream.</source>
          <target state="translated">Лексемы, эквивалентные строки «0», «1», «true» и «false», скорее всего, часто встречаются в XML-поток.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Instead of converting each token into a new string, you can create a <ph id="ph1">&lt;xref:System.Xml.NameTable?displayProperty=nameWithType&gt;</ph> object to hold commonly occurring strings.</source>
          <target state="translated">Вместо преобразования каждого маркера в новую строку, можно создать <ph id="ph1">&lt;xref:System.Xml.NameTable?displayProperty=nameWithType&gt;</ph> объекта, содержащего часто встречающиеся строки.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.Xml.NameTable&gt;</ph> object improves performance, because it retrieves stored strings without allocating temporary memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.NameTable&gt;</ph> Объекта повышает производительность, поскольку он извлекает сохраненные строки без выделения памяти.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When you encounter a token, use the <ph id="ph1">&lt;xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to retrieve the token from the table.</source>
          <target state="translated">При возникновении маркер, используйте <ph id="ph1">&lt;xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> метод для извлечения токена из таблицы.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the token exists, the method returns the corresponding string.</source>
          <target state="translated">Если данная лексема существует, метод возвращает соответствующую строку.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the token does not exist, use the <ph id="ph1">&lt;xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to insert the token into the table and to get the corresponding string.</source>
          <target state="translated">Если маркер не существует, используйте <ph id="ph1">&lt;xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> метод, чтобы вставить маркер в таблицу и для получения соответствующей строки.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 1: Using string assignment</source>
          <target state="translated">Пример 1: Использование строки назначения</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example creates a new string by assigning it a string literal.</source>
          <target state="translated">В следующем примере создается новая строка, назначив строкового литерала.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It creates a second string by assigning the value of the first string to it.</source>
          <target state="translated">Вторая строка создается путем присвоения значения первой строки.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>These are the two most common ways to instantiate a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated">Ниже приведены два наиболее распространенных способа создания нового экземпляра <ph id="ph1">&lt;xref:System.String&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 2: Using a character array</source>
          <target state="translated">Пример 2: Использование массив символов</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example demonstrates how to create a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object from a character array.</source>
          <target state="translated">В следующем примере показано создание нового <ph id="ph1">&lt;xref:System.String&gt;</ph> объекта из массива символов.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 3: Using a portion of a character array and repeating a single character</source>
          <target state="translated">Пример 3: Используя часть массив символов и повторив один символ</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example demonstrates how to create a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object from a portion of a character array, and how to create a new <ph id="ph2">&lt;xref:System.String&gt;</ph> object that contains multiple occurrences of a single character.</source>
          <target state="translated">Ниже приведен пример, как создать новый <ph id="ph1">&lt;xref:System.String&gt;</ph> объекта из части массив символов и как создать новый <ph id="ph2">&lt;xref:System.String&gt;</ph> объект, который содержит несколько экземпляров одного символа.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 4: Using a pointer to a character array</source>
          <target state="translated">Пример 4: Использование указатель на массив знаков</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example demonstrates how to create a new <ph id="ph1">&lt;xref:System.String&gt;</ph> object from a pointer to an array of characters.</source>
          <target state="translated">В следующем примере показано создание нового <ph id="ph1">&lt;xref:System.String&gt;</ph> объекта из указателя на массив символов.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The C# example must be compiled by using the <ph id="ph1">`/unsafe`</ph> compiler switch.</source>
          <target state="translated">В примере на C# необходимо скомпилировать с помощью <ph id="ph1">`/unsafe`</ph> переключатель компилятора.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 5: Instantiating a string from a pointer and a range of an array</source>
          <target state="translated">Пример 5: При создании экземпляра строки с указателем, а также диапазона массива</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example examines the elements of a character array for either a period or an exclamation point.</source>
          <target state="translated">В следующем примере рассматривается элементы массива знаков для точки или восклицательным знаком.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If one is found, it instantiates a string from the characters in the array that precede the punctuation symbol.</source>
          <target state="translated">Если он найден, он создает строку из символов в массиве, предшествующие знак пунктуации.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If not, it instantiates a string with the entire contents of the array.</source>
          <target state="translated">В противном случае он создает строку с все содержимое массива.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The C# example must be compiled using the <ph id="ph1">`/unsafe`</ph> compiler switch.</source>
          <target state="translated">В примере на C# необходимо скомпилировать с помощью <ph id="ph1">`/unsafe`</ph> переключатель компилятора.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example 6: Instantiating a string from a pointer to a signed byte array</source>
          <target state="translated">Пример 6: При создании экземпляра строки из указателя в массив байт со знаком</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example demonstrates how you can create an instance of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class with the <ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph> constructor.</source>
          <target state="translated">В следующем примере показано, как можно создать экземпляр <ph id="ph1">&lt;xref:System.String&gt;</ph> класса <ph id="ph2">&lt;xref:System.String.%23ctor%28System.SByte%2A%29&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Version information</source>
          <target state="translated">Сведения о версии</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET Framework</source>
          <target state="translated">.NET Framework</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All overloads are supported in: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0</source>
          <target state="translated">Все перегрузки поддерживаются в: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET Framework Client Profile</source>
          <target state="translated">.NET Framework (клиентский профиль)</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All overloads are supported in: 4, 3.5 SP1</source>
          <target state="translated">Все перегрузки поддерживаются в: 4, 3.5 с пакетом обновления 1</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Portable Class Library</source>
          <target state="translated">Переносимая библиотека классов</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All overloads without an <ph id="ph1">&lt;xref:System.SByte&gt;</ph><ph id="ph2">`*`</ph> parameter are supported</source>
          <target state="translated">Все перегрузки без <ph id="ph1">&lt;xref:System.SByte&gt;</ph> <ph id="ph2">`*`</ph> поддерживаются параметра</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>.NET for Windows Store apps</source>
          <target state="translated">.NET для приложений Магазина Windows</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All overloads without an <ph id="ph1">&lt;xref:System.SByte&gt;</ph><ph id="ph2">`*`</ph> parameter are supported in: Windows 8</source>
          <target state="translated">Все перегрузки без <ph id="ph1">&lt;xref:System.SByte&gt;</ph> <ph id="ph2">`*`</ph> параметр поддерживаются в: Windows 8</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*)">
          <source>A pointer to a null-terminated array of Unicode characters.</source>
          <target state="translated">Указатель на строку знаков в кодировке Юникод, завершающуюся нулевым значением.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a specified pointer to an array of Unicode characters.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> значением, определенным указателем на массив знаков Юникода.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Примеры и сведений об этом и других комплексное использовании <ph id="ph1">`String`</ph> перегрузки конструктора. в разделе <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> конструктор сводки.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*)">
          <source>The current process does not have read access to all the addressed characters.</source>
          <target state="translated">Текущий процесс не имеет доступа на чтение ко всем рассматриваемым символам.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> specifies an array that contains an invalid Unicode character, or <ph id="ph2">&lt;paramref name="value" /&gt;</ph> specifies an address less than 64000.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="value" /&gt;</ph> определяет массив, содержащий недопустимый знак Юникода, либо параметр <ph id="ph2">&lt;paramref name="value" /&gt;</ph> определяет адрес, меньший 64000.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[])">
          <source>An array of Unicode characters.</source>
          <target state="translated">Массив знаков Юникода.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[])">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by an array of Unicode characters.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> значением, заданным в виде массива знаков Юникода.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char[])">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Примеры и сведений об этом и других комплексное использовании <ph id="ph1">`String`</ph> перегрузки конструктора. в разделе <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> конструктор сводки.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source>A pointer to a null-terminated array of 8-bit signed integers.</source>
          <target state="translated">Указатель на массив 8-разрядных целых чисел со знаком, завершающийся нулевым значением.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source>The integers are interpreted using the current system code page encoding (that is, the encoding specified by <ph id="ph1">&lt;see cref="P:System.Text.Encoding.Default" /&gt;</ph>).</source>
          <target state="translated">Целые числа интерпретируются с использованием текущей системы кодировки страницы системным кодом (то есть, кодировки, заданной <ph id="ph1">&lt;see cref="P:System.Text.Encoding.Default" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a pointer to an array of 8-bit signed integers.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> значением, определенным указателем на массив 8-разрядных целых чисел со знаком.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Примеры и сведений об этом и других комплексное использовании <ph id="ph1">`String`</ph> перегрузки конструктора. в разделе <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> конструктор сводки.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source>A new instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> could not be initialized using <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, assuming <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is encoded in ANSI.</source>
          <target state="translated">Не удалось инициализировать новый экземпляр <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> с помощью <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, если предполагается, что <ph id="ph3">&lt;paramref name="value" /&gt;</ph> представлен в кодировке ANSI.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source>The length of the new string to initialize, which is determined by the null termination character of <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, is too large to allocate.</source>
          <target state="translated">Длина новой инициализируемой строки, определяемая символом, завершающимся нулевым значением <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, слишком велика для выделения.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> specifies an invalid address.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> указывает недопустимый адрес.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char,System.Int32)">
          <source>A Unicode character.</source>
          <target state="translated">Знак Юникода.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char,System.Int32)">
          <source>The number of times <bpt id="p1">&lt;c&gt;</bpt>c<ept id="p1">&lt;/c&gt;</ept> occurs.</source>
          <target state="translated">Количество повторов <bpt id="p1">&lt;c&gt;</bpt>c<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a specified Unicode character repeated a specified number of times.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> значением, полученным путем повторения заданного знака Юникода указанное число раз.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char,System.Int32)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Примеры и сведений об этом и других комплексное использовании <ph id="ph1">`String`</ph> перегрузки конструктора. в разделе <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> конструктор сводки.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="count" /&gt;</ph> меньше нуля.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>A pointer to an array of Unicode characters.</source>
          <target state="translated">Указатель на массив знаков Юникода.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>The starting position within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Начальная позиция в <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>The number of characters within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated">Используемое количество знаков в <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a specified pointer to an array of Unicode characters, a starting character position within that array, and a length.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> значением, которое определяется заданным указателем на массив знаков Юникода, начальной позицией знака в этом массиве и длиной.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Примеры и сведений об этом и других комплексное использовании <ph id="ph1">`String`</ph> перегрузки конструктора. в разделе <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> конструктор сводки.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero, <ph id="ph3">&lt;paramref name="value" /&gt;</ph><ph id="ph4"> + </ph><ph id="ph5">&lt;paramref name="startIndex" /&gt;</ph> cause a pointer overflow, or the current process does not have read access to all the addressed characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> или <ph id="ph2">&lt;paramref name="length" /&gt;</ph> меньше нуля, <ph id="ph3">&lt;paramref name="value" /&gt;</ph><ph id="ph4"> + </ph><ph id="ph5">&lt;paramref name="startIndex" /&gt;</ph> приводит к переполнению указателя, или текущий процесс не имеет доступа на чтение ко всем адресуемым символам.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> specifies an array that contains an invalid Unicode character, or <ph id="ph2">&lt;paramref name="value" /&gt;</ph><ph id="ph3"> + </ph><ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph> specifies an address less than 64000.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> указывает массив, содержащий недопустимый символ Юникода, или <ph id="ph2">&lt;paramref name="value" /&gt;</ph><ph id="ph3"> + </ph><ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph> определяет адрес меньше 64 000.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>An array of Unicode characters.</source>
          <target state="translated">Массив знаков Юникода.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>The starting position within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Начальная позиция в <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>The number of characters within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated">Используемое количество знаков в <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by an array of Unicode characters, a starting character position within that array, and a length.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> значением, заданным массивом знаков Юникода, начальной позицией знака в пределах данного массива и длиной.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Примеры и сведений об этом и других комплексное использовании <ph id="ph1">`String`</ph> перегрузки конструктора. в разделе <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> конструктор сводки.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> или <ph id="ph2">&lt;paramref name="length" /&gt;</ph> меньше нуля.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)">
          <source>The sum of <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is greater than the number of elements in <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated">Сумма значений параметров <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> и <ph id="ph2">&lt;paramref name="length" /&gt;</ph> превышает количество элементов в <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>A pointer to an array of 8-bit signed integers.</source>
          <target state="translated">Указатель на массив 8-разрядных целых чисел со знаком.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The integers are interpreted using the current system code page encoding (that is, the encoding specified by <ph id="ph1">&lt;see cref="P:System.Text.Encoding.Default" /&gt;</ph>).</source>
          <target state="translated">Целые числа интерпретируются с использованием текущей системы кодировки страницы системным кодом (то есть, кодировки, заданной <ph id="ph1">&lt;see cref="P:System.Text.Encoding.Default" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The starting position within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Начальная позиция в <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The number of characters within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated">Используемое количество знаков в <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> значением, определяемым заданным указателем на массив 8-разрядных целых чисел со знаком, начальной позицией в пределах массива и длиной.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Примеры и сведений об этом и других комплексное использовании <ph id="ph1">`String`</ph> перегрузки конструктора. в разделе <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> конструктор сводки.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> или <ph id="ph2">&lt;paramref name="length" /&gt;</ph> меньше нуля.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The address specified by <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is too large for the current platform; that is, the address calculation overflowed.</source>
          <target state="translated">Адрес, указанный значениями <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, слишком велик для текущей платформы, то есть при вычислении адреса произошло переполнение.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The length of the new string to initialize is too large to allocate.</source>
          <target state="translated">Длина новой инициализируемой строки слишком велика для выделения.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>The address specified by <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is less than 64K.</source>
          <target state="translated">Адрес, указанный значениями <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, меньше 64 000.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>A new instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> could not be initialized using <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, assuming <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is encoded in ANSI.</source>
          <target state="translated">Не удалось инициализировать новый экземпляр <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> с помощью <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, исходя из предположения, что значение <ph id="ph3">&lt;paramref name="value" /&gt;</ph> представлено в кодировке ANSI.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="length" /&gt;</ph> collectively specify an invalid address.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> и <ph id="ph3">&lt;paramref name="length" /&gt;</ph> совместно определяют недопустимый адрес.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>A pointer to an array of 8-bit signed integers.</source>
          <target state="translated">Указатель на массив 8-разрядных целых чисел со знаком.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>The starting position within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Начальная позиция в <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>The number of characters within <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated">Используемое количество знаков в <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>An object that specifies how the array referenced by <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> is encoded.</source>
          <target state="translated">Объект, определяющий способ кодировки массива, на который указывает параметр <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>enc<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, ANSI encoding is assumed.</source>
          <target state="translated">Если значением параметра <bpt id="p1">&lt;c&gt;</bpt>enc<ept id="p1">&lt;/c&gt;</ept> является <ph id="ph1">&lt;see langword="null" /&gt;</ph>, предполагается кодировка ANSI.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph> object.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> значением, определенным заданным указателем на массив 8-разрядных целых чисел со знаком, начальной позицией в пределах этого массива, длиной и объектом <ph id="ph2">&lt;see cref="T:System.Text.Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>For examples and comprehensive usage information about this and other <ph id="ph1">`String`</ph> constructor overloads, see the <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> constructor summary.</source>
          <target state="translated">Примеры и сведений об этом и других комплексное использовании <ph id="ph1">`String`</ph> перегрузки конструктора. в разделе <ph id="ph2">&lt;xref:System.String.%23ctor%2A&gt;</ph> конструктор сводки.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> или <ph id="ph2">&lt;paramref name="length" /&gt;</ph> меньше нуля.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>The address specified by <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is too large for the current platform; that is, the address calculation overflowed.</source>
          <target state="translated">Адрес, указанный значениями <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, слишком велик для текущей платформы, то есть при вычислении адреса произошло переполнение.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>The length of the new string to initialize is too large to allocate.</source>
          <target state="translated">Длина новой инициализируемой строки слишком велика для выделения.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>The address specified by <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is less than 64K.</source>
          <target state="translated">Адрес, указанный значениями <ph id="ph1">&lt;paramref name="value" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, меньше 64 000.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>A new instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> could not be initialized using <ph id="ph2">&lt;paramref name="value" /&gt;</ph>, assuming <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is encoded as specified by <ph id="ph4">&lt;paramref name="enc" /&gt;</ph>.</source>
          <target state="translated">Не удалось инициализировать новый экземпляр типа <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> с использованием значения <ph id="ph2">&lt;paramref name="value" /&gt;</ph> исходя из предположения, что значение параметра <ph id="ph3">&lt;paramref name="value" /&gt;</ph> закодировано, как указано в параметре <ph id="ph4">&lt;paramref name="enc" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="length" /&gt;</ph> collectively specify an invalid address.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph>, <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> и <ph id="ph3">&lt;paramref name="length" /&gt;</ph> совместно определяют недопустимый адрес.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="P:System.String.Chars(System.Int32)">
          <source>A position in the current string.</source>
          <target state="translated">Позиция в текущей строке.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="P:System.String.Chars(System.Int32)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Char" /&gt;</ph> object at a specified position in the current <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Char" /&gt;</ph> в указанной позиции в текущем объекте <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>The object at position <ph id="ph1">&lt;paramref name="index" /&gt;</ph>.</source>
          <target state="translated">Объект в позиции <ph id="ph1">&lt;paramref name="index" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>The <ph id="ph1">`index`</ph> parameter is zero-based.</source>
          <target state="translated"><ph id="ph1">`index`</ph> Параметра начинается с нуля.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>This property returns the <ph id="ph1">&lt;xref:System.Char&gt;</ph> object at the position specified by the <ph id="ph2">`index`</ph> parameter.</source>
          <target state="translated">Это свойство возвращает <ph id="ph1">&lt;xref:System.Char&gt;</ph> объект в позиции, указанной параметром <ph id="ph2">`index`</ph> параметр.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>However, a Unicode character might be represented by more than one <ph id="ph1">&lt;xref:System.Char&gt;</ph>.</source>
          <target state="translated">Однако символ Юникода могут быть представлены в более чем одной <ph id="ph1">&lt;xref:System.Char&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph> class to work with Unicode characters instead of <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph> класс для работы с использованием Юникода символов вместо <ph id="ph2">&lt;xref:System.Char&gt;</ph> объектов.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>For more information, see the "Char Objects and Unicode Characters" section in the <ph id="ph1">&lt;xref:System.String&gt;</ph> class overview.</source>
          <target state="translated">Дополнительные сведения см. в подразделе «Char объектов и символы Юникода» <ph id="ph1">&lt;xref:System.String&gt;</ph> Общие сведения о классе.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>In C#, the <ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> property is an indexer.</source>
          <target state="translated">В C# <ph id="ph1">&lt;xref:System.String.Chars%2A&gt;</ph> свойство является индексатором.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>In Visual Basic, it is the default property of the <ph id="ph1">&lt;xref:System.String&gt;</ph> class.</source>
          <target state="translated">В Visual Basic, это свойство по умолчанию для <ph id="ph1">&lt;xref:System.String&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>Each <ph id="ph1">&lt;xref:System.Char&gt;</ph> object in the string can be accessed by using code such as the following.</source>
          <target state="translated">Каждый <ph id="ph1">&lt;xref:System.Char&gt;</ph> объект в строку может осуществляться с помощью кода примерно следующего вида.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Chars(System.Int32)">
          <source>The following example demonstrates how you can use this indexer in a routine to validate a string.</source>
          <target state="translated">Следующий пример демонстрирует, как использовать этот индексатор в подпрограмме для проверки строки.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="P:System.String.Chars(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> is greater than or equal to the length of this object or less than zero.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="index" /&gt;</ph> больше или равно длине данного объекта или меньше нуля.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.String.Clone">
          <source>Returns a reference to this instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Возвращает ссылку на данный экземпляр класса <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.String.Clone">
          <source>This instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Этот экземпляр <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Clone">
          <source>The return value is not an independent copy of this instance; it is simply another view of the same data.</source>
          <target state="translated">Возвращаемое значение не является независимая копия данного экземпляра; Это просто другое представление тех же данных.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Clone">
          <source>Use the <ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.CopyTo%2A&gt;</ph> method to create a separate <ph id="ph3">&lt;xref:System.String&gt;</ph> object with the same value as this instance.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.CopyTo%2A&gt;</ph> метод для создания отдельного <ph id="ph3">&lt;xref:System.String&gt;</ph> объект с тем же значением, что и данный экземпляр.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Clone">
          <source>Because the <ph id="ph1">&lt;xref:System.String.Clone%2A&gt;</ph> method simply returns the existing string instance, there is little reason to call it directly.</source>
          <target state="translated">Поскольку <ph id="ph1">&lt;xref:System.String.Clone%2A&gt;</ph> метод просто возвращает существующий экземпляр строки, практически не существует причин для прямого вызова.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Сравнивает два указанных объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All overloads of the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method return a 32-bit signed integer indicating the lexical relationship between the two comparands.</source>
          <target state="translated">Все перегрузки метода <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> возвращают 32-разрядное целое число со знаком, выражающее лексическое соотношение двух сравниваемых значений.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Value</source>
          <target state="translated">Значение</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Condition</source>
          <target state="translated">Условие</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Less than zero</source>
          <target state="translated">Меньше нуля</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The first substring precedes the second substring in the sort order.</source>
          <target state="translated">Первая подстрока предшествует второй подстроки в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Zero</source>
          <target state="translated">Нуль</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The substrings occur in the same position in the sort order, or <ph id="ph1">`length`</ph> is zero.</source>
          <target state="translated">Подстроки появляются в той же позиции в порядке сортировки, или параметр <ph id="ph1">`length`</ph> равен нулю.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Greater than zero</source>
          <target state="translated">Больше нуля</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The first substring follows the second substring in the sort order.</source>
          <target state="translated">Первая подстрока соответствует второй подстроки в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Whenever possible, you should call an overload of the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method that includes a <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> parameter.</source>
          <target state="translated">Когда это возможно, следует вызывать перегрузку <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> метод, который включает в себя <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> параметра.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Рекомендации по использованию строк<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source>The first string to compare.</source>
          <target state="translated">Первая сравниваемая строка.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source>The second string to compare.</source>
          <target state="translated">Вторая сравниваемая строка.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Сравнивает два указанных объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">32-битовое целое число со знаком, выражающее лексическое отношение двух сравниваемых значений.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Значение</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Условие</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Меньше нуля</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> предшествует <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Нуль</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> occurs in the same position as <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> занимает ту же позицию в порядке сортировки, что и объект <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Больше нуля</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> следует за <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">При сравнении используется текущий язык и региональные параметры для получения сведения о культуре, такие как правила учета регистра и алфавитный порядок отдельных символов.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Например, языка и региональных параметров может указать, что определенные сочетания знаков рассматриваться как один символ, или прописные и строчные буквы сравниваться определенным образом, или, порядок сортировки символа зависит от символов, которые предшествуют или после него.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">Сравнение выполняется с использованием правил сортировки по словам.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о слова, строки и порядковым номерам см. в разделе <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>When comparing strings, you should call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, which requires that you explicitly specify the type of string comparison that the method uses.</source>
          <target state="translated">При сравнении строк необходимо вызвать <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> метод, который необходимо явно указать тип сравнения строк, который использует метод.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Рекомендации по использованию строк<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Один или оба сравниваемых значения могут быть <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">По определению, любая строка, включая пустую строку ("»), сравниваются больше, чем указатель null; и две пустые ссылки равны друг другу.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
          <target state="translated">Сравнение заканчивается, когда встречается неравенство или обе строки уже обработаны.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">Однако если две строки считаются равными конец одной строки, а другая строка символов, оставшихся, затем строка с символами оставшиеся считается большей.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Возвращается результат последнего выполненного сравнения.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Если правила определения регистра для конкретного языка и региональных параметров влияют на результаты сравнений, возможны непредвиденные результаты.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">Например, в турецком алфавите следующий пример вызывает неверных результатов так файловой системы в турецком не регистр по правилам языка правил для букву «i» в «файл».</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">Сравните имя пути для «файл», используя порядковое сравнение.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">Правильный код для этого выглядит следующим образом:</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph> method to compare three sets of strings.</source>
          <target state="translated">В следующем примере вызывается <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph> метод для сравнения трех наборов строк.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>In the following example, the <ph id="ph1">`ReverseStringComparer`</ph> class demonstrates how you can evaluate two strings with the <ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере <ph id="ph1">`ReverseStringComparer`</ph> класс демонстрирует, как можно сравнить две строки с <ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">Наборы символов содержат символы, которые могут игнорироваться.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String)" /&gt;</ph> Метод не учитывает такие символы при сравнении с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>For example, if the following code is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, a culture-sensitive comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</source>
          <target state="translated">Например, следующий код выполняется на <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> или более поздней версии, сравнение с учетом языка и региональных параметров «animal» с «ani почты» (с помощью мягкий перенос или 00AD U +) указывает, что две строки равны.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String)">
          <source>To recognize ignorable characters in a string comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph> method and supply a value of either <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">`comparisonType`</ph> parameter.</source>
          <target state="translated">Для распознавания игнорируемые символы в сравнения строк, вызвать <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph> метод и задать значение либо <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> или <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> для <ph id="ph4">`comparisonType`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The first string to compare.</source>
          <target state="translated">Первая сравниваемая строка.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The second string to compare.</source>
          <target state="translated">Вторая сравниваемая строка.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, чтобы не учитывать регистр при сравнении; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Сравнивает два указанных объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> (с учетом или без учета регистра) и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">32-битовое целое число со знаком, выражающее лексическое отношение двух сравниваемых значений.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Значение</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Условие</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Меньше нуля</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> предшествует <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Нуль</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> occurs in the same position as <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> занимает ту же позицию в порядке сортировки, что и объект <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Больше нуля</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> следует за <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">При сравнении используется текущий язык и региональные параметры для получения сведения о культуре, такие как правила учета регистра и алфавитный порядок отдельных символов.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Например, языка и региональных параметров может указать, что определенные сочетания знаков рассматриваться как один символ, или прописные и строчные буквы сравниваться определенным образом, или, порядок сортировки символа зависит от символов, которые предшествуют или после него.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">Сравнение выполняется с использованием правил сортировки по словам.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о слова, строки и порядковым номерам см. в разделе <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>When comparing strings, you should call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, which requires that you explicitly specify the type of string comparison that the method uses.</source>
          <target state="translated">При сравнении строк необходимо вызвать <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> метод, который необходимо явно указать тип сравнения строк, который использует метод.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Рекомендации по использованию строк<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Один или оба сравниваемых значения могут быть <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">По определению, любая строка, включая пустую строку ("»), сравниваются больше, чем указатель null; и две пустые ссылки равны друг другу.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
          <target state="translated">Сравнение заканчивается, когда встречается неравенство или обе строки уже обработаны.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">Однако если две строки считаются равными конец одной строки, а другая строка символов, оставшихся, затем строка с символами оставшиеся считается большей.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Возвращается результат последнего выполненного сравнения.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Если правила определения регистра для конкретного языка и региональных параметров влияют на результаты сравнений, возможны непредвиденные результаты.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">Например, в турецком алфавите следующий пример вызывает неверных результатов так файловой системы в турецком не регистр по правилам языка правил для букву «i» в «файл».</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">Сравните имя пути для «файл», используя порядковое сравнение.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">Правильный код для этого выглядит следующим образом:</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The following example demonstrates that the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29&gt;</ph> method is equivalent to using <ph id="ph2">&lt;xref:System.String.ToUpper%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.String.ToLower%2A&gt;</ph> when comparing strings.</source>
          <target state="translated">В следующем примере показано, что <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29&gt;</ph> эквивалентно использованию метода <ph id="ph2">&lt;xref:System.String.ToUpper%2A&gt;</ph> или <ph id="ph3">&lt;xref:System.String.ToLower%2A&gt;</ph> при сравнении строк.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">Наборы символов содержат символы, которые могут игнорироваться.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /&gt;</ph> Метод не учитывает такие символы при сравнении с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>For example, if the following code is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, a culture-sensitive, case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</source>
          <target state="translated">Например, следующий код выполняется на <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> или более поздней версии, языка и региональных параметров, с учетом регистра сравнение «animal» с «Ani почты» (с помощью мягкий перенос или 00AD U +) указывает, что две строки равны.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean)">
          <source>To recognize ignorable characters in a string comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph> method and supply a value of either <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Для распознавания игнорируемые символы в сравнения строк, вызвать <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph> метод и задать значение либо <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> или <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> для <ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph> параметра.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The first string to compare.</source>
          <target state="translated">Первая сравниваемая строка.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The second string to compare.</source>
          <target state="translated">Вторая сравниваемая строка.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules to use in the comparison.</source>
          <target state="translated">Одно из значений перечисления, определяющее используемые при сравнении правила.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Сравнивает два указанных объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> с использованием заданных правил и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">32-битовое целое число со знаком, выражающее лексическое отношение двух сравниваемых значений.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Значение</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Условие</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Меньше нуля</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> предшествует <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Нуль</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> is in the same position as <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> занимает ту же позицию в порядке сортировки, что и объект <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Больше нуля</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> следует за <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</source>
          <target state="translated"><ph id="ph1">`comparisonType`</ph> Параметр указывает сравнения необходимость использования текущего или инвариантного языка и региональных параметров, учитывают или без учета регистра сравниваемых объектов либо использовать приложение word (языка и региональных параметров с учетом) или правила для сортировки по порядковому номеру (без учета языка и региональных параметров).</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Один или оба сравниваемых значения могут быть <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">По определению, любая строка, включая пустую строку ("»), сравниваются больше, чем указатель null; и две пустые ссылки равны друг другу.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
          <target state="translated">Сравнение заканчивается, когда встречается неравенство или обе строки уже обработаны.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</source>
          <target state="translated">Однако если две строки считаются равными конец одной строки, а другая строка символов, оставшихся, строка с символами оставшиеся считается большей.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Возвращается результат последнего выполненного сравнения.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Если правила определения регистра для конкретного языка и региональных параметров влияют на результаты сравнений, возможны непредвиденные результаты.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">Например, в турецком алфавите следующий пример вызывает неверных результатов так файловой системы в турецком не регистр по правилам языка правил для букву «i» в «файл».</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">Сравните имя пути для «файл», используя порядковое сравнение.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">Правильный код для этого выглядит следующим образом:</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The following example compares three versions of the letter "I".</source>
          <target state="translated">В следующем примере сравниваются три версии буквы «I».</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</source>
          <target state="translated">Результаты зависят от выбора языка и региональных параметров, учитывается ли регистр и выполняется ли порядковое сравнение.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> не является значением <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;see cref="T:System.StringComparison" /&gt;</ph> is not supported.</source>
          <target state="translated">Тип <ph id="ph1">&lt;see cref="T:System.StringComparison" /&gt;</ph> не поддерживается.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">Наборы символов содержат символы, которые могут игнорироваться.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /&gt;</ph> Метод не учитывает такие символы при сравнении с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.StringComparison)">
          <source>To recognize ignorable characters in your comparison, supply a value of <ph id="ph1">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Для распознавания игнорируемые символы, в отличие от вашей, укажите в качестве параметра <ph id="ph1">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> или <ph id="ph2">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph> для <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> параметра.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The first string to compare.</source>
          <target state="translated">Первая сравниваемая строка.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The second string to compare.</source>
          <target state="translated">Вторая сравниваемая строка.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, чтобы не учитывать регистр при сравнении; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>An object that supplies culture-specific comparison information.</source>
          <target state="translated">Объект, предоставляющий сведения об особенностях сравнения, определяемых языком и региональными параметрами.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects, ignoring or honoring their case, and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Сравнивает два указанных объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> (с учетом или без учета регистра), используя сведения о языке и региональных параметрах, и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">32-битовое целое число со знаком, выражающее лексическое отношение двух сравниваемых значений.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Значение</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Условие</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Меньше нуля</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> предшествует <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Нуль</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> occurs in the same position as <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> занимает ту же позицию в порядке сортировки, что и объект <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Больше нуля</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> следует за <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison uses the <ph id="ph1">`culture`</ph> parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">Сравнение выполняется с помощью <ph id="ph1">`culture`</ph> параметр, чтобы получить сведения о культуре, такие как правила учета регистра и алфавитный порядок отдельных символов.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Например, языка и региональных параметров может указать, что определенные сочетания знаков рассматриваться как один символ, или прописные и строчные буквы сравниваться определенным образом, или, порядок сортировки символа зависит от символов, которые предшествуют или после него.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">Сравнение выполняется с использованием правил сортировки по словам.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о слова, строки и порядковым номерам см. в разделе <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Один или оба сравниваемых значения могут быть <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">По определению, любая строка, включая пустую строку ("»), сравниваются больше, чем указатель null; и две пустые ссылки равны друг другу.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
          <target state="translated">Сравнение заканчивается, когда встречается неравенство или обе строки уже обработаны.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">Однако если две строки считаются равными конец одной строки, а другая строка символов, оставшихся, затем строка с символами оставшиеся считается большей.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Возвращается результат последнего выполненного сравнения.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Если правила определения регистра для конкретного языка и региональных параметров влияют на результаты сравнений, возможны непредвиденные результаты.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">Например, в турецком алфавите следующий пример вызывает неверных результатов так файловой системы в турецком не регистр по правилам языка правил для букву «i» в «файл».</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">Сравните имя пути для «файл», используя порядковое сравнение.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">Правильный код для этого выглядит следующим образом:</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The following example demonstrates how culture can affect a comparison.</source>
          <target state="translated">В следующем примере показано, как язык и региональные параметры могут повлиять на сравнение.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>In Czech - Czech Republic culture, "ch" is a single character that is greater than "d".</source>
          <target state="translated">В чешский — Чешская Республика языка и региональных параметров, «ch» является один символ, который больше, чем «d».</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>However, in English - United States culture, "ch" consists of two characters, and "c" is less than "d".</source>
          <target state="translated">Тем не менее в английский — США языка и региональных параметров, «ch» состоит из двух символов, и «c» меньше, чем «d».</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="culture" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">Наборы символов содержат символы, которые могут игнорироваться.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /&gt;</ph> Метод не учитывает такие символы при сравнении с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>For example, if the following code is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, a case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) using the invariant culture indicates that the two strings are equivalent.</source>
          <target state="translated">Например, следующий код выполняется на <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> или более поздней версии, с учетом регистра «зверька» с «Ani почты» (с помощью мягкий перенос или U + 00AD) с помощью инвариантный язык и региональные параметры указывает, что две строки равны.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>To recognize ignorable characters in a string comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> method and supply a value of either <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">&lt;paramref name="options" /&gt;</ph> parameter.</source>
          <target state="translated">Для распознавания игнорируемые символы в сравнения строк, вызвать <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> метод и задать значение либо <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> или <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> для <ph id="ph4">&lt;paramref name="options" /&gt;</ph> параметра.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The first string to compare.</source>
          <target state="translated">Первая сравниваемая строка.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The second string to compare.</source>
          <target state="translated">Вторая сравниваемая строка.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The culture that supplies culture-specific comparison information.</source>
          <target state="translated">Язык и региональные параметры, которые предоставляют сведения об особенностях сравнения с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Options to use when performing the comparison (such as ignoring case or symbols).</source>
          <target state="translated">Параметры, которые используются во время сравнения (например, игнорирование регистра или символов).</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two strings to each other in the sort order.</source>
          <target state="translated">Сравнивает два заданных объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, используя указанные параметры сравнения и сведения о языке и региональных параметрах, которые влияют на сравнение, и возвращает целое число, показывающее связь между двумя строками в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>A 32-bit signed integer that indicates the lexical relationship between <ph id="ph1">&lt;paramref name="strA" /&gt;</ph> and <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>, as shown in the following table</source>
          <target state="translated">32-разрядное целое число со знаком, которое указывает на лексические отношения между <ph id="ph1">&lt;paramref name="strA" /&gt;</ph> и <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>, как показано в следующей таблице.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Значение</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Условие</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Меньше нуля</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> предшествует <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Нуль</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> occurs in the same position as <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> занимает ту же позицию в порядке сортировки, что и объект <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Больше нуля</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> следует за <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison uses the <ph id="ph1">`culture`</ph> parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</source>
          <target state="translated">Сравнение выполняется с помощью <ph id="ph1">`culture`</ph> параметр для получения сведений о культуре, таких как правила учета регистра и алфавитный порядок отдельных символов.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Например, указать определенный язык и региональные параметры, определенные сочетания знаков рассматриваться как один символ, что прописные и строчные буквы сравниваться определенным образом, или, порядок сортировки символа зависит от символы, Введите перед или после него.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph> method is designed primarily for use in sorting or alphabetizing operations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph> Метод предназначен главным образом для использования при сортировке или операции сортировки в алфавитном порядке.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</source>
          <target state="translated">Он не должен использоваться, если основная цель вызова метода — определить, равны ли две строки (то есть, когда вызывается метод используется для проверки возвращаемое значение равно нулю).</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>To determine whether two strings are equivalent, call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Чтобы определить, равны ли две строки, вызовите <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison can be further specified by the <ph id="ph1">`options`</ph> parameter, which consists of one or more members of the <ph id="ph2">&lt;xref:System.Globalization.CompareOptions&gt;</ph> enumeration.</source>
          <target state="translated">Сравнение могут задаваться с дальнейшей <ph id="ph1">`options`</ph> параметр, который состоит из одного или нескольких членов <ph id="ph2">&lt;xref:System.Globalization.CompareOptions&gt;</ph> перечисления.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> values have no effect.</source>
          <target state="translated">Тем не менее, так как этот метод предназначен для выполнения сравнения строк с учетом языка и региональных параметров, <ph id="ph1">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> значения не оказывают влияния.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Either or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Один или оба сравниваемых значения могут быть <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>By definition, any string, including <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, compares greater than a null reference, and two null references compare equal to each other.</source>
          <target state="translated">По определению, любая строка, включая <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, сравнивает больше, чем пустая ссылка, а две пустые ссылки равны друг другу.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison terminates when an inequality is discovered or both strings have been compared.</source>
          <target state="translated">Сравнение заканчивается, когда встречается неравенство или обе строки уже обработаны.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</source>
          <target state="translated">Однако если две строки считаются равными конец одной строки, а другая строка символов, оставшихся, строка с символами оставшиеся считается большей.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The following example compares two strings in three different ways: using linguistic comparison for the en-US culture; using linguistic case-sensitive comparison for the en-US culture; and using an ordinal comparison.</source>
          <target state="translated">В следующем примере сравниваются две строки тремя разными способами: с помощью лингвистического сравнения для региональных параметров en US; с помощью лингвистического сравнения с учетом регистра для региональных параметров en US; и с помощью порядковое сравнение.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>It illustrates how the three methods of comparison produce three different results.</source>
          <target state="translated">Здесь показано, как эти три метода сравнения, возвращают различные результаты в трех.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Globalization.CompareOptions" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> не является значением <ph id="ph2">&lt;see cref="T:System.Globalization.CompareOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="culture" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> Метод не учитывает такие символы при сравнении с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>To recognize ignorable characters in your comparison, supply a value of <ph id="ph1">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph3">&lt;paramref name="options" /&gt;</ph> parameter.</source>
          <target state="translated">Для распознавания игнорируемые символы, в отличие от вашей, укажите в качестве параметра <ph id="ph1">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> или <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> для <ph id="ph3">&lt;paramref name="options" /&gt;</ph> параметра.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">Первая из сравниваемых строк.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Позиция подстроки в <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">Вторая из сравниваемых строк.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Позиция подстроки в <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">Максимальное число сравниваемых знаков в подстроках.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Сравнивает подстроки двух указанных объектов <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>A 32-bit signed integer indicating the lexical relationship between the two comparands.</source>
          <target state="translated">32-разрядное целое число со знаком, выражающее лексическое соотношение двух сравниваемых значений.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Значение</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Условие</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Меньше нуля</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Подстрока в <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> предшествует подстроке в <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Нуль</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings occur in the same position in the sort order, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Подстроки находятся в той же позиции в порядке сортировки, или параметр <ph id="ph3">&lt;paramref name="length" /&gt;</ph> равен нулю.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Больше нуля</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Подстрока в <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> следует за подстрокой в <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at <ph id="ph2">`indexA`</ph> and in <ph id="ph3">`strB`</ph> at <ph id="ph4">`indexB`</ph>.</source>
          <target state="translated">Старта подстроках <ph id="ph1">`strA`</ph> в <ph id="ph2">`indexA`</ph> и <ph id="ph3">`strB`</ph> в <ph id="ph4">`indexB`</ph>.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Both <ph id="ph1">`indexA`</ph> and <ph id="ph2">`indexB`</ph> are zero-based; that is, the first character in <ph id="ph3">`strA`</ph> and <ph id="ph4">`strB`</ph> is at position zero.</source>
          <target state="translated">Оба <ph id="ph1">`indexA`</ph> и <ph id="ph2">`indexB`</ph> являются отсчитываемый от нуля, то есть первый символ в <ph id="ph3">`strA`</ph> и <ph id="ph4">`strB`</ph> равен нулю.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The length of the first substring is equal to the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus one.</source>
          <target state="translated">Длина первой подстроки равна длине <ph id="ph1">`strA`</ph> минус <ph id="ph2">`indexA`</ph> плюс один.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The length of the second substring is equal to the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus one.</source>
          <target state="translated">Длина второй подстроки равна длине <ph id="ph1">`strB`</ph> минус <ph id="ph2">`indexB`</ph> плюс один.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
          <target state="translated">Число сравниваемых знаков равно меньшему из длин подстрок и <ph id="ph1">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated"><ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, И <ph id="ph3">`length`</ph> параметры должны быть неотрицательными.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">При сравнении используется текущий язык и региональные параметры для получения сведения о культуре, такие как правила учета регистра и алфавитный порядок отдельных символов.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Например, языка и региональных параметров может указать, что определенные сочетания знаков рассматриваться как один символ, или прописные и строчные буквы сравниваться определенным образом, или, порядок сортировки символа зависит от символов, которые предшествуют или после него.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">Сравнение выполняется с использованием правил сортировки по словам.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о слова, строки и порядковым номерам см. в разделе <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>When comparing strings, you should call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph> method, which requires that you explicitly specify the type of string comparison that the method uses.</source>
          <target state="translated">При сравнении строк необходимо вызвать <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph> метод, который необходимо явно указать тип сравнения строк, который использует метод.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Рекомендации по использованию строк<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Один или оба сравниваемых значения могут быть <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">По определению, любая строка, включая пустую строку ("»), сравниваются больше, чем указатель null; и две пустые ссылки равны друг другу.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
          <target state="translated">Сравнение заканчивается, когда встречается неравенство или обе подстроки уже обработаны.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">Однако если две строки считаются равными конец одной строки, а другая строка символов, оставшихся, затем строка с символами оставшиеся считается большей.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Возвращается результат последнего выполненного сравнения.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Если правила определения регистра для конкретного языка и региональных параметров влияют на результаты сравнений, возможны непредвиденные результаты.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">Например, в турецком алфавите следующий пример вызывает неверных результатов так файловой системы в турецком не регистр по правилам языка правил для букву «i» в «файл».</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">Сравните имя пути для «файл», используя порядковое сравнение.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">Правильный код для этого выглядит следующим образом:</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The following example compares two substrings.</source>
          <target state="translated">В следующем примере сравниваются две подстроки.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> больше значения <ph id="ph2">&lt;paramref name="strA" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> больше значения <ph id="ph2">&lt;paramref name="strB" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> или <ph id="ph3">&lt;paramref name="length" /&gt;</ph> является отрицательным значением.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Either <ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> or <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> или <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> равно <ph id="ph3">&lt;see langword="null" /&gt;</ph>, а <ph id="ph4">&lt;paramref name="length" /&gt;</ph> больше нуля.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">Наборы символов содержат символы, которые могут игнорироваться.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /&gt;</ph> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /&gt;</ph> Метод не учитывает эти символы при выполнении лингвистического сравнения или язык и региональные параметры сравнения.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>To recognize ignorable characters in your comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method and supply a value of <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Для распознавания игнорируемые символы, в отличие от вашей, вызовите <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> метод и укажите в качестве параметра <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> или <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> для <ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph> параметра.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">Первая из сравниваемых строк.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Позиция подстроки в <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">Вторая из сравниваемых строк.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Позиция подстроки в <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">Максимальное число сравниваемых знаков в подстроках.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, чтобы не учитывать регистр при сравнении; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Сравнивает подстроки двух заданных объектов <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> (с учетом или без учета регистра) и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">32-битовое целое число со знаком, выражающее лексическое отношение двух сравниваемых значений.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Значение</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Условие</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Меньше нуля</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Подстрока в <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> предшествует подстроке в <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Нуль</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings occur in the same position in the sort order, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Подстроки находятся в той же позиции в порядке сортировки, или параметр <ph id="ph3">&lt;paramref name="length" /&gt;</ph> равен нулю.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Больше нуля</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Подстрока в <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> следует за подстрокой в <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at <ph id="ph2">`indexA`</ph>, and in <ph id="ph3">`strB`</ph> at <ph id="ph4">`indexB`</ph>.</source>
          <target state="translated">Старта подстроках <ph id="ph1">`strA`</ph> в <ph id="ph2">`indexA`</ph>и в <ph id="ph3">`strB`</ph> в <ph id="ph4">`indexB`</ph>.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>Both <ph id="ph1">`indexA`</ph> and <ph id="ph2">`indexB`</ph> are zero-based; that is, the first character in <ph id="ph3">`strA`</ph> and <ph id="ph4">`strB`</ph> is at position zero.</source>
          <target state="translated">Оба <ph id="ph1">`indexA`</ph> и <ph id="ph2">`indexB`</ph> являются отсчитываемый от нуля, то есть первый символ в <ph id="ph3">`strA`</ph> и <ph id="ph4">`strB`</ph> равен нулю.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The length of the first substring is equal to the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus one.</source>
          <target state="translated">Длина первой подстроки равна длине <ph id="ph1">`strA`</ph> минус <ph id="ph2">`indexA`</ph> плюс один.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The length of the second substring is equal to the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus one.</source>
          <target state="translated">Длина второй подстроки равна длине <ph id="ph1">`strB`</ph> минус <ph id="ph2">`indexB`</ph> плюс один.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
          <target state="translated">Число сравниваемых знаков равно меньшему из длин подстрок и <ph id="ph1">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated"><ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, И <ph id="ph3">`length`</ph> параметры должны быть неотрицательными.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">При сравнении используется текущий язык и региональные параметры для получения сведения о культуре, такие как правила учета регистра и алфавитный порядок отдельных символов.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Например, языка и региональных параметров может указать, что определенные сочетания знаков рассматриваться как один символ, или прописные и строчные буквы сравниваться определенным образом, или, порядок сортировки символа зависит от символов, которые предшествуют или после него.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">Сравнение выполняется с использованием правил сортировки по словам.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о слова, строки и порядковым номерам см. в разделе <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>When comparing strings, you should call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph> method, which requires that you explicitly specify the type of string comparison that the method uses.</source>
          <target state="translated">При сравнении строк необходимо вызвать <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph> метод, который необходимо явно указать тип сравнения строк, который использует метод.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Рекомендации по использованию строк<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Один или оба сравниваемых значения могут быть <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">По определению, любая строка, включая пустую строку ("»), сравниваются больше, чем указатель null; и две пустые ссылки равны друг другу.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
          <target state="translated">Сравнение заканчивается, когда встречается неравенство или обе подстроки уже обработаны.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">Однако если две строки считаются равными конец одной строки, а другая строка символов, оставшихся, затем строка с символами оставшиеся считается большей.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Возвращается результат последнего выполненного сравнения.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Если правила определения регистра для конкретного языка и региональных параметров влияют на результаты сравнений, возможны непредвиденные результаты.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">Например, в турецком алфавите следующий пример вызывает неверных результатов так файловой системы в турецком не регистр по правилам языка правил для букву «i» в «файл».</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The path name needs to be compared in an invariant manner.</source>
          <target state="translated">Имя пути должно сравниваться инвариантным способом.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The correct code to do this is as follows.</source>
          <target state="translated">Правильный код для этого выглядит следующим образом.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The following example performs two comparisons of two substrings that only differ in case.</source>
          <target state="translated">В следующем примере выполняется два сравнения двух подстрок, которые различаются только регистром.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The first comparison ignores case and the second comparison considers case.</source>
          <target state="translated">Первое сравнение не учитывает регистр и второй — учитывается.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> больше значения <ph id="ph2">&lt;paramref name="strA" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> больше значения <ph id="ph2">&lt;paramref name="strB" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> или <ph id="ph3">&lt;paramref name="length" /&gt;</ph> является отрицательным значением.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>Either <ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> or <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> или <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> равно <ph id="ph3">&lt;see langword="null" /&gt;</ph>, а <ph id="ph4">&lt;paramref name="length" /&gt;</ph> больше нуля.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">Наборы символов содержат символы, которые могут игнорироваться.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /&gt;</ph> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /&gt;</ph> Метод не учитывает эти символы при выполнении лингвистического сравнения или язык и региональные параметры сравнения.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)">
          <source>To recognize ignorable characters in your comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method and supply a value of <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Для распознавания игнорируемые символы, в отличие от вашей, вызовите <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> метод и укажите в качестве параметра <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> или <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> для <ph id="ph4">&lt;paramref name="comparisonType" /&gt;</ph> параметра.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">Первая из сравниваемых строк.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Позиция подстроки в <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">Вторая из сравниваемых строк.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Позиция подстроки в <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">Максимальное число сравниваемых знаков в подстроках.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules to use in the comparison.</source>
          <target state="translated">Одно из значений перечисления, определяющее используемые при сравнении правила.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Сравнивает подстроки двух указанных объектов <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> с использованием заданных правил и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">32-битовое целое число со знаком, выражающее лексическое отношение двух сравниваемых значений.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Значение</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Условие</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Меньше нуля</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Подстрока в <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> предшествует подстроке в <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Нуль</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings occur in the same position in the sort order, or the <ph id="ph3">&lt;paramref name="length" /&gt;</ph> parameter is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Подстроки находятся в той же позиции в порядке сортировки, или параметр <ph id="ph3">&lt;paramref name="length" /&gt;</ph> равен нулю.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Больше нуля</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follllows the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Подстрока в <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> следует за подстрокой в <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at <ph id="ph2">`indexA`</ph> and in <ph id="ph3">`strB`</ph> at <ph id="ph4">`indexB`</ph>.</source>
          <target state="translated">Старта подстроках <ph id="ph1">`strA`</ph> в <ph id="ph2">`indexA`</ph> и <ph id="ph3">`strB`</ph> в <ph id="ph4">`indexB`</ph>.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Both <ph id="ph1">`indexA`</ph> and <ph id="ph2">`indexB`</ph> are zero-based; that is, the first character in <ph id="ph3">`strA`</ph> and <ph id="ph4">`strB`</ph> is at position zero, not position one.</source>
          <target state="translated">Оба <ph id="ph1">`indexA`</ph> и <ph id="ph2">`indexB`</ph> являются отсчитываемый от нуля, то есть первый символ в <ph id="ph3">`strA`</ph> и <ph id="ph4">`strB`</ph> — на положение ноль, не размещать одну.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The length of the first substring is equal to the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus one.</source>
          <target state="translated">Длина первой подстроки равна длине <ph id="ph1">`strA`</ph> минус <ph id="ph2">`indexA`</ph> плюс один.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The length of the second substring is equal to the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus one.</source>
          <target state="translated">Длина второй подстроки равна длине <ph id="ph1">`strB`</ph> минус <ph id="ph2">`indexB`</ph> плюс один.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
          <target state="translated">Число сравниваемых знаков равно меньшему из длин подстрок и <ph id="ph1">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated"><ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, И <ph id="ph3">`length`</ph> параметры должны быть неотрицательными.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</source>
          <target state="translated"><ph id="ph1">`comparisonType`</ph> Параметр указывает сравнения необходимость использования текущего или инвариантного языка и региональных параметров, учитывают или без учета регистра сравниваемых объектов либо использовать приложение word (языка и региональных параметров с учетом) или правила для сортировки по порядковому номеру (без учета языка и региональных параметров).</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Один или оба сравниваемых значения могут быть <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">По определению, любая строка, включая пустую строку ("»), сравниваются больше, чем указатель null; и две пустые ссылки равны друг другу.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
          <target state="translated">Сравнение заканчивается, когда встречается неравенство или обе подстроки уже обработаны.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</source>
          <target state="translated">Однако если две строки считаются равными конец одной строки, а другая строка символов, оставшихся, строка с символами оставшиеся считается большей.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Возвращается результат последнего выполненного сравнения.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Если правила определения регистра для конкретного языка и региональных параметров влияют на результаты сравнений, возможны непредвиденные результаты.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">Например, в турецком алфавите следующий пример вызывает неверных результатов так файловой системы в турецком не регистр по правилам языка правил для букву «i» в «файл».</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">Сравните имя пути для «файл», используя порядковое сравнение.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">Правильный код для этого выглядит следующим образом:</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The following example compares two substrings.</source>
          <target state="translated">В следующем примере сравниваются две подстроки.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> больше значения <ph id="ph2">&lt;paramref name="strA" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> больше значения <ph id="ph2">&lt;paramref name="strB" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> или <ph id="ph3">&lt;paramref name="length" /&gt;</ph> является отрицательным значением.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Either <ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> or <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> или <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> равно <ph id="ph3">&lt;see langword="null" /&gt;</ph>, а <ph id="ph4">&lt;paramref name="length" /&gt;</ph> больше нуля.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> не является значением <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">Наборы символов содержат символы, которые могут игнорироваться.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> Метод не учитывает эти символы при выполнении лингвистического сравнения или язык и региональные параметры сравнения.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>To recognize ignorable characters in your comparison, supply a value of <ph id="ph1">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Для распознавания игнорируемые символы, в отличие от вашей, укажите в качестве параметра <ph id="ph1">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> или <ph id="ph2">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph> для <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> параметра.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">Первая из сравниваемых строк.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Позиция подстроки в <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">Вторая из сравниваемых строк.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Позиция подстроки в <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">Максимальное число сравниваемых знаков в подстроках.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, чтобы не учитывать регистр при сравнении; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>An object that supplies culture-specific comparison information.</source>
          <target state="translated">Объект, предоставляющий сведения об особенностях сравнения, определяемых языком и региональными параметрами.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects, ignoring or honoring their case and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</source>
          <target state="translated">Сравнивает подстроки двух заданных объектов <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> (с учетом или без учета регистра), используя сведения о языке и региональных параметрах, и возвращает целое число, которое показывает их относительное положение в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>An integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">Целое число, выражающее лексическое соотношение двух сравниваемых значений.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Значение</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Условие</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Меньше нуля</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Подстрока в <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> предшествует подстроке в <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Нуль</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings occur in the same position in the sort order, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Подстроки находятся в той же позиции в порядке сортировки, или параметр <ph id="ph3">&lt;paramref name="length" /&gt;</ph> равен нулю.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Больше нуля</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Подстрока в <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> следует за подстрокой в <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at <ph id="ph2">`indexA`</ph>, and in <ph id="ph3">`strB`</ph> at <ph id="ph4">`indexB`</ph>.</source>
          <target state="translated">Старта подстроках <ph id="ph1">`strA`</ph> в <ph id="ph2">`indexA`</ph>и в <ph id="ph3">`strB`</ph> в <ph id="ph4">`indexB`</ph>.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Both <ph id="ph1">`indexA`</ph> and <ph id="ph2">`indexB`</ph> are zero-based; that is, the first character in <ph id="ph3">`strA`</ph> and <ph id="ph4">`strB`</ph> is at position zero, not position one.</source>
          <target state="translated">Оба <ph id="ph1">`indexA`</ph> и <ph id="ph2">`indexB`</ph> являются отсчитываемый от нуля, то есть первый символ в <ph id="ph3">`strA`</ph> и <ph id="ph4">`strB`</ph> — на положение ноль, не размещать одну.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The length of the first substring is equal to the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph> plus one.</source>
          <target state="translated">Длина первой подстроки равна длине <ph id="ph1">`strA`</ph> минус <ph id="ph2">`indexA`</ph> плюс один.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The length of the second substring is equal to the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph> plus one.</source>
          <target state="translated">Длина второй подстроки равна длине <ph id="ph1">`strB`</ph> минус <ph id="ph2">`indexB`</ph> плюс один.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
          <target state="translated">Число сравниваемых знаков равно меньшему из длин подстрок и <ph id="ph1">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated"><ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, И <ph id="ph3">`length`</ph> параметры должны быть неотрицательными.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison uses the <ph id="ph1">`culture`</ph> parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</source>
          <target state="translated">Сравнение выполняется с помощью <ph id="ph1">`culture`</ph> параметр, чтобы получить сведения о культуре, такие как правила учета регистра и алфавитный порядок отдельных символов.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Например, языка и региональных параметров может указать, что определенные сочетания знаков рассматриваться как один символ, или прописные и строчные буквы сравниваться определенным образом, или, порядок сортировки символа зависит от символов, которые предшествуют или после него.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison is performed using word sort rules.</source>
          <target state="translated">Сравнение выполняется с использованием правил сортировки по словам.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о слова, строки и порядковым номерам см. в разделе <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>One or both comparands can be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Один или оба сравниваемых значения могут быть <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</source>
          <target state="translated">По определению, любая строка, включая пустую строку ("»), сравниваются больше, чем указатель null; и две пустые ссылки равны друг другу.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
          <target state="translated">Сравнение заканчивается, когда встречается неравенство или обе подстроки уже обработаны.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</source>
          <target state="translated">Однако если две строки считаются равными конец одной строки, а другая строка символов, оставшихся, затем строка с символами оставшиеся считается большей.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Возвращается результат последнего выполненного сравнения.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Unexpected results can occur when comparisons are affected by culture-specific casing rules.</source>
          <target state="translated">Если правила определения регистра для конкретного языка и региональных параметров влияют на результаты сравнений, возможны непредвиденные результаты.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</source>
          <target state="translated">Например, в турецком алфавите следующий пример вызывает неверных результатов так файловой системы в турецком не регистр по правилам языка правил для букву «i» в «файл».</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Compare the path name to "file" using an ordinal comparison.</source>
          <target state="translated">Сравните имя пути для «файл», используя порядковое сравнение.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The correct code to do this is as follows:</source>
          <target state="translated">Правильный код для этого выглядит следующим образом:</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The following example compares two substrings using different cultures and ignoring the case of the substrings.</source>
          <target state="translated">В следующем примере сравниваются две подстроки с разными языками и без учета регистра подстроки.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The choice of culture affects how the letter "I" is compared.</source>
          <target state="translated">Выбор языка и региональных параметров влияет на способ букву «I» — по сравнению.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> больше значения <ph id="ph2">&lt;paramref name="strA" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> больше значения <ph id="ph2">&lt;paramref name="strB" /&gt;</ph><ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> или <ph id="ph3">&lt;paramref name="length" /&gt;</ph> является отрицательным значением.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Either <ph id="ph1">&lt;paramref name="strA" /&gt;</ph> or <ph id="ph2">&lt;paramref name="strB" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="strA" /&gt;</ph> или <ph id="ph2">&lt;paramref name="strB" /&gt;</ph> равно <ph id="ph3">&lt;see langword="null" /&gt;</ph>, а <ph id="ph4">&lt;paramref name="length" /&gt;</ph> больше нуля.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="culture" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">Наборы символов содержат символы, которые могут игнорироваться.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /&gt;</ph> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /&gt;</ph> Метод не учитывает эти символы при выполнении лингвистического сравнения или язык и региональные параметры сравнения.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)">
          <source>To recognize ignorable characters in your comparison, call the <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> method and supply a value of <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph4">&lt;paramref name="options" /&gt;</ph> parameter.</source>
          <target state="translated">Для распознавания игнорируемые символы, в отличие от вашей, вызовите <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> метод и укажите в качестве параметра <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> или <ph id="ph3">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> для <ph id="ph4">&lt;paramref name="options" /&gt;</ph> параметра.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">Первая из сравниваемых строк.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The starting position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Начальная позиция подстроки в пределах <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">Вторая из сравниваемых строк.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The starting position of the substring within <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Начальная позиция подстроки в пределах <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">Максимальное число сравниваемых знаков в подстроках.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>An object that supplies culture-specific comparison information.</source>
          <target state="translated">Объект, предоставляющий сведения об особенностях сравнения, определяемых языком и региональными параметрами.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Options to use when performing the comparison (such as ignoring case or symbols).</source>
          <target state="translated">Параметры, которые используются во время сравнения (например, игнорирование регистра или символов).</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two substrings to each other in the sort order.</source>
          <target state="translated">Сравнивает подстроки двух заданных объектов <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, используя указанные параметры сравнения и сведения о языке и региональных параметрах, которые влияют на сравнение, и возвращает целое число, показывающее связь между двумя подстроками в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>An integer that indicates the lexical relationship between the two substrings, as shown in the following table.</source>
          <target state="translated">Целое число, которое указывает на лексические отношения между двумя подстроками, как показано в следующей таблице.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Значение</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Условие</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Меньше нуля</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> precedes the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Подстрока в <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> предшествует подстроке в <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Нуль</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings occur in the same position in the sort order, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Подстроки находятся в той же позиции в порядке сортировки, или параметр <ph id="ph3">&lt;paramref name="length" /&gt;</ph> равен нулю.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Больше нуля</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> follows the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Подстрока в <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> следует за подстрокой в <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> в порядке сортировки.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The substrings to compare start in <ph id="ph1">`strA`</ph> at position <ph id="ph2">`indexA`</ph> and in <ph id="ph3">`strB`</ph> at position <ph id="ph4">`indexB`</ph>.</source>
          <target state="translated">Старта подстроках <ph id="ph1">`strA`</ph> позиции <ph id="ph2">`indexA`</ph> и <ph id="ph3">`strB`</ph> позиции <ph id="ph4">`indexB`</ph>.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The length of the first substring is the length of <ph id="ph1">`strA`</ph> minus <ph id="ph2">`indexA`</ph>.</source>
          <target state="translated">Длина первой подстроки — количество <ph id="ph1">`strA`</ph> минус <ph id="ph2">`indexA`</ph>.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The length of the second substring is the length of <ph id="ph1">`strB`</ph> minus <ph id="ph2">`indexB`</ph>.</source>
          <target state="translated">Длина второй подстроки — количество <ph id="ph1">`strB`</ph> минус <ph id="ph2">`indexB`</ph>.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The number of characters to compare is the lesser of the lengths of the two substrings, and <ph id="ph1">`length`</ph>.</source>
          <target state="translated">Число сравниваемых знаков равно меньшему из длин подстрок и <ph id="ph1">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated"><ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, И <ph id="ph3">`length`</ph> параметры должны быть неотрицательными.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison uses the <ph id="ph1">`culture`</ph> parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</source>
          <target state="translated">Сравнение выполняется с помощью <ph id="ph1">`culture`</ph> параметр для получения сведений о культуре, таких как правила учета регистра и алфавитный порядок отдельных символов.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</source>
          <target state="translated">Например, указать определенный язык и региональные параметры, определенные сочетания знаков рассматриваться как один символ, что прописные и строчные буквы сравниваться определенным образом, или, порядок сортировки символа зависит от символы, Введите перед или после него.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph> method is designed primarily for use in sorting or alphabetizing operations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph> Метод предназначен главным образом для использования при сортировке или операции сортировки в алфавитном порядке.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>It should not be used when the primary purpose of the method call is to determine whether two substrings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</source>
          <target state="translated">Он не должен использоваться, при основная цель вызова метода для определения двух подстрок, эквивалентны ли (то есть, когда вызывается метод используется для проверки возвращаемое значение равно нулю).</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>To determine whether two strings are equivalent, call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Чтобы определить, равны ли две строки, вызовите <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>One or both of <ph id="ph1">`strA`</ph> and <ph id="ph2">`strB`</ph> can be <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Один или оба <ph id="ph1">`strA`</ph> и <ph id="ph2">`strB`</ph> может быть <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>By definition, any string, including <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, compares greater than a null reference, and two null references compare equal to each other.</source>
          <target state="translated">По определению, любая строка, включая <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, сравнивает больше, чем пустая ссылка, а две пустые ссылки равны друг другу.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison can be further specified by the <ph id="ph1">`options`</ph> parameter, which consists of one or more members of the <ph id="ph2">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Сравнение могут задаваться с дальнейшей <ph id="ph1">`options`</ph> параметр, который состоит из одного или нескольких членов <ph id="ph2">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> перечисления.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> values have no effect.</source>
          <target state="translated">Тем не менее, так как этот метод предназначен для выполнения сравнения строк с учетом языка и региональных параметров, <ph id="ph1">&lt;xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> значения не оказывают влияния.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The comparison terminates when an inequality is discovered or both substrings have been compared.</source>
          <target state="translated">Сравнение заканчивается, когда встречается неравенство или обе подстроки уже обработаны.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</source>
          <target state="translated">Однако если две строки считаются равными конец одной строки, а другая строка символов, оставшихся, строка с символами оставшиеся считается большей.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The return value is the result of the last comparison performed.</source>
          <target state="translated">Возвращается результат последнего выполненного сравнения.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph> method to compare the last names of two people.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29&gt;</ph> метод для сравнения фамилий два человека.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>It then lists them in alphabetical order.</source>
          <target state="translated">Затем он размещает их в алфавитном порядке.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.Globalization.CompareOptions" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> не является значением <ph id="ph2">&lt;see cref="T:System.Globalization.CompareOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strA" /&gt;</ph><ph id="ph3">&lt;see langword=".Length" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="indexA" /&gt;</ph> больше значения <ph id="ph2">&lt;paramref name="strA" /&gt;</ph><ph id="ph3">&lt;see langword=".Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="strB" /&gt;</ph><ph id="ph3">&lt;see langword=".Length" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="indexB" /&gt;</ph> больше значения <ph id="ph2">&lt;paramref name="strB" /&gt;</ph><ph id="ph3">&lt;see langword=".Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> или <ph id="ph3">&lt;paramref name="length" /&gt;</ph> является отрицательным значением.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Either <ph id="ph1">&lt;paramref name="strA" /&gt;</ph> or <ph id="ph2">&lt;paramref name="strB" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="length" /&gt;</ph> is greater than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="strA" /&gt;</ph> или <ph id="ph2">&lt;paramref name="strB" /&gt;</ph> равно <ph id="ph3">&lt;see langword="null" /&gt;</ph>, а <ph id="ph4">&lt;paramref name="length" /&gt;</ph> больше нуля.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="culture" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">Наборы символов содержат символы, которые могут игнорироваться.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> method does not consider these characters when it performs a linguistic or culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /&gt;</ph> Метод не учитывает эти символы при выполнении лингвистического сравнения или язык и региональные параметры сравнения.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)">
          <source>To recognize ignorable characters in your comparison, supply a value of <ph id="ph1">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> for the <ph id="ph3">&lt;paramref name="options" /&gt;</ph> parameter.</source>
          <target state="translated">Для распознавания игнорируемые символы, в отличие от вашей, укажите в качестве параметра <ph id="ph1">&lt;see cref="F:System.Globalization.CompareOptions.Ordinal" /&gt;</ph> или <ph id="ph2">&lt;see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /&gt;</ph> для <ph id="ph3">&lt;paramref name="options" /&gt;</ph> параметра.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Compares two <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects by evaluating the numeric values of the corresponding <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph> objects in each string.</source>
          <target state="translated">Сравнивает два объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, оценивая числовые значения соответствующих объектов <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph> в каждой строке.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>The first string to compare.</source>
          <target state="translated">Первая сравниваемая строка.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>The second string to compare.</source>
          <target state="translated">Вторая сравниваемая строка.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>Compares two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects by evaluating the numeric values of the corresponding <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph> objects in each string.</source>
          <target state="translated">Сравнивает два указанных объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, оценивая числовые значения соответствующих объектов <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph> в каждой строке.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>An integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">Целое число, выражающее лексическое соотношение двух сравниваемых значений.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Значение</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Условие</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Меньше нуля</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> is less than <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> меньше <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Нуль</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> and <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> are equal.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> и <ph id="ph4">&lt;paramref name="strB" /&gt;</ph> равны.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Больше нуля</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> is greater than <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="strA" /&gt;</ph> больше <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>This method performs a case-sensitive comparison using ordinal sort rules.</source>
          <target state="translated">Этот метод выполняет сравнение с учетом регистра, используя правила сортировки по порядковому номеру.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о слова, строки и порядковым номерам см. в разделе <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>To perform a case-insensitive comparison using ordinal sort rules, call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method with the <ph id="ph2">`comparisonType`</ph> argument set to <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Чтобы выполнить сравнение без учета регистра, используя правила сортировки по порядковому номеру, вызвать <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> метод с <ph id="ph2">`comparisonType`</ph> аргументу присвоено <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>Because <ph id="ph1">&lt;xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29&gt;</ph> is a static method, <ph id="ph2">`strA`</ph> and <ph id="ph3">`strB`</ph> can be <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Поскольку <ph id="ph1">&lt;xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29&gt;</ph> — статический метод <ph id="ph2">`strA`</ph> и <ph id="ph3">`strB`</ph> может быть <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>If both values are <ph id="ph1">`null`</ph>, the method returns 0 (zero), which indicates that <ph id="ph2">`strA`</ph> and <ph id="ph3">`strB`</ph> are equal.</source>
          <target state="translated">Если оба значения равны <ph id="ph1">`null`</ph>, метод возвращает 0 (ноль), который указывает, что <ph id="ph2">`strA`</ph> и <ph id="ph3">`strB`</ph> равны.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>If only one of the values is <ph id="ph1">`null`</ph>, the method considers the non-null value to be greater.</source>
          <target state="translated">Если используется только одно из значений <ph id="ph1">`null`</ph>, метод учитывает должно следовать значение отличное от null.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.String)">
          <source>The following example performs and ordinal comparison of two strings that only differ in case.</source>
          <target state="translated">В следующем примере выполняется и порядковое сравнение двух строк, различающихся только регистром.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The first string to use in the comparison.</source>
          <target state="translated">Первая из сравниваемых строк.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The starting index of the substring in <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Начальный индекс подстроки в <bpt id="p1">&lt;c&gt;</bpt>strA<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The second string to use in the comparison.</source>
          <target state="translated">Вторая из сравниваемых строк.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The starting index of the substring in <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Начальный индекс подстроки в <bpt id="p1">&lt;c&gt;</bpt>strB<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The maximum number of characters in the substrings to compare.</source>
          <target state="translated">Максимальное число сравниваемых знаков в подстроках.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Compares substrings of two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects by evaluating the numeric values of the corresponding <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph> objects in each substring.</source>
          <target state="translated">Сравнивает подстроки двух указанных объектов <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, вычисляя числовые значения соответствующих объектов <ph id="ph2">&lt;see cref="T:System.Char" /&gt;</ph> в каждой подстроке.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>A 32-bit signed integer that indicates the lexical relationship between the two comparands.</source>
          <target state="translated">32-битовое целое число со знаком, выражающее лексическое отношение двух сравниваемых значений.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Значение</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Условие</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Меньше нуля</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> is less than the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Подстрока в <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> меньше, чем подстрока в <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Нуль</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substrings are equal, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Подстроки равны, или значение параметра <ph id="ph3">&lt;paramref name="length" /&gt;</ph> равно нулю.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Больше нуля</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> The substring in <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> is greater than the substring in <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Подстрока в <ph id="ph3">&lt;paramref name="strA" /&gt;</ph> больше, чем подстрока в <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, and <ph id="ph3">`length`</ph> parameters must be nonnegative.</source>
          <target state="translated"><ph id="ph1">`indexA`</ph>, <ph id="ph2">`indexB`</ph>, И <ph id="ph3">`length`</ph> параметры должны быть неотрицательными.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>The number of characters compared is the lesser of the length of <ph id="ph1">`strA`</ph> less <ph id="ph2">`indexA`</ph>, the length of <ph id="ph3">`strB`</ph> less <ph id="ph4">`indexB`</ph>, and <ph id="ph5">`length`</ph>.</source>
          <target state="translated">Число сравниваемых знаков равно меньшему из длина <ph id="ph1">`strA`</ph> меньше <ph id="ph2">`indexA`</ph>, длина <ph id="ph3">`strB`</ph> меньше <ph id="ph4">`indexB`</ph>, и <ph id="ph5">`length`</ph>.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>This method performs a case-sensitive comparison using ordinal sort rules.</source>
          <target state="translated">Этот метод выполняет сравнение с учетом регистра, используя правила сортировки по порядковому номеру.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о слова, строки и порядковым номерам см. в разделе <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>To perform a case-insensitive comparison using ordinal sort rules, call the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph> method with the <ph id="ph2">`comparisonType`</ph> argument set to <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Чтобы выполнить сравнение без учета регистра, используя правила сортировки по порядковому номеру, вызвать <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29&gt;</ph> метод с <ph id="ph2">`comparisonType`</ph> аргументу присвоено <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>Because <ph id="ph1">&lt;xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29&gt;</ph> is a static method, <ph id="ph2">`strA`</ph> and <ph id="ph3">`strB`</ph> can be <ph id="ph4">`null`</ph>.</source>
          <target state="translated">Поскольку <ph id="ph1">&lt;xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29&gt;</ph> — статический метод <ph id="ph2">`strA`</ph> и <ph id="ph3">`strB`</ph> может быть <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>If both values are <ph id="ph1">`null`</ph>, the method returns 0 (zero), which indicates that <ph id="ph2">`strA`</ph> and <ph id="ph3">`strB`</ph> are equal.</source>
          <target state="translated">Если оба значения равны <ph id="ph1">`null`</ph>, метод возвращает 0 (ноль), который указывает, что <ph id="ph2">`strA`</ph> и <ph id="ph3">`strB`</ph> равны.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>If only one of the values is <ph id="ph1">`null`</ph>, the method considers the non-null value to be greater.</source>
          <target state="translated">Если используется только одно из значений <ph id="ph1">`null`</ph>, метод учитывает должно следовать значение отличное от null.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>This following example demonstrates that <ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph> use different sort orders.</source>
          <target state="translated">В следующем примере показано, что <ph id="ph1">&lt;xref:System.String.CompareOrdinal%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph> используют различный порядок сортировки.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="strA" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph> and <ph id="ph3">&lt;paramref name="indexA" /&gt;</ph> is greater than <ph id="ph4">&lt;paramref name="strA" /&gt;</ph>.<ph id="ph5">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="strA" /&gt;</ph> не имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, и значение <ph id="ph3">&lt;paramref name="indexA" /&gt;</ph> больше <ph id="ph4">&lt;paramref name="strA" /&gt;</ph>,<ph id="ph5">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="strB" /&gt;</ph> is not <ph id="ph2">&lt;see langword="null" /&gt;</ph> and <ph id="ph3">&lt;paramref name="indexB" /&gt;</ph> is greater than <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>.<ph id="ph5">&lt;see cref="P:System.String.Length" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="strB" /&gt;</ph> не имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, и значение <ph id="ph3">&lt;paramref name="indexB" /&gt;</ph> больше <ph id="ph4">&lt;paramref name="strB" /&gt;</ph>,<ph id="ph5">&lt;see cref="P:System.String.Length" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" uid="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="length" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="indexA" /&gt;</ph>, <ph id="ph2">&lt;paramref name="indexB" /&gt;</ph> или <ph id="ph3">&lt;paramref name="length" /&gt;</ph> является отрицательным значением.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Compares this instance with a specified object or <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> and returns an integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified object or <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Сравнивает данный экземпляр с заданным объектом или строкой <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> и возвращает целое число, которое показывает, расположен ли данный экземпляр перед, после или на той же позиции в порядке сортировки, что и заданный объект или строка <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Both overloads of the <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method perform culture-sensitive and case-sensitive comparison.</source>
          <target state="translated">Обе перегрузки <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> метода выполняют сравнение с учетом языка и региональных параметров и регистра.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You cannot use this method to perform culture-insensitive or ordinal comparisons.</source>
          <target state="translated">Этот метод нельзя использовать для сравнения без учета языка и региональных параметров или порядковый номер.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For code clarity, we recommend that you avoid the <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method and call the <ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph> method instead.</source>
          <target state="translated">Для получения более понятного кода рекомендуется избегать <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> метод и вызовите <ph id="ph2">&lt;xref:System.String.Compare%2A&gt;</ph> метод вместо него.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source>An object that evaluates to a <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Объект, имеющий значение <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source>Compares this instance with a specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">Сравнивает данный экземпляр с указанным объектом <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> и показывает, расположен ли экземпляр перед, после или в той же позиции в порядке сортировки, что и заданный объект <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter.</source>
          <target state="translated">32-битовое целое число со знаком, которое показывает, расположен ли данный экземпляр перед, после или на той же позиции в порядке сортировки, что и параметр <ph id="ph1">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Значение</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Условие</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Меньше нуля</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance precedes <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Данный экземпляр предшествует параметру <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Нуль</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance has the same position in the sort order as <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Данный экземпляр имеет ту же позицию в порядке сортировки, что и <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Больше нуля</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance follows <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Данный экземпляр следует за параметром <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">`value`</ph> must be a <ph id="ph2">&lt;xref:System.String&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">`value`</ph> должно быть <ph id="ph2">&lt;xref:System.String&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method was designed primarily for use in sorting or alphabetizing operations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> Метод предназначен главным образом для использования при сортировке или операции сортировки в алфавитном порядке.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</source>
          <target state="translated">Он не должен использоваться, если основная цель вызова метода — определить, равны ли две строки.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>To determine whether two strings are equivalent, call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Чтобы определить, равны ли две строки, вызовите <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</source>
          <target state="translated">Этот метод выполняет сравнение по словам (с учетом регистра и культуры) с использованием текущего языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о слова, строки и порядковым номерам см. в разделе <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>For more information about the behavior of this method, see the Remarks section of the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Дополнительные сведения о поведении этого метода см. в разделе «Примечания» <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> метод с <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>Because it attempts to compare a <ph id="ph1">&lt;xref:System.String&gt;</ph> instance to a <ph id="ph2">`TestClass`</ph> object, the method throws an <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">Так как он пытается сравнить <ph id="ph1">&lt;xref:System.String&gt;</ph> экземпляр <ph id="ph2">`TestClass`</ph> объекта, метод создает <ph id="ph3">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> не является объектом <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">Наборы символов содержат символы, которые могут игнорироваться.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.CompareTo(System.Object)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.CompareTo(System.Object)" /&gt;</ph> Метод не учитывает такие символы при сравнении с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>For example, if the following code is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</source>
          <target state="translated">Например, следующий код выполняется на <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> или более поздней версии, сравнение «animal» с «ani почты» (с помощью мягкий перенос или 00AD U +) указывает, что две строки равны.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.Object)">
          <source>To recognize ignorable characters in a string comparison, call the <ph id="ph1">&lt;see cref="M:System.String.CompareOrdinal(System.String,System.String)" /&gt;</ph> method.</source>
          <target state="translated">Для распознавания игнорируемые символы в сравнения строк, вызвать <ph id="ph1">&lt;see cref="M:System.String.CompareOrdinal(System.String,System.String)" /&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source>The string to compare with this instance.</source>
          <target state="translated">Строка, сравниваемая с данным экземпляром.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source>Compares this instance with a specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string.</source>
          <target state="translated">Сравнивает данный экземпляр с заданным объектом <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> и показывает, расположен ли данный экземпляр перед, после или на той же позиции в порядке сортировки, что и заданная строка.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <ph id="ph1">&lt;paramref name="strB" /&gt;</ph> parameter.</source>
          <target state="translated">32-битовое целое число со знаком, которое показывает, расположен ли данный экземпляр перед, после или на той же позиции в порядке сортировки, что и параметр <ph id="ph1">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Значение</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Condition</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Условие</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Меньше нуля</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance precedes <ph id="ph3">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Данный экземпляр предшествует параметру <ph id="ph3">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Нуль</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance has the same position in the sort order as <ph id="ph3">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Данный экземпляр имеет ту же позицию в порядке сортировки, что и <ph id="ph3">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Больше нуля</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> This instance follows <ph id="ph3">&lt;paramref name="strB" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Данный экземпляр следует за параметром <ph id="ph3">&lt;paramref name="strB" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="M:System.String.CompareTo(System.String)">
          <source><ph id="ph1">&lt;paramref name="strB" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="strB" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</source>
          <target state="translated">Этот метод выполняет сравнение по словам (с учетом регистра и культуры) с использованием текущего языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>For more information about word, string, and ordinal sorts, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о слова, строки и порядковым номерам см. в разделе <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method was designed primarily for use in sorting or alphabetizing operations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> Метод предназначен главным образом для использования при сортировке или операции сортировки в алфавитном порядке.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</source>
          <target state="translated">Он не должен использоваться, если основная цель вызова метода — определить, равны ли две строки.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>To determine whether two strings are equivalent, call the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">Чтобы определить, равны ли две строки, вызовите <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>For more information about the behavior of this method, see the Remarks section of the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph> method.</source>
          <target state="translated">Дополнительные сведения о поведении этого метода см. в разделе «Примечания» <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>This method implements the <ph id="ph1">&lt;xref:System.IComparable%601?displayProperty=nameWithType&gt;</ph> interface and performs slightly better than the <ph id="ph2">&lt;xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType&gt;</ph> method, because it does not have to determine whether the <ph id="ph3">`strB`</ph> argument is a mutable value type that must be boxed, and it does not have to cast its parameter from an <ph id="ph4">&lt;xref:System.Object&gt;</ph> to a <ph id="ph5">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">Этот метод реализует <ph id="ph1">&lt;xref:System.IComparable%601?displayProperty=nameWithType&gt;</ph> интерфейс, а также выполняет немного быстрее, чем <ph id="ph2">&lt;xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType&gt;</ph> метода, так как он не должен определить ли <ph id="ph3">`strB`</ph> аргумент имеет тип изменяемого значения, должны быть упакованы, и он не приходилось приводить его параметр из <ph id="ph4">&lt;xref:System.Object&gt;</ph> для <ph id="ph5">&lt;xref:System.String&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> method to compare the current string instance with another string.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.String.CompareTo%2A&gt;</ph> метод для сравнения текущего экземпляра строки с другой строкой.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>The following example demonstrates generic and non-generic versions of the CompareTo method for several value and reference types.</source>
          <target state="translated">Ниже приведен пример универсальные и неуниверсальные версии метода CompareTo для нескольких типов значений и ссылочных типов.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>Character sets include ignorable characters.</source>
          <target state="translated">Наборы символов содержат символы, которые могут игнорироваться.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>The <ph id="ph1">&lt;see cref="M:System.String.CompareTo(System.String)" /&gt;</ph> method does not consider such characters when it performs a culture-sensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.String.CompareTo(System.String)" /&gt;</ph> Метод не учитывает такие символы при сравнении с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>For example, if the following code is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.</source>
          <target state="translated">Например, следующий код выполняется на <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> или более поздней версии, сравнение «animal» с «ani почты» (с помощью мягкий перенос или 00AD U +) указывает, что две строки равны.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CompareTo(System.String)">
          <source>To recognize ignorable characters in a string comparison, call the <ph id="ph1">&lt;see cref="M:System.String.CompareOrdinal(System.String,System.String)" /&gt;</ph> method.</source>
          <target state="translated">Для распознавания игнорируемые символы в сравнения строк, вызвать <ph id="ph1">&lt;see cref="M:System.String.CompareOrdinal(System.String,System.String)" /&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Concatenates one or more instances of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, or the <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> representations of the values of one or more instances of <ph id="ph3">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">Объединяет один или несколько экземпляров класса <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> или представления в виде <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> значений одного или нескольких экземпляров <ph id="ph3">&lt;see cref="T:System.Object" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>A collection object that implements <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> and whose generic type argument is <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Объект коллекции, реализующий интерфейс <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> и имеющий аргумент универсального типа <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>Concatenates the members of a constructed <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> collection of type <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Сцепляет элементы созданной коллекции <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> типа <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>The concatenated strings in <ph id="ph1">&lt;paramref name="values" /&gt;</ph>, or <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph3">&lt;paramref name="values" /&gt;</ph> is an empty <ph id="ph4">&lt;see langword="IEnumerable(Of String)" /&gt;</ph>.</source>
          <target state="translated">Сцепленные строки в параметре <ph id="ph1">&lt;paramref name="values" /&gt;</ph>. Или <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, если <ph id="ph3">&lt;paramref name="values" /&gt;</ph> — это пустой элемент <ph id="ph4">&lt;see langword="IEnumerable(Of String)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>The method concatenates each object in <ph id="ph1">`values`</ph>; it does not add any delimiters.</source>
          <target state="translated">Метод сцепляет каждый объект в <ph id="ph1">`values`</ph>; разделители не добавляются.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>To specify a delimiter between each member of <ph id="ph1">`values`</ph>, call the <ph id="ph2">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> method.</source>
          <target state="translated">Для указания разделителя между каждым членом <ph id="ph1">`values`</ph>, вызовите <ph id="ph2">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null element in <ph id="ph2">`values`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> Строки используется вместо любой элемент null в <ph id="ph2">`values`</ph>.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>If <ph id="ph1">`values`</ph> is an empty <ph id="ph2">`IEnumerable(Of String)`</ph>, the method returns <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Если <ph id="ph1">`values`</ph> представляет собой пустой <ph id="ph2">`IEnumerable(Of String)`</ph>, метод возвращает <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>If <ph id="ph1">`values`</ph> is <ph id="ph2">`null`</ph>, the method throws an <ph id="ph3">&lt;xref:System.ArgumentNullException&gt;</ph> exception.</source>
          <target state="translated">Если <ph id="ph1">`values`</ph> — <ph id="ph2">`null`</ph>, метод создает <ph id="ph3">&lt;xref:System.ArgumentNullException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source><ph id="ph1">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> is a convenience method that lets you concatenate each element in an <ph id="ph2">`IEnumerable(Of String)`</ph> collection without first converting the elements to a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> удобный метод, который позволяет сцеплять все элементы в <ph id="ph2">`IEnumerable(Of String)`</ph> коллекции без предварительного преобразования элементов в массив строк.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>It is particularly useful with Language-Integrated Query (LINQ) query expressions.</source>
          <target state="translated">Это особенно полезно в выражениях запроса, встроенных в язык запросы (LINQ).</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>The following example passes a <ph id="ph1">`List(Of String)`</ph> object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</source>
          <target state="translated">В следующем примере передается <ph id="ph1">`List(Of String)`</ph> , содержащий прописные или строчные буквы алфавита в лямбда-выражение, определяющее буквы, которые меньше, чем конкретная буква (который, в примере «M»).</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>The <ph id="ph1">`IEnumerable(Of String)`</ph> collection that is returned by the <ph id="ph2">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> method is passed to the <ph id="ph3">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> method to display the result as a single string.</source>
          <target state="translated"><ph id="ph1">`IEnumerable(Of String)`</ph> Коллекции, который возвращается <ph id="ph2">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> методу передается <ph id="ph3">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> метод для отображения результатов в виде одной строки.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</source>
          <target state="translated">Следующий пример использует алгоритм решета Эратосфена для вычисления простых чисел, которые меньше или равно 100.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source>It assigns the result to a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object of type <ph id="ph2">&lt;xref:System.String&gt;</ph>, which it then passes to the <ph id="ph3">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> method.</source>
          <target state="translated">Он назначает результат <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> объекта типа <ph id="ph2">&lt;xref:System.String&gt;</ph>, который затем передается в <ph id="ph3">&lt;xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="values" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object)">
          <source>The object to represent, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект для представления или значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object)">
          <source>Creates the string  representation of a specified object.</source>
          <target state="translated">Создает строковое представление указанного объекта.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object)">
          <source>The string representation of the value of <ph id="ph1">&lt;paramref name="arg0" /&gt;</ph>, or <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph3">&lt;paramref name="arg0" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Строковое представление значения параметра <ph id="ph1">&lt;paramref name="arg0" /&gt;</ph> или <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, если значение параметра <ph id="ph3">&lt;paramref name="arg0" /&gt;</ph> равно <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%29&gt;</ph> method represents <ph id="ph2">`arg0`</ph> as a string by calling its parameterless <ph id="ph3">`ToString`</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Concat%28System.Object%29&gt;</ph> Представляет метод <ph id="ph2">`arg0`</ph> как строку путем вызова его без параметров <ph id="ph3">`ToString`</ph> метод.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object[])">
          <source>An object array that contains the elements to concatenate.</source>
          <target state="translated">Массив объектов, содержащий элементы, которые требуется сцепить.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object[])">
          <source>Concatenates the string representations of the elements in a specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> array.</source>
          <target state="translated">Сцепляет строковые представления элементов указанного массива <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object[])">
          <source>The concatenated string representations of the values of the elements in <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">Сцепленные строковые представления значений элементов параметра <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object[])">
          <source>The method concatenates each object in <ph id="ph1">`args`</ph> by calling the parameterless <ph id="ph2">`ToString`</ph> method of that object; it does not add any delimiters.</source>
          <target state="translated">Метод сцепляет каждый объект в <ph id="ph1">`args`</ph> путем вызова без параметров <ph id="ph2">`ToString`</ph> метод этого объекта; разделители не добавляются.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object[])">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> is used in place of any null object in the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> используется вместо любого пустого объекта в массиве.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object[])">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method with an <ph id="ph2">&lt;xref:System.Object&gt;</ph> array.</source>
          <target state="translated">В следующем примере показано использование <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> метод с <ph id="ph2">&lt;xref:System.Object&gt;</ph> массива.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object[])">
          <source><ph id="ph1">&lt;paramref name="args" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="args" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object[])">
          <source>Out of memory.</source>
          <target state="translated">Недостаточно памяти.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object[])">
          <source>This method is not called by C++ code.</source>
          <target state="translated">Этот метод не вызывается кодом C++.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object[])">
          <source>The C++ compiler resolves calls to <ph id="ph1">&lt;see cref="Overload:System.String.Concat" /&gt;</ph> that have four or more object parameters as a call to <ph id="ph2">&lt;see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /&gt;</ph>.</source>
          <target state="translated">Компилятор C++ разрешает вызовы к <ph id="ph1">&lt;see cref="Overload:System.String.Concat" /&gt;</ph> , имеющие четыре или более параметров объекта как вызов <ph id="ph2">&lt;see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String[])">
          <source>An array of string instances.</source>
          <target state="translated">Массив строк.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String[])">
          <source>Concatenates the elements of a specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> array.</source>
          <target state="translated">Сцепляет элементы указанного массива <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String[])">
          <source>The concatenated elements of <ph id="ph1">&lt;paramref name="values" /&gt;</ph>.</source>
          <target state="translated">Сцепленные элементы <ph id="ph1">&lt;paramref name="values" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String[])">
          <source>The method concatenates each object in <ph id="ph1">`values`</ph>; it does not add any delimiters.</source>
          <target state="translated">Метод сцепляет каждый объект в <ph id="ph1">`values`</ph>; разделители не добавляются.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String[])">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null object in the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> Строки используется вместо любого пустого объекта в массиве.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String[])">
          <source>The following example demonstrates the use of the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method with a <ph id="ph2">&lt;xref:System.String&gt;</ph> array.</source>
          <target state="translated">В следующем примере показано использование <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> метод с <ph id="ph2">&lt;xref:System.String&gt;</ph> массива.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String[])">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="values" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String[])">
          <source>Out of memory.</source>
          <target state="translated">Недостаточно памяти.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>The first object to concatenate.</source>
          <target state="translated">Первый из сцепляемых объектов.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>The second object to concatenate.</source>
          <target state="translated">Второй из сцепляемых объектов.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>Concatenates the string representations of two specified objects.</source>
          <target state="translated">Сцепляет строковые представления двух указанных объектов.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>The concatenated string representations of the values of <ph id="ph1">&lt;paramref name="arg0" /&gt;</ph> and <ph id="ph2">&lt;paramref name="arg1" /&gt;</ph>.</source>
          <target state="translated">Сцепленные строковые представления значений <ph id="ph1">&lt;paramref name="arg0" /&gt;</ph> и <ph id="ph2">&lt;paramref name="arg1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>The method concatenates <ph id="ph1">`arg0`</ph> and <ph id="ph2">`arg1`</ph> by calling the parameterless <ph id="ph3">`ToString`</ph> method of <ph id="ph4">`arg0`</ph> and <ph id="ph5">`arg1`</ph>; it does not add any delimiters.</source>
          <target state="translated">Этот метод объединяет <ph id="ph1">`arg0`</ph> и <ph id="ph2">`arg1`</ph> путем вызова без параметров <ph id="ph3">`ToString`</ph> метод <ph id="ph4">`arg0`</ph> и <ph id="ph5">`arg1`</ph>; разделители не добавляются.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> is used in place of any null argument.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> используется вместо любого пустого аргумента.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>If either of the arguments is an array reference, the method concatenates a string representing that array, instead of its members (for example, "System.String[]").</source>
          <target state="translated">Если аргумент является ссылкой на массив, метод объединяет строковое представление этого массива, вместо его членов (например, «System.String[]")").</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String)">
          <source>The first string to concatenate.</source>
          <target state="translated">Первая из сцепляемых строк.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String)">
          <source>The second string to concatenate.</source>
          <target state="translated">Вторая из сцепляемых строк.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String)">
          <source>Concatenates two specified instances of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Сцепляет два указанных экземпляра <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String)">
          <source>The concatenation of <ph id="ph1">&lt;paramref name="str0" /&gt;</ph> and <ph id="ph2">&lt;paramref name="str1" /&gt;</ph>.</source>
          <target state="translated">Сцепление <ph id="ph1">&lt;paramref name="str0" /&gt;</ph> и <ph id="ph2">&lt;paramref name="str1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String)">
          <source>The method concatenates <ph id="ph1">`str0`</ph> and <ph id="ph2">`str1`</ph>; it does not add any delimiters.</source>
          <target state="translated">Этот метод объединяет <ph id="ph1">`str0`</ph> и <ph id="ph2">`str1`</ph>; разделители не добавляются.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String)">
          <source>You can also use your language's string concatenation operator, such as <ph id="ph1">`+`</ph> in C#, or <ph id="ph2">`&amp;`</ph> and <ph id="ph3">`+`</ph> in Visual Basic)</source>
          <target state="translated">Можно также использовать оператор объединения строк языка, такие как <ph id="ph1">`+`</ph> в C#, или <ph id="ph2">`&amp;`</ph> и <ph id="ph3">`+`</ph> в Visual Basic)</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String)">
          <source>, to concatenate strings.</source>
          <target state="translated">, для объединения строк.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String)">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null argument.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> Строки используется вместо любого пустого аргумента.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String)">
          <source>The following example concatenates a person's first, middle, and last name.</source>
          <target state="translated">Следующий пример Сцепляет имя, отчество и фамилию человека.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The first object to concatenate.</source>
          <target state="translated">Первый из сцепляемых объектов.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The second object to concatenate.</source>
          <target state="translated">Второй из сцепляемых объектов.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The third object to concatenate.</source>
          <target state="translated">Третий из сцепляемых объектов.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>Concatenates the string representations of three specified objects.</source>
          <target state="translated">Сцепляет строковые представления трех указанных объектов.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The concatenated string representations of the values of <ph id="ph1">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph2">&lt;paramref name="arg1" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="arg2" /&gt;</ph>.</source>
          <target state="translated">Сцепленные строковые представления значений <ph id="ph1">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph2">&lt;paramref name="arg1" /&gt;</ph> и <ph id="ph3">&lt;paramref name="arg2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The method concatenates <ph id="ph1">`arg0`</ph>, <ph id="ph2">`arg1`</ph>, and <ph id="ph3">`arg2`</ph> by calling the parameterless <ph id="ph4">`ToString`</ph> method of each object; it does not add any delimiters.</source>
          <target state="translated">Этот метод объединяет <ph id="ph1">`arg0`</ph>, <ph id="ph2">`arg1`</ph>, и <ph id="ph3">`arg2`</ph> путем вызова без параметров <ph id="ph4">`ToString`</ph> метода каждого объекта; разделители не добавляются.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> is used in place of any null argument.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> используется вместо любого пустого аргумента.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The first string to concatenate.</source>
          <target state="translated">Первая из сцепляемых строк.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The second string to concatenate.</source>
          <target state="translated">Вторая из сцепляемых строк.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The third string to concatenate.</source>
          <target state="translated">Третья из сцепляемых строк.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>Concatenates three specified instances of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Сцепляет три указанных экземпляра <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The concatenation of <ph id="ph1">&lt;paramref name="str0" /&gt;</ph>, <ph id="ph2">&lt;paramref name="str1" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="str2" /&gt;</ph>.</source>
          <target state="translated">Сцепление <ph id="ph1">&lt;paramref name="str0" /&gt;</ph>, <ph id="ph2">&lt;paramref name="str1" /&gt;</ph> и <ph id="ph3">&lt;paramref name="str2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The method concatenates <ph id="ph1">`str0`</ph>, <ph id="ph2">`str1`</ph>, and <ph id="ph3">`str2`</ph>; it does not add any delimiters.</source>
          <target state="translated">Этот метод объединяет <ph id="ph1">`str0`</ph>, <ph id="ph2">`str1`</ph>, и <ph id="ph3">`str2`</ph>; разделители не добавляются.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>You can also use your language's string concatenation operator, such as <ph id="ph1">`+`</ph> in C#, or <ph id="ph2">`&amp;`</ph> and <ph id="ph3">`+`</ph> in Visual Basic)</source>
          <target state="translated">Можно также использовать оператор объединения строк языка, такие как <ph id="ph1">`+`</ph> в C#, или <ph id="ph2">`&amp;`</ph> и <ph id="ph3">`+`</ph> в Visual Basic)</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>, to concatenate strings.</source>
          <target state="translated">, для объединения строк.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null argument.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> Строки используется вместо любого пустого аргумента.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method to concatenate three strings and displays the result.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> метод для сцепления трех строк и отображает результат.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The first object to concatenate.</source>
          <target state="translated">Первый из сцепляемых объектов.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The second object to concatenate.</source>
          <target state="translated">Второй из сцепляемых объектов.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The third object to concatenate.</source>
          <target state="translated">Третий из сцепляемых объектов.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The fourth object to concatenate.</source>
          <target state="translated">Четвертый из сцепляемых объектов.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>Concatenates the string representations of four specified objects and any objects specified in an optional variable length parameter list.</source>
          <target state="translated">Сцепляет строковые представления четырех указанных объектов и любые объекты, заданные в необязательном списке параметров переменной длины.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The concatenated string representation of each value in the parameter list.</source>
          <target state="translated">Сцепленное строковое представление каждого значения в списке параметров.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>This API is not CLS-compliant.</source>
          <target state="translated">Этот интерфейс API CLS-несовместим.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The CLS-compliant alternative is <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">CLS-совместимая альтернатива — <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The C# and Visual Basic compilers automatically resolve a call to this method as a call to <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Компиляторы C# и Visual Basic автоматически разрешить вызов этого метода, как вызов <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The method concatenates each object in the parameter list by calling its parameterless <ph id="ph1">`ToString`</ph> method; it does not add any delimiters.</source>
          <target state="translated">Метод сцепляет каждый объект в списке параметров, вызвав его без параметров <ph id="ph1">`ToString`</ph> метода; разделители не добавляются.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> is used in place of any null argument.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> используется вместо любого пустого аргумента.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The last parameter of the  <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> method is an optional comma-delimited list of one or more additional objects to concatenate.</source>
          <target state="translated">Последний параметр <ph id="ph1">&lt;xref:System.String.Concat%2A&gt;</ph> метод — необязательный список с разделителями запятыми из одного или нескольких дополнительных объектов для сцепления.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The following example illustrates the use of the <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph> method to concatenate a list of variable parameters.</source>
          <target state="translated">Следующий пример иллюстрирует использование <ph id="ph1">&lt;xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph> метода для сцепления список параметров переменной.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>In this case, the method is called with nine parameters.</source>
          <target state="translated">В этом случае метод вызывается с девятью параметрами.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>This method is marked with the <ph id="ph1">&lt;see langword="vararg" /&gt;</ph> keyword, which means that it supports a variable number of parameters.</source>
          <target state="translated">Этот метод помечен атрибутом <ph id="ph1">&lt;see langword="vararg" /&gt;</ph> ключевое слово, которое означает, что он поддерживает переменное число параметров.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The method can be called from Visual C++, but it cannot be called from C# or Visual Basic code.</source>
          <target state="translated">Метод может вызываться из Visual C++, но не может вызываться из кода C# или Visual Basic.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)">
          <source>The C# and Visual Basic compilers resolve calls to <ph id="ph1">&lt;see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /&gt;</ph> as calls to <ph id="ph2">&lt;see cref="M:System.String.Concat(System.Object[])" /&gt;</ph>.</source>
          <target state="translated">Компиляторы C# и Visual Basic разрешить вызовы <ph id="ph1">&lt;see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /&gt;</ph> как вызов <ph id="ph2">&lt;see cref="M:System.String.Concat(System.Object[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The first string to concatenate.</source>
          <target state="translated">Первая из сцепляемых строк.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The second string to concatenate.</source>
          <target state="translated">Вторая из сцепляемых строк.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The third string to concatenate.</source>
          <target state="translated">Третья из сцепляемых строк.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The fourth string to concatenate.</source>
          <target state="translated">Четвертая из сцепляемых строк.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>Concatenates four specified instances of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Сцепляет четыре указанных экземпляра <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The concatenation of <ph id="ph1">&lt;paramref name="str0" /&gt;</ph>, <ph id="ph2">&lt;paramref name="str1" /&gt;</ph>, <ph id="ph3">&lt;paramref name="str2" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="str3" /&gt;</ph>.</source>
          <target state="translated">Сцепление <ph id="ph1">&lt;paramref name="str0" /&gt;</ph>, <ph id="ph2">&lt;paramref name="str1" /&gt;</ph>, <ph id="ph3">&lt;paramref name="str2" /&gt;</ph> и <ph id="ph4">&lt;paramref name="str3" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The method concatenates <ph id="ph1">`str0`</ph>, <ph id="ph2">`str1`</ph>, <ph id="ph3">`str2`</ph>, and <ph id="ph4">`str3`</ph>; it does not add any delimiters.</source>
          <target state="translated">Этот метод объединяет <ph id="ph1">`str0`</ph>, <ph id="ph2">`str1`</ph>, <ph id="ph3">`str2`</ph>, и <ph id="ph4">`str3`</ph>; разделители не добавляются.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>You can also use your language's string concatenation operator, such as <ph id="ph1">`+`</ph> in C#, or <ph id="ph2">`&amp;`</ph> and <ph id="ph3">`+`</ph> in Visual Basic)</source>
          <target state="translated">Можно также использовать оператор объединения строк языка, такие как <ph id="ph1">`+`</ph> в C#, или <ph id="ph2">`&amp;`</ph> и <ph id="ph3">`+`</ph> в Visual Basic)</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>, to concatenate strings.</source>
          <target state="translated">, для объединения строк.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null object in the array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> Строки используется вместо любого пустого объекта в массиве.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>The following example defines an array of four-letter words and stores their individual letters to a string array in order to scramble them.</source>
          <target state="translated">В следующем примере определяется массив из четырех – буквы слов и сохраняет отдельные буквы в массив строк для их шифрования.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat(System.String,System.String,System.String,System.String)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29&gt;</ph> method to reassemble the scrambled words.</source>
          <target state="translated">Затем он вызывает <ph id="ph1">&lt;xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29&gt;</ph> метод, чтобы повторно собрать кодированное слова.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The type of the members of <bpt id="p1">&lt;c&gt;</bpt>values<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Тип элементов <bpt id="p1">&lt;c&gt;</bpt>значения<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>A collection object that implements the <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> interface.</source>
          <target state="translated">Объект коллекции, реализующий интерфейс <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>Concatenates the members of an <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> implementation.</source>
          <target state="translated">Сцепляет элементы реализации <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The concatenated members in <ph id="ph1">&lt;paramref name="values" /&gt;</ph>.</source>
          <target state="translated">Сцепленные элементы в параметре <ph id="ph1">&lt;paramref name="values" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The method concatenates each object in <ph id="ph1">`values`</ph>; it does not add any delimiters.</source>
          <target state="translated">Метод сцепляет каждый объект в <ph id="ph1">`values`</ph>; разделители не добавляются.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>An <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> string is used in place of any null argument.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> Строки используется вместо любого пустого аргумента.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source><ph id="ph1">&lt;xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> is a convenience method that lets you concatenate each element in an <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection without first converting the elements to strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> удобный метод, который позволяет сцеплять все элементы в <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> коллекции без предварительного преобразования элементов строк.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>It is particularly useful with Language-Integrated Query (LINQ) query expressions, as the example illustrates.</source>
          <target state="translated">Это особенно полезно в выражениях запроса, встроенных в язык запросы (LINQ), как показано в примере.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The string representation of each object in the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection is derived by calling that object's <ph id="ph2">`ToString`</ph> method.</source>
          <target state="translated">Строковое представление каждого объекта в <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> сбора создается путем вызова этого объекта <ph id="ph2">`ToString`</ph> метод.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The following example defines a very simple <ph id="ph1">`Animal`</ph> class that contains the name of an animal and the order to which it belongs.</source>
          <target state="translated">В следующем примере определяется очень простой <ph id="ph1">`Animal`</ph> класс, содержащий имя животного и заказ, к которой он принадлежит.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>It then defines a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object to contain a number of <ph id="ph2">`Animal`</ph> objects.</source>
          <target state="translated">Затем он определяет <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> объект, содержащий ряд <ph id="ph2">`Animal`</ph> объектов.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> extension method is called to extract the <ph id="ph2">`Animal`</ph> objects whose <ph id="ph3">`Order`</ph> property equals "Rodent".</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> Метод расширения вызывается для извлечения <ph id="ph2">`Animal`</ph> объектов которого <ph id="ph3">`Order`</ph> равно «Грызун».</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source>The result is passed to the <ph id="ph1">&lt;xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> method and displayed to the console.</source>
          <target state="translated">Результат передается <ph id="ph1">&lt;xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> метода и выводится на консоль.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" uid="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="values" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" uid="M:System.String.Contains(System.String)">
          <source>The string to seek.</source>
          <target state="translated">Строка для поиска.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" uid="M:System.String.Contains(System.String)">
          <source>Returns a value indicating whether a specified substring occurs within this string.</source>
          <target state="translated">Возвращает значение, указывающее, встречается ли указанная подстрока внутри этой строки.</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" uid="M:System.String.Contains(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter occurs within this string, or if <ph id="ph3">&lt;paramref name="value" /&gt;</ph> is the empty string (""); otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если параметр <ph id="ph2">&lt;paramref name="value" /&gt;</ph> встречается в строке или <ph id="ph3">&lt;paramref name="value" /&gt;</ph> является пустой строкой (""); в противном случае — <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated">Этот метод выполняет порядковое сравнение (с учетом регистра и без учета языка и региональных параметров).</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>The search begins at the first character position of this string and continues through the last character position.</source>
          <target state="translated">Поиск начинается с позиции первого символа этой строки и продолжается до последней позиции знака.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>To determine whether a string contains a specified substring by using something other than ordinal comparison (such as culture-sensitive comparison, or ordinal case-insensitive comparison), you can create a custom method.</source>
          <target state="translated">Чтобы определить, является ли строка содержит указанной подстроки, используя нечто, отличное от порядкового сравнения (например, сравнение с учетом языка и региональных параметров или сравнение без учета регистра), можно создать пользовательский метод.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>The following example illustrates one such approach.</source>
          <target state="translated">В следующем примере демонстрируется один подход.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>It defines a <ph id="ph1">&lt;xref:System.String&gt;</ph> extension method  that includes a <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> parameter and indicates whether a string contains a substring when using the specified form of string comparison.</source>
          <target state="translated">Он определяет <ph id="ph1">&lt;xref:System.String&gt;</ph> метод расширения, который включает в себя <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> параметр и указывает, содержит ли строка подстроки, при использовании заданной форме сравнения строк.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>The following example then calls the <ph id="ph1">`Contains`</ph> extension method to determine whether a substring is found in a string when using ordinal comparison and case-insensitive ordinal comparison.</source>
          <target state="translated">Следующий пример вызывает <ph id="ph1">`Contains`</ph> метод расширения, позволяющий определить, является ли подстроки в строку при использовании порядковое сравнение и порядковое сравнение без учета регистра.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>If you are interested in the position of the substring <ph id="ph1">`value`</ph> in the current instance, you can call the <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> method to get the starting position of its first occurrence, or you can call the <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method to get the starting position of its last occurrence.</source>
          <target state="translated">Если вы заинтересованы в позиция подстроки <ph id="ph1">`value`</ph> в текущем экземпляре, можно вызвать <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> можно вызвать метод, чтобы получить начальную позицию первого найденного совпадения, или <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> метод для получения начального положения его последнее вхождение.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>The example includes a call to the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> method if a substring is found in a string instance.</source>
          <target state="translated">Пример включает вызов <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> метод найденные подстроки в экземпляр строки.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>The following example determines whether the string "fox" is a substring of a familiar quotation.</source>
          <target state="translated">В следующем примере определяется, является ли строка «лиса» подстроку известной цитаты.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Contains(System.String)">
          <source>If "fox" is found in the string, it also displays its starting position.</source>
          <target state="translated">Если «лиса» находится в строке, он также отображает его начальной позиции.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" uid="M:System.String.Contains(System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" uid="M:System.String.Copy(System.String)">
          <source>The string to copy.</source>
          <target state="translated">Строка для копирования.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" uid="M:System.String.Copy(System.String)">
          <source>Creates a new instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> with the same value as a specified <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Создает экземпляр <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, имеющий то же значение, что и указанный экземпляр <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="M:System.String.Copy(System.String)">
          <source>A new string with the same value as <ph id="ph1">&lt;paramref name="str" /&gt;</ph>.</source>
          <target state="translated">Новая строка с тем же значением, что и <ph id="ph1">&lt;paramref name="str" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.String&gt;</ph> object that has the same value as the original string but represents a different object reference.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> Возвращает метод <ph id="ph2">&lt;xref:System.String&gt;</ph> объекта, который совпадает со значением исходной строки, но представляет ссылку на другой объект.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>It differs from an assignment operation, which assigns an existing string reference to an additional object variable.</source>
          <target state="translated">Он отличается от операции присваивания, который назначает ссылку строки в переменную дополнительных объектов.</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>The example illustrates the difference.</source>
          <target state="translated">В примере демонстрируется различие.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>The following example creates two string objects with different values.</source>
          <target state="translated">В следующем примере создается два строковых объекта с разными значениями.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>When it calls the <ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> method to assign the first value to the second string, the output indicates that the strings represent different object references although their values are now equal.</source>
          <target state="translated">При вызове <ph id="ph1">&lt;xref:System.String.Copy%2A&gt;</ph> метод назначения первое значение вторая строка выходных данных указывает, что строки представляют ссылки на различные объекты, несмотря на то, что теперь равны значения их.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Copy(System.String)">
          <source>On the other hand, when the first string is assigned to the second string, the two strings have identical values because they represent the same object reference.</source>
          <target state="translated">С другой стороны Если первая строка будет назначен второй строки, две строки имеют одинаковые значения, так как они представляют одной ссылки на объект.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" uid="M:System.String.Copy(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="str" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>The index of the first character in this instance to copy.</source>
          <target state="translated">Индекс первого символа в этом экземпляре, который необходимо скопировать.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>An array of Unicode characters to which characters in this instance are copied.</source>
          <target state="translated">Массив символов Юникода, в который копируются символы в этом экземпляре.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>The index in <bpt id="p1">&lt;c&gt;</bpt>destination<ept id="p1">&lt;/c&gt;</ept> at which the copy operation begins.</source>
          <target state="translated">Индекс в массиве <bpt id="p1">&lt;c&gt;</bpt>destination<ept id="p1">&lt;/c&gt;</ept>, с которого начинается копирование.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>The number of characters in this instance to copy to <bpt id="p1">&lt;c&gt;</bpt>destination<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Число символов в этом экземпляре, копируемых в <bpt id="p1">&lt;c&gt;</bpt>destination<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>Copies a specified number of characters from a specified position in this instance to a specified position in an array of Unicode characters.</source>
          <target state="translated">Копирует заданное число знаков, начиная с указанной позиции в этом экземпляре до указанной позиции в массиве знаков Юникода.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>This method copies <ph id="ph1">`count`</ph> characters from the <ph id="ph2">`sourceIndex`</ph> position of this instance to the <ph id="ph3">`destinationIndex`</ph> position of <ph id="ph4">`destination`</ph> character array.</source>
          <target state="translated">Этот метод копирует <ph id="ph1">`count`</ph> символы <ph id="ph2">`sourceIndex`</ph> позицию данного экземпляра, <ph id="ph3">`destinationIndex`</ph> положение <ph id="ph4">`destination`</ph> массив символов.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>This method does not resize the <ph id="ph1">`destination`</ph> character array; it must have a sufficient number of elements to accommodate the copied characters or the method throws an <ph id="ph2">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</source>
          <target state="translated">Этот метод не происходит изменение размеров <ph id="ph1">`destination`</ph> массив символов; он должен иметь достаточное количество элементов для хранения скопированных символов или вызывает метод <ph id="ph2">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">`sourceIndex`</ph> and <ph id="ph2">`destinationIndex`</ph> are zero-based.</source>
          <target state="translated"><ph id="ph1">`sourceIndex`</ph> и <ph id="ph2">`destinationIndex`</ph> отсчитываются от нуля.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.CopyTo%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">&lt;xref:System.String.CopyTo%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destination" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="destination" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="count" /&gt;</ph> is negative</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> или <ph id="ph3">&lt;paramref name="count" /&gt;</ph> является отрицательным значением.</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> does not identify a position in the current instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="sourceIndex" /&gt;</ph> не определяет позицию в текущем экземпляре.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> does not identify a valid index in the <ph id="ph2">&lt;paramref name="destination" /&gt;</ph> array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="destinationIndex" /&gt;</ph> не определяет допустимый индекс в массиве <ph id="ph2">&lt;paramref name="destination" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is greater than the length of the substring from <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> to the end of this instance</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> больше, чем длина подстроки от <ph id="ph2">&lt;paramref name="sourceIndex" /&gt;</ph> до конца данного экземпляра.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" uid="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is greater than the length of the subarray from <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> to the end of the <ph id="ph3">&lt;paramref name="destination" /&gt;</ph> array.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> больше, чем длина подмассива от <ph id="ph2">&lt;paramref name="destinationIndex" /&gt;</ph> до конца массива <ph id="ph3">&lt;paramref name="destination" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" uid="F:System.String.Empty">
          <source>Represents the empty string.</source>
          <target state="translated">Представляет пустую строку.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" uid="F:System.String.Empty">
          <source>This field is read-only.</source>
          <target state="translated">Это поле доступно только для чтения.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.String.Empty">
          <source>The value of this field is the zero-length string, "".</source>
          <target state="translated">Значением этого поля является строкой нулевой длины, «».</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.String.Empty">
          <source>In application code, this field is most commonly used in assignments to initialize a string variable to an empty string.</source>
          <target state="translated">В коде приложения это поле чаще всего используется в назначениях для инициализации переменной строки на пустую строку.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.String.Empty">
          <source>To test whether the value of a string is either <ph id="ph1">`null`</ph> or <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, use the <ph id="ph3">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> method.</source>
          <target state="translated">Чтобы проверить, является ли значение строки <ph id="ph1">`null`</ph> или <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, используйте <ph id="ph3">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Determines whether the end of this string instance matches a specified string.</source>
          <target state="translated">Определяет, совпадает ли конец данного экземпляра строки с указанной строкой.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String)">
          <source>The string to compare to the substring at the end of this instance.</source>
          <target state="translated">Строка, которую необходимо сравнить с подстрокой, расположенной в конце этого экземпляра.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String)">
          <source>Determines whether the end of this string instance matches the specified string.</source>
          <target state="translated">Определяет, совпадает ли конец данного экземпляра строки с указанной строкой.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> matches the end of this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если конец этого экземпляра совпадает с <ph id="ph2">&lt;paramref name="value" /&gt;</ph>; в противном случае — <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>This method compares <ph id="ph1">`value`</ph> to the substring at the end of this instance that is the same length as <ph id="ph2">`value`</ph>, and returns an indication whether they are equal.</source>
          <target state="translated">Этот метод сравнивает <ph id="ph1">`value`</ph> с подстрокой, расположенной в конце данного экземпляра, имеют одинаковую длину поля как <ph id="ph2">`value`</ph>и возвращает значение, указывающее, равны ли они.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be a reference to this same instance or match the end of this instance.</source>
          <target state="translated">Как одинаковые, <ph id="ph1">`value`</ph> должен быть ссылкой на тот же экземпляр или соответствует концу данного экземпляра.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</source>
          <target state="translated">Этот метод выполняет сравнение по словам (с учетом регистра и культуры) с использованием текущего языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>The following example indicates whether each string in an array ends with a period (".").</source>
          <target state="translated">Следующий пример показывает, является ли каждая строка в массиве заканчивается точкой («.»).</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>The following example defines a <ph id="ph1">`StripEndTags`</ph> method that uses the <ph id="ph2">&lt;xref:System.String.EndsWith%28System.String%29&gt;</ph> method to remove HTML end tags from the end of a line.</source>
          <target state="translated">В следующем примере определяется <ph id="ph1">`StripEndTags`</ph> метод, который использует <ph id="ph2">&lt;xref:System.String.EndsWith%28System.String%29&gt;</ph> метод для удаления закрывающие теги HTML в конце строки.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>Note that the  <ph id="ph1">`StripEndTags`</ph> method is called recursively to ensure that multiple HTML end tags at the end of the line are removed.</source>
          <target state="translated">Обратите внимание, что <ph id="ph1">`StripEndTags`</ph> метод вызывается рекурсивно, чтобы удалить несколько закрывающие теги HTML в конце строки.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Как описано в статье <bpt id="p1">[</bpt>советы и рекомендации по использованию строк<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, рекомендуется избегать вызова методов сравнения строк, которые заменяют значения по умолчанию и вместо этого вызывают методы, которые требуют явного указания параметров.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String)">
          <source>To determine whether a string ends with a particular substring by using the string comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Чтобы определить, заканчивается ли строка определенной подстрокой, используя правила сравнения строк для текущего языка и региональных параметров, вызовите <ph id="ph1">&lt;see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /&gt;</ph> перегрузка метода со значением <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> для его <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> параметра.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>The string to compare to the substring at the end of this instance.</source>
          <target state="translated">Строка, которую необходимо сравнить с подстрокой, расположенной в конце этого экземпляра.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>One of the enumeration values that determines how this string and <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> are compared.</source>
          <target state="translated">Одно из значений перечисления, определяющее способ сравнения этой строки со значением <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>Determines whether the end of this string instance matches the specified string when compared using the specified comparison option.</source>
          <target state="translated">Определяет, совпадает ли конец экземпляра строки с заданной строкой при сравнении с учетом заданного параметра сравнения.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter matches the end of this string; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если параметр <ph id="ph2">&lt;paramref name="value" /&gt;</ph> соответствует концу данной строки; в противном случае — <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>The <ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph> method compares the <ph id="ph2">`value`</ph> parameter to the substring at the end of this string and returns a value that indicates whether they are equal.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph> Метод сравнивает <ph id="ph2">`value`</ph> параметр с подстрокой, расположенной в конце этой строки и возвращает значение, указывающее, равны ли они.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be a reference to this same string, must be the empty string (""), or must match the end of this string.</source>
          <target state="translated">Как одинаковые, <ph id="ph1">`value`</ph> должен быть ссылкой на ту же строку, должен быть пустой строкой ("»), или необходимо соответствует концу данной строки.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>The type of comparison performed by the <ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph> method depends on the value of the <ph id="ph2">`comparisonType`</ph> parameter.</source>
          <target state="translated">Тип сравнения, выполняемые <ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph> метод зависит от значения <ph id="ph2">`comparisonType`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>The following example determines whether a string ends with a particular substring.</source>
          <target state="translated">В следующем примере определяется, заканчивается ли строка определенной подстрокой.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source>The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</source>
          <target state="translated">Результаты зависят от выбора языка и региональных параметров, учитывается ли регистр и выполняется ли порядковое сравнение.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> не является значением <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The string to compare to the substring at the end of this instance.</source>
          <target state="translated">Строка, которую необходимо сравнить с подстрокой, расположенной в конце этого экземпляра.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, чтобы не учитывать регистр при сравнении; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Cultural information that determines how this instance and <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> are compared.</source>
          <target state="translated">Связанные с языком и региональными параметрами сведения, определяющие, как выполняется сравнение этого экземпляра и <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the current culture is used.</source>
          <target state="translated">Если значением параметра <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> является <ph id="ph1">&lt;see langword="null" /&gt;</ph>, используются текущие язык и региональные параметры.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Determines whether the end of this string instance matches the specified string when compared using the specified culture.</source>
          <target state="translated">Определяет, совпадает ли конец данного экземпляра строки с заданной строкой при сравнении с учетом заданного языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter matches the end of this string; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если параметр <ph id="ph2">&lt;paramref name="value" /&gt;</ph> соответствует концу данной строки; в противном случае — <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>This method compares the <ph id="ph1">`value`</ph> parameter to the substring at the end of this string that is the same length as <ph id="ph2">`value`</ph>, and returns a value that indicates whether they are equal.</source>
          <target state="translated">Этот метод сравнивает <ph id="ph1">`value`</ph> параметр с подстрокой, расположенной в конце данной строки, имеют одинаковую длину поля как <ph id="ph2">`value`</ph>и возвращает значение, указывающее, равны ли они.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be a reference to this same instance or match the end of this string.</source>
          <target state="translated">Как одинаковые, <ph id="ph1">`value`</ph> должен быть ссылкой на тот же экземпляр или соответствует концу данной строки.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>This method performs a word (culture-sensitive) comparison using the specified casing and culture.</source>
          <target state="translated">Этот метод выполняет сравнение по словам (языка и региональных параметров с учетом) с помощью указанного регистра и языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The following example determines whether a string occurs at the end of another string.</source>
          <target state="translated">В следующем примере определяется, содержится ли строка в конце другой строки.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph> method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.EndsWith%2A&gt;</ph> Метод вызывается несколько раз, используя учет регистра, учет регистра и различные языки и региональные параметры, влияющие на результаты поиска.</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" uid="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Determines whether two <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects have the same value.</source>
          <target state="translated">Определяет, равны ли значения двух объектов <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.Object)">
          <source>The string to compare to this instance.</source>
          <target state="translated">Строка для сравнения с данным экземпляром.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.Object)">
          <source>Determines whether this instance and a specified object, which must also be a <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object, have the same value.</source>
          <target state="translated">Определяет, равны ли значения этого экземпляра и указанного объекта, который также должен быть объектом <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> is a <ph id="ph3">&lt;see cref="T:System.String" /&gt;</ph> and its value is the same as this instance; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> имеет тип <ph id="ph3">&lt;see cref="T:System.String" /&gt;</ph> и его значение совпадает со значением данного экземпляра; в противном случае — <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.Object)">
          <source>If <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, the method returns <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Если значением параметра <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> является <ph id="ph2">&lt;see langword="null" /&gt;</ph>, метод возвращает <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.Object)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated">Этот метод выполняет порядковое сравнение (с учетом регистра и без учета языка и региональных параметров).</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.Object)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String)">
          <source>The string to compare to this instance.</source>
          <target state="translated">Строка для сравнения с данным экземпляром.</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String)">
          <source>Determines whether this instance and another specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object have the same value.</source>
          <target state="translated">Определяет, равны ли значения этого экземпляра и указанного объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter is the same as the value of this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значение параметра <ph id="ph2">&lt;paramref name="value" /&gt;</ph> совпадает со значением данного экземпляра; в противном случае — <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, the method returns <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Если значением параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph> является <ph id="ph2">&lt;see langword="null" /&gt;</ph>, метод возвращает <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated">Этот метод выполняет порядковое сравнение (с учетом регистра и без учета языка и региональных параметров).</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.It compares the title-cased word "File" with an equivalent word, its lowercase equivalent, its uppercase equivalent, and a word that contains LATIN SMALL LETTER DOTLESS I (U+0131) instead of LATIN SMALL LETTER I (U+0069).</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> метод. Он сравнивает регистре заголовка слово «Файл» и эквивалентные word, его эквивалент в нижнем регистре, его эквивалент в верхнем регистре и слово, которое содержит ЛАТИНИЦА НЕБОЛЬШОЙ буквы без ТОЧКИ I (U + 0131) вместо ЛАТИНИЦА НЕБОЛЬШОЙ буквы I (U + 0069).</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String)">
          <source>Because the <ph id="ph1">&lt;xref:System.String.Equals%28System.String%29&gt;</ph> method performs an ordinal comparison, only the comparison with an identical word returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Поскольку <ph id="ph1">&lt;xref:System.String.Equals%28System.String%29&gt;</ph> метод выполняет порядковое сравнение, возвращает только сравнения с идентичными word <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String)">
          <source>The first string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Первая сравниваемая строка или значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String)">
          <source>The second string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Вторая сравниваемая строка или значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String)">
          <source>Determines whether two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects have the same value.</source>
          <target state="translated">Определяет, совпадают ли значения двух указанных объектов <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of <ph id="ph2">&lt;paramref name="a" /&gt;</ph> is the same as the value of <ph id="ph3">&lt;paramref name="b" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значение параметра <ph id="ph2">&lt;paramref name="a" /&gt;</ph> совпадает со значением <ph id="ph3">&lt;paramref name="b" /&gt;</ph>; в противном случае — значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String)">
          <source>If both <ph id="ph1">&lt;paramref name="a" /&gt;</ph> and <ph id="ph2">&lt;paramref name="b" /&gt;</ph> are <ph id="ph3">&lt;see langword="null" /&gt;</ph>, the method returns <ph id="ph4">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Если оба параметра <ph id="ph1">&lt;paramref name="a" /&gt;</ph> и <ph id="ph2">&lt;paramref name="b" /&gt;</ph> имеют значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>, метод возвращает значение <ph id="ph4">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated">Этот метод выполняет порядковое сравнение (с учетом регистра и без учета языка и региональных параметров).</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">&lt;xref:System.String.Equals%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>The string to compare to this instance.</source>
          <target state="translated">Строка для сравнения с данным экземпляром.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>One of the enumeration values that specifies how the strings will be compared.</source>
          <target state="translated">Одно из значений перечисления, задающее способ сравнения строк.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>Determines whether this string and a specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object have the same value.</source>
          <target state="translated">Определяет, равны ли значения этой строки и указанного объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>A parameter specifies the culture, case, and sort rules used in the comparison.</source>
          <target state="translated">Параметр определяет язык и региональные параметры, учет регистра и правила сортировки, используемые при сравнении.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter is the same as this string; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значение параметра <ph id="ph2">&lt;paramref name="value" /&gt;</ph> совпадает со значением данной строки; в противном случае — <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</source>
          <target state="translated"><ph id="ph1">`comparisonType`</ph> Указывает сравнения необходимость использования текущего или инвариантного языка и региональных параметров, учитывают или не учитывают регистр двух сравниваемых строк или используется Microsoft word или правил.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>The following example creates a string array that consists of an uppercase "I", a lowercase "i", and a dotless "ı".</source>
          <target state="translated">В следующем примере создается массив строк, состоящего из прописных «I», строчная буква «i» и без точки «ı».</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph> method to compare them by using each possible <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration value.</source>
          <target state="translated">Затем он вызывает <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.StringComparison%29&gt;</ph> метод, чтобы сравнить их с помощью каждое возможное <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> значение перечисления.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>The following example compares four sets of words by using each member of the <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">В следующем примере сравниваются четыре набора слов с помощью каждого члена <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> перечисления.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures.</source>
          <target state="translated">Сравнение использовать соглашения английский (США) и Саамский (верхняя Швеция) языков и региональных параметров.</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source>Note that the strings "encyclopædia" and "encyclopedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.</source>
          <target state="translated">Обратите внимание, что строки «encyclopædia» и «энциклопедии» считаются эквивалента в en-US, но не в Саамский (Северный Швеция) языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> не является значением <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>The first string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Первая сравниваемая строка или значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>The second string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Вторая сравниваемая строка или значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the comparison.</source>
          <target state="translated">Одно из значений перечисления, определяющее правила сравнения.</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>Determines whether two specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects have the same value.</source>
          <target state="translated">Определяет, совпадают ли значения двух указанных объектов <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>A parameter specifies the culture, case, and sort rules used in the comparison.</source>
          <target state="translated">Параметр определяет язык и региональные параметры, учет регистра и правила сортировки, используемые при сравнении.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of the <ph id="ph2">&lt;paramref name="a" /&gt;</ph> parameter is equal to the value of the <ph id="ph3">&lt;paramref name="b" /&gt;</ph> parameter; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значения параметров <ph id="ph2">&lt;paramref name="a" /&gt;</ph> и <ph id="ph3">&lt;paramref name="b" /&gt;</ph> совпадают; в противном случае — <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</source>
          <target state="translated"><ph id="ph1">`comparisonType`</ph> Указывает сравнения необходимость использования текущего или инвариантного языка и региональных параметров, учитывают или не учитывают регистр двух сравниваемых строк или используется Microsoft word или правил.</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>The following example compares four sets of words by using each member of the <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">В следующем примере сравниваются четыре набора слов с помощью каждого члена <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> перечисления.</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures.</source>
          <target state="translated">Сравнение использовать соглашения английский (США) и Саамский (верхняя Швеция) языков и региональных параметров.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source>Note that the strings "encyclopædia" and "encyclopedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.</source>
          <target state="translated">Обратите внимание, что строки «encyclopædia» и «энциклопедии» считаются эквивалента в en-US, но не в Саамский (Северный Швеция) языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" uid="M:System.String.Equals(System.String,System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> не является значением <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Converts the value of objects to strings based on the formats specified and inserts them into another string.</source>
          <target state="translated">Преобразует значения объектов в строки на основе указанных форматов и вставляет их в другую строку.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>If you are new to the <ph id="ph1">`String.Format`</ph> method, see the <bpt id="p1">[</bpt>Get started with the String.Format method<ept id="p1">](#Starting)</ept> section for a quick overview.</source>
          <target state="translated">Если вы не знакомы с методом <ph id="ph1">`String.Format`</ph>, см. краткие сведения в разделе <bpt id="p1">[</bpt>Начало работы с методом String.Format<ept id="p1">](#Starting)</ept>.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>See the <bpt id="p1">[</bpt>Remarks<ept id="p1">](#remarks-top)</ept> section for general documentation for the <ph id="ph1">`String.Format`</ph> method.</source>
          <target state="translated">В разделе <bpt id="p1">[</bpt>Примечания<ept id="p1">](#remarks-top)</ept> приводится общая документация для метода <ph id="ph1">`String.Format`</ph>.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In this section:</source>
          <target state="translated">Содержание</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Get started with the String.Format method<ept id="p1">](#Starting)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Начало работы с методом String.Format<ept id="p1">](#Starting)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Which method do I call?<ept id="p1">](#FTaskList)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Какой метод нужно вызывать?<ept id="p1">](#FTaskList)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Format method in brief<ept id="p1">](#Format_Brief)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Метод Format краткое описание<ept id="p1">](#Format_Brief)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The Format item<ept id="p1">](#FormatItem)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Элемент формата<ept id="p1">](#FormatItem)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>How arguments are formatted<ept id="p1">](#HowFormatted)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Форматирование аргументов<ept id="p1">](#HowFormatted)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Format items that have the same index<ept id="p1">](#SameIndex)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Формат элементы, имеющие тот же индекс<ept id="p1">](#SameIndex)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Formatting and culture<ept id="p1">](#Format_Culture)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Форматирование и языка и региональных параметров<ept id="p1">](#Format_Culture)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Custom formatting operations<ept id="p1">](#Format_Custom)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Настраиваемое форматирование операций<ept id="p1">](#Format_Custom)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>String.Format Q &amp; A<ept id="p1">](#QA)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>String.Format вопросы и ответы<ept id="p1">](#QA)</ept></target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Get started with the String.Format method</source>
          <target state="translated">Начало работы с методом String.Format</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Use <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> if you need to insert the value of an object, variable, or expression into another string.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> , если необходимо вставить значение объекта, переменной или выражения в другую строку.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, you can insert the value of a <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> value into a string to display it to the user as a single string:</source>
          <target state="translated">Например, можно вставить значение <ph id="ph1">&lt;xref:System.Decimal&gt;</ph> значение в строку, чтобы отобразить ее пользователю как одна строка:</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>And you can control that value's formatting:</source>
          <target state="translated">И управления форматирование этого значения:</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Besides formatting, you can also control alignment and spacing.</source>
          <target state="translated">Помимо форматирование, можно также управлять интервал и выравнивание.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Inserting a string</source>
          <target state="translated">Вставка строки</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> starts with a format string, followed by one or more objects or expressions that will be converted to strings and inserted at a specified place in the format string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> начинается со строки формата, за которым следует один или несколько объектов или выражений, которые будут преобразованы в строки и вставлен в указанной позиции в строке формата.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example:</source>
          <target state="translated">Пример:</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">`{0}`</ph> in the format string is a format item.</source>
          <target state="translated"><ph id="ph1">`{0}`</ph> Формат строки — это элемент формата.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">`0`</ph> is the index of the object whose string value will be inserted at that position.</source>
          <target state="translated"><ph id="ph1">`0`</ph> — Это индекс объекта, значение которого строка вставляется в этой позиции.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(Indexes start at 0.) If the object to be inserted is not a string, its <ph id="ph1">`ToString`</ph> method is called to convert it to one before inserting it in the result string.</source>
          <target state="translated">(Индексы начинаются с 0). Если вставляемый объект не является строкой, его <ph id="ph1">`ToString`</ph> метод вызывается для преобразования его в один перед вставкой его в результирующей строке.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here's another example that uses two format items and two objects in the object list:</source>
          <target state="translated">Вот другой пример, использующий два элемента форматирования и два объекта в списке объектов.</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can have as many format items and as many objects in the object list as you want, as long as the index of every format item has a matching object in the object list.</source>
          <target state="translated">Может иметь любое количество элементов форматирования и любое количество объектов в списке объектов, как вы хотите, при условии, что индекс каждого элемента форматирования имеет соответствующий объект в списке объектов.</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You also don't have to worry about which overload you call; the compiler will select the appropriate one for you.</source>
          <target state="translated">Также не нужно беспокоиться о перегрузки метода. компилятор будет выберите наиболее подходящий для вас.</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Controlling formatting</source>
          <target state="translated">Управление форматированием</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can follow the index in a format item with a format string to control how an object is formatted.</source>
          <target state="translated">Вы можете использовать индекс в элементе форматирования, использующая строку формата для управления форматированием объекта.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, <ph id="ph1">`{0:d}`</ph> applies the "d" format string to the first object in the object list.</source>
          <target state="translated">Например <ph id="ph1">`{0:d}`</ph> применяется строка формата «d» для первого объекта в списке объектов.</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here is an example with a single object and two format items:</source>
          <target state="translated">Ниже приведен пример с одним объектом и два формата элементов:</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A number of types support format strings, including all numeric types (both                                          <bpt id="p1">[</bpt>standard<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and                                          <bpt id="p2">[</bpt>custom<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept> format strings), all dates and times (both                                          <bpt id="p3">[</bpt>standard<ept id="p3">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> and                                          <bpt id="p4">[</bpt>custom<ept id="p4">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept> format strings) and time intervals (both                                          <bpt id="p5">[</bpt>standard<ept id="p5">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept> and                                          <bpt id="p6">[</bpt>custom<ept id="p6">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept> format strings), all enumeration types                                          <bpt id="p7">[</bpt>enumeration types<ept id="p7">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>, and                                          <bpt id="p8">[</bpt>GUIDs<ept id="p8">](https://msdn.microsoft.com/library/97af8hh4.aspx)</ept>.</source>
          <target state="translated">Количество типов поддержки строк формата, включая все числовые типы (оба <bpt id="p1">[</bpt>Стандартная<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> и <bpt id="p2">[</bpt>пользовательские<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept> строки формата), все даты и во время начала (ленты h <bpt id="p3">[</bpt>Стандартная<ept id="p3">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> и <bpt id="p4">[</bpt>пользовательские<ept id="p4">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept> строки формата) и интервалы времени (оба <bpt id="p5">[</bpt>стандартных d<ept id="p5">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept> и <bpt id="p6">[</bpt>пользовательские<ept id="p6">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept> форматирования строк), все типы перечисления <bpt id="p7">[</bpt>типы перечисления<ept id="p7">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>, и                                          <bpt id="p8">[</bpt>GUID<ept id="p8">](https://msdn.microsoft.com/library/97af8hh4.aspx)</ept>.</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also add support for format strings to your own types.</source>
          <target state="translated">Также можно добавить поддержку строки формата для собственных типов.</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Controlling spacing</source>
          <target state="translated">Управление интервалы</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can define the width of the string that is inserted into the result string by using syntax such as <ph id="ph1">`{0,12}`</ph>, which inserts a 12-character string.</source>
          <target state="translated">Можно задать ширину строки, вставляемой в результирующую строку с помощью синтаксиса, такие как <ph id="ph1">`{0,12}`</ph>, который вставляет строку 12 символов.</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In this case, the string representation of the first object is right-aligned in the 12-character field.</source>
          <target state="translated">В этом случае строковое представление первого объекта по правому краю поля 12 символов.</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(If the string representation of the first object is more than 12 characters in length, though, the preferred field width is ignored, and the entire string is inserted into the result string.)</source>
          <target state="translated">(Если строковое представление первого объекта более 12 символов, желательной ширины поля учитывается, и вся строка вставляется в результирующую строку.)</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example defines a 6-character field to hold the string "Year" and some year strings, as well as an 15-character field to hold the string "Population" and some population data.</source>
          <target state="translated">В следующем примере определяется 6-символьного поля для хранения строки «Год» и некоторые строки года, а также поля из 15 символов для хранения строки «Заполнение» и некоторые данные.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Note that the characters are right-aligned in the field.</source>
          <target state="translated">Обратите внимание, что символы находятся по правому краю в поле.</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Controlling alignment</source>
          <target state="translated">Управление выравнивания</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By default, strings are right-aligned within their field if you specify a field width.</source>
          <target state="translated">По умолчанию строки по правому краю в пределах их поле при указании ширины поля.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To left-align strings in a field, you preface the field width with a negative sign, such as <ph id="ph1">`{0,-12}`</ph> to define a 12-character right-aligned field.</source>
          <target state="translated">Чтобы по левому краю строки в поле, в начале ширины поля со знаком минус, такие как <ph id="ph1">`{0,-12}`</ph> определение по правому краю поля 12 символов.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example is similar to the previous one, except that it left-aligns both labels and data.</source>
          <target state="translated">Следующий пример похож на предыдущий, за исключением того, что он выравниваются по левому краю метки и данных.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> makes use of the composite formatting feature.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> используется составное форматирование.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information, see <bpt id="p1">[</bpt>Composite Formatting<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Составное форматирование<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Which method do I call?</source>
          <target state="translated">Какой метод нужно вызывать?</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To</source>
          <target state="translated">Кому</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Call</source>
          <target state="translated">Call</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Format one or more objects by using the conventions of the current culture.</source>
          <target state="translated">Формате один или несколько объектов с использованием правил текущего языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Except for the overloads that include a <ph id="ph1">`provider`</ph> parameter, the remaining <ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph> overloads include a <ph id="ph3">&lt;xref:System.String&gt;</ph> parameter followed by one or more object parameters.</source>
          <target state="translated">За исключением перегрузки, включающие <ph id="ph1">`provider`</ph> параметра, оставшиеся <ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph> перезагрузки включают <ph id="ph3">&lt;xref:System.String&gt;</ph> параметр следуют один или несколько параметров объекта.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because of this, you don't have to determine which <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> overload you intend to call.</source>
          <target state="translated">По этой причине не нужно определить, какие <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> требуется вызвать перегрузку.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Your language compiler selects the appropriate overload from among the overloads that don't have a <ph id="ph1">`provider`</ph> parameter, based on your argument list.</source>
          <target state="translated">Языковой компилятор выбирает соответствующую перегрузку, один из перегруженных версий, которые не являются <ph id="ph1">`provider`</ph> параметру, основанному на ваш список аргументов.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, if your argument list has five arguments, the compiler calls the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Например, если ваш список аргументов имеет пять аргументов, компилятор вызывает <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Format one or more objects by using the conventions of a specific culture.</source>
          <target state="translated">Формате один или несколько объектов с использованием соглашений для определенного языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> overload that begins with a <ph id="ph2">`provider`</ph> parameter is followed by a <ph id="ph3">&lt;xref:System.String&gt;</ph> parameter and one or more object parameters.</source>
          <target state="translated">Каждый <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> перегрузку, которая начинается с <ph id="ph2">`provider`</ph> следуют параметр <ph id="ph3">&lt;xref:System.String&gt;</ph> параметр и один или несколько объектов параметров.</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because of this, you don't have to determine which specific <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> overload you intend to call.</source>
          <target state="translated">По этой причине не нужно определить, какие конкретно <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> требуется вызвать перегрузку.</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Your language compiler selects the appropriate overload from among the overloads that have a <ph id="ph1">`provider`</ph> parameter, based on your argument list.</source>
          <target state="translated">Языковой компилятор выбирает соответствующую перегрузку из перегрузок, имеющих <ph id="ph1">`provider`</ph> параметру, основанному на ваш список аргументов.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, if your argument list has five arguments, the compiler calls the <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Например, если ваш список аргументов имеет пять аргументов, компилятор вызывает <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Perform a custom formatting operation either with an <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> implementation or an <ph id="ph2">&lt;xref:System.IFormattable&gt;</ph> implementation.</source>
          <target state="translated">Выполнять пользовательские операции форматирования с помощью <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> реализацию или <ph id="ph2">&lt;xref:System.IFormattable&gt;</ph> реализации.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Any of the four overloads with a <ph id="ph1">`provider`</ph> parameter.</source>
          <target state="translated">Все четыре перегруженных методов с <ph id="ph1">`provider`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The compiler selects the appropriate overload from among the overloads that have a <ph id="ph1">`provider`</ph> parameter, based on your argument list.</source>
          <target state="translated">Компилятор выбирает соответствующую перегрузку из перегрузок, имеющих <ph id="ph1">`provider`</ph> параметру, основанному на ваш список аргументов.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The Format method in brief</source>
          <target state="translated">Метод Format краткое описание</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each overload of the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to include zero-based indexed placeholders, called <bpt id="p2">*</bpt>format items<ept id="p2">*</ept>, in a composite format string.</source>
          <target state="translated">Каждой версии перегруженной <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> использует метод <bpt id="p1">[</bpt>составное форматирование<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> для включения отсчитываемый от нуля индексированные местозаполнители, <bpt id="p2">*</bpt>форматирования элементов<ept id="p2">*</ept>, в строке составного формата.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>At run time, each format item is replaced with the string representation of the corresponding argument in a parameter list.</source>
          <target state="translated">Во время выполнения каждый элемент формата заменяется строковым представлением соответствующего аргумента в списке параметров.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the value of the argument is <ph id="ph1">`null`</ph>, the format item is replaced with <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Если значение аргумента равно <ph id="ph1">`null`</ph>, элемент формата заменяется <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the following call to the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph> method includes a format string with three format items, <ph id="ph2">{0}</ph>, <ph id="ph3">{1}</ph>, and <ph id="ph4">{2}</ph>, and an argument list with three items.</source>
          <target state="translated">Например, в следующем вызове <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph> метод включает строку формата с тремя элементами форматирования и <ph id="ph2">{0}</ph>, <ph id="ph3">{1}</ph>, и <ph id="ph4">{2}</ph>и список аргументов с тремя элементами.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The format item</source>
          <target state="translated">Элемент формата</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A format item has this syntax:</source>
          <target state="translated">Элемент форматирования имеет следующий синтаксис:</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Brackets denote optional elements.</source>
          <target state="translated">Квадратные скобки обозначают необязательные элементы.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The opening and closing braces are required.</source>
          <target state="translated">Требуются открывающей и закрывающей фигурными скобками.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(To include a literal opening or closing brace in the format string, see the "Escaping Braces" section in the <bpt id="p1">[</bpt>Composite Formatting<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> article.)</source>
          <target state="translated">(Для включения открывающей или закрывающая фигурная скобка в строке формата, см. в разделе «Экранирования скобок» в <bpt id="p1">[</bpt>составное форматирование<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> статье.)</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, a format item to format a currency value might appear like this:</source>
          <target state="translated">Например элемент форматирования для форматирования значения валюты может отображаться следующим образом:</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A format item has the following elements:</source>
          <target state="translated">Элемент форматирования имеет следующие элементы:</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">*</bpt>index<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>Индекс<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The zero-based index of the argument whose string representation is to be included at this position in the string.</source>
          <target state="translated">Отсчитываемый от нуля индекс, строковое представление аргумента должно быть включено в этой позиции в строке.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If this argument is <ph id="ph1">`null`</ph>, an empty string will be included at this position in the string.</source>
          <target state="translated">Если этот аргумент является <ph id="ph1">`null`</ph>, пустая строка будут включены в этой позиции в строке.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">*</bpt>alignment<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>Выравнивание<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Optional.</source>
          <target state="translated">Необязательный.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A signed integer that indicates the total length of the field into which the argument is inserted and whether it is right-aligned (a positive integer) or left-aligned (a negative integer).</source>
          <target state="translated">Целое число со знаком, указывающее общая длина поля, в котором вставляется аргумента, и по правому краю (положительное целое число) или по левому краю (отрицательное целое число).</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you omit <bpt id="p1">*</bpt>alignment<ept id="p1">*</ept>, the string representation of the corresponding argument is inserted in a field with no leading or trailing spaces.</source>
          <target state="translated">Если не указан <bpt id="p1">*</bpt>выравнивание<ept id="p1">*</ept>, строковым представлением соответствующего аргумента вставляется в поле без начальных и конечных пробелов.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the value of <bpt id="p1">*</bpt>alignment<ept id="p1">*</ept> is less than the length of the argument to be inserted, <bpt id="p2">*</bpt>alignment<ept id="p2">*</ept> is ignored and the length of the string representation of the argument is used as the field width.</source>
          <target state="translated">Если значение <bpt id="p1">*</bpt>выравнивание<ept id="p1">*</ept> меньше, чем длина аргумента должны быть вставлены, <bpt id="p2">*</bpt>выравнивание<ept id="p2">*</ept> игнорируется и длина строкового представления аргумента используется в качестве ширины поля.</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">*</bpt>formatString<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>formatString<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Optional.</source>
          <target state="translated">Необязательный.</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A string that specifies the format of the corresponding argument's result string.</source>
          <target state="translated">Строка, задающая формат результирующей строки соответствующего аргумента.</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you omit <bpt id="p1">*</bpt>formatString<ept id="p1">*</ept>, the corresponding argument's parameterless <ph id="ph1">`ToString`</ph> method is called to produce its string representation.</source>
          <target state="translated">Если не указан <bpt id="p1">*</bpt>formatString<ept id="p1">*</ept>, соответствующего аргумента без параметров <ph id="ph1">`ToString`</ph> метод вызывается для получения строкового представления.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you specify <bpt id="p1">*</bpt>formatString<ept id="p1">*</ept>, the argument referenced by the format item must implement the <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> interface.</source>
          <target state="translated">При указании <bpt id="p1">*</bpt>formatString<ept id="p1">*</ept>, аргумент, который ссылается элемент форматирования должен реализовывать <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> интерфейса.</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Types that support format strings include:</source>
          <target state="translated">Типы, которые поддерживают строки формата:</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All integral and floating-point types.</source>
          <target state="translated">Все типы целочисленные и с плавающей запятой.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(See <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.)</source>
          <target state="translated">(См. <bpt id="p1">[</bpt>строки стандартных числовых форматов<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> и <bpt id="p2">[</bpt>строки настраиваемых числовых форматов<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.DateTime&gt;</ph> and <ph id="ph2">&lt;xref:System.DateTimeOffset&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.DateTime&gt;</ph> и <ph id="ph2">&lt;xref:System.DateTimeOffset&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(See <bpt id="p1">[</bpt>Standard Date and Time Format Strings<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Date and Time Format Strings<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>.)</source>
          <target state="translated">(См. <bpt id="p1">[</bpt>стандартных форматов даты и времени строки<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> и <bpt id="p2">[</bpt>настраиваемых форматов даты и времени строки<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All enumeration types.</source>
          <target state="translated">Все типы перечисления.</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(See <bpt id="p1">[</bpt>Enumeration Format Strings<ept id="p1">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>.)</source>
          <target state="translated">(См. <bpt id="p1">[</bpt>строки форматов перечисления<ept id="p1">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> values.</source>
          <target state="translated">значения типа <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(See <bpt id="p1">[</bpt>Standard TimeSpan Format Strings<ept id="p1">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom TimeSpan Format Strings<ept id="p2">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept>.)</source>
          <target state="translated">(См. <bpt id="p1">[</bpt>строки стандартного формата TimeSpan<ept id="p1">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept> и <bpt id="p2">[</bpt>строки пользовательского формата TimeSpan<ept id="p2">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>GUIDs.</source>
          <target state="translated">Идентификаторы GUID.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>(See the <ph id="ph1">&lt;xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> method.)</source>
          <target state="translated">(См. <ph id="ph1">&lt;xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> метод.)</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, note that any custom type can implement <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> or extend an existing type's <ph id="ph2">&lt;xref:System.IFormattable&gt;</ph> implementation.</source>
          <target state="translated">Однако обратите внимание, что любой тип можно реализовать <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> или расширить существующий тип <ph id="ph2">&lt;xref:System.IFormattable&gt;</ph> реализации.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses the <ph id="ph1">`alignment`</ph> and <ph id="ph2">`formatString`</ph> arguments to produce formatted output.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">`alignment`</ph> и <ph id="ph2">`formatString`</ph> аргументы для создания Форматированные выходные данные.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How arguments are formatted</source>
          <target state="translated">Форматирование аргументов</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Format items are processed sequentially from the beginning of the string.</source>
          <target state="translated">Элементы форматирования обрабатываются последовательно от начала строки.</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Each format item has an index that corresponds to an object in the method's argument list.</source>
          <target state="translated">Каждый элемент формата имеет индекс, который соответствует объекту в списке аргументов метода.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method retrieves the argument and derives its string representation as follows:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> Метод получает аргумент и наследует его строковое представление следующим образом:</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the argument is <ph id="ph1">`null`</ph>, the method inserts <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> into the result string.</source>
          <target state="translated">Если аргумент является <ph id="ph1">`null`</ph>, то метод вставляет <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> в результирующую строку.</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You don't have to be converned with handling an <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> for null arguments.</source>
          <target state="translated">Не нужно быть converned с обработкой <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph> для аргументов, значение null.</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you call the <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> overload and the <ph id="ph2">`provider`</ph> parameter implements the <ph id="ph3">&lt;xref:System.ICustomFormatter&gt;</ph> interface, the argument is passed to the <ph id="ph4">`provider`</ph> object's <ph id="ph5">&lt;xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">При вызове метода <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> перегрузки и <ph id="ph2">`provider`</ph> реализует параметр <ph id="ph3">&lt;xref:System.ICustomFormatter&gt;</ph> интерфейс, передается аргумент <ph id="ph4">`provider`</ph> объекта <ph id="ph5">&lt;xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the format item includes a <bpt id="p1">*</bpt>formatString<ept id="p1">*</ept> argument, it is passed as the first argument to the method.</source>
          <target state="translated">Если элемент формата включает <bpt id="p1">*</bpt>formatString<ept id="p1">*</ept> аргумент, он передается в качестве первого аргумента метода.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> implementation is able to provide formatting services, it returns the string representation of the argument; otherwise, it returns <ph id="ph2">`null`</ph> and the next step executes.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> реализация может предоставить службы форматирования, он возвращает строковое представление аргумента; в противном случае он возвращает <ph id="ph2">`null`</ph> и выполняет следующий шаг.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the argument implements the <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> interface, its <ph id="ph2">&lt;xref:System.IFormattable.ToString%2A?displayProperty=nameWithType&gt;</ph> implementation is called.</source>
          <target state="translated">Если аргумент реализует <ph id="ph1">&lt;xref:System.IFormattable&gt;</ph> интерфейса, его <ph id="ph2">&lt;xref:System.IFormattable.ToString%2A?displayProperty=nameWithType&gt;</ph> реализация вызывается.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The argument's parameterless <ph id="ph1">`ToString`</ph> method, which is either overridden or inherited from the <ph id="ph2">&lt;xref:System.Object&gt;</ph> class, is called.</source>
          <target state="translated">Аргумент без параметров <ph id="ph1">`ToString`</ph> метод, который является либо переопределить или наследуется от <ph id="ph2">&lt;xref:System.Object&gt;</ph> класса, называется.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For an example that intercepts calls to the <ph id="ph1">&lt;xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType&gt;</ph> method and allows you to see what information the <ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph> method passes to a formatting method for each format item in a composite format string, see <bpt id="p1">[</bpt>Example: An intercept provider and Roman numeral formatter<ept id="p1">](#Format7_Example)</ept>.</source>
          <target state="translated">Пример, который перехватывает вызовы <ph id="ph1">&lt;xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType&gt;</ph> метод и позволяет видеть, какие сведения <ph id="ph2">&lt;xref:System.String.Format%2A&gt;</ph> метод передается в метод форматирования для каждого элемента форматирования в строке составного формата, в разделе <bpt id="p1">[</bpt>пример: поставщик отсекаемый отрезок и Модуль форматирования римские цифры<ept id="p1">](#Format7_Example)</ept>.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Format items that have the same index</source>
          <target state="translated">Формат элементы, имеющие тот же индекс</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method throws a <ph id="ph2">&lt;xref:System.FormatException&gt;</ph> exception if the index of an index item is greater than or equal to the number of arguments in the argument list.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> Вызывает исключение <ph id="ph2">&lt;xref:System.FormatException&gt;</ph> исключение, если индекс элемента индекса больше или равно количеству аргументов в списке аргументов.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, <ph id="ph1">`format`</ph> can include more format items than there are arguments, as long as multiple format items have the same index.</source>
          <target state="translated">Тем не менее <ph id="ph1">`format`</ph> может включать несколько элементов формата, превышает количество аргументов, при условии, что несколько элементов форматирования имеют тот же индекс.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In the call to the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph> method in following example, the argument list has a single argument, but the format string includes two format items: one displays the decimal value of a number, and the other displays its hexadecimal value.</source>
          <target state="translated">В вызове <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph> метод в следующем примере список аргументов имеет один аргумент, но строка формата содержит два элемента форматирования: один отображает десятичное значение числа, и другой шестнадцатеричное значение.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Formatting and culture</source>
          <target state="translated">Форматирование и языка и региональных параметров</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Generally, objects in the argument list are converted to their string representations by using the conventions of the current culture, which is returned by the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Как правило, объекты в списке аргументов, преобразуются в их строковые представления с использованием правил текущего языка и региональных параметров, который возвращается методом <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can control this behavior by calling one of the overloads of <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> that includes a <ph id="ph2">`provider`</ph> parameter.</source>
          <target state="translated">Этот параметр можно настроить путем вызова одной из перегрузок <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> , включающего <ph id="ph2">`provider`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">`provider`</ph> parameter is an <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> implementation that supplies custom and culture-specific formatting information that is used to moderate the formatting process.</source>
          <target state="translated"><ph id="ph1">`provider`</ph> Параметр <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> обработать реализацию, предоставляющий пользовательские и зависящие от языка и региональных параметров форматирования информации, которая используется средний форматирование.</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> interface has a single member, <ph id="ph2">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph>, which is responsible for returning the object that provides formatting information.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> Интерфейса есть только один член, <ph id="ph2">&lt;xref:System.IFormatProvider.GetFormat%2A&gt;</ph>, который отвечает за возврат объекта, который предоставляет сведения о форматировании.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The .NET Framework has three <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> implementations that provide culture-specific formatting:</source>
          <target state="translated">Платформа .NET Framework имеет три <ph id="ph1">&lt;xref:System.IFormatProvider&gt;</ph> реализациями, которые предоставляют форматирования с учетом языка и региональных параметров:</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Its <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> method returns a culture-specific <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> object for formatting numeric values and a culture-specific <ph id="ph3">&lt;xref:System.Globalization.DateTimeFormatInfo&gt;</ph> object for formatting date and time values.</source>
          <target state="translated">Его <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.GetFormat%2A&gt;</ph> метод возвращает зависящим от культуры <ph id="ph2">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph> объект для форматирования числовых значений и зависящие от языка и региональных параметров <ph id="ph3">&lt;xref:System.Globalization.DateTimeFormatInfo&gt;</ph> объект для форматирования значений даты и времени.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.Globalization.DateTimeFormatInfo&gt;</ph>, which is used for culture-specific formatting of date and time values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Globalization.DateTimeFormatInfo&gt;</ph>, который используется для конкретного языка и региональных параметров форматирования значений даты и времени.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Its <ph id="ph1">&lt;xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A&gt;</ph> method returns itself.</source>
          <target state="translated">Его <ph id="ph1">&lt;xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A&gt;</ph> метод возвращает сам себя.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph>, which is used for culture-specific formatting of numeric values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo&gt;</ph>, который используется для конкретного языка и региональных параметров форматирования числовых значений.</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Its <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> property returns itself.</source>
          <target state="translated">Его <ph id="ph1">&lt;xref:System.Globalization.NumberFormatInfo.GetFormat%2A&gt;</ph> свойство возвращает сам.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Custom formatting operations</source>
          <target state="translated">Настраиваемое форматирование операций</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also call the any of the overloads of the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method that have a <ph id="ph2">`provider`</ph> parameter of type <ph id="ph3">&lt;xref:System.IFormatProvider&gt;</ph> to perform custom formatting operations.</source>
          <target state="translated">Можно также вызвать любой из перегруженных версий <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> метода, который имеет <ph id="ph2">`provider`</ph> параметр типа <ph id="ph3">&lt;xref:System.IFormatProvider&gt;</ph> для выполнения пользовательских операций форматирования.</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, you could format an integer as an identification number or as a telephone number.</source>
          <target state="translated">Например можно форматирование целое число, идентификационный номер или номер телефона.</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To perform custom formatting, your <ph id="ph1">`provider`</ph> argument must implement both the <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> and <ph id="ph3">&lt;xref:System.ICustomFormatter&gt;</ph> interfaces.</source>
          <target state="translated">Для выполнения пользовательского форматирования вашей <ph id="ph1">`provider`</ph> аргумент должен реализовывать <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> и <ph id="ph3">&lt;xref:System.ICustomFormatter&gt;</ph> интерфейсов.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>When the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method is passed an <ph id="ph2">&lt;xref:System.ICustomFormatter&gt;</ph> implementation as the <ph id="ph3">`provider`</ph> argument, the <ph id="ph4">&lt;xref:System.String.Format%2A&gt;</ph> method calls its   <ph id="ph5">&lt;xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType&gt;</ph> implementation and requests an object of type <ph id="ph6">&lt;xref:System.ICustomFormatter&gt;</ph>.</source>
          <target state="translated">При <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> методу передается <ph id="ph2">&lt;xref:System.ICustomFormatter&gt;</ph> реализации как <ph id="ph3">`provider`</ph> аргумент, <ph id="ph4">&lt;xref:System.String.Format%2A&gt;</ph> вызовы метода его <ph id="ph5">&lt;xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType&gt;</ph> реализацию и запрашивает объект типа <ph id="ph6">&lt;xref:System.ICustomFormatter&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It then calls the returned <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> object's <ph id="ph2">&lt;xref:System.ICustomFormatter.Format%2A&gt;</ph> method to format each format item in the composite string passed to it.</source>
          <target state="translated">Затем он вызывает возвращаемый <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> объекта <ph id="ph2">&lt;xref:System.ICustomFormatter.Format%2A&gt;</ph> переданного ему метод, чтобы каждый элемент формата в строке составного формата.</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more information about providing custom formatting solutions, see <bpt id="p1">[</bpt>How to: Define and Use Custom Numeric Format Providers<ept id="p1">](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md)</ept> and <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о предоставлении пользовательских решений форматирования см. в разделе <bpt id="p1">[</bpt>как: определить и использовать пользовательские числового формата поставщики<ept id="p1">](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md)</ept> и <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For an example that converts integers to formatted custom numbers, see <bpt id="p1">[</bpt>Example: A custom formatting operation<ept id="p1">](#Format6_Example)</ept>.</source>
          <target state="translated">Пример, преобразует пользовательские числа целых чисел, в разделе <bpt id="p1">[</bpt>пример: пользовательские операции форматирования<ept id="p1">](#Format6_Example)</ept>.</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For an example that converts unsigned bytes to Roman numerals, see <bpt id="p1">[</bpt>Example: An intercept provider and Roman numeral formatter<ept id="p1">](#Format7_Example)</ept>.</source>
          <target state="translated">Пример, который преобразует римские цифры байтов без знака, в разделе <bpt id="p1">[</bpt>пример: поставщик перехвата и форматирования римские цифры<ept id="p1">](#Format7_Example)</ept>.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example: A custom formatting operation</source>
          <target state="translated">Пример: Пользовательские операции форматирования</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This example defines a format provider that formats an integer value as a customer account number in the form x-xxxxx-xx.</source>
          <target state="translated">Этот пример определяет поставщик формата, который форматирует целое число как номер счета клиента в форме x-xxxxx-xx.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Example: An intercept provider and Roman numeral formatter</source>
          <target state="translated">Пример: Отсекаемый отрезок поставщика и форматирования римские цифры</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This example defines a custom format provider that implements the <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> and <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> interfaces to do two things:</source>
          <target state="translated">В этом примере определяется поставщика настраиваемого формата, который реализует <ph id="ph1">&lt;xref:System.ICustomFormatter&gt;</ph> и <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> интерфейсы, чтобы сделать две вещи:</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It displays the parameters passed to its <ph id="ph1">&lt;xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType&gt;</ph> implementation.</source>
          <target state="translated">Он отображает параметры, передаваемые его <ph id="ph1">&lt;xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType&gt;</ph> реализации.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This enables us to see what parameters the <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> method is passing to the custom formatting implementation for each object that it tries to format.</source>
          <target state="translated">Это позволяет увидеть, какие параметры <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> метод передает реализацию пользовательского форматирования для каждого объекта, он предпринимает для форматирования.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This can be useful when you're debugging your application.</source>
          <target state="translated">Это может быть полезно при отладке приложения.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the object to be formatted is an unsigned byte value that is to be formatted by using the "R" standard format string, the custom formatter formats the numeric value as a Roman numeral.</source>
          <target state="translated">Если объект форматируемое значение байтов без знака, который должен быть отформатирован с использованием строки стандартного формата «R», пользовательский модуль форматирования форматирует числовое значение в виде римские цифры.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String.Format Q &amp; A</source>
          <target state="translated">String.Format вопросы и ответы</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Why do you recommend string interpolation over calls to the <ph id="ph1">`String.Format`</ph> method?</source>
          <target state="translated">Почему вы рекомендуем интерполяции строк через вызовы <ph id="ph1">`String.Format`</ph> метод?</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>String interpolation is:</source>
          <target state="translated">— Интерполяции строк:</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>More flexible.</source>
          <target state="translated">Более гибким.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It can be used in any string without requiring a call to a method that supports composite formatting.</source>
          <target state="translated">Он может использоваться ни в одной строке без необходимости вызова методу, поддерживающему составное форматирование.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Otherwise, you have to call the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method or another method that supports composite formatting, such as <ph id="ph2">&lt;xref:System.Console.WriteLine%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">В противном случае необходимо вызвать <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> метода или другой метод, который поддерживает составное форматирование, такими как <ph id="ph2">&lt;xref:System.Console.WriteLine%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph3">&lt;xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>More readable.</source>
          <target state="translated">Более удобном для чтения.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the expression to insert into a string appears in the interpolated expression rather than in a argument list, interpolated strings are far easier to code and to read.</source>
          <target state="translated">Поскольку выражение для вставки в строку, отображается в интерполированного выражения, а не в списке аргументов, интерполированные строки являются гораздо удобнее для кода и для чтения.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because of their greater readability, interpolated strings can replace not only calls to composite format methods, but they can also be used in string concatenation operations to produce more concise, clearer code.</source>
          <target state="translated">Из-за их улучшения удобочитаемости интерполированные строки можно заменить не только вызовы методов составного формата, но они могут также использоваться в операциях объединения строк для получения более компактные и чистый кода.</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A comparison of the following two code examples illustrates the superiority of interpolated strings over string concatenation and calls to composite formatting methods.</source>
          <target state="translated">Сравнение в следующих двух примерах кода демонстрируется superiority интерполированные строки через объединение строк и вызовы методов составного форматирования.</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The use of multiple string concatenation operations in the following example produces verbose and hard-to-read code.</source>
          <target state="translated">Использование нескольких операциях объединения строк, в следующем примере создается код verbose и трудный для чтения.</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>In contrast, the use of interpolated strings in the following example produce much clearer, more concise code than the string concatenation statement and the call to the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method in the previous example.</source>
          <target state="translated">С другой стороны, использование интерполированные строки в следующем примере создают гораздо более четкое, более компактные кода, чем оператор объединения строки и возврата вызова <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> метод в предыдущем примере.</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Where can I find a list of the predefined format strings that can be used with format items?</source>
          <target state="translated">Где можно найти список стандартных строк форматирования, используемых элементами форматирования</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For all integral and floating-point types, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
          <target state="translated">Для всех типов целочисленные и с плавающей запятой, в разделе <bpt id="p1">[</bpt>строки стандартного числового формата<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> и <bpt id="p2">[</bpt>строки настраиваемых числовых форматов<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For date and time values, see <bpt id="p1">[</bpt>Standard Date and Time Format Strings<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Date and Time Format Strings<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>.</source>
          <target state="translated">Значения даты и времени см. в разделе <bpt id="p1">[</bpt>стандартной строки даты и времени формат<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> и <bpt id="p2">[</bpt>пользовательских строк даты и времени формат<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For enumeration values, see <bpt id="p1">[</bpt>Enumeration Format Strings<ept id="p1">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>.</source>
          <target state="translated">Значения перечисления см. в разделе <bpt id="p1">[</bpt>строки форматов перечисления<ept id="p1">](~/docs/standard/base-types/enumeration-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> values, see  <bpt id="p1">[</bpt>Standard TimeSpan Format Strings<ept id="p1">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom TimeSpan Format Strings<ept id="p2">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept>.</source>
          <target state="translated">Для <ph id="ph1">&lt;xref:System.TimeSpan&gt;</ph> значения, в разделе <bpt id="p1">[</bpt>строки стандартного формата TimeSpan<ept id="p1">](~/docs/standard/base-types/standard-timespan-format-strings.md)</ept> и <bpt id="p2">[</bpt>строки настраиваемого формата TimeSpan<ept id="p2">](~/docs/standard/base-types/custom-timespan-format-strings.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For <ph id="ph1">&lt;xref:System.Guid&gt;</ph> values, see the Remarks section of the <ph id="ph2">&lt;xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> reference page.</source>
          <target state="translated">Для <ph id="ph1">&lt;xref:System.Guid&gt;</ph> значения, в разделе «Примечания» <ph id="ph2">&lt;xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> справочной странице.</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How do I control the alignment of the result strings that replace format items?</source>
          <target state="translated">Управление выравнивание строки результатов, которые замены элементов форматирования</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The general syntax of a format item is:</source>
          <target state="translated">Приведен общий синтаксис элементов форматирования.</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>where <bpt id="p1">*</bpt>alignment<ept id="p1">*</ept> is a signed integer that defines the field width.</source>
          <target state="translated">где <bpt id="p1">*</bpt>выравнивание<ept id="p1">*</ept> является целое число со знаком, определяющее ширину поля.</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If this value is negative, text in the field is left-aligned.</source>
          <target state="translated">Если это значение является отрицательным, текст в поле по левому краю.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If it is positive, text is right-aligned.</source>
          <target state="translated">Если он является положительным, текст по правому краю.</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How do I control the number of digits after the decimal separator?</source>
          <target state="translated">Как контролировать количество разрядов после десятичного разделителя?</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>All <bpt id="p1">[</bpt>standard numeric format strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> except "D" (which is used with integers only), "G", "R", and "X" allow a precision specifier that defines the number of decimal digits in the result string.</source>
          <target state="translated">Все <bpt id="p1">[</bpt>строки стандартных числовых форматов<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> , кроме «D» (которое используется только целые числа), «G», «R», а «X» разрешить описатель точности, которое определяет количество цифр дробной части в результирующей строке.</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses standard numeric format strings to control the number of decimal digits in the result string.</source>
          <target state="translated">В следующем примере строки стандартных числовых форматов для управления количество цифр дробной части в результирующей строке.</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you're using a <bpt id="p1">[</bpt>custom numeric format string<ept id="p1">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>, use the "0" format specifier to control the number of decimal digits in the result string, as the following example shows.</source>
          <target state="translated">Если вы используете <bpt id="p1">[</bpt>строка настраиваемого числового формата<ept id="p1">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>, позволяет контролировать количество цифр дробной части в результирующей строке, как показано в следующем примере описатель формата «0».</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How do I control the number of integral digits?</source>
          <target state="translated">Как контролировать число цифр целой части?</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>By default, formatting operations only display non-zero integral digits.</source>
          <target state="translated">По умолчанию операций форматирования будет отображаться только цифры целой части ненулевое значение.</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you are formatting integers, you can use a precision specifier with the "D" and "X" standard format strings to control the number of digits.</source>
          <target state="translated">При форматировании целые числа, можно использовать описатель точности строки стандартного формата «X» и «D» для управления количеством цифр.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can pad an integer or floating-point number with leading zeros to produce a result string with a specified number of integral digits by using the "0" <bpt id="p1">[</bpt>custom numeric format specifier<ept id="p1">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>, as the following example shows.</source>
          <target state="translated">Целое число или число с плавающей запятой с нулем в начале для создания результирующую строку с указанным количеством цифр целой части с помощью «0» можно добавлять <bpt id="p1">[</bpt>описатель настраиваемого числового формата<ept id="p1">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>, как показано в следующем примере.</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How many items can I include in the format list?</source>
          <target state="translated">Количество элементов, можно включить в список формата</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>There is no practical limit.</source>
          <target state="translated">Нет ограничения.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The second parameter of the <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> method is tagged with the <ph id="ph2">&lt;xref:System.ParamArrayAttribute&gt;</ph> attribute, which allows you to include either a delimited list or an object array as your format list.</source>
          <target state="translated">Второй параметр <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> метод обозначен цифрой <ph id="ph2">&lt;xref:System.ParamArrayAttribute&gt;</ph> атрибут, который позволяет включать список с разделителями или массив объектов в формате списка.</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>How do I include literal braces ("{" and "}") in the result string?</source>
          <target state="translated">Как содержащие литерала фигурные скобки ("{» и «}») в результирующей строке?</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, how do you prevent the following method call from throwing a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> exception?</source>
          <target state="translated">Например, как вы запрещают следующий вызов метода возникновения <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> исключение?</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A single opening or closing brace is always interpreted as the beginning or end of a format item.</source>
          <target state="translated">Один открывающую или закрывающую скобку, всегда интерпретируется как начало или конец элемента форматирования.</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>To be interpreted literally, it must be escaped.</source>
          <target state="translated">Следует интерпретировать буквально, ее следует экранировать.</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You escape a brace by adding another brace ("{{" and "}}" instead of "{" and "}"), as in the following method call:</source>
          <target state="translated">Экранировать фигурную скобку путем добавления другого фигурная скобка ("{{» и»}}» вместо «{» и «}»), как показано в следующем вызове метода:</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>However, even escaped braces are easily misinterpreted.</source>
          <target state="translated">Однако даже скобок, легко misinterpreted.</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>We recommend that you include braces in the format list and use format items to insert them in the result string, as the following example shows.</source>
          <target state="translated">Корпорация Майкрософт рекомендует включать квадратные скобки в списке формат и вставить их в результирующей строке, как показано в следующем примере с помощью элементов формата.</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Why does my call to the String.Format method throw a FormatException?</source>
          <target state="translated">Почему моя вызов метода String.Format исключение FormatException?</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The most common cause of the exception is that the index of a format item doesn't correspond to an object in the format list.</source>
          <target state="translated">Наиболее распространенной причиной исключения является то, что индекс элемента формата не соответствует объекта в списке формат.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Usually this indicates that you've misnumbered the indexes of format items or you've forgotten to include an object in the format list.</source>
          <target state="translated">Обычно это указывает на misnumbered индексы элементов формата или забыли включить объект в формате списка.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Attempting to include an unescaped left or right brace character also throws a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph>.</source>
          <target state="translated">Попытка включить escape-последовательность фигурной скобки влево или вправо символ также вызывает исключение <ph id="ph1">&lt;xref:System.FormatException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Occasionally, the exception is the result of a typo; for example, a typical mistake is to mistype "[" (the left bracket) instead of "{" (the left brace).</source>
          <target state="translated">В некоторых случаях исключение является результатом опечатка; Например, типичный встречается ошиблись «[» (левую скобку) вместо «{» (открывающая фигурная скобка).</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If the Format(System.IFormatProvider,System.String,System.Object[]) method supports parameter arrays, why does my code throw an exception when I use an array?</source>
          <target state="translated">Если метод Format(System.IFormatProvider,System.String,System.Object[]) поддерживает массивы параметров, почему коде вызывает исключение при использовании массива?</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the following code throws a <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> exception:</source>
          <target state="translated">Например, следующий код создает исключение <ph id="ph1">&lt;xref:System.FormatException&gt;</ph> исключение:</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is a problem of compiler overload resolution.</source>
          <target state="translated">Это проблема компилятора разрешения перегрузки.</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because the compiler cannot convert an array of integers to an object array, it treats the integer array as a single argument, so it calls the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph> method.</source>
          <target state="translated">Поскольку компилятор не может преобразовать массив целых чисел в массив объектов, он рассматривает массив целых чисел как один аргумент, он вызывает <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The exception is thrown because there are four format items but only a single item in the format list.</source>
          <target state="translated">Исключение, так как существуют четыре формата элементы, но только один элемент в списке формат.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Because neither Visual Basic nor C# can convert an integer array to an object array, you have to perform the conversion yourself before calling the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Так как не Visual Basic и C# можно преобразовать массив целых чисел в массив объектов, необходимо самостоятельно выполнить преобразование, перед вызовом метода <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example provides one implementation.</source>
          <target state="translated">Следующий пример предоставляет одну реализацию.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Numerous examples that call the <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> method are interspersed through the <bpt id="p1">[</bpt>Remarks<ept id="p1">](#remarks)</ept> section of this article.</source>
          <target state="translated">Многочисленные примеры, которые вызывают <ph id="ph1">&lt;xref:System.String.Format%2A&gt;</ph> метод смешиваются через <bpt id="p1">[</bpt>примечания<ept id="p1">](#remarks)</ept> этой статьи.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also download a complete set of <ph id="ph1">`String.Format`</ph> examples, which are included a <bpt id="p1">[</bpt>.NET Core 2.0 project for C#<ept id="p1">](https://github.com/dotnet/docs/raw/master/samples/snippets/csharp/downloads/api/System/String.Format.zip)</ept> and a <bpt id="p2">[</bpt>.NET Core 2.0 project for Visual Basic<ept id="p2">](https://github.com/dotnet/docs/raw/master/samples/snippets/visualbasic/downloads/api/System/String.Format.zip)</ept>, from the <bpt id="p3">[</bpt>dotnet/docs GitHub repository<ept id="p3">](https://github.com/dotnet/docs)</ept>.</source>
          <target state="translated">Вы также можете скачать полный набор <ph id="ph1">`String.Format`</ph> примеры, которые входят в <bpt id="p1">[</bpt>проект .NET Core 2.0 для C#<ept id="p1">](https://github.com/dotnet/docs/raw/master/samples/snippets/csharp/downloads/api/System/String.Format.zip)</ept> и <bpt id="p2">[</bpt>проект .NET Core 2.0 для Visual Basic<ept id="p2">](https://github.com/dotnet/docs/raw/master/samples/snippets/visualbasic/downloads/api/System/String.Format.zip)</ept>, из <bpt id="p3">[</bpt>dotnet/docs Репозитории GitHub<ept id="p3">](https://github.com/dotnet/docs)</ept>.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following are some of the examples included in the article:</source>
          <target state="translated">Ниже приведены некоторые примеры, включенные в статью.</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Create a format string</source>
          <target state="translated">Создать строку формата</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Inserting a string<ept id="p1">](#inserting-a-string)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Вставка строки<ept id="p1">](#inserting-a-string)</ept></target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>The format item<ept id="p1">](#the-format-item)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Элемент формата<ept id="p1">](#the-format-item)</ept></target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Format items that have the same index<ept id="p1">](#format-items-that-have-the-same-index)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Формат элементы, имеющие тот же индекс<ept id="p1">](#format-items-that-have-the-same-index)</ept></target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Control formatted output</source>
          <target state="translated">Выходные данные в формате элемента управления</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Controlling formatting<ept id="p1">](#controlling-formatting)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Управление форматированием<ept id="p1">](#controlling-formatting)</ept></target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Controlling spacing<ept id="p1">](#controlling-spacing)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Управление интервалы<ept id="p1">](#controlling-spacing)</ept></target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Controlling alignment<ept id="p1">](#controlling-alignment)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Управление выравнивания<ept id="p1">](#controlling-alignment)</ept></target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Controlling the number of integral digits<ept id="p1">](#how-do-i-control-the-number-of-integral-digits)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Управление количеством цифр целой части<ept id="p1">](#how-do-i-control-the-number-of-integral-digits)</ept></target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Controlling the number of digits after the decimal separator<ept id="p1">](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Управление числом знаков после десятичного разделителя<ept id="p1">](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)</ept></target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Including literal braces in a result string<ept id="p1">](#braces)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Включая фигурные скобки литерала в результирующей строке<ept id="p1">](#braces)</ept></target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Make format strings culture-sensitive</source>
          <target state="translated">Сделать строки формата, язык и региональные параметры</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>Culture-sensitive formatting<ept id="p1">](#culture-sensitive-formatting)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Форматирование с учетом языка и региональных параметров<ept id="p1">](#culture-sensitive-formatting)</ept></target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Customize the formatting operation</source>
          <target state="translated">Настройка операции форматирования</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>A custom formatting operation<ept id="p1">](#example-a-custom-formatting-operation)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Пользовательские операции форматирования<ept id="p1">](#example-a-custom-formatting-operation)</ept></target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><bpt id="p1">[</bpt>An intercept provider and Roman numeral formatter<ept id="p1">](#example-an-intercept-provider-and-roman-numeral-formatter)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Модуль форматирования римские цифры и отсекаемый отрезок поставщика<ept id="p1">](#example-an-intercept-provider-and-roman-numeral-formatter)</ept></target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>Строка составного форматирования<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>The object to format.</source>
          <target state="translated">Объект для форматирования.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>Replaces one or more format items in a string with the string representation of a specified object.</source>
          <target state="translated">Заменяет один или более элементов формата в строке строковым представлением указанного объекта.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which any format items are replaced by the string representation of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>.</source>
          <target state="translated">Копия <ph id="ph1">&lt;paramref name="format" /&gt;</ph>, в которой все элементы формата заменены строковыми представлениями <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert the value of an expression to its string representation and to embed that representation in a string.</source>
          <target state="translated">Этот метод использует <bpt id="p1">[</bpt>составное форматирование<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> преобразуемое значение выражения в строковое представление и встроить это представление в строку.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object)">
          <source>Example: Formatting a single argument</source>
          <target state="translated">Пример: Форматирование один аргумент</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph> method to embed an individual's age in the middle of a string.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%29&gt;</ph> метод для внедрения возраст человека в середине строки.</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="format" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>The format item in <ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated">Недопустимый элемент формата в <ph id="ph1">&lt;paramref name="format" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object)">
          <source>The index of a format item is not zero.</source>
          <target state="translated">Индекс элемента формата не равен нулю.</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>Строка составного форматирования<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>An object array that contains zero or more objects to format.</source>
          <target state="translated">Массив объектов, содержащий нуль или более форматируемых объектов.</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>Replaces the format item in a specified string with the string representation of a corresponding object in a specified array.</source>
          <target state="translated">Заменяет элемент формата в указанной строке строковым представлением соответствующего объекта в указанном массиве.</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which the format items have been replaced by the string representation of the corresponding objects in <ph id="ph2">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">Копия <ph id="ph1">&lt;paramref name="format" /&gt;</ph>, в которой элементы формата заменены строковыми представления соответствующих объектов в <ph id="ph2">&lt;paramref name="args" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert the value of four or more expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">Этот метод использует <bpt id="p1">[</bpt>составное форматирование<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> для преобразования значения четыре или более выражений в их строковые представления и встроить эти представления в строку.</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>Since the <ph id="ph1">`args`</ph> parameter is marked with the <ph id="ph2">&lt;xref:System.ParamArrayAttribute?displayProperty=nameWithType&gt;</ph> attribute, you can pass the objects to the method as individual arguments or as an <ph id="ph3">&lt;xref:System.Object&gt;</ph> array.</source>
          <target state="translated">Поскольку <ph id="ph1">`args`</ph> параметр помечается <ph id="ph2">&lt;xref:System.ParamArrayAttribute?displayProperty=nameWithType&gt;</ph> атрибут, можно передать объекты метода как отдельные аргументы или <ph id="ph3">&lt;xref:System.Object&gt;</ph> массива.</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>Example: Formatting more than three arguments</source>
          <target state="translated">Пример: Форматирование больше трех аргументов</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>This example creates a string that contains data on the high and low temperature on a particular date.</source>
          <target state="translated">В этом примере создается строка, содержащая данные на самой высокой и низкой температуры в определенный день.</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>The composite format string has five format items in the C# example and six in the Visual Basic example.</source>
          <target state="translated">Строка составного формата имеет пять элементов формата в примере C# и шесть в примере Visual Basic.</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>Two of the format items define the width of their corresponding value's string representation, and the first format item also includes a standard date and time format string.</source>
          <target state="translated">Два элемента форматирования определяют ширину строкового представления соответствующего значения, и первый элемент форматирования также включает стандартные формата даты и времени.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object[])">
          <source>You can also pass the objects to be formatted as an array rather than a an argument list.</source>
          <target state="translated">Можно также передать объекты форматируется как массив, а не список аргументов.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> or <ph id="ph2">&lt;paramref name="args" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="format" /&gt;</ph> или <ph id="ph2">&lt;paramref name="args" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> недопустим.</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object[])">
          <source>The index of a format item is less than zero, or greater than or equal to the length of the <ph id="ph1">&lt;paramref name="args" /&gt;</ph> array.</source>
          <target state="translated">Индекс элемента формата меньше нуля, либо больше или равен длине массива <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>An object that supplies culture-specific formatting information.</source>
          <target state="translated">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>Строка составного форматирования<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>The object to format.</source>
          <target state="translated">Объект для форматирования.</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>Replaces the format item or items in a specified string with the string representation of the corresponding object.</source>
          <target state="translated">Заменяет элементы формата в указанной строке строковым представлением соответствующего объекта.</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>A parameter supplies culture-specific formatting information.</source>
          <target state="translated">Параметр предоставляет сведения об особенностях форматирования, связанных с языком и региональными параметрами.</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which the format item or items have been replaced by the string representation of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>.</source>
          <target state="translated">Копия <ph id="ph1">&lt;paramref name="format" /&gt;</ph>, в которой элементы форматирования были заменены строковым представлением <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert the value of an expression to its string representation and to embed that representation in a string.</source>
          <target state="translated">Этот метод использует <bpt id="p1">[</bpt>составное форматирование<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> преобразуемое значение выражения в строковое представление и встроить это представление в строку.</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</source>
          <target state="translated">При выполнении преобразования, метод использует форматирования с учетом языка и региональных параметров или пользовательский модуль форматирования.</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>The method converts <ph id="ph1">`arg0`</ph> to its string representation by calling its <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> method or, if the object's corresponding format item includes a format string, by calling its <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> method.</source>
          <target state="translated">Метод преобразует <ph id="ph1">`arg0`</ph> в строковое представление, вызвав его <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> метода или, если объект к соответствующему элемент форматирования, включающий строку формата, вызвав его <bpt id="p2">**</bpt>ToString () String, IFormatProvider)<ept id="p2">**</ept> метод.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>If these methods don't exist, it calls the object's parameterless <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> method.</source>
          <target state="translated">Если эти методы не существует, он вызывает метод объекта без параметров <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> метод.</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="format" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> недопустим.</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object)">
          <source>The index of a format item is not zero.</source>
          <target state="translated">Индекс элемента формата не равен нулю.</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>An object that supplies culture-specific formatting information.</source>
          <target state="translated">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>Строка составного форматирования<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>An object array that contains zero or more objects to format.</source>
          <target state="translated">Массив объектов, содержащий нуль или более форматируемых объектов.</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>Replaces the format items in a string with the string representations of corresponding objects in a specified array.</source>
          <target state="translated">Заменяет элементы формата в строке строковым представлениями соответствующих объектов в указанном массиве.</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>A parameter supplies culture-specific formatting information.</source>
          <target state="translated">Параметр предоставляет сведения об особенностях форматирования, связанных с языком и региональными параметрами.</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which the format items have been replaced by the string representation of the corresponding objects in <ph id="ph2">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">Копия <ph id="ph1">&lt;paramref name="format" /&gt;</ph>, в которой элементы формата заменены строковыми представления соответствующих объектов в <ph id="ph2">&lt;paramref name="args" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert four or more expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">Этот метод использует <bpt id="p1">[</bpt>составное форматирование<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> для преобразования четырьмя или более выражений в их строковые представления и встроить эти представления в строку.</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</source>
          <target state="translated">При выполнении преобразования, метод использует форматирования с учетом языка и региональных параметров или пользовательский модуль форматирования.</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>The method converts each <ph id="ph1">&lt;xref:System.Object&gt;</ph> argument to its string representation by calling its <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> method or, if the object's corresponding format item includes a format string, by calling its <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> method.</source>
          <target state="translated">Метод преобразует каждый <ph id="ph1">&lt;xref:System.Object&gt;</ph> аргумент в строковое представление, вызвав его <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> метода или, если объект к соответствующему элемент форматирования, включающий строку формата, вызвав его <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> метод.</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>If these methods don't exist, it calls the object's parameterless <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> method.</source>
          <target state="translated">Если эти методы не существует, он вызывает метод объекта без параметров <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> метод.</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>Example: Culture-sensitive formatting</source>
          <target state="translated">Пример: Язык и региональные параметры форматирования</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>This example uses the <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> method to display the string representation of some date and time values and numeric values by using several different cultures.</source>
          <target state="translated">В этом примере используется <ph id="ph1">&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29&gt;</ph> метод для отображения некоторых значений даты и времени и числовых значений строковое представление с использованием нескольких языков и региональных параметров.</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> or <ph id="ph2">&lt;paramref name="args" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="format" /&gt;</ph> или <ph id="ph2">&lt;paramref name="args" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> недопустим.</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])">
          <source>The index of a format item is less than zero, or greater than or equal to the length of the <ph id="ph1">&lt;paramref name="args" /&gt;</ph> array.</source>
          <target state="translated">Индекс элемента формата меньше нуля, либо больше или равен длине массива <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>Строка составного форматирования<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>The first object to format.</source>
          <target state="translated">Первый объект для форматирования.</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>The second object to format.</source>
          <target state="translated">Второй объект для форматирования.</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>Replaces the format items in a string with the string representation of two specified objects.</source>
          <target state="translated">Заменяет элементы формата в строке строковым представлением двух указанных объектов.</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which format items are replaced by the string representations of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> and <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph>.</source>
          <target state="translated">Копия <ph id="ph1">&lt;paramref name="format" /&gt;</ph>, в которой все элементы формата заменены строковыми представлениями <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> и <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert the value of two expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">Этот метод использует <bpt id="p1">[</bpt>составное форматирование<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> для преобразования значения из двух выражений в их строковые представления и встроить эти представления в строку.</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>Example: Formatting two arguments</source>
          <target state="translated">Пример: Форматирование двух аргументов</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>This example uses the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29&gt;</ph> method to display time and temperature data stored in a generic <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> object.</source>
          <target state="translated">В этом примере используется <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29&gt;</ph> метод для отображения времени и температуры данные, хранящиеся в универсальный <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>Note that the format string has three format items, although there are only two objects to format.</source>
          <target state="translated">Обратите внимание, что строка формата имеет три элемента форматирования, несмотря на то, что имеется только два объекта для форматирования.</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>This is because the first object in the list (a date and time value) is used by two format items: The first format item displays the time, and the second displays the date.</source>
          <target state="translated">Это, поскольку первый объект в списке (значение даты и времени) используется двумя элементами формата: первый отображает элемент форматирования, время, а вторая отображает дату.</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="format" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> недопустим.</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object)">
          <source>The index of a format item is not zero or one.</source>
          <target state="translated">Индекс элемента формата не равен нулю или единице.</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>An object that supplies culture-specific formatting information.</source>
          <target state="translated">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>Строка составного форматирования<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>The first object to format.</source>
          <target state="translated">Первый объект для форматирования.</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>The second object to format.</source>
          <target state="translated">Второй объект для форматирования.</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>Replaces the format items in a string with the string representation of two specified objects.</source>
          <target state="translated">Заменяет элементы формата в строке строковым представлением двух указанных объектов.</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>A parameter supplies culture-specific formatting information.</source>
          <target state="translated">Параметр предоставляет сведения об особенностях форматирования, связанных с языком и региональными параметрами.</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which format items are replaced by the string representations of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> and <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph>.</source>
          <target state="translated">Копия <ph id="ph1">&lt;paramref name="format" /&gt;</ph>, в которой все элементы формата заменены строковыми представлениями <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph> и <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert two expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">Этот метод использует <bpt id="p1">[</bpt>составное форматирование<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> для преобразования в их строковые представления двух выражений и встроить эти представления в строку.</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</source>
          <target state="translated">При выполнении преобразования, метод использует форматирования с учетом языка и региональных параметров или пользовательский модуль форматирования.</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>The method converts each <ph id="ph1">&lt;xref:System.Object&gt;</ph> argument to its string representation by calling its <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> method or, if the object's corresponding format item includes a format string, by calling its <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> method.</source>
          <target state="translated">Метод преобразует каждый <ph id="ph1">&lt;xref:System.Object&gt;</ph> аргумент в строковое представление, вызвав его <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> метода или, если объект к соответствующему элемент форматирования, включающий строку формата, вызвав его <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> метод.</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>If these methods don't exist, it calls the object's parameterless <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> method.</source>
          <target state="translated">Если эти методы не существует, он вызывает метод объекта без параметров <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> метод.</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="format" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> недопустим.</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)">
          <source>The index of a format item is not zero or one.</source>
          <target state="translated">Индекс элемента формата не равен нулю или единице.</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>Строка составного форматирования<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>The first object to format.</source>
          <target state="translated">Первый объект для форматирования.</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>The second object to format.</source>
          <target state="translated">Второй объект для форматирования.</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>The third object to format.</source>
          <target state="translated">Третий объект для форматирования.</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>Replaces the format items in a string with the string representation of three specified objects.</source>
          <target state="translated">Заменяет элементы формата в строке строковым представлением трех указанных объектов.</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which the format items have been replaced by the string representations of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="arg2" /&gt;</ph>.</source>
          <target state="translated">Копия <ph id="ph1">&lt;paramref name="format" /&gt;</ph>, в которой все элементы формата заменены строковыми представлениями <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph> и <ph id="ph4">&lt;paramref name="arg2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert the value of three expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">Этот метод использует <bpt id="p1">[</bpt>составное форматирование<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> для преобразования значения из трех выражений в их строковые представления и встроить эти представления в строку.</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>Example: Formatting three arguments</source>
          <target state="translated">Пример: Форматирование три аргумента</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>This example uses the <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph> method to create a string that illustrates the result of a Boolean <ph id="ph2">`And`</ph> operation with two integer values.</source>
          <target state="translated">В этом примере используется <ph id="ph1">&lt;xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29&gt;</ph> метод, чтобы создать строку, показан результат логического значения <ph id="ph2">`And`</ph> операцию с двумя целочисленными значениями.</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>Note that the format string includes six format items, but the method has only three items in its parameter list, because each item is formatted in two different ways.</source>
          <target state="translated">Обратите внимание, строка формата содержит шесть элементов форматирования, что метод имеет только три элемента в списке параметров, поскольку каждый элемент форматируется различными способами.</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="format" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> недопустим.</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.String,System.Object,System.Object,System.Object)">
          <source>The index of a format item is less than zero, or greater than two.</source>
          <target state="translated">Индекс элемента формата меньше нуля или больше двух.</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>An object that supplies culture-specific formatting information.</source>
          <target state="translated">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>A <bpt id="p1">[</bpt>composite format string<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</source>
          <target state="translated"><bpt id="p1">[</bpt>Строка составного форматирования<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>The first object to format.</source>
          <target state="translated">Первый объект для форматирования.</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>The second object to format.</source>
          <target state="translated">Второй объект для форматирования.</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>The third object to format.</source>
          <target state="translated">Третий объект для форматирования.</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>Replaces the format items in a string with the string representation of three specified objects.</source>
          <target state="translated">Заменяет элементы формата в строке строковым представлением трех указанных объектов.</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>An parameter supplies culture-specific formatting information.</source>
          <target state="translated">Параметр предоставляет сведения об особенностях форматирования, связанных с языком и региональными параметрами.</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>A copy of <ph id="ph1">&lt;paramref name="format" /&gt;</ph> in which the format items have been replaced by the string representations of <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph>, and <ph id="ph4">&lt;paramref name="arg2" /&gt;</ph>.</source>
          <target state="translated">Копия <ph id="ph1">&lt;paramref name="format" /&gt;</ph>, в которой все элементы формата заменены строковыми представлениями <ph id="ph2">&lt;paramref name="arg0" /&gt;</ph>, <ph id="ph3">&lt;paramref name="arg1" /&gt;</ph> и <ph id="ph4">&lt;paramref name="arg2" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>This method uses the <bpt id="p1">[</bpt>composite formatting feature<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> to convert three expressions to their string representations and to embed those representations in a string.</source>
          <target state="translated">Этот метод использует <bpt id="p1">[</bpt>составное форматирование<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> для преобразования в их строковые представления трех выражений и встроить эти представления в строку.</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</source>
          <target state="translated">При выполнении преобразования, метод использует форматирования с учетом языка и региональных параметров или пользовательский модуль форматирования.</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>The method converts each <ph id="ph1">&lt;xref:System.Object&gt;</ph> argument to its string representation by calling its <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> method or, if the object's corresponding format item includes a format string, by calling its <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> method.</source>
          <target state="translated">Метод преобразует каждый <ph id="ph1">&lt;xref:System.Object&gt;</ph> аргумент в строковое представление, вызвав его <bpt id="p1">**</bpt>ToString(IFormatProvider)<ept id="p1">**</ept> метода или, если объект к соответствующему элемент форматирования, включающий строку формата, вызвав его <bpt id="p2">**</bpt>ToString(String,IFormatProvider)<ept id="p2">**</ept> метод.</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>If these methods don't exist, it calls the object's parameterless <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> method.</source>
          <target state="translated">Если эти методы не существует, он вызывает метод объекта без параметров <bpt id="p1">**</bpt>ToString<ept id="p1">**</ept> метод.</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="format" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="format" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="format" /&gt;</ph> недопустим.</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" uid="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)">
          <source>The index of a format item is less than zero, or greater than two.</source>
          <target state="translated">Индекс элемента формата меньше нуля или больше двух.</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" uid="M:System.String.GetEnumerator">
          <source>Retrieves an object that can iterate through the individual characters in this string.</source>
          <target state="translated">Извлекает объект, который может выполнять итерацию отдельных знаков данной строки.</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" uid="M:System.String.GetEnumerator">
          <source>An enumerator object.</source>
          <target state="translated">Объект перечислителя.</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source>Rather than calling the <ph id="ph1">&lt;xref:System.String.GetEnumerator%2A&gt;</ph> method to retrieve a <ph id="ph2">&lt;xref:System.CharEnumerator&gt;</ph> object that you then use to enumerate a string, you should instead use your language's iteration construct ( in C#,  in C++/CLR, and  in Visual Basic).</source>
          <target state="translated">Вместо вызова <ph id="ph1">&lt;xref:System.String.GetEnumerator%2A&gt;</ph> метод для извлечения <ph id="ph2">&lt;xref:System.CharEnumerator&gt;</ph> объект можно затем использовать для перечисления строки, следует использовать конструкцию итерации ваш язык (в C#, в C + +/ CLR и в Visual Basic).</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source><bpt id="p1">[</bpt>foreach<ept id="p1">](~/docs/csharp/language-reference/keywords/foreach-in.md)</ept> in C#,                  <bpt id="p2">[</bpt>for each<ept id="p2">](http://msdn.microsoft.com/library/0c3a364b-2747-43f3-bb8d-b7d3b7023f79)</ept> in C++/CLR, and                  <bpt id="p3">[</bpt>For Each<ept id="p3">](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md)</ept> in Visual Basic).</source>
          <target state="translated"><bpt id="p1">[</bpt>foreach<ept id="p1">](~/docs/csharp/language-reference/keywords/foreach-in.md)</ept> в C# <bpt id="p2">[</bpt>для каждого<ept id="p2">](http://msdn.microsoft.com/library/0c3a364b-2747-43f3-bb8d-b7d3b7023f79)</ept> в C + +/ CLR, и <bpt id="p3">[</bpt>для каждого<ept id="p3">](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md)</ept> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source>This method enables you to iterate the individual characters in a string.</source>
          <target state="translated">Этот метод позволяет итерацию отдельных знаков в строке.</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source>For example, the Visual Basic <ph id="ph1">`For Each`</ph> and C# <ph id="ph2">`foreach`</ph> statements invoke this method to return a <ph id="ph3">&lt;xref:System.CharEnumerator&gt;</ph> object that can provide read-only access to the characters in this string instance.</source>
          <target state="translated">Например, Visual Basic <ph id="ph1">`For Each`</ph> и C# <ph id="ph2">`foreach`</ph> инструкции вызывать этот метод для возврата <ph id="ph3">&lt;xref:System.CharEnumerator&gt;</ph> объект, способный предоставлять доступ только для чтения к знаки данного экземпляра строки.</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source>The following example iterates the characters in several strings and displays information about their individual characters.</source>
          <target state="translated">В следующем примере выполняется итерация символы в нескольких строках и отображает сведения об их отдельных символов.</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetEnumerator">
          <source>It uses the language iteration construct rather than a call to the <ph id="ph1">&lt;xref:System.String.GetEnumerator%2A&gt;</ph> method.</source>
          <target state="translated">Она использует языковой конструкции итерации, а не вызов <ph id="ph1">&lt;xref:System.String.GetEnumerator%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" uid="M:System.String.GetHashCode">
          <source>Returns the hash code for this string.</source>
          <target state="translated">Возвращает хэш-код для этой строки.</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" uid="M:System.String.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Хэш-код в виде 32-разрядного целого числа со знаком.</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The behavior of <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph> is dependent on its implementation, which might change from one version of the common language runtime to another.</source>
          <target state="translated">Поведение <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph> зависит от его реализации, которая может изменяться от одной версии среды CLR в другой.</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>A reason why this might happen is to improve the performance of <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph>.</source>
          <target state="translated">Причина, почему это произошло заключается в повышении производительности <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>If two string objects are equal, the <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph> method returns identical values.</source>
          <target state="translated">Если два строковых объекта равны, <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph> метод возвращает одинаковые значения.</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>However, there is not a unique hash code value for each unique string value.</source>
          <target state="translated">Тем не менее не уникальный хэш-кодом для каждого уникального строкового значения.</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Different strings can return the same hash code.</source>
          <target state="translated">Различные строки могут возвращать тот же хэш-код.</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The hash code itself is not guaranteed to be stable.</source>
          <target state="translated">Хэш-код, сам не обязательно быть нестабильным.</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Hash codes for identical strings can differ across versions of the .NET Framework and across platforms (such as 32-bit and 64-bit) for a single version of the .NET Framework.</source>
          <target state="translated">Хэш-коды для одинаковых строк может отличаться в разных версий платформы .NET Framework и платформ (таких как 32-разрядные и 64-разрядных) для одной версии платформы .NET Framework.</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>In some cases, they can even differ by application domain.</source>
          <target state="translated">В некоторых случаях можно даже зависят от домена приложения.</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>This implies two subsequent runs of the same program may return different hash codes.</source>
          <target state="translated">Это означает, что в последующих запусках той же программы могут возвращать различные хэш-кодов.</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>As a result, hash codes should never be used outside of the application domain in which they were created, they should never be used as key fields in a collection, and they should never be persisted.</source>
          <target state="translated">В результате хэш кодов никогда не должно использоваться за пределами домена приложения, в котором они были созданы, они никогда не должны использоваться в качестве ключевых полей в коллекции и они никогда не должен быть сохранен.</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Finally, don't use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</source>
          <target state="translated">Наконец не используйте хэш-код вместо значения, возвращенные шифрования функции хэширования, если вам требуется криптостойкой хэш.</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>For cryptographic hashes, use a class derived from the <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType&gt;</ph> class.</source>
          <target state="translated">Для криптографическое хэширование, используйте класс, производный от <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>For more information about hash codes, see <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о хэш-кодах см. в разделе <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>In desktop apps, you can use the             <bpt id="p1">[</bpt><ph id="ph1">\&lt;</ph>UseRandomizedStringHashAlgorithm&gt; element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept> to generate unique hash codes on a per application domain basis.</source>
          <target state="translated">В настольных приложениях можно использовать <bpt id="p1">[</bpt> <ph id="ph1">\&lt;</ph>UseRandomizedStringHashAlgorithm &gt; элемент<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept> создания уникальный хэш-кодов для каждого домена приложения.</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables.</source>
          <target state="translated">Это может уменьшить количество конфликтов и повысить общую производительность операции вставки и уточняющих запросов, использующих хэш-таблицы.</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The following example shows how to use the                <bpt id="p1">[</bpt><ph id="ph1">\&lt;</ph>UseRandomizedStringHashAlgorithm&gt; element<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept>.</source>
          <target state="translated">В следующем примере показано, как использовать <bpt id="p1">[</bpt> <ph id="ph1">\&lt;</ph>UseRandomizedStringHashAlgorithm &gt; элемент<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>It defines a  to generate unique hash codes on a per application domain basis.</source>
          <target state="translated">Он определяет создания уникальный хэш-кодов для каждого домена приложения.</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables.</source>
          <target state="translated">Это может уменьшить количество конфликтов и повысить общую производительность операции вставки и уточняющих запросов, использующих хэш-таблицы.</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The following example shows how to use the .</source>
          <target state="translated">В следующем примере показано, как использовать.</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>It defines a <ph id="ph1">`DisplayString`</ph> class that includes a private string constant, <ph id="ph2">`s`</ph>, whose value is "This is a string."</source>
          <target state="translated">Он определяет <ph id="ph1">`DisplayString`</ph> класс, который содержит частную строковую константу, <ph id="ph2">`s`</ph>, значение которого является «Это строка».</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>It also includes a <ph id="ph1">`ShowStringHashCode`</ph> method that displays the string value and its hash code along with the name of the application domain in which the method is executing.</source>
          <target state="translated">Он также включает метод <ph id="ph1">`ShowStringHashCode`</ph>, который отображает значение строки и ее хэш-код вместе с именем домена приложения, в котором метод выполняется.</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>When you run the example without supplying a configuration file, it displays output similar to the following.</source>
          <target state="translated">При выполнении примера без указания файла конфигурации он отображает подобный следующему вывод.</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Note that the hash codes for the string are identical in the two application domains.</source>
          <target state="translated">Обратите внимание, что хэш-коды для строки идентичны в обоих доменах приложений.</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>However, if you add the following configuration file to the example's directory and then run the example, the hash codes for the same string will differ by application domain.</source>
          <target state="translated">Однако при добавлении следующего файла конфигурации в каталог примеров и запуске примера, хэш-коды для той же строки будут отличаться по домену приложения.</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>When the configuration file is present, the example displays the following output:</source>
          <target state="translated">Если файл конфигурации существует, пример отображает следующие выходные данные:</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Hash codes are used to insert and retrieve keyed objects from hash tables efficiently.</source>
          <target state="translated">Хэш-кодов используются для вставки и извлечения с ключом объектов из хэш-таблицы эффективно.</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>However, hash codes don't uniquely identify strings.</source>
          <target state="translated">Однако хэш-кодов не уникальным идентификатором строки.</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Identical strings have  equal hash codes, but the common language runtime can also assign the same hash code to different strings.</source>
          <target state="translated">Идентичные строки имеют равные хэш-кодов, но среда также может назначать же хэш-код для разных строк.</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>In addition, hash codes can vary by version of the .NET Framework, by platform within a single version, and by application domain.</source>
          <target state="translated">Кроме того хэш-коды можно различаются по версии платформы .NET Framework, платформа в рамках одной версии и домена приложения.</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>Because of this, you should not serialize or persist hash code values, nor should you use them as keys in a hash table or dictionary.</source>
          <target state="translated">По этой причине не следует сериализовать или сохранить значения хэш-кода, и не следует использовать их как ключи в словаре или хэш-таблицы.</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>For additional information about the use of hash codes and the <ph id="ph1">`GetHashCode`</ph> method, see <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения об использовании хэш-кодов и <ph id="ph1">`GetHashCode`</ph> метода, в разделе <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph> method using various input strings.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">&lt;xref:System.String.GetHashCode%2A&gt;</ph> метод, с помощью различных входных строк.</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>The value returned by <ph id="ph1">&lt;see cref="M:System.String.GetHashCode" /&gt;</ph> is platform-dependent.</source>
          <target state="translated">Значение, возвращаемое <ph id="ph1">&lt;see cref="M:System.String.GetHashCode" /&gt;</ph> зависит от платформы.</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>It differs on the 32-bit and 64-bit versions of the .NET Framework.</source>
          <target state="translated">Отличается в 32-разрядных и 64-разрядной версии платформы .NET Framework.</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetHashCode">
          <source>It also can differ between versions of the .NET Framework.</source>
          <target state="translated">Он также могут различаться в разных версиях .NET Framework.</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" uid="M:System.String.GetTypeCode">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.TypeCode" /&gt;</ph> for class <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Возвращает <ph id="ph1">&lt;see cref="T:System.TypeCode" /&gt;</ph> для класса <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" uid="M:System.String.GetTypeCode">
          <source>The enumerated constant, <ph id="ph1">&lt;see cref="F:System.TypeCode.String" /&gt;</ph>.</source>
          <target state="translated">Константа перечислимого типа, <ph id="ph1">&lt;see cref="F:System.TypeCode.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.GetTypeCode">
          <source>The following example displays the <ph id="ph1">&lt;xref:System.TypeCode&gt;</ph> enumerated constant for the <ph id="ph2">&lt;xref:System.String&gt;</ph> type.</source>
          <target state="translated">В следующем примере отображается <ph id="ph1">&lt;xref:System.TypeCode&gt;</ph> перечислимой константы для <ph id="ph2">&lt;xref:System.String&gt;</ph> типа.</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Reports the zero-based index of the first occurrence of a specified Unicode character or string within this instance.</source>
          <target state="translated">Возвращает индекс с отсчетом от нуля первого вхождения указанного символа Юникода или строки в пределах данного экземпляра.</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>The method returns -1 if the character or string is not found in this instance.</source>
          <target state="translated">Метод возвращает -1, если знак или строка не найдена в данном экземпляре.</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char)">
          <source>A Unicode character to seek.</source>
          <target state="translated">Искомый знак Юникода.</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char)">
          <source>Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</source>
          <target state="translated">Возвращает индекс с отсчетом от нуля первого вхождения указанного символа Юникода в данной строке.</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that character is found, or -1 if it is not.</source>
          <target state="translated">Отсчитываемое от нуля значение индекса параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, если этот знак найден; в противном случае — значение -1.</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Индексация начинается с нуля.</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярные значения в Юникоде.</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Для выполнения поиска с учетом языка и региональных параметров используйте <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> метод, где скалярное значение Юникода, представляющее составной знак, таких как лигатуры «Æ» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения компонентов символа в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char)">
          <source>The following example demonstrates how you can search a <ph id="ph1">&lt;xref:System.String&gt;</ph> for a character using the <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере показано, как можно выполнить поиск <ph id="ph1">&lt;xref:System.String&gt;</ph> символ с помощью <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String)">
          <source>The string to seek.</source>
          <target state="translated">Строка для поиска.</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String)">
          <source>Reports the zero-based index of the first occurrence of the specified string in this instance.</source>
          <target state="translated">Возвращает индекс с отсчетом от нуля первого вхождения значения указанной строки в данном экземпляре.</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that string is found, or -1 if it is not.</source>
          <target state="translated">Положение в индексе (начиная с нуля) параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, если эта строка найдена, или значение -1, если она не найдена.</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is 0.</source>
          <target state="translated">Если значение <ph id="ph1">&lt;paramref name="value" /&gt;</ph> равно <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, то возвращаемое значение равно 0.</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Индексация начинается с нуля.</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">Этот метод выполняет поиск слова (с учетом регистра и культуры) с использованием текущего языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>The search begins at the first character position of this instance and continues until the last character position.</source>
          <target state="translated">Поиск начинается с позиции первого знака данного экземпляра и продолжается до последней позиции знака.</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Если при поиске с учетом языка и региональных параметров параметр <ph id="ph1">`value`</ph> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом.</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> состоит только из одного или нескольких игнорируемые символы, <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> метод всегда возвращает 0 (ноль), чтобы указать совпадения в начале текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</source>
          <target state="translated">В следующем примере <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> метод используется для поиска три подстроки (мягкий перенос (U + 00AD) мягкого переноса, а затем «n» и мягкий перенос буквой «m») в двух строк.</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>Only one of the strings contains a soft hyphen.</source>
          <target state="translated">Только одна из строк содержит мягкий перенос.</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in <ph id="ph2">`value`</ph>.</source>
          <target state="translated">Если пример выполняется <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> или более поздней версии, в каждом случае, поскольку мягкий перенос является игнорируемый символ, результат равен как если бы мягкий перенос не были включены в <ph id="ph2">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>When searching for a soft hyphen only, the method returns 0 (zero) to indicate that it has found a match at the beginning of the string.</source>
          <target state="translated">При поиске мягкий перенос, метод возвращает 0 (ноль), чтобы указать, что обнаружено совпадение в начале строки.</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>The following example searches for the "n" in "animal".</source>
          <target state="translated">Следующий пример просматривает «n» в «animal».</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>Because string indexes begin at zero rather than one, the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> method indicates that the "n" is at position 1.</source>
          <target state="translated">Так как строка индексы отсчитываются с нуля, а не, <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%29&gt;</ph> метод указывает, что «н» в позиции 1.</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method to determine the starting position of an animal name in a sentence.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> метод, чтобы определить начальную позицию имени животных предложения.</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>It then uses this position to insert an adjective that describes the animal into the sentence.</source>
          <target state="translated">Затем эта позиция используется для вставки прилагательное, которое описывает животное в предложении.</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Как описано в статье <bpt id="p1">[</bpt>советы и рекомендации по использованию строк<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, рекомендуется избегать вызова методов сравнения строк, которые заменяют значения по умолчанию и вместо этого вызывают методы, которые требуют явного указания параметров.</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String)">
          <source>To find the first index of a substring within a string instance by using the comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">`comparisonType`</ph> parameter.</source>
          <target state="translated">Чтобы найти первый индекс подстроки в пределах экземпляра строки, используя правила сравнения строк для текущего языка и региональных параметров, вызовите <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph> перегрузка метода со значением <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> для его <ph id="ph3">`comparisonType`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>A Unicode character to seek.</source>
          <target state="translated">Искомый знак Юникода.</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Позиция, с которой начинается поиск.</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</source>
          <target state="translated">Возвращает индекс с отсчетом от нуля первого вхождения указанного символа Юникода в данной строке.</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The search starts at a specified character position.</source>
          <target state="translated">Поиск начинается с указанной позиции знака.</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> from the start of the string if that character is found, or -1 if it is not.</source>
          <target state="translated">Отсчитываемая от нуля позиция индекса параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph> с начала строки, если символ найден. Значение –1, если символ не найден.</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>Index numbering starts from 0.</source>
          <target state="translated">Индексация начинается с 0.</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated">Параметр <ph id="ph1">`startIndex`</ph> может иметь значение в диапазоне от 0 до длины экземпляра строки.</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> equals the length of the string instance, the method returns -1.</source>
          <target state="translated">Если <ph id="ph1">`startIndex`</ph> равно сумме длины экземпляра строки, то метод возвращает значение -1.</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The search ranges from <ph id="ph1">`startIndex`</ph> to the end of the string.</source>
          <target state="translated">Поиск в диапазоне от <ph id="ph1">`startIndex`</ph> до конца строки.</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярные значения в Юникоде.</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Для выполнения поиска с учетом языка и региональных параметров используйте <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> метод, где скалярное значение Юникода, представляющее составной знак, таких как лигатуры «Æ» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения компонентов символа в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is less than 0 (zero) or greater than the length of the string.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> меньше 0 (нуля) или больше, чем длина строки.</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The string to seek.</source>
          <target state="translated">Строка для поиска.</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Позиция, с которой начинается поиск.</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>Reports the zero-based index of the first occurrence of the specified string in this instance.</source>
          <target state="translated">Возвращает индекс с отсчетом от нуля первого вхождения значения указанной строки в данном экземпляре.</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The search starts at a specified character position.</source>
          <target state="translated">Поиск начинается с указанной позиции знака.</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> from the start of the current instance if that string is found, or -1 if it is not.</source>
          <target state="translated">Отсчитываемая от нуля позиция индекса параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph> с начала текущего экземпляра, если строка найдена. Значение –1, если строка не найдена.</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">Если значение параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph> равно <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, возвращаемым значением является <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>Index numbering starts from 0.</source>
          <target state="translated">Индексация начинается с 0.</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated">Параметр <ph id="ph1">`startIndex`</ph> может иметь значение в диапазоне от 0 до длины экземпляра строки.</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> equals the length of the string instance, the method returns -1.</source>
          <target state="translated">Если <ph id="ph1">`startIndex`</ph> равно сумме длины экземпляра строки, то метод возвращает значение -1.</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">Этот метод выполняет поиск слова (с учетом регистра и культуры) с использованием текущего языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position of this instance and continues until the last character position.</source>
          <target state="translated">Поиск начинается с <ph id="ph1">`startIndex`</ph> символ позицию данного экземпляра и продолжается до последней позиции знака.</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Если при поиске с учетом языка и региональных параметров параметр <ph id="ph1">`value`</ph> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом.</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29&gt;</ph> method always returns <ph id="ph3">`startIndex`</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> состоит только из одного или нескольких игнорируемые символы, <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29&gt;</ph> метод всегда возвращает <ph id="ph3">`startIndex`</ph>, являющееся позицию символа, с которого начинается поиск.</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in two strings.</source>
          <target state="translated">В следующем примере <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%29&gt;</ph> метод позволяет определить позицию мягкий перенос (U + 00AD) буквой «m» в двух строк.</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">Только одна из строк содержит требуемую подстроку.</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string.</source>
          <target state="translated">Если пример выполняется <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> или более поздней версии, в обоих случаях, поскольку мягкий перенос является игнорируемый символ, метод возвращает индекс «m» в строке.</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</source>
          <target state="translated">Обратите внимание, что в случае первой строки, содержащей мягкий перенос перед буквой "m", этот метод возвращает не индекс мягкого переноса, а индекс буквы "m".</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>The following example searches for all occurrences of a specified string within a target string.</source>
          <target state="translated">Следующий пример просматривает все вхождения указанной строки в целевой строке.</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is less than 0 (zero) or greater than the length of this string.</source>
          <target state="translated">параметр <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> меньше 0 (нуля) или больше длины этой строки.</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Как описано в статье <bpt id="p1">[</bpt>советы и рекомендации по использованию строк<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, рекомендуется избегать вызова методов сравнения строк, которые заменяют значения по умолчанию и вместо этого вызывают методы, которые требуют явного указания параметров.</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32)">
          <source>To find the first index of a substring that occurs after a particular character position by using the comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">`comparisonType`</ph> parameter.</source>
          <target state="translated">Чтобы найти первый индекс подстроки, происходит после позиции конкретного символа, используя правила сравнения строк для текущего языка и региональных параметров, вызовите <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> перегрузка метода со значением <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> для его <ph id="ph3">`comparisonType`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">Строка для поиска.</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">Одно из значений перечисления, определяющее правила поиска.</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>Reports the zero-based index of the first occurrence of the specified string in the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Возвращает индекс с отсчетом от нуля первого вхождения указанной строки в текущем объекте <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>A parameter specifies the type of search to use for the specified string.</source>
          <target state="translated">Параметр определяет тип поиска заданной строки.</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>The index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter if that string is found, or -1 if it is not.</source>
          <target state="translated">Индекс позиции строки, заданной в параметре <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, если она найдена, и -1, если нет.</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is 0.</source>
          <target state="translated">Если значение <ph id="ph1">&lt;paramref name="value" /&gt;</ph> равно <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, то возвращаемое значение равно 0.</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Индексация начинается с нуля.</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated"><ph id="ph1">`comparisonType`</ph> Указывает параметр для поиска <ph id="ph2">`value`</ph> параметра с помощью текущего или инвариантного языка и региональных параметров, с помощью поиска с учетом регистра и без учета регистра и с помощью Microsoft word или правил сравнения по порядковому номеру.</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method that find the first occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">Exampledemonstrates следующие три перегрузки <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> метод, который поиска первого экземпляра строки внутри другой строки с использованием разных значениях <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> перечисления.</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> не является допустимым значением <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Если при поиске с учетом языка и региональных параметров (то есть, если параметр <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> не имеет значение <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> или <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>) параметр <ph id="ph4">&lt;paramref name="value" /&gt;</ph> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом.</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.</source>
          <target state="translated">Если <ph id="ph1">&lt;paramref name="value" /&gt;</ph> состоит только из одного или нескольких игнорируемые символы, <ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph> метод всегда возвращает 0 (ноль), чтобы указать совпадения в начале текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</source>
          <target state="translated">В следующем примере <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /&gt;</ph> метод используется для поиска три подстроки (мягкий перенос (U + 00AD) мягкого переноса, а затем «n» и мягкий перенос буквой «m») в двух строк.</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>Only one of the strings contains a soft hyphen.</source>
          <target state="translated">Только одна из строк содержит мягкий перенос.</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string.</source>
          <target state="translated">Если пример выполняется <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> или более поздней версии, поскольку мягкий перенос является игнорируемым символом, поиск с учетом языка и региональных параметров возвращает то же значение, то будет возвращено, если мягкий перенос не были включены в строку поиска.</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.StringComparison)">
          <source>An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.</source>
          <target state="translated">Поиск по порядковым номерам, однако успешно находит мягкого переноса в одной строке и сообщает, что он не существует из второй строки.</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>A Unicode character to seek.</source>
          <target state="translated">Искомый знак Юникода.</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Позиция, с которой начинается поиск.</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Количество позиций знаков для проверки.</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>Reports the zero-based index of the first occurrence of the specified character in this instance.</source>
          <target state="translated">Возвращает индекс с отсчетом от нуля первого вхождения указанного символа в данном экземпляре.</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search starts at a specified character position and examines a specified number of character positions.</source>
          <target state="translated">Поиск начинается с указанной позиции знака; проверяется заданное количество позиций.</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> from the start of the string if that character is found, or -1 if it is not.</source>
          <target state="translated">Отсчитываемая от нуля позиция индекса параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph> с начала строки, если символ найден. Значение –1, если символ не найден.</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search begins at <ph id="ph1">`startIndex`</ph> and continues to <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`count`</ph> -1.</source>
          <target state="translated">Поиск начинается с <ph id="ph1">`startIndex`</ph> и продолжает <ph id="ph2">`startIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`count`</ph> -1.</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The character at <ph id="ph1">`startIndex`</ph><ph id="ph2"> + </ph><ph id="ph3">`count`</ph> is not included in the search.</source>
          <target state="translated">Символ в <ph id="ph1">`startIndex`</ph> <ph id="ph2"> + </ph> <ph id="ph3">`count`</ph> не включены в поиск.</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>Index numbering starts from 0 (zero).</source>
          <target state="translated">Индексация начинается с 0 (ноль).</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated">Параметр <ph id="ph1">`startIndex`</ph> может иметь значение в диапазоне от 0 до длины экземпляра строки.</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярные значения в Юникоде.</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Для выполнения поиска с учетом языка и региональных параметров используйте <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> метод, где скалярное значение Юникода, представляющее составной знак, таких как лигатуры «Æ» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения компонентов символа в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> or <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> или <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> является отрицательным значением.</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is greater than the length of this string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> больше длины этой строки.</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is greater than the length of this string minus <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> больше, чем длина этой строки минус <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The string to seek.</source>
          <target state="translated">Строка для поиска.</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Позиция, с которой начинается поиск.</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Количество позиций знаков для проверки.</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Reports the zero-based index of the first occurrence of the specified string in this instance.</source>
          <target state="translated">Возвращает индекс с отсчетом от нуля первого вхождения значения указанной строки в данном экземпляре.</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The search starts at a specified character position and examines a specified number of character positions.</source>
          <target state="translated">Поиск начинается с указанной позиции знака; проверяется заданное количество позиций.</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> from the start of the current instance if that string is found, or -1 if it is not.</source>
          <target state="translated">Отсчитываемая от нуля позиция индекса параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph> с начала текущего экземпляра, если строка найдена. Значение –1, если строка не найдена.</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">Если значение параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph> равно <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, возвращаемым значением является <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Index numbering starts from 0 (zero).</source>
          <target state="translated">Индексация начинается с 0 (ноль).</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated">Параметр <ph id="ph1">`startIndex`</ph> может иметь значение в диапазоне от 0 до длины экземпляра строки.</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">Этот метод выполняет поиск слова (с учетом регистра и культуры) с использованием текущего языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The search begins at <ph id="ph1">`startIndex`</ph> and continues to <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`count`</ph> -1.</source>
          <target state="translated">Поиск начинается с <ph id="ph1">`startIndex`</ph> и продолжает <ph id="ph2">`startIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`count`</ph> -1.</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The character at <ph id="ph1">`startIndex`</ph><ph id="ph2"> + </ph><ph id="ph3">`count`</ph> is not included in the search.</source>
          <target state="translated">Символ в <ph id="ph1">`startIndex`</ph> <ph id="ph2"> + </ph> <ph id="ph3">`count`</ph> не включены в поиск.</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Если при поиске с учетом языка и региональных параметров параметр <ph id="ph1">`value`</ph> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом.</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method always returns <ph id="ph3">`startIndex`</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> состоит только из одного или нескольких игнорируемые символы, <ph id="ph2">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> метод всегда возвращает <ph id="ph3">`startIndex`</ph>, являющееся позицию символа, с которого начинается поиск.</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings.</source>
          <target state="translated">В следующем примере <ph id="ph1">&lt;xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> метод позволяет найти позицию (U + 00AD) мягкий перенос перед буквой «m», начиная с третьего по шестой позиции символов в двух строк.</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">Только одна из строк содержит требуемую подстроку.</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">Если пример выполняется <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> или более поздней версии, в обоих случаях, поскольку мягкий перенос является игнорируемый символ, метод возвращает индекс «m» в строке при сравнении с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</source>
          <target state="translated">Обратите внимание, что в случае первой строки, содержащей мягкий перенос перед буквой "m", этот метод возвращает не индекс мягкого переноса, а индекс буквы "m".</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>The following example finds the index of all occurrences of the string "he" within a substring of another string.</source>
          <target state="translated">Следующий пример выполняет поиск всех вхождений строки «he» в подстроке другой строки.</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>Note that the number of characters to be searched must be recalculated for each search iteration.</source>
          <target state="translated">Обратите внимание, что количество символов для поиска должен вычисляться для каждой итерации поиска.</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> or <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> или <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> является отрицательным значением.</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is greater than the length of this string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> больше длины этой строки.</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is greater than the length of this string minus <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> больше, чем длина этой строки минус <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Как описано в статье <bpt id="p1">[</bpt>советы и рекомендации по использованию строк<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, рекомендуется избегать вызова методов сравнения строк, которые заменяют значения по умолчанию и вместо этого вызывают методы, которые требуют явного указания параметров.</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32)">
          <source>To use the comparison rules of the current culture to perform this operation, call the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">`comparisonType`</ph> parameter.</source>
          <target state="translated">Чтобы использовать правила сравнения строк для текущего языка и региональных параметров для выполнения этой операции, вызовите <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> перегрузка метода со значением <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> для его <ph id="ph3">`comparisonType`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">Строка для поиска.</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The search starting position.</source>
          <target state="translated">Позиция, с которой начинается поиск.</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">Одно из значений перечисления, определяющее правила поиска.</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Reports the zero-based index of the first occurrence of the specified string in the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Возвращает индекс с отсчетом от нуля первого вхождения указанной строки в текущем объекте <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Parameters specify the starting search position in the current string and the type of search to use for the specified string.</source>
          <target state="translated">Параметры задают начальную позицию поиска в текущей строке и тип поиска.</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The zero-based index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter from the start of the current instance if that string is found, or -1 if it is not.</source>
          <target state="translated">Отсчитываемая от нуля позиция параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph> с начала текущего экземпляра, если строка найдена, или -1, если нет.</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">Если значение параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph> равно <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, возвращаемым значением является <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Index numbering starts from 0.</source>
          <target state="translated">Индексация начинается с 0.</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated">Параметр <ph id="ph1">`startIndex`</ph> может иметь значение в диапазоне от 0 до длины экземпляра строки.</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">`startIndex`</ph> equals the length of the string instance, the method returns -1.</source>
          <target state="translated">Если <ph id="ph1">`startIndex`</ph> равно сумме длины экземпляра строки, то метод возвращает значение -1.</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated"><ph id="ph1">`comparisonType`</ph> Указывает параметр для поиска <ph id="ph2">`value`</ph> параметра с помощью текущего или инвариантного языка и региональных параметров, с помощью поиска с учетом регистра и без учета регистра и с помощью Microsoft word или правил сравнения по порядковому номеру.</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method that find the first occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">Exampledemonstrates следующие три перегрузки <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> метод, который поиска первого экземпляра строки внутри другой строки с использованием разных значениях <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> перечисления.</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is less than 0 (zero) or greater than the length of this string.</source>
          <target state="translated">параметр <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> меньше 0 (нуля) или больше длины этой строки.</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> не является допустимым значением <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Если при поиске с учетом языка и региональных параметров (то есть, если параметр <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> не имеет значение <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> или <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>) параметр <ph id="ph4">&lt;paramref name="value" /&gt;</ph> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом.</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method always returns <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Если <ph id="ph1">&lt;paramref name="value" /&gt;</ph> состоит только из одного или нескольких игнорируемые символы, <ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> метод всегда возвращает <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, являющееся позицию символа, с которого начинается поиск.</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting with the third character position in two strings.</source>
          <target state="translated">В следующем примере <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> метод позволяет определить позицию мягкий перенос (U + 00AD) буквой «m», начиная с третьего положение символа в двух строк.</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Only one of the strings contains the required substring.If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">Только одна из строк содержит требуемую подстроку. Если пример выполняется <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> или более поздней версии, в обоих случаях, поскольку мягкий перенос является игнорируемый символ, метод возвращает индекс «m» в строке при сравнении с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</source>
          <target state="translated">Обратите внимание, что в случае первой строки, содержащей мягкий перенос перед буквой "m", этот метод возвращает не индекс мягкого переноса, а индекс буквы "m".</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</source>
          <target state="translated">Этот метод возвращает индекс мягкого переноса в первой строке только при выполнении порядкового сравнения.</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">Строка для поиска.</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search starting position.</source>
          <target state="translated">Позиция, с которой начинается поиск.</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Количество позиций знаков для проверки.</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">Одно из значений перечисления, определяющее правила поиска.</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Reports the zero-based index of the first occurrence of the specified string in the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Возвращает индекс с отсчетом от нуля первого вхождения указанной строки в текущем объекте <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Parameters specify the starting search position in the current string, the number of characters in the current string to search, and the type of search to use for the specified string.</source>
          <target state="translated">Параметры задают начальную позицию поиска в текущей строке, количество проверяемых знаков текущей строки и тип поиска.</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The zero-based index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter from the start of the current instance if that string is found, or -1 if it is not.</source>
          <target state="translated">Отсчитываемая от нуля позиция параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph> с начала текущего экземпляра, если строка найдена, или -1, если нет.</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">Если значение параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph> равно <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, возвращаемым значением является <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Index numbering starts from 0 (zero).</source>
          <target state="translated">Индексация начинается с 0 (ноль).</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to the length of the string instance.</source>
          <target state="translated">Параметр <ph id="ph1">`startIndex`</ph> может иметь значение в диапазоне от 0 до длины экземпляра строки.</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search begins at <ph id="ph1">`startIndex`</ph> and continues to <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`count`</ph> -1.</source>
          <target state="translated">Поиск начинается с <ph id="ph1">`startIndex`</ph> и продолжает <ph id="ph2">`startIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`count`</ph> -1.</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The character at <ph id="ph1">`startIndex`</ph><ph id="ph2"> + </ph><ph id="ph3">`count`</ph> is not included in the search.</source>
          <target state="translated">Символ в <ph id="ph1">`startIndex`</ph> <ph id="ph2"> + </ph> <ph id="ph3">`count`</ph> не включены в поиск.</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated"><ph id="ph1">`comparisonType`</ph> Указывает параметр для поиска <ph id="ph2">`value`</ph> параметра с помощью текущего или инвариантного языка и региональных параметров, с помощью поиска с учетом регистра и без учета регистра и с помощью Microsoft word или правил сравнения по порядковому номеру.</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method that find the first occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">Exampledemonstrates следующие три перегрузки <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> метод, который поиска первого экземпляра строки внутри другой строки с использованием разных значениях <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> перечисления.</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> or <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> или <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> является отрицательным значением.</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is greater than the length of this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> больше длины этого экземпляра.</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is greater than the length of this string minus <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> больше, чем длина этой строки минус <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> не является допустимым значением <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Если при поиске с учетом языка и региональных параметров (то есть, если параметр <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> не имеет значение <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> или <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>) параметр <ph id="ph4">&lt;paramref name="value" /&gt;</ph> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом.</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method always returns <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Если <ph id="ph1">&lt;paramref name="value" /&gt;</ph> состоит только из одного или нескольких игнорируемые символы, <ph id="ph2">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> метод всегда возвращает <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, являющееся позицию символа, с которого начинается поиск.</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings.</source>
          <target state="translated">В следующем примере <ph id="ph1">&lt;see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> метод позволяет найти позицию (U + 00AD) мягкий перенос перед буквой «m», начиная с третьего по шестой позиции символов в двух строк.</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">Только одна из строк содержит требуемую подстроку.</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">Если пример выполняется <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> или более поздней версии, в обоих случаях, поскольку мягкий перенос является игнорируемый символ, метод возвращает индекс «m» в строке при сравнении с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>When it performs an ordinal comparison, however, it finds the substring only in the first string.</source>
          <target state="translated">Когда он выполняет порядковое сравнение, однако она находит подстроку только в первой строке.</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison.</source>
          <target state="translated">Обратите внимание, что в случае первой строки, содержащей мягкий перенос перед буквой «m», метод не возвращает индекс мягкого переноса, а вместо этого возвращает индекс символа «m», при сравнении с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</source>
          <target state="translated">Этот метод возвращает индекс мягкого переноса в первой строке только при выполнении порядкового сравнения.</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Reports the index of the first occurrence in this instance of any character in a specified array of Unicode characters.</source>
          <target state="translated">Возвращает индекс первого обнаруженного в данном экземпляре знака из указанного массива знаков Юникода.</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>The method returns -1 if the characters in the array are not found in this instance.</source>
          <target state="translated">Метод возвращает -1, если знаки массива не найдены в этом экземпляре.</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Массив знаков Юникода, содержащий один или несколько искомых знаков.</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</source>
          <target state="translated">Возвращает индекс с отсчетом от нуля первого обнаруженного в данном экземпляре символа из указанного массива символов Юникода.</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>The zero-based index position of the first occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found.</source>
          <target state="translated">Начинающееся с нуля значение индекса первого вхождения какого-либо знака из <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> в данном экземпляре; -1, если не найден ни один знак из <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Индексация начинается с нуля.</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>The search for <ph id="ph1">`anyOf`</ph> is case-sensitive.</source>
          <target state="translated">Поиск <ph id="ph1">`anyOf`</ph> учитывается регистр.</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>If <ph id="ph1">`anyOf`</ph> is an empty array, the method finds a match at the beginning of the string (that  is, at index zero).</source>
          <target state="translated">Если <ph id="ph1">`anyOf`</ph> — пустой массив, находит метод a совпадения в начале строки (то есть в нулевом индексе).</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярные значения в Юникоде.</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Для выполнения поиска с учетом языка и региональных параметров используйте <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> метод, где скалярное значение Юникода, представляющее составной знак, таких как лигатуры «Æ» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения компонентов символа в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[])">
          <source>The following example finds the first vowel in a string.</source>
          <target state="translated">В следующем примере вычисляется первая буква в строке.</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[])">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Массив знаков Юникода, содержащий один или несколько искомых знаков.</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Позиция, с которой начинается поиск.</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</source>
          <target state="translated">Возвращает индекс с отсчетом от нуля первого обнаруженного в данном экземпляре символа из указанного массива символов Юникода.</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The search starts at a specified character position.</source>
          <target state="translated">Поиск начинается с указанной позиции знака.</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The zero-based index position of the first occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found.</source>
          <target state="translated">Начинающееся с нуля значение индекса первого вхождения какого-либо знака из <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> в данном экземпляре; -1, если не найден ни один знак из <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Индексация начинается с нуля.</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to one less than the length of the string instance.</source>
          <target state="translated"><ph id="ph1">`startIndex`</ph> Параметр можно в диапазоне от 0 до меньше длины экземпляра строки.</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The search ranges from <ph id="ph1">`startIndex`</ph> to the end of the string.</source>
          <target state="translated">Поиск в диапазоне от <ph id="ph1">`startIndex`</ph> до конца строки.</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The search for <ph id="ph1">`anyOf`</ph> is case-sensitive.</source>
          <target state="translated">Поиск <ph id="ph1">`anyOf`</ph> учитывается регистр.</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</source>
          <target state="translated">Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярные значения в Юникоде.</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Для выполнения поиска с учетом языка и региональных параметров используйте <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> метод, где скалярное значение Юникода, представляющее составной знак, таких как лигатуры «Æ» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения компонентов символа в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>The following example finds the index of the occurrence of any character of the string "is" within a substring of another string.</source>
          <target state="translated">В следующем примере вычисляется индекс вхождение любого символа в строке «is» в подстроке другой строки.</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> является отрицательным значением.</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is greater than the number of characters in this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> больше числа знаков в данном экземпляре.</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Массив знаков Юникода, содержащий один или несколько искомых знаков.</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Позиция, с которой начинается поиск.</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Количество позиций знаков для проверки.</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</source>
          <target state="translated">Возвращает индекс с отсчетом от нуля первого обнаруженного в данном экземпляре символа из указанного массива символов Юникода.</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search starts at a specified character position and examines a specified number of character positions.</source>
          <target state="translated">Поиск начинается с указанной позиции знака; проверяется заданное количество позиций.</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The zero-based index position of the first occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found.</source>
          <target state="translated">Начинающееся с нуля значение индекса первого вхождения какого-либо знака из <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> в данном экземпляре; -1, если не найден ни один знак из <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search begins at <ph id="ph1">`startIndex`</ph> and continues to <ph id="ph2">`startIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`count`</ph> -1.</source>
          <target state="translated">Поиск начинается с <ph id="ph1">`startIndex`</ph> и продолжает <ph id="ph2">`startIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`count`</ph> -1.</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The character at <ph id="ph1">`startIndex`</ph><ph id="ph2"> + </ph><ph id="ph3">`count`</ph> is not included in the search.</source>
          <target state="translated">Символ в <ph id="ph1">`startIndex`</ph> <ph id="ph2"> + </ph> <ph id="ph3">`count`</ph> не включены в поиск.</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Индексация начинается с нуля.</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter can range from 0 to one less than the length of the string instance.</source>
          <target state="translated"><ph id="ph1">`startIndex`</ph> Параметр можно в диапазоне от 0 до меньше длины экземпляра строки.</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search for <ph id="ph1">`anyOf`</ph> is case-sensitive.</source>
          <target state="translated">Поиск <ph id="ph1">`anyOf`</ph> учитывается регистр.</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</source>
          <target state="translated">Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярные значения в Юникоде.</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Для выполнения поиска с учетом языка и региональных параметров используйте <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType&gt;</ph> метод, где скалярное значение Юникода, представляющее составной знак, таких как лигатуры «Æ» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения компонентов символа в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The following example finds the index of the occurrence of any character of the string "aid" within a substring of another string.</source>
          <target state="translated">В следующем примере вычисляется индекс вхождения любого знака строки «aid» в подстроке другой строки.</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> or <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> или <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> является отрицательным значением.</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" uid="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is greater than the number of characters in this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph><ph id="ph2"> + </ph><ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> больше, чем количество символов в этом экземпляре.</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>The zero-based index position of the insertion.</source>
          <target state="translated">Положение отсчитываемого от нуля индекса вставки.</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>The string to insert.</source>
          <target state="translated">Строка, которую требуется вставить.</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>Returns a new string in which a specified string is inserted at a specified index position in this instance.</source>
          <target state="translated">Возвращает новую строку, в которой указанная строка вставляется в указанной позиции индекса в данном экземпляре.</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>A new string that is equivalent to this instance, but with <ph id="ph1">&lt;paramref name="value" /&gt;</ph> inserted at position <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">Новая строка, эквивалентная данному экземпляру, но с тем отличием, что в положение <ph id="ph1">&lt;paramref name="value" /&gt;</ph> помещено значение <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>If <ph id="ph1">`startIndex`</ph> is equal to the length of this instance, <ph id="ph2">`value`</ph> is appended to the end of this instance.</source>
          <target state="translated">Если <ph id="ph1">`startIndex`</ph> равно длине данного экземпляра, <ph id="ph2">`value`</ph> добавляется в конец этого экземпляра.</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Этот метод не изменяет значение текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>Instead, it returns a new string in which <ph id="ph1">`value`</ph> is inserted into the current instance.</source>
          <target state="translated">Вместо этого он возвращает новую строку, в которой <ph id="ph1">`value`</ph> вставляется в текущий экземпляр.</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>For example, the return value of <ph id="ph1">`"abc".Insert(2, "XYZ")`</ph> is "abXYZc".</source>
          <target state="translated">Например, возвращаемое значение <ph id="ph1">`"abc".Insert(2, "XYZ")`</ph> является «abXYZc».</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>The following example inserts a space character in the fourth character position (the character at index 3) of a string.</source>
          <target state="translated">Следующий пример вставляет символ пробела в четвертой позиции символа (знак с индексом 3) строки.</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>The following console application prompts the users to enter one or more adjectives to describe two animals.</source>
          <target state="translated">Следующее консольное приложение предлагает пользователю ввести один или несколько прилагательные для описания двух животных.</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Insert(System.Int32,System.String)">
          <source>It then calls the <ph id="ph1">&lt;xref:System.String.Insert%2A&gt;</ph> method to insert the text entered by the user into a string.</source>
          <target state="translated">Затем он вызывает <ph id="ph1">&lt;xref:System.String.Insert%2A&gt;</ph> для вставки текста, введенного пользователем в строку.</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" uid="M:System.String.Insert(System.Int32,System.String)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is negative or greater than the length of this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> является отрицательным или больше длины данного экземпляра.</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" uid="M:System.String.Intern(System.String)">
          <source>A string to search for in the intern pool.</source>
          <target state="translated">Строка для поиска в пуле интернирования.</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" uid="M:System.String.Intern(System.String)">
          <source>Retrieves the system's reference to the specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Извлекает системную ссылку на указанный объект <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" uid="M:System.String.Intern(System.String)">
          <source>The system's reference to <ph id="ph1">&lt;paramref name="str" /&gt;</ph>, if it is interned; otherwise, a new reference to a string with the value of <ph id="ph2">&lt;paramref name="str" /&gt;</ph>.</source>
          <target state="translated">Системная ссылка на значение <ph id="ph1">&lt;paramref name="str" /&gt;</ph>, если оно уже интернировано; в противном случае возвращается новая ссылка на строку со значением <ph id="ph2">&lt;paramref name="str" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The common language runtime conserves string storage by maintaining a table, called the intern pool, that contains a single reference to each unique literal string declared or created programmatically in your program.</source>
          <target state="translated">Общеязыковая среда выполнения экономит пространство для хранения строк, сохраняя таблицу, называемую пулом интернирования, которая содержит по одной ссылке на каждый уникальный строковый литерал, объявленный или созданный в программе.</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Consequently, an instance of a literal string with a particular value only exists once in the system.</source>
          <target state="translated">В результате экземпляр строкового литерала с конкретным значением существует только один раз в системе.</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>For example, if you assign the same literal string to several variables, the runtime retrieves the same reference to the literal string from the intern pool and assigns it to each variable.</source>
          <target state="translated">Например если несколько переменных назначается тот же строковый литерал, среда выполнения извлекает же ссылка на строковый литерал в пуле интернирования и присваивает его для каждой переменной.</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> method uses the intern pool to search for a string equal to the value of <ph id="ph2">`str`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> Метод использует пуле интернирования для поиска строки, равной значению <ph id="ph2">`str`</ph>.</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>If such a string exists, its reference in the intern pool is returned.</source>
          <target state="translated">Если такая строка существует, возвращается его ссылка в пуле интернирования.</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>If the string does not exist, a reference to <ph id="ph1">`str`</ph> is added to the intern pool, then that reference is returned.</source>
          <target state="translated">Если строка не существует, ссылку на <ph id="ph1">`str`</ph> добавляется в пуле интернирования, а затем эта ссылка возвращается.</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>In the following example, the string s1, which has a value of "MyTest", is already interned because it is a literal in the program.</source>
          <target state="translated">В следующем примере строка s1 имеет значение «MyTest», уже интернировано, так как она является литералом в программе.</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.StringBuilder?displayProperty=nameWithType&gt;</ph> class generates a new string object that has the same value as s1.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.StringBuilder?displayProperty=nameWithType&gt;</ph> Класс создает новый объект string, которое совпадает со значением s1.</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>A reference to that string is assigned to s2.</source>
          <target state="translated">Ссылка на эту строку присваивается s2.</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> method searches for a string that has the same value as s2.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> Метод выполняет поиск строки, которая содержит совпадает со значением s2.</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Because such a string exists, the method returns the same reference that is assigned to s1.</source>
          <target state="translated">Поскольку такая строка существует, метод возвращает ту же ссылку, которая присвоена s1.</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>That reference is then assigned to s3.</source>
          <target state="translated">Эта ссылка затем присваивается s3.</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>References s1 and s2 compare unequal because they refer to different objects; references s1 and s3 compare equal because they refer to the same string.</source>
          <target state="translated">Ссылки s1 и s2 не считаются равными, поскольку они ссылаются на разные объекты; Ссылки s1 и s3 равны, поскольку они ссылаются на ту же строку.</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Compare this method to the <ph id="ph1">&lt;xref:System.String.IsInterned%2A&gt;</ph> method.</source>
          <target state="translated">Этот метод, чтобы сравнить <ph id="ph1">&lt;xref:System.String.IsInterned%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Version Considerations</source>
          <target state="translated">Описание версии</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]</ph>, the <ph id="ph2">&lt;xref:System.String.Intern%2A&gt;</ph> method reverts to its behavior in the .NET Framework 1.0 and 1.1 with regard to interning the empty string.</source>
          <target state="translated">В <ph id="ph1">[!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)]</ph>, <ph id="ph2">&lt;xref:System.String.Intern%2A&gt;</ph> метод возвращается к его поведения в .NET Framework 1.0 и 1.1 по отношению к интернирование пустая строка.</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>In the following example, the variable <ph id="ph1">`str1`</ph> is assigned a reference to <ph id="ph2">&lt;xref:System.String.Empty&gt;</ph>, and the variable <ph id="ph3">`str2`</ph> is assigned the reference to <ph id="ph4">&lt;xref:System.String.Empty&gt;</ph> that is returned by calling the <ph id="ph5">&lt;xref:System.String.Intern%2A&gt;</ph> method after converting a <ph id="ph6">&lt;xref:System.Text.StringBuilder&gt;</ph> object whose value is <ph id="ph7">&lt;xref:System.String.Empty&gt;</ph> to a string.</source>
          <target state="translated">В следующем примере переменная <ph id="ph1">`str1`</ph> назначается ссылку на <ph id="ph2">&lt;xref:System.String.Empty&gt;</ph>, а переменная <ph id="ph3">`str2`</ph> назначается ссылку на <ph id="ph4">&lt;xref:System.String.Empty&gt;</ph> , возвращается путем вызова <ph id="ph5">&lt;xref:System.String.Intern%2A&gt;</ph> метод после преобразования <ph id="ph6">&lt;xref:System.Text.StringBuilder&gt;</ph>объект, значение которого является <ph id="ph7">&lt;xref:System.String.Empty&gt;</ph> в строку.</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Then the references contained in <ph id="ph1">`str1`</ph> and <ph id="ph2">`str2`</ph> are compared for equality.</source>
          <target state="translated">Затем ссылок, содержащихся в <ph id="ph1">`str1`</ph> и <ph id="ph2">`str2`</ph> проверяются на равенство.</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]</ph>, <ph id="ph2">[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph>, <ph id="ph4">`str1`</ph> and <ph id="ph5">`str2`</ph> are equal.</source>
          <target state="translated">В <ph id="ph1">[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]</ph>, <ph id="ph2">[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]</ph>, и <ph id="ph3">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph>, <ph id="ph4">`str1`</ph> и <ph id="ph5">`str2`</ph> равны.</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph> and <ph id="ph2">[!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)]</ph>, <ph id="ph3">`str1`</ph> and <ph id="ph4">`str2`</ph> are not equal.</source>
          <target state="translated">В <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph> и <ph id="ph2">[!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)]</ph>, <ph id="ph3">`str1`</ph> и <ph id="ph4">`str2`</ph> не равны.</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Performance Considerations</source>
          <target state="translated">Особенности производительности</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>If you are trying to reduce the total amount of memory your application allocates, keep in mind that interning a string has two unwanted side effects.</source>
          <target state="translated">Если вы пытаетесь сократить объем памяти выделяет ваше приложение, имейте в виду, что интернирование строки имеет два нежелательных побочных эффектов.</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>First, the memory allocated for interned <ph id="ph1">&lt;xref:System.String&gt;</ph> objects is not likely be released until the common language runtime (CLR) terminates.</source>
          <target state="translated">Во-первых, памяти, выделенной для интернировано <ph id="ph1">&lt;xref:System.String&gt;</ph> объектов скорее всего будет освобождается до завершения общеязыковой среды выполнения (CLR).</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The reason is that the CLR's reference to the interned <ph id="ph1">&lt;xref:System.String&gt;</ph> object can persist after your application, or even your application domain, terminates.</source>
          <target state="translated">Это вызвано тем, CLR ссылка интернировано <ph id="ph1">&lt;xref:System.String&gt;</ph> объект могут сохраняться после приложения или даже домена приложения, завершается.</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Second, to intern a string, you must first create the string.</source>
          <target state="translated">Во-вторых для интернирования строки, необходимо сначала создать строку.</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The memory used by the <ph id="ph1">&lt;xref:System.String&gt;</ph> object must still be allocated, even though the memory will eventually be garbage collected.</source>
          <target state="translated">Объем памяти, используемой <ph id="ph1">&lt;xref:System.String&gt;</ph> необходимо по-прежнему выделена память для объекта, даже если память в конечном счете будут собраны как мусор.</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The .NET Framework version 2.0 introduces the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType&gt;</ph> enumeration member.</source>
          <target state="translated">.NET Framework версии 2.0 появился <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType&gt;</ph> член перечисления.</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning&gt;</ph> member marks an assembly as not requiring string-literal interning.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning&gt;</ph> Член помечает сборку как не требующий строковых литералов.</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>You can apply <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning&gt;</ph> to an assembly using the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute&gt;</ph> attribute.</source>
          <target state="translated">Можно применить <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning&gt;</ph> в сборку с помощью <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute&gt;</ph> атрибута.</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>Also, when you use the <bpt id="p1">[</bpt>Ngen.exe (Native Image Generator)<ept id="p1">](~/docs/framework/tools/ngen-exe-native-image-generator.md)</ept> to compile an assembly in advance of run time, strings are not interned across modules.</source>
          <target state="translated">Кроме того, при использовании <bpt id="p1">[</bpt>Ngen.exe (генератор образов в машинном)<ept id="p1">](~/docs/framework/tools/ngen-exe-native-image-generator.md)</ept> для компиляции сборки до времени выполнения, строки не интернировано между модулями.</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Intern(System.String)">
          <source>The following example uses three strings that are equal in value to determine whether a newly created string and an interned string are equal.</source>
          <target state="translated">В следующем примере используется три строки, которые равны по значению, чтобы определить, является ли строка только что созданный интернировано равны и строки.</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" uid="M:System.String.Intern(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="str" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" uid="M:System.String.IsInterned(System.String)">
          <source>The string to search for in the intern pool.</source>
          <target state="translated">Строка для поиска в пуле интернирования.</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" uid="M:System.String.IsInterned(System.String)">
          <source>Retrieves a reference to a specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Извлекает ссылку на указанный объект <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" uid="M:System.String.IsInterned(System.String)">
          <source>A reference to <ph id="ph1">&lt;paramref name="str" /&gt;</ph> if it is in the common language runtime intern pool; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ссылка на значение <ph id="ph1">&lt;paramref name="str" /&gt;</ph>, если оно находится в пуле интернирования среды CLR; в противном случае — значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>The common language runtime automatically maintains a table, called the intern pool, which contains a single instance of each unique literal string constant declared in a program, as well as any unique instance of <ph id="ph1">&lt;xref:System.String&gt;</ph> you add programmatically by calling the <ph id="ph2">&lt;xref:System.String.Intern%2A&gt;</ph> method.</source>
          <target state="translated">Общеязыковая среда выполнения автоматически поддерживает таблицу, называемую пулом интернирования, которая содержит один экземпляр каждого уникальный строковый литерал константе, объявленной в программу, а также любой уникальный экземпляр <ph id="ph1">&lt;xref:System.String&gt;</ph> добавить программным образом путем вызова <ph id="ph2">&lt;xref:System.String.Intern%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>The intern pool conserves string storage.</source>
          <target state="translated">Пуле интернирования экономит пространство для хранения строк.</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>If you assign a literal string constant to several variables, each variable is set to reference the same constant in the intern pool instead of referencing several different instances of <ph id="ph1">&lt;xref:System.String&gt;</ph> that have identical values.</source>
          <target state="translated">Если назначить несколько переменных литерала строковая константа, каждая переменная присвоена ссылка же константу в пуле интернирования, а не на несколько различных экземпляров <ph id="ph1">&lt;xref:System.String&gt;</ph> , имеют одинаковые значения.</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>This method looks up <ph id="ph1">`str`</ph> in the intern pool.</source>
          <target state="translated">Этот метод выполняет поиск <ph id="ph1">`str`</ph> в пуле интернирования.</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>If <ph id="ph1">`str`</ph> has already been interned, a reference to that instance is returned; otherwise, <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">Если <ph id="ph1">`str`</ph> уже интернировано, ссылка на этот экземпляр возвращен; в противном случае — <ph id="ph2">`null`</ph> возвращается.</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>Compare this method to the <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> method.</source>
          <target state="translated">Этот метод, чтобы сравнить <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>This method does not return a Boolean value.</source>
          <target state="translated">Этот метод не возвращает значение типа Boolean.</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>If you call the method because you want a Boolean value that indicates whether a particular string is interned, you can use code such as the following.</source>
          <target state="translated">Если вызвать метод, так как требуется логическое значение, указывающее, является ли интернировано определенной строки, можно использовать следующий код.</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>Starting with the .NET Framework version 2.0, you can override the use of the intern pool when you use the <bpt id="p1">[</bpt>Ngen.exe (Native Image Generator)<ept id="p1">](~/docs/framework/tools/ngen-exe-native-image-generator.md)</ept> to install an assembly to the native image cache on a local computer.</source>
          <target state="translated">Начиная с .NET Framework версии 2.0, можно переопределить использование пула интернирования при использовании <bpt id="p1">[</bpt>Ngen.exe (генератор образов в машинном)<ept id="p1">](~/docs/framework/tools/ngen-exe-native-image-generator.md)</ept> для установки сборки в кэш образов в машинном коде на локальном компьютере.</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>For more information, see Performance Considerations in the Remarks section for the <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> property.</source>
          <target state="translated">Дополнительные сведения см. в разделе вопросы производительности в разделе "Примечания" <ph id="ph1">&lt;xref:System.String.Intern%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsInterned(System.String)">
          <source>The following example demonstrates that literal strings are interned automatically by the compiler.</source>
          <target state="translated">В следующем примере показано автоматически интернировано строковых литералов компилятором.</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" uid="M:System.String.IsInterned(System.String)">
          <source><ph id="ph1">&lt;paramref name="str" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="str" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Indicates whether this string is in a particular Unicode normalization form.</source>
          <target state="translated">Указывает, находится ли данная строка в определенной форме нормализации Юникода.</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized">
          <source>Indicates whether this string is in Unicode normalization form C.</source>
          <target state="translated">Указывает, находится ли данная строка в форме нормализации Юникода C.</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this string is in normalization form C; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если данная строка находится в форме нормализации Юникода C; в противном случае — <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</source>
          <target state="translated">Некоторые символы Юникода имеют несколько эквивалентных двоичных представлений, которые состоят из наборов несамостоятельных и/или составных знаков Юникода.</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</source>
          <target state="translated">Наличие нескольких представлений одного символа затрудняет поиск, сортировка, сопоставления и других операций.</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</source>
          <target state="translated">В стандарте Юникода определен процесс, называемый нормализацией, который возвращает одно двоичное представление при наличии нескольких эквивалентных представлений символа.</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</source>
          <target state="translated">Нормализация может выполняться с использованием нескольких алгоритмов, называются формами нормализации, которые следуют различным правилам.</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>The .NET Framework currently supports normalization forms C, D, KC, and KD.</source>
          <target state="translated">Платформа .NET Framework в настоящее время поддерживает формы нормализации C, D, КС и KD.</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>For a description of supported Unicode normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Описание поддерживаемых форм нормализации Юникода см. в разделе <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>The following example determines whether a string is successfully normalized to various normalization forms.</source>
          <target state="translated">В следующем примере определяется, является ли строка успешно нормализуется в различные формы нормализации.</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized">
          <source>The current instance contains invalid Unicode characters.</source>
          <target state="translated">Текущий экземпляр содержит недопустимые символы Юникода.</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>The <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> method returns <ph id="ph2">&lt;see langword="false" /&gt;</ph> as soon as it encounters the first non-normalized character in a string.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> Возвращает <ph id="ph2">&lt;see langword="false" /&gt;</ph> как только он встречает первый символ, не нормализуются в строке.</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized">
          <source>Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> method will throw an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> although <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> returns <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Таким образом, если строка содержит ненормализованной символы, недопустимые символы Юникода, а затем <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> метод вызывает исключение <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> хотя <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> возвращает <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>A Unicode normalization form.</source>
          <target state="translated">Форма нормализации Юникода.</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>Indicates whether this string is in the specified Unicode normalization form.</source>
          <target state="translated">Указывает, находится ли данная строка в заданной форме нормализации Юникода.</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this string is in the normalization form specified by the <ph id="ph2">&lt;paramref name="normalizationForm" /&gt;</ph> parameter; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если строка находится в форме нормализации, указанной в параметре <ph id="ph2">&lt;paramref name="normalizationForm" /&gt;</ph>; в противном случае — <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</source>
          <target state="translated">Некоторые символы Юникода имеют несколько эквивалентных двоичных представлений, которые состоят из наборов несамостоятельных и/или составных знаков Юникода.</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</source>
          <target state="translated">Наличие нескольких представлений одного символа затрудняет поиск, сортировка, сопоставления и других операций.</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</source>
          <target state="translated">В стандарте Юникода определен процесс, называемый нормализацией, который возвращает одно двоичное представление при наличии нескольких эквивалентных представлений символа.</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</source>
          <target state="translated">Нормализация может выполняться с использованием нескольких алгоритмов, называются формами нормализации, которые следуют различным правилам.</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The .NET Framework currently supports normalization forms C, D, KC, and KD.</source>
          <target state="translated">Платформа .NET Framework в настоящее время поддерживает формы нормализации C, D, КС и KD.</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>For a description of supported Unicode normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Описание поддерживаемых форм нормализации Юникода см. в разделе <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.IsNormalized%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.String.Normalize%2A&gt;</ph> methods.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">&lt;xref:System.String.IsNormalized%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.String.Normalize%2A&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The current instance contains invalid Unicode characters.</source>
          <target state="translated">Текущий экземпляр содержит недопустимые символы Юникода.</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>The <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> method returns <ph id="ph2">&lt;see langword="false" /&gt;</ph> as soon as it encounters the first non-normalized character in a string.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> Возвращает <ph id="ph2">&lt;see langword="false" /&gt;</ph> как только он встречает первый символ, не нормализуются в строке.</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNormalized(System.Text.NormalizationForm)">
          <source>Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> method will throw an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> although <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> returns <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Таким образом, если строка содержит ненормализованной символы, недопустимые символы Юникода, а затем <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> метод вызывает исключение <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> хотя <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> возвращает <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>The string to test.</source>
          <target state="translated">Строка для проверки.</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>Indicates whether the specified string is <ph id="ph1">&lt;see langword="null" /&gt;</ph> or an <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> string.</source>
          <target state="translated">Указывает, является ли указанная строка строкой <ph id="ph1">&lt;see langword="null" /&gt;</ph> или <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty string (""); otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если параметр <ph id="ph2">&lt;paramref name="value" /&gt;</ph> равен <ph id="ph3">&lt;see langword="null" /&gt;</ph> или пустой строке (""); в противном случае — значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source><ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> is a convenience method that enables you to simultaneously test whether a <ph id="ph2">&lt;xref:System.String&gt;</ph> is <ph id="ph3">`null`</ph> or its value is <ph id="ph4">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> удобный метод, дающий возможность одновременно выполнять тестирование ли <ph id="ph2">&lt;xref:System.String&gt;</ph> — <ph id="ph3">`null`</ph> или имеет значение <ph id="ph4">&lt;xref:System.String.Empty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>It is equivalent to the following code:</source>
          <target state="translated">Это эквивалентно следующему коду:</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>You can use the <ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> method to test whether a string is <ph id="ph2">`null`</ph>, its value is <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>,  or it consists only of white-space characters.</source>
          <target state="translated">Можно использовать <ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> метод для проверки, является ли строка <ph id="ph2">`null`</ph>, его значением является <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, или он содержит только пробелы.</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>What is a null string?</source>
          <target state="translated">Что такое пустая строка</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>A string is <ph id="ph1">`null`</ph> if it has not been assigned a value (in C++ and Visual Basic) or if has explicitly been assigned a value of <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Строка — <ph id="ph1">`null`</ph> если ей не было назначено значение (в C++ и Visual Basic) или явно назначено значение <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>Although the <bpt id="p1">[</bpt>composite formatting<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> feature can gracefully handle a null string, as the following example shows, attempting to call one if its members throws a <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>.</source>
          <target state="translated">Несмотря на то что <bpt id="p1">[</bpt>составное форматирование<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> компонент может аккуратно пустой строки, как показано в следующем примере, попытка вызова одного Если вызывает его члены <ph id="ph1">&lt;xref:System.NullReferenceException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>What is an empty string?</source>
          <target state="translated">Что такое пустая строка</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>A string is empty if it  is explicitly assigned an empty string ("") or <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Строка пуста, если явно присваивается пустая строка ("») или <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>An empty string has a <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> of 0.</source>
          <target state="translated">Пустая строка имеет <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> 0.</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>The following example creates an empty string and displays its value and its length.</source>
          <target state="translated">В следующем примере создается пустая строка и отображает его значение и его длина.</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrEmpty(System.String)">
          <source>The following example examines three strings and determines whether each string has a value, is an empty string, or is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">В следующем примере рассматриваются три строки и определяет, каждая строка имеет значение, является пустой строкой или является <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source>The string to test.</source>
          <target state="translated">Строка для проверки.</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source>Indicates whether a specified string is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, empty, or consists only of white-space characters.</source>
          <target state="translated">Указывает, имеет ли указанная строка значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>, является ли она пустой строкой или строкой, состоящей только из символов-разделителей.</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or <ph id="ph4">&lt;see cref="F:System.String.Empty" /&gt;</ph>, or if <ph id="ph5">&lt;paramref name="value" /&gt;</ph> consists exclusively of white-space characters.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если параметр <ph id="ph2">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph> или <ph id="ph4">&lt;see cref="F:System.String.Empty" /&gt;</ph>, либо если параметр <ph id="ph5">&lt;paramref name="value" /&gt;</ph> содержит только символы-разделители.</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source><ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> is a convenience method that is similar to the following  code, except that it offers superior performance:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> — Это удобный метод, который похож на следующий код, за исключением того, что он обеспечивает превосходную производительность:</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source>White-space characters are defined by the Unicode standard.</source>
          <target state="translated">Пробельные символы определены в стандарте Юникода.</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> method interprets any character that returns a value of <ph id="ph2">`true`</ph> when it is passed to the <ph id="ph3">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method as a white-space character.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> Метод интерпретирует любой символ, который возвращает значение <ph id="ph2">`true`</ph> при его передаче <ph id="ph3">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> метод как символ пробела.</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.IsNullOrWhiteSpace(System.String)">
          <source>The following example creates a string array, and then passes each element of the array to the <ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> method.</source>
          <target state="translated">Следующий пример создает массив строк, а затем передает каждый элемент массива в <ph id="ph1">&lt;xref:System.String.IsNullOrWhiteSpace%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Concatenates the elements of a specified array or the members of a collection, using the specified separator between each element or member.</source>
          <target state="translated">Сцепляет элементы указанного массива или элементы коллекции, помещая между ними заданный разделитель.</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>The string to use as a separator.<bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> is included in the returned string only if <bpt id="p2">&lt;c&gt;</bpt>values<ept id="p2">&lt;/c&gt;</ept> has more than one element.</source>
          <target state="translated">Строка, которую необходимо использовать в качестве разделителя. <bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> включается в возвращаемую строку, только если в <bpt id="p2">&lt;c&gt;</bpt>values<ept id="p2">&lt;/c&gt;</ept> более одного элемента.</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>A collection that contains the strings to concatenate.</source>
          <target state="translated">Коллекция, содержащая сцепляемые строки.</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>Concatenates the members of a constructed <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> collection of type <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>, using the specified separator between each member.</source>
          <target state="translated">Сцепляет элементы созданной коллекции <ph id="ph1">&lt;see cref="T:System.Collections.Generic.IEnumerable`1" /&gt;</ph> типа <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>, помещая между ними заданный разделитель.</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>A string that consists of the members of <ph id="ph1">&lt;paramref name="values" /&gt;</ph> delimited by the <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> string.</source>
          <target state="translated">Строка, состоящая из элементов <ph id="ph1">&lt;paramref name="values" /&gt;</ph>, разделяемых строками <ph id="ph2">&lt;paramref name="separator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>If <ph id="ph1">&lt;paramref name="values" /&gt;</ph> has no members, the method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Если <ph id="ph1">&lt;paramref name="values" /&gt;</ph> не содержит членов, метод возвращает <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph>, an empty string (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) is used instead.</source>
          <target state="translated">Если <ph id="ph1">`separator`</ph> — <ph id="ph2">`null`</ph>, пустая строка (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) вместо него будет использоваться.</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>If any member of <ph id="ph1">`values`</ph> is <ph id="ph2">`null`</ph>, an empty string is used instead.</source>
          <target state="translated">Если любой член <ph id="ph1">`values`</ph> — <ph id="ph2">`null`</ph>, вместо него используется пустая строка.</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source><ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> is a convenience method that lets you concatenate each element in an <ph id="ph2">`IEnumerable(Of String)`</ph> collection without first converting the elements to a string array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> удобный метод, который позволяет сцеплять все элементы в <ph id="ph2">`IEnumerable(Of String)`</ph> коллекции без предварительного преобразования элементов в массив строк.</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>It is particularly useful with Language-Integrated Query (LINQ) query expressions.</source>
          <target state="translated">Это особенно полезно в выражениях запроса, встроенных в язык запросы (LINQ).</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>The following example passes a <ph id="ph1">`List(Of String)`</ph> object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</source>
          <target state="translated">В следующем примере передается <ph id="ph1">`List(Of String)`</ph> , содержащий прописные или строчные буквы алфавита в лямбда-выражение, определяющее буквы, которые меньше, чем конкретная буква (который, в примере «M»).</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>The <ph id="ph1">`IEnumerable(Of String)`</ph> collection returned by the <ph id="ph2">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> method is passed to the <ph id="ph3">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> method to display the result as a single string.</source>
          <target state="translated"><ph id="ph1">`IEnumerable(Of String)`</ph> Коллекцию, возвращаемую <ph id="ph2">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> методу передается <ph id="ph3">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> метод для отображения результатов в виде одной строки.</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</source>
          <target state="translated">Следующий пример использует алгоритм решета Эратосфена для вычисления простых чисел, которые меньше или равно 100.</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source>It assigns the result to a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object of type <ph id="ph2">&lt;xref:System.String&gt;</ph>, which it then passes to the <ph id="ph3">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> method.</source>
          <target state="translated">Он назначает результат <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> объекта типа <ph id="ph2">&lt;xref:System.String&gt;</ph>, который затем передается в <ph id="ph3">&lt;xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="values" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source>The string to use as a separator.</source>
          <target state="translated">Строка для использования в качестве разделителя.</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> is included in the returned string only if <bpt id="p2">&lt;c&gt;</bpt>values<ept id="p2">&lt;/c&gt;</ept> has more than one element.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> включается в возвращаемую строку, только если в <bpt id="p2">&lt;c&gt;</bpt>values<ept id="p2">&lt;/c&gt;</ept> более одного элемента.</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source>An array that contains the elements to concatenate.</source>
          <target state="translated">Массив, содержащий элементы, которые требуется сцепить.</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source>Concatenates the elements of an object array, using the specified separator between each element.</source>
          <target state="translated">Сцепляет элементы массива объектов, помещая между ними заданный разделитель.</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source>A string that consists of the elements of <ph id="ph1">&lt;paramref name="values" /&gt;</ph> delimited by the <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> string.</source>
          <target state="translated">Строка, состоящая из элементов <ph id="ph1">&lt;paramref name="values" /&gt;</ph>, разделяемых строками <ph id="ph2">&lt;paramref name="separator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source>If <ph id="ph1">&lt;paramref name="values" /&gt;</ph> is an empty array, the method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Если <ph id="ph1">&lt;paramref name="values" /&gt;</ph> равен пустому массиву, метод возвращает значение <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph> or if any element of <ph id="ph3">`values`</ph> other than the first element is <ph id="ph4">`null`</ph>, an empty string (<ph id="ph5">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) is used instead.</source>
          <target state="translated">Если <ph id="ph1">`separator`</ph> — <ph id="ph2">`null`</ph> или если какой-либо элемент <ph id="ph3">`values`</ph> не является первым элементом <ph id="ph4">`null`</ph>, пустая строка (<ph id="ph5">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) вместо него будет использоваться.</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>See the Notes for Callers section if the first element of <ph id="ph1">`values`</ph> is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Если см. в заметках для раздела вызывающим объектам на первый элемент <ph id="ph1">`values`</ph> — <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source><ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> is a convenience method that lets you concatenate each element in an object array without explicitly converting its elements to strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> представляет удобный метод, который позволяет сцеплять без явного преобразования строки его элементы каждого элемента в массиве объектов.</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>The string representation of each object in the array is derived by calling that object's <ph id="ph1">`ToString`</ph> method.</source>
          <target state="translated">Строковое представление каждого объекта в массиве является производным путем вызова этого объекта <ph id="ph1">`ToString`</ph> метод.</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</source>
          <target state="translated">Следующий пример использует алгоритм решета Эратосфена для вычисления простых чисел, которые меньше или равно 100.</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>It assigns the result to a integer array, which it then passes to the <ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">Присваивает результат целочисленный массив, который затем передается в <ph id="ph1">&lt;xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="values" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>If the first element of <ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, the <ph id="ph3">&lt;see cref="M:System.String.Join(System.String,System.Object[])" /&gt;</ph> method does not concatenate the elements in <ph id="ph4">&lt;paramref name="values" /&gt;</ph> but instead returns <ph id="ph5">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Если первый элемент <ph id="ph1">&lt;paramref name="values" /&gt;</ph> — <ph id="ph2">&lt;see langword="null" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.String.Join(System.String,System.Object[])" /&gt;</ph> метод не объединять элементы в <ph id="ph4">&lt;paramref name="values" /&gt;</ph> , но вместо этого возвращает <ph id="ph5">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>A number of workarounds for this issue are available.</source>
          <target state="translated">Доступны несколько решений этой проблемы.</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.Object[])">
          <source>The easiest is to assign a value of <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> to the first element of the array, as the following example shows.</source>
          <target state="translated">Самый простой способ — присвоить значение <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> на первый элемент массива, как приведенный ниже пример показывает.</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source>The string to use as a separator.</source>
          <target state="translated">Строка для использования в качестве разделителя.</target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source><bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> is included in the returned string only if <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept> has more than one element.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> включается в возвращаемую строку, только если в <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept> более одного элемента.</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source>An array that contains the elements to concatenate.</source>
          <target state="translated">Массив, содержащий элементы, которые требуется сцепить.</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source>Concatenates all the elements of a string array, using the specified separator between each element.</source>
          <target state="translated">Сцепляет все элементы массива строк, помещая между ними заданный разделитель.</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source>A string that consists of the elements in <ph id="ph1">&lt;paramref name="value" /&gt;</ph> delimited by the <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> string.</source>
          <target state="translated">Строка, состоящая из элементов <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, разделяемых строками <ph id="ph2">&lt;paramref name="separator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is an empty array, the method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Если <ph id="ph1">&lt;paramref name="value" /&gt;</ph> равен пустому массиву, метод возвращает значение <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[])">
          <source>For example, if <ph id="ph1">`separator`</ph> is ", " and the elements of <ph id="ph2">`value`</ph> are "apple", "orange", "grape", and "pear", <ph id="ph3">`Join(separator, value)`</ph> returns "apple, orange, grape, pear".</source>
          <target state="translated">Например если <ph id="ph1">`separator`</ph> — «,» и элементы <ph id="ph2">`value`</ph> являются «apple», «оранжевый», «виноград» и «Груши» <ph id="ph3">`Join(separator, value)`</ph> возвращает «apple, orange, виноград, Груши».</target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[])">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph>, an empty string (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) is used instead.</source>
          <target state="translated">Если <ph id="ph1">`separator`</ph> — <ph id="ph2">`null`</ph>, пустая строка (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) вместо него будет использоваться.</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[])">
          <source>If any element in <ph id="ph1">`value`</ph> is <ph id="ph2">`null`</ph>, an empty string is used instead.</source>
          <target state="translated">Если любой элемент в <ph id="ph1">`value`</ph> — <ph id="ph2">`null`</ph>, вместо него используется пустая строка.</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[])">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Join%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">&lt;xref:System.String.Join%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[])">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>The string to use as a separator.</source>
          <target state="translated">Строка для использования в качестве разделителя.</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> is included in the returned string only if <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept> has more than one element.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> включается в возвращаемую строку, только если в <bpt id="p2">&lt;c&gt;</bpt>value<ept id="p2">&lt;/c&gt;</ept> более одного элемента.</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>An array that contains the elements to concatenate.</source>
          <target state="translated">Массив, содержащий элементы, которые требуется сцепить.</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>The first element in <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated">Первый используемый элемент массива <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>The number of elements of <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> to use.</source>
          <target state="translated">Число используемых элементов массива <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>Concatenates the specified elements of a string array, using the specified separator between each element.</source>
          <target state="translated">Сцепляет указанные элементы массива строк, помещая между ними заданный разделитель.</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>A string that consists of the strings in <ph id="ph1">&lt;paramref name="value" /&gt;</ph> delimited by the <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> string.</source>
          <target state="translated">Строка, состоящая из строк из параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, разделяемых строками <ph id="ph2">&lt;paramref name="separator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is zero, <ph id="ph3">&lt;paramref name="value" /&gt;</ph> has no elements, or <ph id="ph4">&lt;paramref name="separator" /&gt;</ph> and all the elements of <ph id="ph5">&lt;paramref name="value" /&gt;</ph> are <ph id="ph6">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, если параметр <ph id="ph2">&lt;paramref name="count" /&gt;</ph> равен нулю, параметр <ph id="ph3">&lt;paramref name="value" /&gt;</ph> не содержит элементов или параметр <ph id="ph4">&lt;paramref name="separator" /&gt;</ph> и все элементы параметра <ph id="ph5">&lt;paramref name="value" /&gt;</ph> равны <ph id="ph6">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>For example, if <ph id="ph1">`separator`</ph> is ", " and the elements of <ph id="ph2">`value`</ph> are "apple", "orange", "grape", and "pear", <ph id="ph3">`Join(separator, value, 1, 2)`</ph> returns "orange, grape".</source>
          <target state="translated">Например если <ph id="ph1">`separator`</ph> — «,» и элементы <ph id="ph2">`value`</ph> являются «apple», «оранжевый», «виноград» и «Груши» <ph id="ph3">`Join(separator, value, 1, 2)`</ph> возвращает «оранжевый, виноград».</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph>, an empty string (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) is used instead.</source>
          <target state="translated">Если <ph id="ph1">`separator`</ph> — <ph id="ph2">`null`</ph>, пустая строка (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) вместо него будет использоваться.</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>If any element in <ph id="ph1">`value`</ph> is <ph id="ph2">`null`</ph>, an empty string is used instead.</source>
          <target state="translated">Если любой элемент в <ph id="ph1">`value`</ph> — <ph id="ph2">`null`</ph>, вместо него используется пустая строка.</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>The following example concatenates two elements from an array of names of fruit.</source>
          <target state="translated">Следующий пример Сцепляет два элемента массива названий фруктов.</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than 0.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> или <ph id="ph2">&lt;paramref name="count" /&gt;</ph> меньше 0.</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> plus <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is greater than the number of elements in <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> плюс <ph id="ph2">&lt;paramref name="count" /&gt;</ph> больше, чем число элементов в <ph id="ph3">&lt;paramref name="value" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" uid="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)">
          <source>Out of memory.</source>
          <target state="translated">Недостаточно памяти.</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The type of the members of <bpt id="p1">&lt;c&gt;</bpt>values<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Тип элементов <bpt id="p1">&lt;c&gt;</bpt>значения<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The string to use as a separator.<bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> is included in the returned string only if <bpt id="p2">&lt;c&gt;</bpt>values<ept id="p2">&lt;/c&gt;</ept> has more than one element.</source>
          <target state="translated">Строка, которую необходимо использовать в качестве разделителя. <bpt id="p1">&lt;c&gt;</bpt>separator<ept id="p1">&lt;/c&gt;</ept> включается в возвращаемую строку, только если в <bpt id="p2">&lt;c&gt;</bpt>values<ept id="p2">&lt;/c&gt;</ept> более одного элемента.</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>A collection that contains the objects to concatenate.</source>
          <target state="translated">Коллекция, содержащая сцепляемые объекты.</target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>Concatenates the members of a collection, using the specified separator between each member.</source>
          <target state="translated">Сцепляет элементы созданной коллекции, помещая между ними заданный разделитель.</target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>A string that consists of the members of <ph id="ph1">&lt;paramref name="values" /&gt;</ph> delimited by the <ph id="ph2">&lt;paramref name="separator" /&gt;</ph> string.</source>
          <target state="translated">Строка, состоящая из элементов <ph id="ph1">&lt;paramref name="values" /&gt;</ph>, разделяемых строками <ph id="ph2">&lt;paramref name="separator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>If <ph id="ph1">&lt;paramref name="values" /&gt;</ph> has no members, the method returns <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Если <ph id="ph1">&lt;paramref name="values" /&gt;</ph> не содержит членов, метод возвращает <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>If <ph id="ph1">`separator`</ph> is <ph id="ph2">`null`</ph>, an empty string (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) is used instead.</source>
          <target state="translated">Если <ph id="ph1">`separator`</ph> — <ph id="ph2">`null`</ph>, пустая строка (<ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>) вместо него будет использоваться.</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>If any member of <ph id="ph1">`values`</ph> is <ph id="ph2">`null`</ph>, an empty string is used instead.</source>
          <target state="translated">Если любой член <ph id="ph1">`values`</ph> — <ph id="ph2">`null`</ph>, вместо него используется пустая строка.</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source><ph id="ph1">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> is a convenience method that lets you concatenate each member of an <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection without first converting them to strings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> удобный метод, который позволяет сцеплять каждый член <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> коллекции без предварительного преобразования их в строки.</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The string representation of each object in the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> collection is derived by calling that object's <ph id="ph2">`ToString`</ph> method.</source>
          <target state="translated">Строковое представление каждого объекта в <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> сбора создается путем вызова этого объекта <ph id="ph2">`ToString`</ph> метод.</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>This method is particular useful with Language-Integrated Query (LINQ) query expressions.</source>
          <target state="translated">Этот метод является полезным для выражения запросов встроенных в язык запросы (LINQ).</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>For example, the following code defines a very simple <ph id="ph1">`Animal`</ph> class that contains the name of an animal and the order to which it belongs.</source>
          <target state="translated">Например, следующий код определяет очень простой <ph id="ph1">`Animal`</ph> класс, содержащий имя животного и заказ, к которой он принадлежит.</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>It then defines a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object that contains a number of <ph id="ph2">`Animal`</ph> objects.</source>
          <target state="translated">Затем он определяет <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> , содержащий ряд <ph id="ph2">`Animal`</ph> объектов.</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The <ph id="ph1">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> extension method is called to extract the <ph id="ph2">`Animal`</ph> objects whose <ph id="ph3">`Order`</ph> property equals "Rodent".</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType&gt;</ph> Метод расширения вызывается для извлечения <ph id="ph2">`Animal`</ph> объектов которого <ph id="ph3">`Order`</ph> равно «Грызун».</target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The result is passed to the <ph id="ph1">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> method.</source>
          <target state="translated">Результат передается <ph id="ph1">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</source>
          <target state="translated">Следующий пример использует алгоритм решета Эратосфена для вычисления простых чисел, которые меньше или равно 100.</target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source>It assigns the result to a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object of type integer, which it then passes to the <ph id="ph2">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> method.</source>
          <target state="translated">Он назначает результат <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> объект целочисленного типа, который затем передается в <ph id="ph2">&lt;xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" uid="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
          <source><ph id="ph1">&lt;paramref name="values" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="values" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Reports the zero-based index position of the last occurrence of a specified Unicode character or string within this instance.</source>
          <target state="translated">Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанного символа Юникода или строки в пределах данного экземпляра.</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>The method returns -1 if the character or string is not found in this instance.</source>
          <target state="translated">Метод возвращает -1, если знак или строка не найдена в данном экземпляре.</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char)">
          <source>The Unicode character to seek.</source>
          <target state="translated">Знак Юникода, который необходимо найти.</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char)">
          <source>Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</source>
          <target state="translated">Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанного символа Юникода в пределах данного экземпляра.</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that character is found, or -1 if it is not.</source>
          <target state="translated">Отсчитываемое от нуля значение индекса параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, если этот знак найден; в противном случае — значение -1.</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Индексация начинается с нуля.</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">То есть первый символ в строке с нулевым индексом, последний равен <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either <ph id="ph1">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">Этот метод начинает поиск с позиции последнего знака данного экземпляра и выполняется в обратном направлении до начала, пока не будет <ph id="ph1">`value`</ph> найден или проверит позицию первого символа.</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>The search is case-sensitive.</source>
          <target state="translated">При поиске учитывается регистр.</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярные значения в Юникоде.</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Для выполнения поиска с учетом языка и региональных параметров используйте <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> метод, где скалярное значение Юникода, представляющее составной знак, таких как лигатуры «Æ» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения компонентов символа в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>The following example defines an <ph id="ph1">`ExtractFilename`</ph> method that uses the <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.Char%29&gt;</ph> method to find the last directory separator character in a string and to extract the string's file name.</source>
          <target state="translated">В следующем примере определяется <ph id="ph1">`ExtractFilename`</ph> метод, который использует <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.Char%29&gt;</ph> метод для поиска последнего символом разделителя каталогов в строке и для извлечения строки имени файла.</target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char)">
          <source>If the file exists, the method returns the file name without its path.</source>
          <target state="translated">Если файл существует, метод возвращает имя файла без пути.</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String)">
          <source>The string to seek.</source>
          <target state="translated">Строка для поиска.</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String)">
          <source>Reports the zero-based index position of the last occurrence of a specified string within this instance.</source>
          <target state="translated">Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанной строки в данном экземпляре.</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String)">
          <source>The zero-based starting index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that string is found, or -1 if it is not.</source>
          <target state="translated">Положение в отсчитываемом от нуля индексе параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, если эта строка найдена, или значение -1, если она не найдена.</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the last index position in this instance.</source>
          <target state="translated">Если параметр <ph id="ph1">&lt;paramref name="value" /&gt;</ph> равен <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, возвращаемым значением является последняя позиция в индексе данного экземпляра.</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Индексация начинается с нуля.</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">То есть первый символ в строке с нулевым индексом, последний равен <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>The search begins at the last character position of this instance and proceeds backward toward the beginning until either <ph id="ph1">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">Поиск начинается с позиции последнего знака данного экземпляра и выполняется в обратном направлении до начала, пока не будет <ph id="ph1">`value`</ph> найден или проверит позицию первого символа.</target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">Этот метод выполняет поиск слова (с учетом регистра и культуры) с использованием текущего языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Если при поиске с учетом языка и региональных параметров параметр <ph id="ph1">`value`</ph> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом.</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.String%29&gt;</ph> method always returns <ph id="ph3">&lt;xref:System.String.Length%2A?displayProperty=nameWithType&gt;</ph> – 1, which represents the last index position in the current instance.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> состоит только из одного или нескольких игнорируемые символы, <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.String%29&gt;</ph> метод всегда возвращает <ph id="ph3">&lt;xref:System.String.Length%2A?displayProperty=nameWithType&gt;</ph> – 1, представляющее последнего значения индекса в текущем экземпляре.</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.LastIndexOf%28System.String%29&gt;</ph> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</source>
          <target state="translated">В следующем примере <ph id="ph1">&lt;xref:System.String.LastIndexOf%28System.String%29&gt;</ph> метод используется для поиска три подстроки (мягкий перенос (U + 00AD) мягкого переноса, а затем «n» и мягкий перенос буквой «m») в двух строк.</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>Only one of the strings contains a soft hyphen.</source>
          <target state="translated">Только одна из строк содержит мягкий перенос.</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in <ph id="ph2">`value`</ph>.</source>
          <target state="translated">Если пример выполняется <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> или более поздней версии, в каждом случае, поскольку мягкий перенос является игнорируемый символ, результат равен как если бы мягкий перенос не были включены в <ph id="ph2">`value`</ph>.</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>When searching for a soft hyphen only, the method returns 6 and 5.</source>
          <target state="translated">При поиске мягкий перенос, метод возвращает 6 и 5.</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>These values correspond to the index of the last character in the two strings.</source>
          <target state="translated">Эти значения соответствуют индекс последнего символа в двух строк.</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>The following example removes opening and closing HTML tags from a string if the tags begin and end the string.</source>
          <target state="translated">В следующем примере удаляется открывающие и закрывающие теги HTML из строки, если они находятся в начале и конце строки.</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>If a string ends with a closing bracket character ("&gt;"), the example uses the <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method to locate the start of the end tag.</source>
          <target state="translated">Если строка заканчивается закрывающий символ квадратной скобки («&gt;»), в примере используется <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> метод нахождения начала закрывающий тег.</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Как описано в статье <bpt id="p1">[</bpt>советы и рекомендации по использованию строк<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, рекомендуется избегать вызова методов сравнения строк, которые заменяют значения по умолчанию и вместо этого вызывают методы, которые требуют явного указания параметров.</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String)">
          <source>To find the last index of a substring within a string instance by using the comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Чтобы найти последний индекс подстроки в пределах экземпляра строки, используя правила сравнения строк для текущего языка и региональных параметров, вызовите <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph> перегрузка метода со значением <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> для его <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> параметра.</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The Unicode character to seek.</source>
          <target state="translated">Знак Юникода, который необходимо найти.</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The starting position of the search.</source>
          <target state="translated">Начальное положение поиска.</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">Поиск выполняется от индекса, заданного параметром <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept>, до начала данного экземпляра.</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</source>
          <target state="translated">Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанного символа Юникода в пределах данного экземпляра.</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string.</source>
          <target state="translated">Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки.</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that character is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Отсчитываемая от нуля позиция параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph> в индексе, если этот символ найден, или значение -1, если он не найден или текущий экземпляр равен <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Индексация начинается с нуля.</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.This method begins searching at the <ph id="ph2">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning of the current instance until either <ph id="ph3">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">То есть первый символ в строке с нулевым индексом, последний равен <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> -1. Этот метод начинает поиск <ph id="ph2">`startIndex`</ph> этот экземпляр и переход назад к началу текущего экземпляра, пока позиции знака <ph id="ph3">`value`</ph> найден или проверит позицию первого символа.</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches every character from the last character in the string to the beginning.</source>
          <target state="translated">Например если <ph id="ph1">`startIndex`</ph> — <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, метод выполняет поиск каждого символа, начиная с последнего знака строки в начало.</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The search is case-sensitive.</source>
          <target state="translated">При поиске учитывается регистр.</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярные значения в Юникоде.</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Для выполнения поиска с учетом языка и региональных параметров используйте <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> метод, где скалярное значение Юникода, представляющее составной знак, таких как лигатуры «Æ» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения компонентов символа в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The following example finds the index of all occurrences of a character in a string, working from the end of the string to the start of the string.</source>
          <target state="translated">В следующем примере вычисляется всех вхождений знака в строке от конца строки до начала строки.</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than zero or greater than or equal to the length of this instance.</source>
          <target state="translated">Текущий экземпляр не равен <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, а <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> меньше нуля либо равно или превышает длину этого экземпляра.</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The string to seek.</source>
          <target state="translated">Строка для поиска.</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Позиция, с которой начинается поиск.</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">Поиск выполняется от индекса, заданного параметром <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept>, до начала данного экземпляра.</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>Reports the zero-based index position of the last occurrence of a specified string within this instance.</source>
          <target state="translated">Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанной строки в данном экземпляре.</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string.</source>
          <target state="translated">Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки.</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The zero-based starting index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that string is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Отсчитываемая от нуля начальная позиция индекса параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, если строка найдена; значение -1, если строка не найдена или значение текущего экземпляра равно <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the smaller of <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and the last index position in this instance.</source>
          <target state="translated">Если значение параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph> равно <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, возвращаемым значением является наименьшее значение из <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> и последнего значения индекса в данном экземпляре.</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Индексация начинается с нуля.</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">То есть первый символ в строке с нулевым индексом, последний равен <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning until either <ph id="ph2">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">Поиск начинается с <ph id="ph1">`startIndex`</ph> этот экземпляр и переход назад к началу, пока позиции знака <ph id="ph2">`value`</ph> найден или проверит позицию первого символа.</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches every character from the last character in the string to the beginning.</source>
          <target state="translated">Например если <ph id="ph1">`startIndex`</ph> — <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, метод выполняет поиск каждого символа, начиная с последнего знака строки в начало.</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">Этот метод выполняет поиск слова (с учетом регистра и культуры) с использованием текущего языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Если при поиске с учетом языка и региональных параметров параметр <ph id="ph1">`value`</ph> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом.</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29&gt;</ph> method always returns <ph id="ph3">`startIndex`</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> состоит только из одного или нескольких игнорируемые символы, <ph id="ph2">&lt;xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29&gt;</ph> метод всегда возвращает <ph id="ph3">`startIndex`</ph>, являющееся позицию символа, с которого начинается поиск.</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29&gt;</ph> method is used to find a substring that includes a soft hyphen (U+00AD) and that precedes or includes the final "m" in a string.</source>
          <target state="translated">В следующем примере <ph id="ph1">&lt;xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29&gt;</ph> метод используется для поиска подстроки, включающего мягкий перенос (U + 00AD) и предшествует или описатель конечного символа «m» используется в строке.</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, because the soft hyphen in the search string is ignored, calling the method to find a substring that consists of the soft hyphen and "m" returns the position of the "m" in the string, whereas calling it to find a substring that consists of the soft hyphen and "n" returns the position of the "n".</source>
          <target state="translated">Если пример выполняется <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> или более поздней версии, поскольку мягкий перенос в строке поиска учитывается, вызов метода подстроке, которая состоит из мягкий перенос и «m» возвращает позицию символа «m» в строке, в то время как вызов его для поиска substrin g, состоящий из мягкого переноса и «n» возвращает позицию «n».</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>When the search string contains only the soft hyphen, the method returns the index of the "m", which represents the value of <ph id="ph1">`startIndex`</ph>.</source>
          <target state="translated">Если строка поиска, которая содержит только мягкого переноса, метод возвращает индекс символа «m», который представляет значение <ph id="ph1">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The following example finds the index of all occurrences of a string in target string, working from the end of the target string to the start of the target string.</source>
          <target state="translated">В следующем примере вычисляется всех вхождений строки в целевой строке в конце целевой строки до начала целевой строки.</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than zero or greater than the length of the current instance.</source>
          <target state="translated">Текущий экземпляр не равен <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, а <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> меньше нуля или больше длины текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than -1 or greater than zero.</source>
          <target state="translated">Текущий экземпляр равен <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, а <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> меньше –1 или больше нуля.</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Как описано в статье <bpt id="p1">[</bpt>советы и рекомендации по использованию строк<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, рекомендуется избегать вызова методов сравнения строк, которые заменяют значения по умолчанию и вместо этого вызывают методы, которые требуют явного указания параметров.</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32)">
          <source>To find the index of a substring that precedes a particular character position by using the comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Чтобы найти индекс подстроке, которая предшествует положения определенного символа, используя правила сравнения строк для текущего языка и региональных параметров, вызовите <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> перегрузка метода со значением <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> для его <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> параметра.</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">Строка для поиска.</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">Одно из значений перечисления, определяющее правила поиска.</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>Reports the zero-based index of the last occurrence of a specified string within the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Возвращает индекс с отсчетом от нуля последнего вхождения указанной строки в текущем объекте <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>A parameter specifies the type of search to use for the specified string.</source>
          <target state="translated">Параметр определяет тип поиска заданной строки.</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>The zero-based starting index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter if that string is found, or -1 if it is not.</source>
          <target state="translated">Начальное положение в отсчитываемом от нуля индексе параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, если эта строка найдена, или значение -1, если она не найдена.</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the last index position in this instance.</source>
          <target state="translated">Если параметр <ph id="ph1">&lt;paramref name="value" /&gt;</ph> равен <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, возвращаемым значением является последняя позиция в индексе данного экземпляра.</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Индексация начинается с нуля.</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">То есть первый символ в строке с нулевым индексом, последний равен <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated"><ph id="ph1">`comparisonType`</ph> Указывает параметр для поиска <ph id="ph2">`value`</ph> параметра с помощью текущего или инвариантного языка и региональных параметров, с помощью поиска с учетом регистра и без учета регистра и с помощью Microsoft word или правил сравнения по порядковому номеру.</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>The search begins at the last character position of this instance and proceeds backward toward the beginning until either <ph id="ph1">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">Поиск начинается с позиции последнего знака данного экземпляра и выполняется в обратном направлении до начала, пока не будет <ph id="ph1">`value`</ph> найден или проверит позицию первого символа.</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method that find the last occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">Exampledemonstrates следующие три перегрузки <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> метод, который поиска последнего вхождения строки внутри другой строки с использованием разных значениях <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> перечисления.</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> не является допустимым значением <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Если при поиске с учетом языка и региональных параметров (то есть, если параметр <ph id="ph1">&lt;paramref name="options" /&gt;</ph> не имеет значение <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> или <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>) параметр <ph id="ph4">&lt;paramref name="value" /&gt;</ph> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом.</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph> method always returns <ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph> – 1, which represents the last index position in the current instance.</source>
          <target state="translated">Если <ph id="ph1">&lt;paramref name="value" /&gt;</ph> состоит только из одного или нескольких игнорируемые символы, <ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph> метод всегда возвращает <ph id="ph3">&lt;see cref="P:System.String.Length" /&gt;</ph> – 1, представляющее последнего значения индекса в текущем экземпляре.</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</source>
          <target state="translated">В следующем примере <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /&gt;</ph> метод используется для поиска три подстроки (мягкий перенос (U + 00AD) мягкого переноса, а затем «n» и мягкий перенос буквой «m») в двух строк.</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>Only one of the strings contains a soft hyphen.</source>
          <target state="translated">Только одна из строк содержит мягкий перенос.</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string.</source>
          <target state="translated">Если пример выполняется <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> или более поздней версии, поскольку мягкий перенос является игнорируемым символом, поиск с учетом языка и региональных параметров возвращает то же значение, то будет возвращено, если мягкий перенос не были включены в строку поиска.</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.StringComparison)">
          <source>An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.</source>
          <target state="translated">Поиск по порядковым номерам, однако успешно находит мягкого переноса в одной строке и сообщает, что он не существует из второй строки.</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The Unicode character to seek.</source>
          <target state="translated">Знак Юникода, который необходимо найти.</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The starting position of the search.</source>
          <target state="translated">Начальное положение поиска.</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">Поиск выполняется от индекса, заданного параметром <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept>, до начала данного экземпляра.</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Количество позиций знаков для проверки.</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>Reports the zero-based index position of the last occurrence of the specified Unicode character in a substring within this instance.</source>
          <target state="translated">Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанного символа Юникода в подстроке в пределах данного экземпляра.</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</source>
          <target state="translated">Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки для заданного числа позиций символов.</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The zero-based index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that character is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Отсчитываемая от нуля позиция параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph> в индексе, если этот символ найден, или значение -1, если он не найден или текущий экземпляр равен <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Индексация начинается с нуля.</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">То есть первый символ в строке с нулевым индексом, последний равен <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>This method begins searching at the <ph id="ph1">`startIndex`</ph> character position and proceeds backward toward the beginning of this instance until either <ph id="ph2">`value`</ph> is found or <ph id="ph3">`count`</ph> character positions have been examined.</source>
          <target state="translated">Этот метод начинает поиск <ph id="ph1">`startIndex`</ph> символ в позиции и переходит назад к началу данного экземпляра, пока <ph id="ph2">`value`</ph> найден или <ph id="ph3">`count`</ph> будет проверена.</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches backward <ph id="ph3">`count`</ph> characters from the last character in the string.</source>
          <target state="translated">Например если <ph id="ph1">`startIndex`</ph> — <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, метод ищет в обратном направлении <ph id="ph3">`count`</ph> символов из последнего символа в строке.</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The search is case-sensitive.</source>
          <target state="translated">При поиске учитывается регистр.</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</source>
          <target state="translated">Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярные значения в Юникоде.</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Для выполнения поиска с учетом языка и региональных параметров используйте <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> метод, где скалярное значение Юникода, представляющее составной знак, таких как лигатуры «Æ» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения компонентов символа в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The following example finds the index of all occurrences of a character in a substring, working from the end of the substring to the start of the substring.</source>
          <target state="translated">В следующем примере вычисляется всех вхождений символа в подстроке от конца подстроки в начало подстроки.</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than zero or greater than or equal to the length of this instance.</source>
          <target state="translated">Текущий экземпляр не равен <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, а <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> меньше нуля либо равно или превышает длину этого экземпляра.</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="count" /&gt;</ph> + 1 is less than zero.</source>
          <target state="translated">Текущий экземпляр не равен <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, а <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="count" /&gt;</ph> + 1 является отрицательным числом.</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The string to seek.</source>
          <target state="translated">Строка для поиска.</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Позиция, с которой начинается поиск.</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">Поиск выполняется от индекса, заданного параметром <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept>, до начала данного экземпляра.</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Количество позиций знаков для проверки.</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>Reports the zero-based index position of the last occurrence of a specified string within this instance.</source>
          <target state="translated">Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанной строки в данном экземпляре.</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</source>
          <target state="translated">Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки для заданного числа позиций символов.</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The zero-based starting index position of <ph id="ph1">&lt;paramref name="value" /&gt;</ph> if that string is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Отсчитываемая от нуля начальная позиция индекса параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, если строка найдена; значение -1, если строка не найдена или значение текущего экземпляра равно <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the smaller of <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and the last index position in this instance.</source>
          <target state="translated">Если значение параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph> равно <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, возвращаемым значением является наименьшее значение из <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> и последнего значения индекса в данном экземпляре.</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Индексация начинается с нуля.</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">То есть первый символ в строке с нулевым индексом, последний равен <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning until either <ph id="ph2">`value`</ph> is found or <ph id="ph3">`count`</ph> character positions have been examined.</source>
          <target state="translated">Поиск начинается с <ph id="ph1">`startIndex`</ph> этот экземпляр и переход назад к началу, пока позиции знака <ph id="ph2">`value`</ph> найден или <ph id="ph3">`count`</ph> будет проверена.</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches backward <ph id="ph3">`count`</ph> characters from the last character in the string.</source>
          <target state="translated">Например если <ph id="ph1">`startIndex`</ph> — <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, метод ищет в обратном направлении <ph id="ph3">`count`</ph> символов из последнего символа в строке.</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</source>
          <target state="translated">Этот метод выполняет поиск слова (с учетом регистра и культуры) с использованием текущего языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>In a culture-sensitive search, if <ph id="ph1">`value`</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Если при поиске с учетом языка и региональных параметров параметр <ph id="ph1">`value`</ph> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом.</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>If <ph id="ph1">`value`</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method always returns <ph id="ph3">`startIndex`</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Если <ph id="ph1">`value`</ph> состоит только из одного или нескольких игнорируемые символы, <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> метод всегда возвращает <ph id="ph3">`startIndex`</ph>, являющееся позицию символа, с которого начинается поиск.</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>In the following example, the <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) in the two characters that precede the final "m" of two strings.</source>
          <target state="translated">В следующем примере <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> метод используется для поиска позицию мягкий перенос (U + 00AD) в два символа, которые предшествуют конечный «m» двух строк.</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">Только одна из строк содержит требуемую подстроку.</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">Если пример выполняется <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> или более поздней версии, в обоих случаях, поскольку мягкий перенос является игнорируемый символ, метод возвращает индекс «m» в строке при сравнении с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</source>
          <target state="translated">Обратите внимание, что в случае первой строки, содержащей мягкий перенос перед буквой "m", этот метод возвращает не индекс мягкого переноса, а индекс буквы "m".</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The following example finds the index of all occurrences of a string in substring, working from the end of the substring to the start of the substring.</source>
          <target state="translated">Следующий пример выполняет поиск всех вхождений строки в подстроке от конца подстроки в начало подстроки.</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> является отрицательным значением.</target>       </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated">Текущий экземпляр не равен <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, а <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> является отрицательным.</target>       </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is greater than the length of this instance.</source>
          <target state="translated">Текущий экземпляр не равен <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, а <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> превышает длину этого экземпляра.</target>       </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="count" /&gt;</ph>+ 1 specifies a position that is not within this instance.</source>
          <target state="translated">Текущий экземпляр не равен <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, а <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="count" /&gt;</ph> + 1 указывает позицию вне пределов данного экземпляра.</target>       </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> and <ph id="ph2">&lt;paramref name="start" /&gt;</ph> is less than -1 or greater than zero.</source>
          <target state="translated">Текущий экземпляр равен <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, а <ph id="ph2">&lt;paramref name="start" /&gt;</ph> меньше -1 или больше нуля.</target>       </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is greater than 1.</source>
          <target state="translated">Текущий экземпляр равен <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, а <ph id="ph2">&lt;paramref name="count" /&gt;</ph> больше 1.</target>       </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Как описано в статье <bpt id="p1">[</bpt>советы и рекомендации по использованию строк<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, рекомендуется избегать вызова методов сравнения строк, которые заменяют значения по умолчанию и вместо этого вызывают методы, которые требуют явного указания параметров.</target>       </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)">
          <source>To perform this operation by using the comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Чтобы выполнить эту операцию, используя правила сравнения строк для текущего языка и региональных параметров, вызовите <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> перегрузка метода со значением <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> для его <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> параметра.</target>       </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">Строка для поиска.</target>       </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The search starting position.</source>
          <target state="translated">Позиция, с которой начинается поиск.</target>       </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">Поиск выполняется от индекса, заданного параметром <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept>, до начала данного экземпляра.</target>       </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">Одно из значений перечисления, определяющее правила поиска.</target>       </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Reports the zero-based index of the last occurrence of a specified string within the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Возвращает индекс с отсчетом от нуля последнего вхождения указанной строки в текущем объекте <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string.</source>
          <target state="translated">Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки.</target>       </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>A parameter specifies the type of comparison to perform when searching for the specified string.</source>
          <target state="translated">Параметр определяет тип сравнения для выполнения во время поиска заданной строки.</target>       </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The zero-based starting index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter if that string is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Отсчитываемая от нуля начальная позиция индекса параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, если эта строка найдена, или значение -1, если строка не найдена или текущий экземпляр равен <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the smaller of <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and the last index position in this instance.</source>
          <target state="translated">Если значение параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph> равно <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, возвращаемым значением является наименьшее значение из <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> и последнего значения индекса в данном экземпляре.</target>       </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Индексация начинается с нуля.</target>       </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">То есть первый символ в строке с нулевым индексом, последний равен <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position and proceeds backward until either <ph id="ph2">`value`</ph> is found or the first character position has been examined.</source>
          <target state="translated">Поиск начинается с <ph id="ph1">`startIndex`</ph> символ в позиции и переходит назад, пока не будет <ph id="ph2">`value`</ph> найден или проверит позицию первого символа.</target>       </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches every character from the last character in the string to the beginning.</source>
          <target state="translated">Например если <ph id="ph1">`startIndex`</ph> — <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, метод выполняет поиск каждого символа, начиная с последнего знака строки в начало.</target>       </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated"><ph id="ph1">`comparisonType`</ph> Указывает параметр для поиска <ph id="ph2">`value`</ph> параметра с помощью текущего или инвариантного языка и региональных параметров, с помощью поиска с учетом регистра и без учета регистра и с помощью Microsoft word или правил сравнения по порядковому номеру.</target>       </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method that find the last occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">Exampledemonstrates следующие три перегрузки <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> метод, который поиска последнего вхождения строки внутри другой строки с использованием разных значениях <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> перечисления.</target>       </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than zero or greater than the length of the current instance.</source>
          <target state="translated">Текущий экземпляр не равен <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, а <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> меньше нуля или больше длины текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is less than -1 or greater than zero.</source>
          <target state="translated">Текущий экземпляр равен <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, а <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> меньше -1 или больше нуля.</target>       </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> не является допустимым значением <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Если при поиске с учетом языка и региональных параметров (то есть, если параметр <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> не имеет значение <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> или <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>) параметр <ph id="ph4">&lt;paramref name="value" /&gt;</ph> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом.</target>       </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method always returns <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Если <ph id="ph1">&lt;paramref name="value" /&gt;</ph> состоит только из одного или нескольких игнорируемые символы, <ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> метод всегда возвращает <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, являющееся позицию символа, с которого начинается поиск.</target>       </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m", starting with the final "m" in two strings.</source>
          <target state="translated">В следующем примере <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /&gt;</ph> метод позволяет определить позицию мягкий перенос (U + 00AD) буквой «m», начиная с последней «m» в двух строк.</target>       </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">Только одна из строк содержит требуемую подстроку.</target>       </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">Если пример выполняется <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> или более поздней версии, в обоих случаях, поскольку мягкий перенос является игнорируемый символ, метод возвращает индекс «m» в строке при сравнении с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</source>
          <target state="translated">Обратите внимание, что в случае первой строки, содержащей мягкий перенос перед буквой "m", этот метод возвращает не индекс мягкого переноса, а индекс буквы "m".</target>       </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)">
          <source>The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</source>
          <target state="translated">Этот метод возвращает индекс мягкого переноса в первой строке только при выполнении порядкового сравнения.</target>       </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The string to seek.</source>
          <target state="translated">Строка для поиска.</target>       </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search starting position.</source>
          <target state="translated">Позиция, с которой начинается поиск.</target>       </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">Поиск выполняется от индекса, заданного параметром <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept>, до начала данного экземпляра.</target>       </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Количество позиций знаков для проверки.</target>       </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>One of the enumeration values that specifies the rules for the search.</source>
          <target state="translated">Одно из значений перечисления, определяющее правила поиска.</target>       </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Reports the zero-based index position of the last occurrence of a specified string within this instance.</source>
          <target state="translated">Возвращает позицию индекса с отсчетом от нуля последнего вхождения указанной строки в данном экземпляре.</target>       </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string for the specified number of character positions.</source>
          <target state="translated">Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки для заданного числа позиций символов.</target>       </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>A parameter specifies the type of comparison to perform when searching for the specified string.</source>
          <target state="translated">Параметр определяет тип сравнения для выполнения во время поиска заданной строки.</target>       </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The zero-based starting index position of the <ph id="ph1">&lt;paramref name="value" /&gt;</ph> parameter if that string is found, or -1 if it is not found or if the current instance equals <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Отсчитываемая от нуля начальная позиция индекса параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph>, если эта строка найдена, или значение -1, если строка не найдена или текущий экземпляр равен <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, the return value is the smaller of <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> and the last index position in this instance.</source>
          <target state="translated">Если значение параметра <ph id="ph1">&lt;paramref name="value" /&gt;</ph> равно <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, возвращаемым значением является наименьшее значение из <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> и последнего значения индекса в данном экземпляре.</target>       </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Индексация начинается с нуля.</target>       </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>That is, the first character in the string is at index zero and the last is at <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</source>
          <target state="translated">То есть первый символ в строке с нулевым индексом, последний равен <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> - 1.</target>       </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The search begins at the <ph id="ph1">`startIndex`</ph> character position and proceeds backward until either <ph id="ph2">`value`</ph> is found or <ph id="ph3">`count`</ph> character positions have been examined.</source>
          <target state="translated">Поиск начинается с <ph id="ph1">`startIndex`</ph> символ в позиции и переходит назад, пока не будет <ph id="ph2">`value`</ph> найден или <ph id="ph3">`count`</ph> будет проверена.</target>       </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>For example, if <ph id="ph1">`startIndex`</ph> is <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, the method searches backward <ph id="ph3">`count`</ph> characters from the last character in the string.</source>
          <target state="translated">Например если <ph id="ph1">`startIndex`</ph> — <ph id="ph2">&lt;xref:System.String.Length%2A&gt;</ph> - 1, метод ищет в обратном направлении <ph id="ph3">`count`</ph> символов из последнего символа в строке.</target>       </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The <ph id="ph1">`comparisonType`</ph> parameter specifies to search for the <ph id="ph2">`value`</ph> parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</source>
          <target state="translated"><ph id="ph1">`comparisonType`</ph> Указывает параметр для поиска <ph id="ph2">`value`</ph> параметра с помощью текущего или инвариантного языка и региональных параметров, с помощью поиска с учетом регистра и без учета регистра и с помощью Microsoft word или правил сравнения по порядковому номеру.</target>       </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The following exampledemonstrates three overloads of the <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> method that find the last occurrence of a string within another string using different values of the <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> enumeration.</source>
          <target state="translated">Exampledemonstrates следующие три перегрузки <ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> метод, который поиска последнего вхождения строки внутри другой строки с использованием разных значениях <ph id="ph2">&lt;xref:System.StringComparison&gt;</ph> перечисления.</target>       </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> является отрицательным значением.</target>       </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated">Текущий экземпляр не равен <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, а <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> является отрицательным.</target>       </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> is greater than the length of this instance.</source>
          <target state="translated">Текущий экземпляр не равен <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, а <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> превышает длину этого экземпляра.</target>       </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> + 1 - <ph id="ph3">&lt;paramref name="count" /&gt;</ph> specifies a position that is not within this instance.</source>
          <target state="translated">Текущий экземпляр не равен <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, а <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> – <ph id="ph3">&lt;paramref name="count" /&gt;</ph> + 1 указывает позицию вне пределов данного экземпляра.</target>       </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> and <ph id="ph2">&lt;paramref name="start" /&gt;</ph> is less than -1 or greater than zero.</source>
          <target state="translated">Текущий экземпляр равен <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, а <ph id="ph2">&lt;paramref name="start" /&gt;</ph> меньше -1 или больше нуля.</target>       </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The current instance equals <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is greater than 1.</source>
          <target state="translated">Текущий экземпляр равен <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, а <ph id="ph2">&lt;paramref name="count" /&gt;</ph> больше 1.</target>       </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> не является допустимым значением <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</source>
          <target state="translated">Наборы символов содержат игнорируемые символы, то есть символы, которые не учитываются при выполнении лингвистического сравнения или сравнения с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>In a culture-sensitive search (that is, if <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>), if <ph id="ph4">&lt;paramref name="value" /&gt;</ph> contains an ignorable character, the result is equivalent to searching with that character removed.</source>
          <target state="translated">Если при поиске с учетом языка и региональных параметров (то есть, если параметр <ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> не имеет значение <ph id="ph2">&lt;see cref="F:System.StringComparison.Ordinal" /&gt;</ph> или <ph id="ph3">&lt;see cref="F:System.StringComparison.OrdinalIgnoreCase" /&gt;</ph>) параметр <ph id="ph4">&lt;paramref name="value" /&gt;</ph> содержит игнорируемый символ, результат аналогичен поиску с удаленным этим символом.</target>       </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If <ph id="ph1">&lt;paramref name="value" /&gt;</ph> consists only of one or more ignorable characters, the <ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method always returns <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, which is the character position at which the search begins.</source>
          <target state="translated">Если <ph id="ph1">&lt;paramref name="value" /&gt;</ph> состоит только из одного или нескольких игнорируемые символы, <ph id="ph2">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> метод всегда возвращает <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph>, являющееся позицию символа, с которого начинается поиск.</target>       </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>In the following example, the <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in all but the first character position before the final "m" in two strings.</source>
          <target state="translated">В следующем примере <ph id="ph1">&lt;see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /&gt;</ph> метод используется для поиска положение мягкий перенос (U + 00AD) буквой «m» во всех но позиции первого символа окончательной «m» в двух строк.</target>       </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Only one of the strings contains the required substring.</source>
          <target state="translated">Только одна из строк содержит требуемую подстроку.</target>       </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>If the example is run on the <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</source>
          <target state="translated">Если пример выполняется <ph id="ph1">[!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)]</ph> или более поздней версии, в обоих случаях, поскольку мягкий перенос является игнорируемый символ, метод возвращает индекс «m» в строке при сравнении с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>When it performs an ordinal comparison, however, it finds the substring only in the first string.</source>
          <target state="translated">Когда он выполняет порядковое сравнение, однако она находит подстроку только в первой строке.</target>       </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison.</source>
          <target state="translated">Обратите внимание, что в случае первой строки, содержащей мягкий перенос перед буквой «m», метод не возвращает индекс мягкого переноса, а вместо этого возвращает индекс символа «m», при сравнении с учетом языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
          <source>The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.</source>
          <target state="translated">Этот метод возвращает индекс мягкого переноса в первой строке только при выполнении порядкового сравнения.</target>       </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</source>
          <target state="translated">Возвращает позицию индекса с отсчетом от нуля последнего вхождения в данном экземпляре какого-либо одного или нескольких символов, указанных в массиве символов Юникода.</target>       </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>The method returns -1 if the characters in the array are not found in this instance.</source>
          <target state="translated">Метод возвращает -1, если знаки массива не найдены в этом экземпляре.</target>       </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Массив знаков Юникода, содержащий один или несколько искомых знаков.</target>       </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</source>
          <target state="translated">Возвращает позицию индекса с отсчетом от нуля последнего вхождения в данном экземпляре какого-либо одного или нескольких символов, указанных в массиве символов Юникода.</target>       </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>The index position of the last occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found.</source>
          <target state="translated">Значение индекса последнего вхождения какого-либо знака из <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> в данном экземпляре; -1, если ни один знак из <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> не был найден.</target>       </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Индексация начинается с нуля.</target>       </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either a character in <ph id="ph1">`anyOf`</ph> is found or the first character position has been examined.</source>
          <target state="translated">Этот метод начинает поиск с позиции последнего знака данного экземпляра и выполняется в обратном направлении до начала до символа в <ph id="ph1">`anyOf`</ph> найден или проверит позицию первого символа.</target>       </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>The search is case-sensitive.</source>
          <target state="translated">При поиске учитывается регистр.</target>       </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярные значения в Юникоде.</target>       </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Для выполнения поиска с учетом языка и региональных параметров используйте <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> метод, где скалярное значение Юникода, представляющее составной знак, таких как лигатуры «Æ» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения компонентов символа в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source>The following example finds the index of the last occurrence of any character in the string "is" within another string.</source>
          <target state="translated">В следующем примере вычисляется индекс последнего вхождения символа в строке «is» в другую строку.</target>       </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[])">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Массив знаков Юникода, содержащий один или несколько искомых знаков.</target>       </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Позиция, с которой начинается поиск.</target>       </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">Поиск выполняется от индекса, заданного параметром <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept>, до начала данного экземпляра.</target>       </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</source>
          <target state="translated">Возвращает позицию индекса с отсчетом от нуля последнего вхождения в данном экземпляре какого-либо одного или нескольких символов, указанных в массиве символов Юникода.</target>       </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string.</source>
          <target state="translated">Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки.</target>       </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The index position of the last occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found or if the current instance equals <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Значение индекса последнего вхождения какого-либо знака из <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> в данном экземпляре; -1, если ни один знак из <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> не был найден или текущий экземпляр равен <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Индексация начинается с нуля.</target>       </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>This method begins searching at the <ph id="ph1">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning until either a character in <ph id="ph2">`anyOf`</ph> is found or the first character position has been examined.</source>
          <target state="translated">Этот метод начинает поиск <ph id="ph1">`startIndex`</ph> этот экземпляр и переход назад к началу, пока символ в позиции знака <ph id="ph2">`anyOf`</ph> найден или проверит позицию первого символа.</target>       </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The search is case-sensitive.</source>
          <target state="translated">При поиске учитывается регистр.</target>       </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярные значения в Юникоде.</target>       </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Для выполнения поиска с учетом языка и региональных параметров используйте <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> метод, где скалярное значение Юникода, представляющее составной знак, таких как лигатуры «Æ» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения компонентов символа в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The following example finds the index of the last occurrence of any character in the string "is" within a substring of another string.</source>
          <target state="translated">В следующем примере вычисляется индекс последнего вхождения символа в строке «is» в подстроке другой строки.</target>       </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> specifies a position that is not within this instance.</source>
          <target state="translated">Текущий экземпляр не равен <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, а <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> указывает позицию вне пределов данного экземпляра.</target>       </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>A Unicode character array containing one or more characters to seek.</source>
          <target state="translated">Массив знаков Юникода, содержащий один или несколько искомых знаков.</target>       </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search starting position.</source>
          <target state="translated">Позиция, с которой начинается поиск.</target>       </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search proceeds from <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept> toward the beginning of this instance.</source>
          <target state="translated">Поиск выполняется от индекса, заданного параметром <bpt id="p1">&lt;c&gt;</bpt>startIndex<ept id="p1">&lt;/c&gt;</ept>, до начала данного экземпляра.</target>       </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The number of character positions to examine.</source>
          <target state="translated">Количество позиций знаков для проверки.</target>       </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</source>
          <target state="translated">Возвращает позицию индекса с отсчетом от нуля последнего вхождения в данном экземпляре какого-либо одного или нескольких символов, указанных в массиве символов Юникода.</target>       </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</source>
          <target state="translated">Поиск начинается с указанной позиции символа и выполняется в обратном направлении до начала строки для заданного числа позиций символов.</target>       </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The index position of the last occurrence in this instance where any character in <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> was found; -1 if no character in <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> was found or if the current instance equals <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</source>
          <target state="translated">Значение индекса последнего вхождения какого-либо знака из <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> в данном экземпляре; -1, если ни один знак из <ph id="ph2">&lt;paramref name="anyOf" /&gt;</ph> не был найден или текущий экземпляр равен <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>Index numbering starts from zero.</source>
          <target state="translated">Индексация начинается с нуля.</target>       </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>This method begins searching at the <ph id="ph1">`startIndex`</ph> character position of this instance and proceeds backward toward the beginning until either a character in <ph id="ph2">`anyOf`</ph> is found or <ph id="ph3">`count`</ph> character positions have been examined.</source>
          <target state="translated">Этот метод начинает поиск <ph id="ph1">`startIndex`</ph> этот экземпляр и переход назад к началу, пока символ в позиции знака <ph id="ph2">`anyOf`</ph> найден или <ph id="ph3">`count`</ph> будет проверена.</target>       </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The search is case-sensitive.</source>
          <target state="translated">При поиске учитывается регистр.</target>       </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</source>
          <target state="translated">Этот метод выполняет поиск по порядковым номерам (без учета языка и региональных параметров), где символ считаются эквивалентными, только в том случае, если совпадают их скалярные значения в Юникоде.</target>       </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>To perform a culture-sensitive search, use the <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</source>
          <target state="translated">Для выполнения поиска с учетом языка и региональных параметров используйте <ph id="ph1">&lt;xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType&gt;</ph> метод, где скалярное значение Юникода, представляющее составной знак, таких как лигатуры «Æ» (U + 00 C 6), может рассматриваться как эквивалент любого вхождения компонентов символа в Исправьте последовательности, например «AE» (U + 0041, U + 0045), в зависимости от языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The following example finds the index of the last occurrence of any character in the string "aid" within a substring of another string.</source>
          <target state="translated">В следующем примере вычисляется индекс последнего вхождения символа строки «aid» в подстроке другой строки.</target>       </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="anyOf" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> or <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is negative.</source>
          <target state="translated">Текущий экземпляр не равен <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, а <ph id="ph2">&lt;paramref name="count" /&gt;</ph> или <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> является отрицательным числом.</target>       </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve" uid="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
          <source>The current instance does not equal <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, and <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> minus <ph id="ph3">&lt;paramref name="count" /&gt;</ph> + 1 is less than zero.</source>
          <target state="translated">Текущий экземпляр не равен <ph id="ph1">&lt;see cref="F:System.String.Empty" /&gt;</ph>, а разность <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> и <ph id="ph3">&lt;paramref name="count" /&gt;</ph> + 1 меньше нуля.</target>       </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" uid="P:System.String.Length">
          <source>Gets the number of characters in the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Возвращает число знаков в текущем объекте <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>The number of characters in the current string.</source>
          <target state="translated">Количество знаков в текущей строке.</target>       </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>The <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> property returns the number of <ph id="ph2">&lt;xref:System.Char&gt;</ph> objects in this instance, not the number of Unicode characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> Свойство возвращает число <ph id="ph2">&lt;xref:System.Char&gt;</ph> объектов в этом экземпляре, не число символов Юникода.</target>       </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>The reason is that a Unicode character might be represented by more than one <ph id="ph1">&lt;xref:System.Char&gt;</ph>.</source>
          <target state="translated">Причина заключается в том, что символ Юникода могут быть представлены в более чем одной <ph id="ph1">&lt;xref:System.Char&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>Use the <ph id="ph1">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph> class to work with each Unicode character instead of each <ph id="ph2">&lt;xref:System.Char&gt;</ph>.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Globalization.StringInfo?displayProperty=nameWithType&gt;</ph> класс для работы с каждым знаком Юникода вместо каждого <ph id="ph2">&lt;xref:System.Char&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>In some languages, such as C and C++, a null character indicates the end of a string.</source>
          <target state="translated">В некоторых языках, таких как C и C++ символ null указывает на конец строки.</target>       </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>In the .NET Framework, a null character can be embedded in a string.</source>
          <target state="translated">В .NET Framework символ null может быть внедрен в строку.</target>       </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>When a string includes one or more null characters, they are included in the length of the total string.</source>
          <target state="translated">Если строка содержит один или несколько символов null, они включаются в длину всего строки.</target>       </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>For example, in the following string, the substrings "abc" and "def" are separated by a null character.</source>
          <target state="translated">Например в следующей строке подстроки «abc» и «def» разделены символом null.</target>       </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>The <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> property returns 7, which indicates that it includes the six alphabetic characters as well as the null character.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> Свойство возвращает значение 7, что означает, что он включает шесть буквенные символы, а также нуль-символ.</target>       </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.String.Length">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> property.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">&lt;xref:System.String.Length%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string whose binary representation is in a particular Unicode normalization form.</source>
          <target state="translated">Возвращает новую строку, двоичное представление которой находится в определенной нормализованной форме Юникода.</target>       </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" uid="M:System.String.Normalize">
          <source>Returns a new string whose textual value is the same as this string, but whose binary representation is in Unicode normalization form C.</source>
          <target state="translated">Возвращает новую строку, текстовое значение которой совпадает с данной строкой, а двоичное представление находится в нормализованной форме C Юникода.</target>       </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" uid="M:System.String.Normalize">
          <source>A new, normalized string whose textual value is the same as this string, but whose binary representation is in normalization form C.</source>
          <target state="translated">Новая нормализованная строка, текстовое значение которой совпадает с данной строкой, а двоичное представление находится в нормализованной форме C Юникода.</target>       </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</source>
          <target state="translated">Некоторые символы Юникода имеют несколько эквивалентных двоичных представлений, которые состоят из наборов несамостоятельных и/или составных знаков Юникода.</target>       </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>For example, any of the following code points can represent the letter "ắ":</source>
          <target state="translated">Например любой из следующих кодовых точек может представлять собой букву символа «ắ»:</target>       </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>U+1EAF</source>
          <target state="translated">U + 1EAF</target>       </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>U+0103 U+0301</source>
          <target state="translated">U + 0103 U + 0301</target>       </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>U+0061 U+0306 U+0301</source>
          <target state="translated">U+0061 U+0306 U+0301</target>       </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</source>
          <target state="translated">Наличие нескольких представлений одного символа затрудняет поиск, сортировка, сопоставления и других операций.</target>       </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</source>
          <target state="translated">В стандарте Юникода определен процесс, называемый нормализацией, который возвращает одно двоичное представление при наличии нескольких эквивалентных представлений символа.</target>       </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</source>
          <target state="translated">Нормализация может выполняться с использованием нескольких алгоритмов, называются формами нормализации, которые следуют различным правилам.</target>       </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>The .NET Framework supports the four normalization forms (C, D, KC, and KD)that are defined by the Unicode standard.When two strings are represented in the same normalization form, theycan be compared by using ordinal comparison.</source>
          <target state="translated">Платформа .NET Framework поддерживает четырех форм (C, D, КС и KD), определенных в стандарте Юникода. Если две строки, представлены в той же форме нормализации, theycan сравнивать с помощью порядкового сравнения.</target>       </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>To normalize and compare two strings, do the following:</source>
          <target state="translated">Для нормализации и сравнить две строки, выполните следующие действия.</target>       </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Obtain the strings to be compared from an input source, such as a file or a user input device.</source>
          <target state="translated">Получите строки для сравнения с источника входных данных, например файл или устройство ввода пользователя.</target>       </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Call the <ph id="ph1">&lt;xref:System.String.Normalize&gt;</ph> method to normalize the strings to normalization form C.</source>
          <target state="translated">Вызовите <ph id="ph1">&lt;xref:System.String.Normalize&gt;</ph> метод строки следует нормализовать в нормализованной форме c Юникода.</target>       </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>To compare two strings, call a method that supports ordinal string comparison, such as the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, and supply a value of <ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> as the <ph id="ph4">&lt;xref:System.StringComparison&gt;</ph> argument.</source>
          <target state="translated">Для сравнения двух строк, вызвать метод, который поддерживает сравнение строк по порядковому номеру, таких как <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> метода и укажите в качестве параметра <ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> или <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> как <ph id="ph4">&lt;xref:System.StringComparison&gt;</ph> аргумент.</target>       </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>To sort an array of normalized strings, pass a <ph id="ph1">`comparer`</ph> value of <ph id="ph2">&lt;xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType&gt;</ph> to an appropriate overload of <ph id="ph4">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Для сортировки массива нормализованных строк, передайте <ph id="ph1">`comparer`</ph> значение <ph id="ph2">&lt;xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph3">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType&gt;</ph> в соответствующую перегрузку <ph id="ph4">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Emit the strings in the sorted output based on the order indicated by the previous step.</source>
          <target state="translated">Выведите строки в отсортированных выходных данных, на основе порядка, указанного на предыдущем шаге.</target>       </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>For a description of supported Unicode normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Описание поддерживаемых форм нормализации Юникода см. в разделе <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.</source>
          <target state="translated">Следующий пример нормализация строку для каждой из четырех форм нормализации, строки были нормализованы по форме нормализации, указанной, а затем список кодовых точек нормализованной строки.</target>       </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" uid="M:System.String.Normalize">
          <source>The current instance contains invalid Unicode characters.</source>
          <target state="translated">Текущий экземпляр содержит недопустимые символы Юникода.</target>       </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>The <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> method returns <ph id="ph2">&lt;see langword="false" /&gt;</ph> as soon as it encounters the first non-normalized character in a string.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> Возвращает <ph id="ph2">&lt;see langword="false" /&gt;</ph> как только он встречает первый символ, не нормализуются в строке.</target>       </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize">
          <source>Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> method will throw an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> although <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> returns <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Таким образом, если строка содержит ненормализованной символы, недопустимые символы Юникода, а затем <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> метод вызывает исключение <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> хотя <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> возвращает <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>A Unicode normalization form.</source>
          <target state="translated">Форма нормализации Юникода.</target>       </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Returns a new string whose textual value is the same as this string, but whose binary representation is in the specified Unicode normalization form.</source>
          <target state="translated">Возвращает новую строку, текстовое значение которой совпадает с данной строкой, а двоичное представление находится в заданной нормализованной форме Юникода.</target>       </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>A new string whose textual value is the same as this string, but whose binary representation is in the normalization form specified by the <ph id="ph1">&lt;paramref name="normalizationForm" /&gt;</ph> parameter.</source>
          <target state="translated">Новая строка, текстовое значение которой совпадает с данной строкой, а двоичное представление находится в форме нормализации, заданной в параметре <ph id="ph1">&lt;paramref name="normalizationForm" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</source>
          <target state="translated">Некоторые символы Юникода имеют несколько эквивалентных двоичных представлений, которые состоят из наборов несамостоятельных и/или составных знаков Юникода.</target>       </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</source>
          <target state="translated">Наличие нескольких представлений одного символа затрудняет поиск, сортировка, сопоставления и других операций.</target>       </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</source>
          <target state="translated">В стандарте Юникода определен процесс, называемый нормализацией, который возвращает одно двоичное представление при наличии нескольких эквивалентных представлений символа.</target>       </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</source>
          <target state="translated">Нормализация может выполняться с использованием нескольких алгоритмов, называются формами нормализации, которые следуют различным правилам.</target>       </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The .NET Framework supports the four normalization forms (C, D, KC, and KD)that are defined by the Unicode standard.When two strings are represented in the same normalization form, they can be compared by using ordinal comparison.</source>
          <target state="translated">Платформа .NET Framework поддерживает четырех форм (C, D, КС и KD), определенных в стандарте Юникода. Если две строки, представлены в той же форме нормализации, их можно проверять с помощью порядкового сравнения.</target>       </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>To normalize and compare two strings, do the following:</source>
          <target state="translated">Для нормализации и сравнить две строки, выполните следующие действия.</target>       </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Obtain the strings to be compared from an input source, such as a file or a user input device.</source>
          <target state="translated">Получите строки для сравнения с источника входных данных, например файл или устройство ввода пользователя.</target>       </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Call the <ph id="ph1">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29&gt;</ph> method to normalize the strings to a specified normalization form.</source>
          <target state="translated">Вызовите <ph id="ph1">&lt;xref:System.String.Normalize%28System.Text.NormalizationForm%29&gt;</ph> метод для нормализации строк для указанной нормализованной форме.</target>       </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>To compare two strings, call a method that supports ordinal string comparison, such as the <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> method, and supply a value of <ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> as the <ph id="ph4">&lt;xref:System.StringComparison&gt;</ph> argument.</source>
          <target state="translated">Для сравнения двух строк, вызвать метод, который поддерживает сравнение строк по порядковому номеру, таких как <ph id="ph1">&lt;xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29&gt;</ph> метода и укажите в качестве параметра <ph id="ph2">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> или <ph id="ph3">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph> как <ph id="ph4">&lt;xref:System.StringComparison&gt;</ph> аргумент.</target>       </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>To sort an array of normalized strings, pass a <ph id="ph1">`comparer`</ph> value of <ph id="ph2">&lt;xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType&gt;</ph> to an appropriate overload of <ph id="ph4">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Для сортировки массива нормализованных строк, передайте <ph id="ph1">`comparer`</ph> значение <ph id="ph2">&lt;xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph3">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType&gt;</ph> в соответствующую перегрузку <ph id="ph4">&lt;xref:System.Array.Sort%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Emit the strings in the sorted output based on the order indicated by the previous step.</source>
          <target state="translated">Выведите строки в отсортированных выходных данных, на основе порядка, указанного на предыдущем шаге.</target>       </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>For a description of supported Unicode normalization forms, see <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Описание поддерживаемых форм нормализации Юникода см. в разделе <ph id="ph1">&lt;xref:System.Text.NormalizationForm?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.</source>
          <target state="translated">Следующий пример нормализация строку для каждой из четырех форм нормализации, строки были нормализованы по форме нормализации, указанной, а затем список кодовых точек нормализованной строки.</target>       </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The current instance contains invalid Unicode characters.</source>
          <target state="translated">Текущий экземпляр содержит недопустимые символы Юникода.</target>       </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>The <ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> method returns <ph id="ph2">&lt;see langword="false" /&gt;</ph> as soon as it encounters the first non-normalized character in a string.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> Возвращает <ph id="ph2">&lt;see langword="false" /&gt;</ph> как только он встречает первый символ, не нормализуются в строке.</target>       </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Normalize(System.Text.NormalizationForm)">
          <source>Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> method may throw an <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> although <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> returns <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Таким образом, если строка содержит ненормализованной символы, недопустимые символы Юникода, а затем <ph id="ph1">&lt;see cref="Overload:System.String.Normalize" /&gt;</ph> может вызвать метод <ph id="ph2">&lt;see cref="T:System.ArgumentException" /&gt;</ph> хотя <ph id="ph3">&lt;see cref="Overload:System.String.IsNormalized" /&gt;</ph> возвращает <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The first string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Первая сравниваемая строка или значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The second string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Вторая сравниваемая строка или значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>Determines whether two specified strings have the same value.</source>
          <target state="translated">Определяет, равны ли значения двух указанных строк.</target>       </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" uid="M:System.String.op_Equality(System.String,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of <ph id="ph2">&lt;paramref name="a" /&gt;</ph> is the same as the value of <ph id="ph3">&lt;paramref name="b" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значение параметра <ph id="ph2">&lt;paramref name="a" /&gt;</ph> совпадает со значением <ph id="ph3">&lt;paramref name="b" /&gt;</ph>; в противном случае — значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.op_Equality%2A&gt;</ph> method defines the operation of the equality operator for the <ph id="ph2">&lt;xref:System.String&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.op_Equality%2A&gt;</ph> Метод определяет операцию оператор равенства для <ph id="ph2">&lt;xref:System.String&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>It enables code such as that shown in the Example section.</source>
          <target state="translated">Он позволяет коду, например, показано в следующем примере.</target>       </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The operator, in turn, calls the static <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.String%29&gt;</ph> method, which performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated">Оператор, в свою очередь, вызывает статический <ph id="ph1">&lt;xref:System.String.Equals%28System.String%2CSystem.String%29&gt;</ph> метод, который выполняет порядковое сравнение (с учетом регистра и без учета языка и региональных параметров).</target>       </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The Visual Basic compiler does not resolve the equality operator as a call to the <ph id="ph1">&lt;xref:System.String.op_Equality%2A&gt;</ph> method.</source>
          <target state="translated">Компилятор Visual Basic не разрешается как вызов оператора равенства <ph id="ph1">&lt;xref:System.String.op_Equality%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>Instead, the equality operator wraps a call to the <ph id="ph1">&lt;xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Вместо этого оператор равенства создает оболочку для вызова <ph id="ph1">&lt;xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Equality(System.String,System.String)">
          <source>The following example demonstrates the equality operator.</source>
          <target state="translated">Ниже приведен пример оператора равенства.</target>       </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The first string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Первая сравниваемая строка или значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The second string to compare, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Вторая сравниваемая строка или значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>Determines whether two specified strings have different values.</source>
          <target state="translated">Определяет, различаются ли значения двух указанных строк.</target>       </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of <ph id="ph2">&lt;paramref name="a" /&gt;</ph> is different from the value of <ph id="ph3">&lt;paramref name="b" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значение <ph id="ph2">&lt;paramref name="a" /&gt;</ph> отличается от значения <ph id="ph3">&lt;paramref name="b" /&gt;</ph>; в противном случае — значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> method defines the operation of the inequality operator for the <ph id="ph2">&lt;xref:System.String&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> Метод определяет операцию неравенства для <ph id="ph2">&lt;xref:System.String&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>It enables code such as that shown in the Examples section.</source>
          <target state="translated">При этом код, показанный в разделе «примеры».</target>       </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> operator in turn calls the static <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.String%29&gt;</ph> method, which  performs an ordinal (case-sensitive and culture-insensitive) comparison.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> Оператор, в свою очередь, вызывает статический <ph id="ph2">&lt;xref:System.String.Equals%28System.String%2CSystem.String%29&gt;</ph> метод, который выполняет порядковое сравнение (с учетом регистра и без учета языка и региональных параметров).</target>       </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The Visual Basic compiler does not resolve the inequality operator as a call to the <ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> method.</source>
          <target state="translated">Компилятор Visual Basic не разрешается как вызов оператора неравенства <ph id="ph1">&lt;xref:System.String.op_Inequality%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>Instead, the inequality operator wraps a call to the <ph id="ph1">&lt;xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Вместо этого оператор неравенства создает оболочку для вызова <ph id="ph1">&lt;xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.op_Inequality(System.String,System.String)">
          <source>The following example demonstrates the inequality operator.</source>
          <target state="translated">Ниже приведен пример оператора неравенства.</target>       </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string of a specified length in which the beginning of the current string is padded with spaces or with a specified Unicode character.</source>
          <target state="translated">Возвращает новую строку указанной длины, в которой начало текущей строки заполняется символами-разделителями или указанным знаком Юникода.</target>       </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</source>
          <target state="translated">Количество знаков в полученной строке, равное числу исходных знаков плюс некоторое количество добавленных для заполнения знаков.</target>       </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source>Returns a new string that right-aligns the characters in this instance by padding them with spaces on the left, for a specified total length.</source>
          <target state="translated">Возвращает новую строку, в которой знаки данного экземпляра выровнены по правому краю путем добавления слева символов-разделителей до указанной общей длины.</target>       </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source>A new string that is equivalent to this instance, but right-aligned and padded on the left with as many spaces as needed to create a length of <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph>.</source>
          <target state="translated">Новая строка, эквивалентная данному экземпляру, но с выравниванием по правому краю и с добавленными слева пробелами, необходимыми для достижения длины <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source>However, if <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than the length of this instance, the method returns a reference to the existing instance.</source>
          <target state="translated">Однако если значение параметра <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> меньше длины данного экземпляра, метод возвращает ссылку на имеющийся экземпляр.</target>       </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is equal to the length of this instance, the method returns a new string that is identical to this instance.</source>
          <target state="translated">Если значение параметра <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> равно длине данного экземпляра, метод возвращает новую строку, идентичную данному экземпляру.</target>       </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>A Unicode space is defined as hexadecimal 0x0020.</source>
          <target state="translated">Пробел в Юникоде определен как шестнадцатеричное 0x0020.</target>       </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.PadLeft%28System.Int32%29&gt;</ph> method pads the beginning of the returned string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.PadLeft%28System.Int32%29&gt;</ph> Метод дополняет начало возвращаемой строки.</target>       </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>This means that, when used with right-to-left languages, it pads the right portion of the string.</source>
          <target state="translated">Это означает, что при использовании с языками справа налево дополняет правой части строки.</target>       </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>If the <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> метод дополняет текущий экземпляр с пробела, этот метод не изменяет значение текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>Instead, it returns a new string that is padded with leading white space so that its total length is <ph id="ph1">`totalWidth`</ph> characters.</source>
          <target state="translated">Вместо этого возвращается новая строка, дополняется начальные пробелы, чтобы общая длина строки составляет <ph id="ph1">`totalWidth`</ph> символов.</target>       </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than zero.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> меньше нуля.</target>       </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</source>
          <target state="translated">Количество знаков в полученной строке, равное числу исходных знаков плюс некоторое количество добавленных для заполнения знаков.</target>       </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>A Unicode padding character.</source>
          <target state="translated">Добавляемый в качестве заполнителя знак Юникода.</target>       </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>Returns a new string that right-aligns the characters in this instance by padding them on the left with a specified Unicode character, for a specified total length.</source>
          <target state="translated">Возвращает новую строку, в которой знаки данного экземпляра выровнены по правому краю путем добавления слева пробелов или указанного знака Юникода до указанной общей длины.</target>       </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>A new string that is equivalent to this instance, but right-aligned and padded on the left with as many <ph id="ph1">&lt;paramref name="paddingChar" /&gt;</ph> characters as needed to create a length of <ph id="ph2">&lt;paramref name="totalWidth" /&gt;</ph>.</source>
          <target state="translated">Новая строка, эквивалентная данному экземпляру, но с выравниванием по правому краю и с добавленными слева знаками <ph id="ph1">&lt;paramref name="paddingChar" /&gt;</ph>, необходимыми для достижения длины <ph id="ph2">&lt;paramref name="totalWidth" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>However, if <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than the length of this instance, the method returns a reference to the existing instance.</source>
          <target state="translated">Однако если значение параметра <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> меньше длины данного экземпляра, метод возвращает ссылку на имеющийся экземпляр.</target>       </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>If <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is equal to the length of this instance, the method returns a new string that is identical to this instance.</source>
          <target state="translated">Если значение параметра <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> равно длине данного экземпляра, метод возвращает новую строку, идентичную данному экземпляру.</target>       </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>The <ph id="ph1">&lt;xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29&gt;</ph> method pads the beginning of the returned string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29&gt;</ph> Метод дополняет начало возвращаемой строки.</target>       </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>This means that, when used with right-to-left languages, it pads the right portion of the string.</source>
          <target state="translated">Это означает, что при использовании с языками справа налево дополняет правой части строки.</target>       </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>If the <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> метод дополняет текущий экземпляр с пробела, этот метод не изменяет значение текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>Instead, it returns a new string that is padded with leading <ph id="ph1">`paddingChar`</ph> characters so that its total length is <ph id="ph2">`totalWidth`</ph> characters.</source>
          <target state="translated">Вместо этого возвращается новая строка, дополняется стоящими в начале <ph id="ph1">`paddingChar`</ph> символами, чтобы общая длина строки составляет <ph id="ph2">`totalWidth`</ph> символов.</target>       </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">&lt;xref:System.String.PadLeft%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" uid="M:System.String.PadLeft(System.Int32,System.Char)">
          <source><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than zero.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> меньше нуля.</target>       </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string of a specified length in which the end of the current string is padded with spaces or with a specified Unicode character.</source>
          <target state="translated">Возвращает новую строку указанной длины, в которой конец текущей строки заполняется символами-разделителями или указанным знаком Юникода.</target>       </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</source>
          <target state="translated">Количество знаков в полученной строке, равное числу исходных знаков плюс некоторое количество добавленных для заполнения знаков.</target>       </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source>Returns a new string that left-aligns the characters in this string by padding them with spaces on the right, for a specified total length.</source>
          <target state="translated">Возвращает новую строку, в которой знаки данной строки выровнены по левому краю путем добавления справа символов-разделителей до указанной общей длины.</target>       </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source>A new string that is equivalent to this instance, but left-aligned and padded on the right with as many spaces as needed to create a length of <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph>.</source>
          <target state="translated">Новая строка, эквивалентная данному экземпляру, но с выравниванием по левому краю и с добавленными справа пробелами, необходимыми для достижения длины <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source>However, if <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than the length of this instance, the method returns a reference to the existing instance.</source>
          <target state="translated">Однако если значение параметра <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> меньше длины данного экземпляра, метод возвращает ссылку на имеющийся экземпляр.</target>       </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is equal to the length of this instance, the method returns a new string that is identical to this instance.</source>
          <target state="translated">Если значение параметра <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> равно длине данного экземпляра, метод возвращает новую строку, идентичную данному экземпляру.</target>       </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>A Unicode space is defined as hexadecimal 0x0020.</source>
          <target state="translated">Пробел в Юникоде определен как шестнадцатеричное 0x0020.</target>       </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.PadRight%28System.Int32%29&gt;</ph> method pads the end of the returned string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.PadRight%28System.Int32%29&gt;</ph> Метод дополняет конец возвращаемой строки.</target>       </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>This means that, when used with right-to-left languages, it pads the left portion of the string.</source>
          <target state="translated">Это означает, что при использовании с языками справа налево дополняет левой части строки.</target>       </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>If the <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> метод дополняет текущий экземпляр с пробела, этот метод не изменяет значение текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>Instead, it returns a new string that is padded with trailing white space so that its total length is <ph id="ph1">`totalWidth`</ph> characters.</source>
          <target state="translated">Вместо этого возвращается новая строка, заполняются конечными пробелами, чтобы общая длина строки составляет <ph id="ph1">`totalWidth`</ph> символов.</target>       </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than zero.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> меньше нуля.</target>       </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</source>
          <target state="translated">Количество знаков в полученной строке, равное числу исходных знаков плюс некоторое количество добавленных для заполнения знаков.</target>       </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>A Unicode padding character.</source>
          <target state="translated">Добавляемый в качестве заполнителя знак Юникода.</target>       </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>Returns a new string that left-aligns the characters in this string by padding them on the right with a specified Unicode character, for a specified total length.</source>
          <target state="translated">Возвращает новую строку, в которой знаки данной строки выровнены по левому краю путем добавления справа пробелов или указанного знака Юникода до указанной общей длины.</target>       </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>A new string that is equivalent to this instance, but left-aligned and padded on the right with as many <ph id="ph1">&lt;paramref name="paddingChar" /&gt;</ph> characters as needed to create a length of <ph id="ph2">&lt;paramref name="totalWidth" /&gt;</ph>.</source>
          <target state="translated">Новая строка, эквивалентная данному экземпляру, но с выравниванием по левому краю и с добавленными справа знаками <ph id="ph1">&lt;paramref name="paddingChar" /&gt;</ph>, необходимыми для достижения длины <ph id="ph2">&lt;paramref name="totalWidth" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>However, if <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than the length of this instance, the method returns a reference to the existing instance.</source>
          <target state="translated">Однако если значение параметра <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> меньше длины данного экземпляра, метод возвращает ссылку на имеющийся экземпляр.</target>       </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>If <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is equal to the length of this instance, the method returns a new string that is identical to this instance.</source>
          <target state="translated">Если значение параметра <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> равно длине данного экземпляра, метод возвращает новую строку, идентичную данному экземпляру.</target>       </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>The <ph id="ph1">&lt;xref:System.String.PadRight%28System.Int32%2CSystem.Char%29&gt;</ph> method pads the end of the returned string.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.PadRight%28System.Int32%2CSystem.Char%29&gt;</ph> Метод дополняет конец возвращаемой строки.</target>       </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>This means that, when used with right-to-left languages, it pads the left portion of the string.</source>
          <target state="translated">Это означает, что при использовании с языками справа налево дополняет левой части строки.</target>       </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>If the <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> метод дополняет текущий экземпляр с пробела, этот метод не изменяет значение текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>Instead, it returns a new string that is padded with trailing <ph id="ph1">`paddingChar`</ph> characters so that its total length is <ph id="ph2">`totalWidth`</ph> characters.</source>
          <target state="translated">Вместо этого возвращается новая строка, дополняется конечные <ph id="ph1">`paddingChar`</ph> символами, чтобы общая длина строки составляет <ph id="ph2">`totalWidth`</ph> символов.</target>       </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">&lt;xref:System.String.PadRight%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve" uid="M:System.String.PadRight(System.Int32,System.Char)">
          <source><ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> is less than zero.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="totalWidth" /&gt;</ph> меньше нуля.</target>       </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string in which a specified number of characters from the current string are deleted.</source>
          <target state="translated">Возвращает новую строку, в которой удалено указанное число знаков текущей строки.</target>       </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source>The zero-based position to begin deleting characters.</source>
          <target state="translated">Отсчитываемая от нуля позиция, с которой начинается удаление знаков.</target>       </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source>Returns a new string in which all the characters in the current instance, beginning at a specified position and continuing through the last position, have been deleted.</source>
          <target state="translated">Возвращает новую строку, в которой были удалены все символы, начиная с указанной позиции и до конца в текущем экземпляре.</target>       </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source>A new string that is equivalent to this string except for the removed characters.</source>
          <target state="translated">Новая строка, эквивалентная данной строке за минусом удаленных знаков.</target>       </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>In the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>, strings are zero-based.</source>
          <target state="translated">В <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>, строки отсчитываются от нуля.</target>       </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>The value of the <ph id="ph1">`startIndex`</ph> parameter can range from zero to one less than the length of the string instance.</source>
          <target state="translated">Значение <ph id="ph1">`startIndex`</ph> параметра допустимы значения от 0 до величины, равной длины экземпляра строки.</target>       </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Этот метод не изменяет значение текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>Instead, it returns a new string in which all characters from position <ph id="ph1">`startIndex`</ph> to the end of the original string have been removed.</source>
          <target state="translated">Вместо этого возвращается новая строка в которой все символы с позиции <ph id="ph1">`startIndex`</ph> до конца исходной строки были удалены.</target>       </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.Remove%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">&lt;xref:System.String.Remove%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>The next-to-last case removes all text starting from the specified index through the end of the string.</source>
          <target state="translated">Регистр следующей последней удаляет весь текст, начиная с заданного индекса и до конца строки.</target>       </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32)">
          <source>The last case removes three characters starting from the specified index.</source>
          <target state="translated">В последнем случае удаляются трех символов, начиная с заданного индекса.</target>       </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> меньше нуля.</target>       </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> specifies a position that is not within this string.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> задает позицию вне пределов данной строки.</target>       </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>The zero-based position to begin deleting characters.</source>
          <target state="translated">Отсчитываемая от нуля позиция, с которой начинается удаление знаков.</target>       </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>The number of characters to delete.</source>
          <target state="translated">Число символов для удаления.</target>       </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>Returns a new string in which a specified number of characters in the current instance beginning at a specified position have been deleted.</source>
          <target state="translated">Возвращает новую строку, в которой было удалено указанное число символов в указанной позиции.</target>       </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>A new string that is equivalent to this instance except for the removed characters.</source>
          <target state="translated">Новая строка, эквивалентная данному экземпляру за минусом удаленных знаков.</target>       </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>In the <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>, strings are zero-based.</source>
          <target state="translated">В <ph id="ph1">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph>, строки отсчитываются от нуля.</target>       </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>The value of the <ph id="ph1">`startIndex`</ph> parameter can range from zero to one less than the length of the string instance.</source>
          <target state="translated">Значение <ph id="ph1">`startIndex`</ph> параметра допустимы значения от 0 до величины, равной длины экземпляра строки.</target>       </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Этот метод не изменяет значение текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>Instead, it returns a new string in which the number of characters specified by the <ph id="ph1">`count`</ph> parameter have been removed.</source>
          <target state="translated">Вместо этого он возвращает новую строку, в котором указано число знаков, <ph id="ph1">`count`</ph> параметра были удалены.</target>       </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>The characters are removed at the position specified by <ph id="ph1">`startIndex`</ph>.</source>
          <target state="translated">Символы удаляются в позиции, указанной параметром <ph id="ph1">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>The following example demonstrates how you can remove the middle name from a complete name.</source>
          <target state="translated">В следующем примере показано, как удалить отчества из полного имени.</target>       </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>Either <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> или <ph id="ph2">&lt;paramref name="count" /&gt;</ph> меньше нуля.</target>       </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" uid="M:System.String.Remove(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> plus <ph id="ph2">&lt;paramref name="count" /&gt;</ph> specify a position outside this instance.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> плюс <ph id="ph2">&lt;paramref name="count" /&gt;</ph> задает позицию вне пределов данного экземпляра.</target>       </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string in which all occurrences of a specified Unicode character or <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> in the current string are replaced with another specified Unicode character or <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Возвращает новую строку, в которой все вхождения заданного знака Юникода или <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> в текущей строке заменены другим заданным знаком Юникода или <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>The Unicode character to be replaced.</source>
          <target state="translated">Заменяемый знак Юникода.</target>       </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>The Unicode character to replace all occurrences of <bpt id="p1">&lt;c&gt;</bpt>oldChar<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Символ Юникода для замены всех обнаруженных вхождений <bpt id="p1">&lt;c&gt;</bpt>oldChar<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>Returns a new string in which all occurrences of a specified Unicode character in this instance are replaced with another specified Unicode character.</source>
          <target state="translated">Возвращает новую строку, в которой все вхождения заданного знака Юникода в текущем экземпляре заменены другим заданным знаком Юникода.</target>       </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>A string that is equivalent to this instance except that all instances of <ph id="ph1">&lt;paramref name="oldChar" /&gt;</ph> are replaced with <ph id="ph2">&lt;paramref name="newChar" /&gt;</ph>.</source>
          <target state="translated">Строка, эквивалентная данному экземпляру, но с тем отличием, что все вхождения <ph id="ph1">&lt;paramref name="oldChar" /&gt;</ph> заменены на <ph id="ph2">&lt;paramref name="newChar" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>If <ph id="ph1">&lt;paramref name="oldChar" /&gt;</ph> is not found in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Если <ph id="ph1">&lt;paramref name="oldChar" /&gt;</ph> не обнаружен в текущем экземпляре метод возвращает текущий экземпляр без изменений.</target>       </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) search to find <ph id="ph1">`oldChar`</ph>.</source>
          <target state="translated">Этот метод выполняет поиск по порядковым номерам (с учетом регистра и без учета языка и региональных параметров) для поиска <ph id="ph1">`oldChar`</ph>.</target>       </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Этот метод не изменяет значение текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>Instead, it returns a new string in which all occurrences of <ph id="ph1">`oldChar`</ph> are replaced by <ph id="ph2">`newChar`</ph>.</source>
          <target state="translated">Вместо этого он возвращает новую строку, в которой все вхождения <ph id="ph1">`oldChar`</ph> заменяются <ph id="ph2">`newChar`</ph>.</target>       </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>Because this method returns the modified string, you can chain together successive calls to the <ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> method to perform multiple replacements on the original string.</source>
          <target state="translated">Так как этот метод возвращает измененную строку, можно соединить в цепочку вместе последующие вызовы <ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> метод для выполнения нескольких замены исходной строки.</target>       </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>Method calls are executed from left to right.</source>
          <target state="translated">Вызовы методов выполняются слева направо.</target>       </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>The following example provides an illustration.</source>
          <target state="translated">Ниже приведен пример.</target>       </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.Char,System.Char)">
          <source>The following example creates a comma separated value list by substituting commas for the blanks between a series of numbers.</source>
          <target state="translated">В следующем примере создается список значений с разделителями-запятыми, путем замены пробелов между последовательностями цифр запятыми.</target>       </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source>The string to be replaced.</source>
          <target state="translated">Строка, которую требуется заменить.</target>       </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source>The string to replace all occurrences of <bpt id="p1">&lt;c&gt;</bpt>oldValue<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Строка для замены всех вхождений <bpt id="p1">&lt;c&gt;</bpt>oldValue<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source>Returns a new string in which all occurrences of a specified string in the current instance are replaced with another specified string.</source>
          <target state="translated">Возвращает новую строку, в которой все вхождения заданной строки в текущем экземпляре заменены другой заданной строкой.</target>       </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source>A string that is equivalent to the current string except that all instances of <ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> are replaced with <ph id="ph2">&lt;paramref name="newValue" /&gt;</ph>.</source>
          <target state="translated">Строка, эквивалентная текущей строке, но с тем отличием, что все вхождения <ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> заменены на <ph id="ph2">&lt;paramref name="newValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source>If <ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> is not found in the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Если <ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> не обнаружен в текущем экземпляре метод возвращает текущий экземпляр без изменений.</target>       </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>If <ph id="ph1">`newValue`</ph> is <ph id="ph2">`null`</ph>, all occurrences of <ph id="ph3">`oldValue`</ph> are removed.</source>
          <target state="translated">Если <ph id="ph1">`newValue`</ph> — <ph id="ph2">`null`</ph>, все вхождения <ph id="ph3">`oldValue`</ph> удаляются.</target>       </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Этот метод не изменяет значение текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>Instead, it returns a new string in which all occurrences of <ph id="ph1">`oldValue`</ph> are replaced by <ph id="ph2">`newValue`</ph>.</source>
          <target state="translated">Вместо этого он возвращает новую строку, в которой все вхождения <ph id="ph1">`oldValue`</ph> заменяются <ph id="ph2">`newValue`</ph>.</target>       </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>This method performs an ordinal (case-sensitive and culture-insensitive) search to find <ph id="ph1">`oldValue`</ph>.</source>
          <target state="translated">Этот метод выполняет поиск по порядковым номерам (с учетом регистра и без учета языка и региональных параметров) для поиска <ph id="ph1">`oldValue`</ph>.</target>       </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>Because this method returns the modified string, you can chain together successive calls to the <ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> method to perform multiple replacements on the original string.</source>
          <target state="translated">Так как этот метод возвращает измененную строку, можно соединить в цепочку вместе последующие вызовы <ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> метод для выполнения нескольких замены исходной строки.</target>       </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>Method calls are executed from left to right.</source>
          <target state="translated">Вызовы методов выполняются слева направо.</target>       </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>The following example provides an illustration.</source>
          <target state="translated">Ниже приведен пример.</target>       </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Replace(System.String,System.String)">
          <source>The following example demonstrates how you can use the <ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> method to correct a spelling error.</source>
          <target state="translated">В следующем примере показано, как можно использовать <ph id="ph1">&lt;xref:System.String.Replace%2A&gt;</ph> метода для исправления грамматической ошибки.</target>       </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" uid="M:System.String.Replace(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> is the empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="oldValue" /&gt;</ph> является пустой строкой ("").</target>       </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a string array that contains the substrings in this instance that are delimited by elements of a specified string or Unicode character array.</source>
          <target state="translated">Возвращает строковый массив, содержащий подстроки данного экземпляра, разделенные элементами заданной строки или массива знаков Юникода.</target>       </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> is used to break a delimited string into substrings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> используется для разбиение подстроки в строку с разделителями.</target>       </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can use either a character array to specify zero, one, or multiple delimiting characters (the <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> method), or you can use a character array to specify zero, one, or multiple delimiting strings.</source>
          <target state="translated">Массив символов можно использовать для указания ноль, один или несколько символы-разделители ( <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> метод), или массив символов можно использовать для указания ноль, один или несколько разделителей строк.</target>       </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Overloads of the <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method allow you to limit the number of substrings returned by the method (the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29&gt;</ph> method), to determine whether empty strings are included in the returned substrings (the <ph id="ph3">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph> and <ph id="ph4">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph> methods, or to do both (the <ph id="ph5">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29&gt;</ph> and <ph id="ph6">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29&gt;</ph> methods).</source>
          <target state="translated">Перегруженные версии <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> метод позволяют ограничить количество подстрок, возвращенный методом ( <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29&gt;</ph> метод), чтобы определить, включены ли пустые строки в возвращаемой подстроки ( <ph id="ph3">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph> и <ph id="ph4">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph> методов, или для другого ( <ph id="ph5">&lt;xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29&gt;</ph> и <ph id="ph6">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29&gt;</ph> методов).</target>       </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For more detailed information on the <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method, as well as for examples that call each overload, see the documentation for the individual overloads of <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph>.</source>
          <target state="translated">Для получения дополнительных сведений о <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> метода, как хорошо, как и для примеров, которые вызывают друг перегрузки, см. в документации для отдельных перегрузок <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method is not always the best way to break a delimited string into substrings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Метод не всегда является лучшим способом разбиение подстроки в строку с разделителями.</target>       </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you don't want to extract all of the substrings of a delimited string, or if you want to parse a string based on a pattern instead of a set of delimiter characters, consider the following alternatives.</source>
          <target state="translated">Если вы не хотите, чтобы извлечь все подстроки строку с разделителями, или если требуется синтаксический анализ строки на основе шаблона вместо набора символов-разделителей, рассмотрим следующие варианты.</target>       </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Regular expressions</source>
          <target state="translated">Регулярные выражения</target>       </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If your strings conform to a fixed pattern, you can use a regular expression to extract and handle their elements.</source>
          <target state="translated">Если строки соответствуют фиксированный шаблон, можно использовать регулярное выражение для извлечения и обрабатывать их элементов.</target>       </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, if strings take the form "<bpt id="p1">*</bpt>number<ept id="p1">*</ept> <bpt id="p2">*</bpt>operand<ept id="p2">*</ept> <bpt id="p3">*</bpt>number<ept id="p3">*</ept>" you can use a <bpt id="p4">[</bpt>regular expression<ept id="p4">](~/docs/standard/base-types/regular-expressions.md)</ept> to extract and handle the string's elements.</source>
          <target state="translated">Например, если строки представляются в виде «<bpt id="p1">*</bpt>номер<ept id="p1">*</ept> <bpt id="p2">*</bpt>операнд<ept id="p2">*</ept> <bpt id="p3">*</bpt>номер<ept id="p3">*</ept>» можно использовать <bpt id="p4">[</bpt>регулярное выражение<ept id="p4">](~/docs/standard/base-types/regular-expressions.md)</ept> для извлечения и обработки элементы строки.</target>       </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Here's an example:</source>
          <target state="translated">Ниже приведен пример:</target>       </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The regular expression pattern <ph id="ph1">`(\d+)\s+([-+*/])\s+(\d+)`</ph> is defined like this:</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`(\d+)\s+([-+*/])\s+(\d+)`</ph> определяется следующим образом:</target>       </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match one or more decimal digits.</source>
          <target state="translated">Совпадение с одной или несколькими десятичными цифрами.</target>       </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is the first capturing group.</source>
          <target state="translated">Это первая группа записи.</target>       </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match one or more whitespace characters.</source>
          <target state="translated">Совпадает с одним или несколькими символами пробела.</target>       </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match an arithmetic operator sign (+, -, *, or /).</source>
          <target state="translated">Соответствует знака арифметического оператора (+, -, *, или /).</target>       </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is the second capturing group.</source>
          <target state="translated">Это вторая группа записи.</target>       </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match one or more whitespace characters.</source>
          <target state="translated">Совпадает с одним или несколькими символами пробела.</target>       </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match one or more decimal digits.</source>
          <target state="translated">Совпадение с одной или несколькими десятичными цифрами.</target>       </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is the third capturing group.</source>
          <target state="translated">Это третья группа записи.</target>       </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can also use a regular expression to extract substrings from a string based on a pattern rather than a fixed set of characters.</source>
          <target state="translated">Можно также использовать регулярное выражение для извлечения подстрок из строки, на основе шаблона, а не фиксированный набор символов.</target>       </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is a common scenario when either of these conditions occurs:</source>
          <target state="translated">Это очень распространенный сценарий, когда происходит одно из этих условий:</target>       </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>One or more of the delimiter characters does not always serve as a delimiter in the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance.</source>
          <target state="translated">Один или несколько символов-разделителей не всегда использовать в качестве разделителя в <ph id="ph1">&lt;xref:System.String&gt;</ph> экземпляра.</target>       </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The sequence and number of delimiter characters is variable or unknown.</source>
          <target state="translated">Порядок и число символов-разделителей переменной или unknown.</target>       </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method cannot be used to split the following string, because the number of <ph id="ph2">`\n`</ph> (in C#) or <ph id="ph3">`vbCrLf`</ph> (in Visual Basic) characters is variable, and they don't always serve as delimiters.</source>
          <target state="translated">Например <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> метод не может использоваться для разделения следующую строку, поскольку число <ph id="ph2">`\n`</ph> (в C#) или <ph id="ph3">`vbCrLf`</ph> (в Visual Basic), символы — переменная, и они не всегда служат в качестве разделителей.</target>       </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>A regular expression can split this string easily, as the following example shows.</source>
          <target state="translated">Эта строка может разбиение регулярных выражений легко, как показано в следующем примере.</target>       </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The regular expression pattern <ph id="ph1">`\[([^\[\]]+)\]`</ph> is defined like this:</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`\[([^\[\]]+)\]`</ph> определяется следующим образом:</target>       </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match an opening bracket.</source>
          <target state="translated">Соответствует открывающей круглой скобкой.</target>       </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match any character that is not an opening or a closing bracket one or more times.</source>
          <target state="translated">Соответствует любому символу, не является открывающей или закрывающей скобкой один или несколько раз.</target>       </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>This is the first capturing group.</source>
          <target state="translated">Это первая группа записи.</target>       </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match a closing bracket.</source>
          <target state="translated">Соответствует закрывающая скобка.</target>       </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> method is almost identical to <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph>, except that it splits a string based on a regular expression pattern instead of a fixed character set.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> Метод практически идентичен <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph>, за исключением того, что она разбивает строку на основе шаблона регулярного выражения вместо набора символов фиксированной.</target>       </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>For example, the following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> method to split a string that contains substrings delimited by various combinations of hyphens and other characters.</source>
          <target state="translated">Например, в следующем примере используется <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> метод для разбиения строки, содержащий подстроки, разделенных различные сочетания дефисы и другие символы.</target>       </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The regular expression pattern <ph id="ph1">`\s-\s?[+*]?\s?-\s`</ph> is defined like this:</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`\s-\s?[+*]?\s?-\s`</ph> определяется следующим образом:</target>       </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match a whitespace character followed by a hyphen.</source>
          <target state="translated">Совпадает с символом пробела и дефиса.</target>       </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match zero or one whitespace character.</source>
          <target state="translated">Совпадение с нулем или одним символом пробела.</target>       </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match zero or one occurrence of either the + or * character.</source>
          <target state="translated">Совпадение с нулем или одним вхождением либо + или * символ.</target>       </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match zero or one whitespace character.</source>
          <target state="translated">Совпадение с нулем или одним символом пробела.</target>       </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Match a hyphen followed by a whitespace character.</source>
          <target state="translated">Выделение дефиса, за которым следует символ пробела.</target>       </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>Search methods and the Substring method</source>
          <target state="translated">Способы поиска и Substring-метод</target>       </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>If you aren't interested in all of the substrings in a string, you might prefer to work with one of the string comparison methods that returns the index at which the match begins.</source>
          <target state="translated">Если вы не хотите во всех подстроки в строке, вы предпочитаете работать с одним из методов сравнения строк, которые возвращает индекс, с которого начинается совпадение.</target>       </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>You can then call the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to extract the substring that you want.</source>
          <target state="translated">Затем можно вызвать <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> метод для извлечения подстроки, которую требуется.</target>       </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The string comparison methods include:</source>
          <target state="translated">Ниже перечислены методы сравнения строк.</target>       </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>, which returns the zero-based index of the first occurrence of a character or string in a string instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>, который возвращает отсчитываемый от нуля индекс первого вхождения символа или строки в экземпляре строки.</target>       </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>, which returns the zero-based index in the current string instance of the first occurrence of any character in a character array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>, который возвращает отсчитываемый от нуля индекс в текущем экземпляре строки первого вхождения любого символа в массиве символов.</target>       </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, which returns the zero-based index of the last occurrence of a character or string in a string instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, который возвращает отсчитываемый от нуля индекс последнего вхождения символа или строки в экземпляре строки.</target>       </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source><ph id="ph1">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph>, which returns a zero-based index in the current string instance of the last occurrence of any character in a character array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph>, который возвращает отсчитываемый от нуля индекс в текущем экземпляре строка последнего вхождения символа в массиве символов.</target>       </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method to find the periods in a string.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> способ поиска точек в строке.</target>       </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.String">
          <source>It then uses the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to return full sentences.</source>
          <target state="translated">Затем он использует <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> метод для возврата полного предложения.</target>       </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[])">
          <source>A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Массив символов, разделяющий подстроки в данной строке, пустой массив, не содержащий разделителей, или <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[])">
          <source>Splits a string into substrings that are based on the characters in an array.</source>
          <target state="translated">Разбивает строку на подстроки в зависимости от символов в массиве.</target>       </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[])">
          <source>An array whose elements contain the substrings from this instance that are delimited by one or more characters in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">Массив, элементы которого содержат подстроки из этого экземпляра, разделенные символами из <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[])">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>When a string is delimited by a known set of characters, you can use the <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> method to separate it into substrings.</source>
          <target state="translated">Если строка отделена с известным набором символов, можно использовать <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> метод, чтобы разделить подстроки.</target>       </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For other ways to extract substrings from a string, see the <bpt id="p1">[</bpt>Alternatives to String.Split<ept id="p1">](#Alternatives)</ept> section.</source>
          <target state="translated">Другие способы извлечения подстрок из строки, в разделе <bpt id="p1">[</bpt>альтернативы String.Split<ept id="p1">](#Alternatives)</ept> раздела.</target>       </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Return value details</source>
          <target state="translated">Сведения о возвращаемом значении</target>       </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Delimiter characters are not included in the elements of the returned array.</source>
          <target state="translated">Символы-разделители не включаются в возвращаемый массив элементов.</target>       </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For example, if the separator array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</source>
          <target state="translated">Например, если массив разделитель включает символ «-» и «aa bb cc» имеет значение текущего экземпляра строки, метод возвращает массив, содержащий три элемента: «aa», «bb» и «копия».</target>       </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If this instance does not contain any of the characters in <ph id="ph1">`separator`</ph>, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">Если данный экземпляр не содержит символов в <ph id="ph1">`separator`</ph>, возвращаемый массив состоит из единственного элемента, содержащего данный экземпляр.</target>       </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter character.</source>
          <target state="translated">Каждый элемент <ph id="ph1">`separator`</ph> определяет отдельный знак-разделитель.</target>       </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding element in the returned array contains <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">Если два разделителя являются смежными или с разделителем, обнаруженным в начале или в конце этого экземпляра, соответствующий элемент в возвращенном массиве содержит <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Here are some examples:</source>
          <target state="translated">Далее приводятся некоторые примеры.</target>       </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>String value</source>
          <target state="translated">Строковое значение</target>       </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Separator</source>
          <target state="translated">Separator</target>       </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Returned array</source>
          <target state="translated">Возвращаемый массив</target>       </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"42, 12, 19"</source>
          <target state="translated">"42, 12, 19"</target>       </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>new Char[] {',', ' '} (C#)</source>
          <target state="translated">новые Char [] {',', ' '} (C#)</target>       </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Char() = {","c, " "c}) (Visual Basic)</source>
          <target state="translated">Char() = {«,» c «» c}) (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>{"42", "", "12", "", "19"}</source>
          <target state="translated">{"42", "", "12", "", "19"}</target>       </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"42..12..19"</source>
          <target state="translated">"42..12..19"</target>       </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>new Char[] {'.'}</source>
          <target state="translated">новые Char [] {"."}</target>       </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>(C#)</source>
          <target state="translated">(C#)</target>       </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Char() = {"."c} (Visual Basic)</source>
          <target state="translated">Char() = {«.» c} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>{"42", "", "12", "", "19"}</source>
          <target state="translated">{"42", "", "12", "", "19"}</target>       </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"Banana"</source>
          <target state="translated">«Banana»</target>       </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>new Char[] {'.'}</source>
          <target state="translated">новые Char [] {"."}</target>       </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>(C#)</source>
          <target state="translated">(C#)</target>       </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Char() = {"."c} (Visual Basic)</source>
          <target state="translated">Char() = {«.» c} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>{"Banana"}</source>
          <target state="translated">{«Банана»}</target>       </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"Darb\nSmarba" (C#)</source>
          <target state="translated">«Darb\nSmarba» (C#)</target>       </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">«Darb» &amp; vbLf &amp; «Smarba» (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>new Char[] <ph id="ph1">{}</ph> (C#)</source>
          <target state="translated">новые Char [] <ph id="ph1">{}</ph> (C#)</target>       </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Char() = <ph id="ph1">{}</ph> (Visual Basic)</source>
          <target state="translated">Char() = <ph id="ph1">{}</ph> (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>{"Darb", "Smarba"}</source>
          <target state="translated">{«Darb», «Smarba»}</target>       </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"Darb\nSmarba" (C#)</source>
          <target state="translated">«Darb\nSmarba» (C#)</target>       </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">«Darb» &amp; vbLf &amp; «Smarba» (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>null (C#)</source>
          <target state="translated">null (C#)</target>       </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Nothing (Visual Basic)</source>
          <target state="translated">Nothing (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>{"Darb", "Smarba"}</source>
          <target state="translated">{«Darb», «Smarba»}</target>       </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The separator array</source>
          <target state="translated">Массив разделителя</target>       </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Each element of separator defines a separate delimiter that consists of a single character.</source>
          <target state="translated">Каждый элемент разделителя определяет отдельный разделитель, который состоит из одного символа.</target>       </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If the <ph id="ph1">`separator`</ph> argument is <ph id="ph2">`null`</ph> or contains no characters, the method treats white-space characters as the delimiters.</source>
          <target state="translated">Если <ph id="ph1">`separator`</ph> аргумент <ph id="ph2">`null`</ph> или не содержит символов, метод рассматривает пробелы как разделители.</target>       </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>White-space characters are defined by the Unicode standard; they return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Символы-разделители определяются Unicode standard. они возвращают <ph id="ph1">`true`</ph> , если они передаются <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>String.Split(Char[]) and compiler overload resolution</source>
          <target state="translated">Разрешение перегрузки String.Split(Char[]) и компилятора</target>       </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Although the single parameter for this overload of <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> is a character array, you can call it with a single character, as the following example shows.</source>
          <target state="translated">Несмотря на то что одним параметром для перегруженного <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> является массив символов, его можно вызвать в виде одного символа, как показано в следующем примере.</target>       </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Because the <ph id="ph1">`separator`</ph> parameter is decorated  with the <ph id="ph2">&lt;xref:System.ParamArrayAttribute&gt;</ph> attribute, compilers will interpret a single character as a single-element character array.</source>
          <target state="translated">Поскольку <ph id="ph1">`separator`</ph> декорированных параметр <ph id="ph2">&lt;xref:System.ParamArrayAttribute&gt;</ph> атрибут, компиляторы будет интерпретировать один символ как символ одноэлементный массив.</target>       </trans-unit>
        <trans-unit id="2904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is not the case for other <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> overloads that include a <ph id="ph2">`separator`</ph> parameter; you must explicitly pass these overloads a character array as the <ph id="ph3">`separator`</ph> argument.</source>
          <target state="translated">Это не так, для других <ph id="ph1">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph> перегрузки, включающие <ph id="ph2">`separator`</ph> параметр; необходимо явным образом передать эти перегрузки массив символов, как <ph id="ph3">`separator`</ph> аргумент.</target>       </trans-unit>
        <trans-unit id="2905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Comparison details</source>
          <target state="translated">Сведения о сравнении</target>       </trans-unit>
        <trans-unit id="2906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> method extracts the substrings in this string that are delimited by one or more of the characters in the <ph id="ph2">`separator`</ph> array, and returns those substrings as elements of an array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> Метод извлекает подстроки данной строки, разделенные одним или несколькими символами в <ph id="ph2">`separator`</ph> массива и возвращает эти подстроки в виде элементов в массиве.</target>       </trans-unit>
        <trans-unit id="2907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> Метод ищет разделители, выполняя сравнения с использованием правил сортировки по порядковому номеру с учетом регистра.</target>       </trans-unit>
        <trans-unit id="2908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For more information about word, string, and ordinal sorts, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Дополнительные сведения о слова, строки и порядковым номерам см. в разделе <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> перечисления.</target>       </trans-unit>
        <trans-unit id="2909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Alternatives to String.Split</source>
          <target state="translated">Альтернативы String.Split</target>       </trans-unit>
        <trans-unit id="2910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method is not always the best way to break a delimited string into substrings.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Метод не всегда является лучшим способом разбиение подстроки в строку с разделителями.</target>       </trans-unit>
        <trans-unit id="2911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If you don't want to extract all of the substrings of a delimited string, or if you want to parse a string based on a pattern instead of a set of delimiter characters, consider the following alternatives.</source>
          <target state="translated">Если вы не хотите, чтобы извлечь все подстроки строку с разделителями, или если требуется синтаксический анализ строки на основе шаблона вместо набора символов-разделителей, рассмотрим следующие варианты.</target>       </trans-unit>
        <trans-unit id="2912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Regular expressions</source>
          <target state="translated">Регулярные выражения</target>       </trans-unit>
        <trans-unit id="2913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If your strings conform to a fixed pattern, you can use a regular expression to extract and handle their elements.</source>
          <target state="translated">Если строки соответствуют фиксированный шаблон, можно использовать регулярное выражение для извлечения и обрабатывать их элементов.</target>       </trans-unit>
        <trans-unit id="2914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For example, if strings take the form "<bpt id="p1">*</bpt>number<ept id="p1">*</ept> <bpt id="p2">*</bpt>operand<ept id="p2">*</ept> <bpt id="p3">*</bpt>number<ept id="p3">*</ept>" you can use a <bpt id="p4">[</bpt>regular expression<ept id="p4">](~/docs/standard/base-types/regular-expressions.md)</ept> to extract and handle the string's elements.</source>
          <target state="translated">Например, если строки представляются в виде «<bpt id="p1">*</bpt>номер<ept id="p1">*</ept> <bpt id="p2">*</bpt>операнд<ept id="p2">*</ept> <bpt id="p3">*</bpt>номер<ept id="p3">*</ept>» можно использовать <bpt id="p4">[</bpt>регулярное выражение<ept id="p4">](~/docs/standard/base-types/regular-expressions.md)</ept> для извлечения и обработки элементы строки.</target>       </trans-unit>
        <trans-unit id="2915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Here's an example:</source>
          <target state="translated">Ниже приведен пример:</target>       </trans-unit>
        <trans-unit id="2916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The regular expression pattern <ph id="ph1">`(\d+)\s+([-+*/])\s+(\d+)`</ph> is defined like this:</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`(\d+)\s+([-+*/])\s+(\d+)`</ph> определяется следующим образом:</target>       </trans-unit>
        <trans-unit id="2917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="2918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match one or more decimal digits.</source>
          <target state="translated">Совпадение с одной или несколькими десятичными цифрами.</target>       </trans-unit>
        <trans-unit id="2920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is the first capturing group.</source>
          <target state="translated">Это первая группа записи.</target>       </trans-unit>
        <trans-unit id="2921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match one or more whitespace characters.</source>
          <target state="translated">Совпадает с одним или несколькими символами пробела.</target>       </trans-unit>
        <trans-unit id="2922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match an arithmetic operator sign (+, -, *, or /).</source>
          <target state="translated">Соответствует знака арифметического оператора (+, -, *, или /).</target>       </trans-unit>
        <trans-unit id="2923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is the second capturing group.</source>
          <target state="translated">Это вторая группа записи.</target>       </trans-unit>
        <trans-unit id="2924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match one or more whitespace characters.</source>
          <target state="translated">Совпадает с одним или несколькими символами пробела.</target>       </trans-unit>
        <trans-unit id="2925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match one or more decimal digits.</source>
          <target state="translated">Совпадение с одной или несколькими десятичными цифрами.</target>       </trans-unit>
        <trans-unit id="2926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is the third capturing group.</source>
          <target state="translated">Это третья группа записи.</target>       </trans-unit>
        <trans-unit id="2927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>You can also use a regular expression to extract substrings from a string based on a pattern rather than a fixed set of characters.</source>
          <target state="translated">Можно также использовать регулярное выражение для извлечения подстрок из строки, на основе шаблона, а не фиксированный набор символов.</target>       </trans-unit>
        <trans-unit id="2928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is a common scenario when either of these conditions occurs:</source>
          <target state="translated">Это очень распространенный сценарий, когда происходит одно из этих условий:</target>       </trans-unit>
        <trans-unit id="2929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>One or more of the delimiter characters does not always serve as a delimiter in the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance.</source>
          <target state="translated">Один или несколько символов-разделителей не всегда использовать в качестве разделителя в <ph id="ph1">&lt;xref:System.String&gt;</ph> экземпляра.</target>       </trans-unit>
        <trans-unit id="2930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The sequence and number of delimiter characters is variable or unknown.</source>
          <target state="translated">Порядок и число символов-разделителей переменной или unknown.</target>       </trans-unit>
        <trans-unit id="2931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method cannot be used to split the following string, because the number of <ph id="ph2">`\n`</ph> (in C#) or <ph id="ph3">`vbCrLf`</ph> (in Visual Basic) characters is variable, and they don't always serve as delimiters.</source>
          <target state="translated">Например <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> метод не может использоваться для разделения следующую строку, поскольку число <ph id="ph2">`\n`</ph> (в C#) или <ph id="ph3">`vbCrLf`</ph> (в Visual Basic), символы — переменная, и они не всегда служат в качестве разделителей.</target>       </trans-unit>
        <trans-unit id="2932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>A regular expression can split this string easily, as the following example shows.</source>
          <target state="translated">Эта строка может разбиение регулярных выражений легко, как показано в следующем примере.</target>       </trans-unit>
        <trans-unit id="2933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The regular expression pattern <ph id="ph1">`\[([^\[\]]+)\]`</ph> is defined like this:</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`\[([^\[\]]+)\]`</ph> определяется следующим образом:</target>       </trans-unit>
        <trans-unit id="2934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="2935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match an opening bracket.</source>
          <target state="translated">Соответствует открывающей круглой скобкой.</target>       </trans-unit>
        <trans-unit id="2937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match any character that is not an opening or a closing bracket one or more times.</source>
          <target state="translated">Соответствует любому символу, не является открывающей или закрывающей скобкой один или несколько раз.</target>       </trans-unit>
        <trans-unit id="2938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This is the first capturing group.</source>
          <target state="translated">Это первая группа записи.</target>       </trans-unit>
        <trans-unit id="2939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match a closing bracket.</source>
          <target state="translated">Соответствует закрывающая скобка.</target>       </trans-unit>
        <trans-unit id="2940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> method is almost identical to <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph>, except that it splits a string based on a regular expression pattern instead of a fixed character set.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> Метод практически идентичен <ph id="ph2">&lt;xref:System.String.Split%2A?displayProperty=nameWithType&gt;</ph>, за исключением того, что она разбивает строку на основе шаблона регулярного выражения вместо набора символов фиксированной.</target>       </trans-unit>
        <trans-unit id="2941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>For example, the following example uses the <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> method to split a string that contains substrings delimited by various combinations of hyphens and other characters.</source>
          <target state="translated">Например, в следующем примере используется <ph id="ph1">&lt;xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType&gt;</ph> метод для разбиения строки, содержащий подстроки, разделенных различные сочетания дефисы и другие символы.</target>       </trans-unit>
        <trans-unit id="2942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The regular expression pattern <ph id="ph1">`\s-\s?[+*]?\s?-\s`</ph> is defined like this:</source>
          <target state="translated">Шаблон регулярного выражения <ph id="ph1">`\s-\s?[+*]?\s?-\s`</ph> определяется следующим образом:</target>       </trans-unit>
        <trans-unit id="2943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Pattern</source>
          <target state="translated">Шаблон</target>       </trans-unit>
        <trans-unit id="2944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Description</source>
          <target state="translated">Описание:</target>       </trans-unit>
        <trans-unit id="2945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match a whitespace character followed by a hyphen.</source>
          <target state="translated">Совпадает с символом пробела и дефиса.</target>       </trans-unit>
        <trans-unit id="2946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match zero or one whitespace character.</source>
          <target state="translated">Совпадение с нулем или одним символом пробела.</target>       </trans-unit>
        <trans-unit id="2947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match zero or one occurrence of either the + or * character.</source>
          <target state="translated">Совпадение с нулем или одним вхождением либо + или * символ.</target>       </trans-unit>
        <trans-unit id="2948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match zero or one whitespace character.</source>
          <target state="translated">Совпадение с нулем или одним символом пробела.</target>       </trans-unit>
        <trans-unit id="2949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Match a hyphen followed by a whitespace character.</source>
          <target state="translated">Выделение дефиса, за которым следует символ пробела.</target>       </trans-unit>
        <trans-unit id="2950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Search methods and the Substring method</source>
          <target state="translated">Способы поиска и Substring-метод</target>       </trans-unit>
        <trans-unit id="2951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If you aren't interested in all of the substrings in a string, you might prefer to work with one of the string comparison methods that returns the index at which the match begins.</source>
          <target state="translated">Если вы не хотите во всех подстроки в строке, вы предпочитаете работать с одним из методов сравнения строк, которые возвращает индекс, с которого начинается совпадение.</target>       </trans-unit>
        <trans-unit id="2952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>You can then call the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to extract the substring that you want.</source>
          <target state="translated">Затем можно вызвать <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> метод для извлечения подстроки, которую требуется.</target>       </trans-unit>
        <trans-unit id="2953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The string comparison methods include:</source>
          <target state="translated">Ниже перечислены методы сравнения строк.</target>       </trans-unit>
        <trans-unit id="2954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source><ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>, which returns the zero-based index of the first occurrence of a character or string in a string instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph>, который возвращает отсчитываемый от нуля индекс первого вхождения символа или строки в экземпляре строки.</target>       </trans-unit>
        <trans-unit id="2955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source><ph id="ph1">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>, which returns the zero-based index in the current string instance of the first occurrence of any character in a character array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IndexOfAny%2A&gt;</ph>, который возвращает отсчитываемый от нуля индекс в текущем экземпляре строки первого вхождения любого символа в массиве символов.</target>       </trans-unit>
        <trans-unit id="2956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source><ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, which returns the zero-based index of the last occurrence of a character or string in a string instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.LastIndexOf%2A&gt;</ph>, который возвращает отсчитываемый от нуля индекс последнего вхождения символа или строки в экземпляре строки.</target>       </trans-unit>
        <trans-unit id="2957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source><ph id="ph1">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph>, which returns a zero-based index in the current string instance of the last occurrence of any character in a character array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.LastIndexOfAny%2A&gt;</ph>, который возвращает отсчитываемый от нуля индекс в текущем экземпляре строка последнего вхождения символа в массиве символов.</target>       </trans-unit>
        <trans-unit id="2958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method to find the periods in a string.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> способ поиска точек в строке.</target>       </trans-unit>
        <trans-unit id="2959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>It then uses the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to return full sentences.</source>
          <target state="translated">Затем он использует <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> метод для возврата полного предложения.</target>       </trans-unit>
        <trans-unit id="2960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Performance Considerations</source>
          <target state="translated">Особенности производительности</target>       </trans-unit>
        <trans-unit id="2961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Методы выделить память для объекта, возвращаемого массива и <ph id="ph2">&lt;xref:System.String&gt;</ph> объект для каждого элемента массива.</target>       </trans-unit>
        <trans-unit id="2962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method.</source>
          <target state="translated">Если приложение требует оптимальной производительности или распределением памяти играют важную роль в приложении, рассмотрите возможность использования <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>You also have the option of using the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to locate a substring within a string.</source>
          <target state="translated">Также имеется возможность использования <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> метод для поиска подстроки в строке.</target>       </trans-unit>
        <trans-unit id="2964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>To split a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">Для разбиения строки на символ-разделитель, используйте <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> метод нахождения знаков-разделителей в строке.</target>       </trans-unit>
        <trans-unit id="2965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>To split a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">Для разбиения строки на строку разделителя, используйте <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> метод для обнаружения первого символа строки-разделителя.</target>       </trans-unit>
        <trans-unit id="2966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">Затем с помощью <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> метод, чтобы определить, равны ли знаки после первого знака остальные символы строки-разделителя.</target>       </trans-unit>
        <trans-unit id="2967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">Кроме того, если же набор символов используется для разделения строк в нескольких <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> вызовы методов, рекомендуется создать один массив и ссылки на него в каждом вызове метода.</target>       </trans-unit>
        <trans-unit id="2968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">Это значительно уменьшает дополнительную нагрузку, каждый вызов метода.</target>       </trans-unit>
        <trans-unit id="2969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The following example demonstrates how to extract individual words from a block of text by treating white space and punctuation marks as delimiters.</source>
          <target state="translated">Ниже приведен пример, как извлечь отдельные слова из блока текста, рассматривая пробелы и знаки препинания как разделители.</target>       </trans-unit>
        <trans-unit id="2970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>The character array passed to the <ph id="ph1">`separator`</ph> parameter of the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> method consists of a space character and a tab character, together with some common punctuation symbols.</source>
          <target state="translated">Массив символов, передаваемый <ph id="ph1">`separator`</ph> параметр <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> метод состоит из пробел и знак табуляции, а также некоторые специальные символы пунктуации.</target>       </trans-unit>
        <trans-unit id="2971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">В <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> и более ранних версий, если <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> методу передается <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> , <ph id="ph4">&lt;see langword="null" /&gt;</ph> или не содержит символов, метод использует несколько иной набор символов для разбиения строки, чем <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> выполняет метод для обрежьте строку.</target>       </trans-unit>
        <trans-unit id="2972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[])">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">В <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, оба метода используют идентичный набор пробельные символы Юникода.</target>       </trans-unit>
        <trans-unit id="2973" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Массив символов, разделяющий подстроки в данной строке, пустой массив, не содержащий разделителей, или <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2974" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>The maximum number of substrings to return.</source>
          <target state="translated">Максимальное число возвращаемых подстрок.</target>       </trans-unit>
        <trans-unit id="2975" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Splits a string into a maximum number of substrings based on the characters in an array.</source>
          <target state="translated">Разбивает строку на максимальное число подстрок в зависимости от символов в массиве.</target>       </trans-unit>
        <trans-unit id="2976" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>You also specify the maximum number of substrings to return.</source>
          <target state="translated">Можно также указать максимальное число возвращаемых подстрок.</target>       </trans-unit>
        <trans-unit id="2977" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>An array whose elements contain the substrings in this instance that are delimited by one or more characters in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">Массив, элементы которого содержат подстроки данного экземпляра, разделенные одним или более знаками из <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2978" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="2979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Delimiter characters are not included in the elements of the returned array.</source>
          <target state="translated">Символы-разделители не включаются в возвращаемый массив элементов.</target>       </trans-unit>
        <trans-unit id="2980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If this instance does not contain any of the characters in <ph id="ph1">`separator`</ph>, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">Если данный экземпляр не содержит символов в <ph id="ph1">`separator`</ph>, возвращаемый массив состоит из единственного элемента, содержащего данный экземпляр.</target>       </trans-unit>
        <trans-unit id="2981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If <ph id="ph1">`count`</ph> is zero, an empty array is returned.</source>
          <target state="translated">Если <ph id="ph1">`count`</ph> равен нулю, возвращается пустой массив.</target>       </trans-unit>
        <trans-unit id="2982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
          <target state="translated">Если <ph id="ph1">`separator`</ph> параметр <ph id="ph2">`null`</ph> или не содержит символы, пробелы считаются разделителями.</target>       </trans-unit>
        <trans-unit id="2983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Символы-разделители определяются Unicode standard и возврата <ph id="ph1">`true`</ph> , если они передаются <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter character.</source>
          <target state="translated">Каждый элемент <ph id="ph1">`separator`</ph> определяет отдельный знак-разделитель.</target>       </trans-unit>
        <trans-unit id="2985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">Если два разделителя являются смежными или с разделителем, обнаруженным в начале или в конце этого экземпляра, соответствующий элемент массива содержит <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If there are more than <ph id="ph1">`count`</ph> substrings in this instance, the first <ph id="ph2">`count`</ph> minus 1 substrings are returned in the first <ph id="ph3">`count`</ph> minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</source>
          <target state="translated">При наличии более чем <ph id="ph1">`count`</ph> подстроки данного экземпляра, первый <ph id="ph2">`count`</ph> минус 1 подстрок возвращаются в первом <ph id="ph3">`count`</ph> возвращается минус 1 элементах возвращаемого значения, а остальные символы в этом экземпляре за последние элемент возвращаемого значения.</target>       </trans-unit>
        <trans-unit id="2987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If <ph id="ph1">`count`</ph> is greater than the number of substrings, the available substrings are returned and no exception is thrown.</source>
          <target state="translated">Если <ph id="ph1">`count`</ph> больше, чем число подстрок, доступных подстроки возвращаются и исключение не возникает.</target>       </trans-unit>
        <trans-unit id="2988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>The following table provides examples.</source>
          <target state="translated">В следующей таблице приведены примеры.</target>       </trans-unit>
        <trans-unit id="2989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>String value</source>
          <target state="translated">Строковое значение</target>       </trans-unit>
        <trans-unit id="2990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Separator</source>
          <target state="translated">Separator</target>       </trans-unit>
        <trans-unit id="2991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Count</source>
          <target state="translated">Количество</target>       </trans-unit>
        <trans-unit id="2992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Returned array</source>
          <target state="translated">Возвращаемый массив</target>       </trans-unit>
        <trans-unit id="2993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"42, 12, 19"</source>
          <target state="translated">"42, 12, 19"</target>       </trans-unit>
        <trans-unit id="2994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] {',', ' '} (C#)</source>
          <target state="translated">новые Char [] {',', ' '} (C#)</target>       </trans-unit>
        <trans-unit id="2995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = {","c, " "c} (Visual Basic)</source>
          <target state="translated">Char() = {«,» c «» c} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="2996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="2997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"42", " 12, 19"}</source>
          <target state="translated">{"42", " 12, 19"}</target>       </trans-unit>
        <trans-unit id="2998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"42..12..19"</source>
          <target state="translated">"42..12..19"</target>       </trans-unit>
        <trans-unit id="2999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] {'.'}</source>
          <target state="translated">новые Char [] {"."}</target>       </trans-unit>
        <trans-unit id="3000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>(C#)</source>
          <target state="translated">(C#)</target>       </trans-unit>
        <trans-unit id="3001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = {"."c} (Visual Basic)</source>
          <target state="translated">Char() = {«.» c} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>4</source>
          <target state="translated">4</target>       </trans-unit>
        <trans-unit id="3003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"42", "", "12", ".19"}</source>
          <target state="translated">{"42", "", "12", ".19"}</target>       </trans-unit>
        <trans-unit id="3004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Banana"</source>
          <target state="translated">«Banana»</target>       </trans-unit>
        <trans-unit id="3005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] {'.'}</source>
          <target state="translated">новые Char [] {"."}</target>       </trans-unit>
        <trans-unit id="3006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>(C#)</source>
          <target state="translated">(C#)</target>       </trans-unit>
        <trans-unit id="3007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = {"."c} (Visual Basic)</source>
          <target state="translated">Char() = {«.» c} (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="3009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"Banana"}</source>
          <target state="translated">{«Банана»}</target>       </trans-unit>
        <trans-unit id="3010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb\nSmarba" (C#)</source>
          <target state="translated">«Darb\nSmarba» (C#)</target>       </trans-unit>
        <trans-unit id="3011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">«Darb» &amp; vbLf &amp; «Smarba» (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] <ph id="ph1">{}</ph> (C#)</source>
          <target state="translated">новые Char [] <ph id="ph1">{}</ph> (C#)</target>       </trans-unit>
        <trans-unit id="3013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = <ph id="ph1">{}</ph> (Visual Basic)</source>
          <target state="translated">Char() = <ph id="ph1">{}</ph> (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="3015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"Darb\nSmarba"} (C#)</source>
          <target state="translated">{«Darb\nSmarba»} (C#)</target>       </trans-unit>
        <trans-unit id="3016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">«Darb» &amp; vbLf &amp; «Smarba» (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb\nSmarba" (C#)</source>
          <target state="translated">«Darb\nSmarba» (C#)</target>       </trans-unit>
        <trans-unit id="3018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">«Darb» &amp; vbLf &amp; «Smarba» (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] null (C#)</source>
          <target state="translated">новый Char [] null (C#)</target>       </trans-unit>
        <trans-unit id="3020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = Nothing</source>
          <target state="translated">Char() = Nothing</target>       </trans-unit>
        <trans-unit id="3021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="3022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"Darb", "Smarba"}</source>
          <target state="translated">{«Darb», «Smarba»}</target>       </trans-unit>
        <trans-unit id="3023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb\nSmarba" (C#)</source>
          <target state="translated">«Darb\nSmarba» (C#)</target>       </trans-unit>
        <trans-unit id="3024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>"Darb" &amp; vbLf &amp; "Smarba" (Visual Basic)</source>
          <target state="translated">«Darb» &amp; vbLf &amp; «Smarba» (Visual Basic)</target>       </trans-unit>
        <trans-unit id="3025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>new Char[] null (C#)</source>
          <target state="translated">новый Char [] null (C#)</target>       </trans-unit>
        <trans-unit id="3026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Char() = Nothing</source>
          <target state="translated">Char() = Nothing</target>       </trans-unit>
        <trans-unit id="3027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>100</source>
          <target state="translated">100</target>       </trans-unit>
        <trans-unit id="3028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>{"Darb", "Smarba"}</source>
          <target state="translated">{«Darb», «Smarba»}</target>       </trans-unit>
        <trans-unit id="3029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Performance Considerations</source>
          <target state="translated">Особенности производительности</target>       </trans-unit>
        <trans-unit id="3030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Методы выделить память для объекта, возвращаемого массива и <ph id="ph2">&lt;xref:System.String&gt;</ph> объект для каждого элемента массива.</target>       </trans-unit>
        <trans-unit id="3031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
          <target state="translated">Если приложение требует оптимальной производительности или распределением памяти играют важную роль в приложении, рассмотрите возможность использования <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> метод и при необходимости <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> метод для поиска подстроки в строке.</target>       </trans-unit>
        <trans-unit id="3032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">Если требуется разбить строку на символ-разделитель, используйте <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> метод нахождения знаков-разделителей в строке.</target>       </trans-unit>
        <trans-unit id="3033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">Если требуется разделить строку в строку разделителя, используйте <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> метод для обнаружения первого символа строки-разделителя.</target>       </trans-unit>
        <trans-unit id="3034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">Затем с помощью <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> метод, чтобы определить, равны ли знаки после первого знака остальные символы строки-разделителя.</target>       </trans-unit>
        <trans-unit id="3035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">Кроме того, если же набор символов используется для разделения строк в нескольких <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> вызовы методов, рекомендуется создать один массив и ссылки на него в каждом вызове метода.</target>       </trans-unit>
        <trans-unit id="3036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">Это значительно уменьшает дополнительную нагрузку, каждый вызов метода.</target>       </trans-unit>
        <trans-unit id="3037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>The following example demonstrates how <ph id="ph1">`count`</ph> affects the number of strings returned by <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph>.</source>
          <target state="translated">В следующем примере показано, как <ph id="ph1">`count`</ph> влияет на число строк, возвращенных <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3038" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> является отрицательным значением.</target>       </trans-unit>
        <trans-unit id="3039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">В <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> и более ранних версий, если <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> методу передается <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> , <ph id="ph4">&lt;see langword="null" /&gt;</ph> или не содержит символов, метод использует несколько иной набор символов для разбиения строки, чем <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> выполняет метод для обрежьте строку.</target>       </trans-unit>
        <trans-unit id="3040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">В <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, оба метода используют идентичный набор пробельные символы Юникода.</target>       </trans-unit>
        <trans-unit id="3041" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Массив символов, разделяющий подстроки в данной строке, пустой массив, не содержащий разделителей, или <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3042" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> to omit empty array elements from the array returned; or <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> to include empty array elements in the array returned.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph>, чтобы исключить пустые элементы из возвращаемого массива; или <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> для включения пустых элементов в возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="3043" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Splits a string into substrings based on the characters in an array.</source>
          <target state="translated">Разбивает строку на подстроки в зависимости от символов в массиве.</target>       </trans-unit>
        <trans-unit id="3044" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>You can specify whether the substrings include empty array elements.</source>
          <target state="translated">Можно указать, включают ли подстроки пустые элементы массива.</target>       </trans-unit>
        <trans-unit id="3045" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>An array whose elements contain the substrings in this string that are delimited by one or more characters in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">Массив, элементы которого содержат подстроки данной строки, разделенные одним или более знаками из <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3046" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="3047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Return value details</source>
          <target state="translated">Сведения о возвращаемом значении</target>       </trans-unit>
        <trans-unit id="3048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Delimiter characters (the characters in the <ph id="ph1">`separator`</ph> array) are not included in the elements of the returned array.</source>
          <target state="translated">Символы-разделители (символы в <ph id="ph1">`separator`</ph> массива) не включаются в возвращаемый массив элементов.</target>       </trans-unit>
        <trans-unit id="3049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>For example, if the <ph id="ph1">`separator`</ph> array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</source>
          <target state="translated">Например если <ph id="ph1">`separator`</ph> массива включает символ «-» и «aa bb cc» имеет значение текущего экземпляра строки, метод возвращает массив, содержащий три элемента: «aa», «bb» и «cc».</target>       </trans-unit>
        <trans-unit id="3050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If this instance does not contain any of the characters in <ph id="ph1">`separator`</ph>, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">Если данный экземпляр не содержит символов в <ph id="ph1">`separator`</ph>, возвращаемый массив состоит из единственного элемента, содержащего данный экземпляр.</target>       </trans-unit>
        <trans-unit id="3051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> parameter is <ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> and the length of this instance is zero, the method returns an empty array.</source>
          <target state="translated">Если <ph id="ph1">`options`</ph> параметр <ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> и имеет нулевую длину этого экземпляра, метод возвращает пустой массив.</target>       </trans-unit>
        <trans-unit id="3052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter that consists of a single character.</source>
          <target state="translated">Каждый элемент <ph id="ph1">`separator`</ph> определяет отдельный разделитель, который состоит из одного символа.</target>       </trans-unit>
        <trans-unit id="3053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> argument is <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Если <ph id="ph1">`options`</ph> аргумент <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>и два разделителя являются смежными или разделитель в начале или в конце этого экземпляра, соответствующий элемент массива содержит <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>For example, if <ph id="ph1">`separator`</ph> includes  two elements, "-" and "<ph id="ph2">\_</ph>", the value of the string instance is "-<ph id="ph3">\_</ph>aa-<ph id="ph4">\_</ph>", and the value of   the <ph id="ph5">`options`</ph> argument is <ph id="ph6">&lt;xref:System.StringSplitOptions.None&gt;</ph>, the method returns a string array with the following five elements:</source>
          <target state="translated">Например если <ph id="ph1">`separator`</ph> входят два элемента, «-» и»<ph id="ph2">\_</ph>», значение экземпляра строки»-<ph id="ph3">\_</ph>aa -<ph id="ph4">\_</ph>» и значение <ph id="ph5">`options`</ph> аргумент является <ph id="ph6">&lt;xref:System.StringSplitOptions.None&gt;</ph>, метод возвращает массив строк с помощью следующие пять элементов:</target>       </trans-unit>
        <trans-unit id="3055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that precedes the "-" character at index 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, который представляет пустую строку, которая предшествует»-«знак с индексом 0.</target>       </trans-unit>
        <trans-unit id="3056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string between the "-" character at index 0 and the "_" character at index 1.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, который представляет пустую строку между»-«знак с индексом 0 и символа «_» с индексом 1.</target>       </trans-unit>
        <trans-unit id="3057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>"aa",</source>
          <target state="translated">«aa»</target>       </trans-unit>
        <trans-unit id="3058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that follows the "_" character at index 4.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, который представляет пустую строку после символа «_» в строке по индексу 4.</target>       </trans-unit>
        <trans-unit id="3059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that follows the "-" character at index 5.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, который представляет пустую строку, которая следует за»-«символ по индексу 5.</target>       </trans-unit>
        <trans-unit id="3060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The separator array</source>
          <target state="translated">Массив разделителя</target>       </trans-unit>
        <trans-unit id="3061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
          <target state="translated">Если <ph id="ph1">`separator`</ph> параметр <ph id="ph2">`null`</ph> или не содержит символы, пробелы считаются разделителями.</target>       </trans-unit>
        <trans-unit id="3062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Символы-разделители определяются Unicode standard и возврата <ph id="ph1">`true`</ph> , если они передаются <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter in the call to this method overload is <ph id="ph2">`null`</ph>, compiler overload resolution fails.</source>
          <target state="translated">Если <ph id="ph1">`separator`</ph> параметр в вызове перегрузка метода является <ph id="ph2">`null`</ph>, происходит сбой разрешения перегрузки компилятора.</target>       </trans-unit>
        <trans-unit id="3064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>To unambiguously identify the called method, your code must indicate the type of the <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Для однозначной идентификации, вызываемому методу, коде необходимо указать тип <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="3065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The following example shows several ways to unambiguously identify this overload.</source>
          <target state="translated">В следующем примере показано несколько способов для однозначной идентификации, эта перегрузка.</target>       </trans-unit>
        <trans-unit id="3066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Comparison details</source>
          <target state="translated">Сведения о сравнении</target>       </trans-unit>
        <trans-unit id="3067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method extracts the substrings in this string that are delimited by one or more of the characters in the <ph id="ph2">`separator`</ph> parameter, and returns those substrings as elements of an array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Метод извлекает подстроки данной строки, разделенные одним или несколькими символами в <ph id="ph2">`separator`</ph> параметра и возвращает эти подстроки в виде элементов в массиве.</target>       </trans-unit>
        <trans-unit id="3068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Метод ищет разделители, выполняя сравнения с использованием правил сортировки по порядковому номеру с учетом регистра.</target>       </trans-unit>
        <trans-unit id="3069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>For more information about word, string, and ordinal sorts, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Дополнительные сведения о слова, строки и порядковым номерам см. в разделе <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> перечисления.</target>       </trans-unit>
        <trans-unit id="3070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Performance Considerations</source>
          <target state="translated">Особенности производительности</target>       </trans-unit>
        <trans-unit id="3071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Методы выделить память для объекта, возвращаемого массива и <ph id="ph2">&lt;xref:System.String&gt;</ph> объект для каждого элемента массива.</target>       </trans-unit>
        <trans-unit id="3072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
          <target state="translated">Если приложение требует оптимальной производительности или распределением памяти играют важную роль в приложении, рассмотрите возможность использования <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> метод и при необходимости <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> метод для поиска подстроки в строке.</target>       </trans-unit>
        <trans-unit id="3073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">Если требуется разбить строку на символ-разделитель, используйте <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> метод нахождения знаков-разделителей в строке.</target>       </trans-unit>
        <trans-unit id="3074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">Если требуется разделить строку в строку разделителя, используйте <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> метод для обнаружения первого символа строки-разделителя.</target>       </trans-unit>
        <trans-unit id="3075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">Затем с помощью <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> метод, чтобы определить, равны ли знаки после первого знака остальные символы строки-разделителя.</target>       </trans-unit>
        <trans-unit id="3076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">Кроме того, если же набор символов используется для разделения строк в нескольких <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> вызовы методов, рекомендуется создать один массив и ссылки на него в каждом вызове метода.</target>       </trans-unit>
        <trans-unit id="3077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">Это значительно уменьшает дополнительную нагрузку, каждый вызов метода.</target>       </trans-unit>
        <trans-unit id="3078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph> enumeration to include or exclude substrings generated by the <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph> перечисления для включения или исключения подстроки, созданные <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3079" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> не является одним из значений <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">В <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> и более ранних версий, если <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> методу передается <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> , <ph id="ph4">&lt;see langword="null" /&gt;</ph> или не содержит символов, метод использует несколько иной набор символов для разбиения строки, чем <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> выполняет метод для обрежьте строку.</target>       </trans-unit>
        <trans-unit id="3081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">В <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, оба метода используют идентичный набор пробельные символы Юникода.</target>       </trans-unit>
        <trans-unit id="3082" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Массив строк, разделяющих подстроки в данной строке, пустой массив, не содержащий разделителей, или <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3083" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> to omit empty array elements from the array returned; or <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> to include empty array elements in the array returned.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph>, чтобы исключить пустые элементы из возвращаемого массива; или <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> для включения пустых элементов в возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="3084" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Splits a string into substrings based on the strings in an array.</source>
          <target state="translated">Разбивает строку на подстроки в зависимости от строк в массиве.</target>       </trans-unit>
        <trans-unit id="3085" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>You can specify whether the substrings include empty array elements.</source>
          <target state="translated">Можно указать, включают ли подстроки пустые элементы массива.</target>       </trans-unit>
        <trans-unit id="3086" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>An array whose elements contain the substrings in this string that are delimited by one or more strings in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">Массив, элементы которого содержат подстроки данной строки, разделенные одной или более строками из <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3087" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="3088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>When a string is delimited by a known set of strings, you can use the <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method to separate it into substrings.</source>
          <target state="translated">Если строка отделена с известным набором строк, можно использовать <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> метод, чтобы разделить подстроки.</target>       </trans-unit>
        <trans-unit id="3089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Return value details</source>
          <target state="translated">Сведения о возвращаемом значении</target>       </trans-unit>
        <trans-unit id="3090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Delimiter strings are not included in the elements of the returned array.</source>
          <target state="translated">Строки-разделители не включаются в возвращаемый массив элементов.</target>       </trans-unit>
        <trans-unit id="3091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For example, if the <ph id="ph1">`separator`</ph> array includes the string "--" and the value of the current string instance is "aa--bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</source>
          <target state="translated">Например если <ph id="ph1">`separator`</ph> массива включает строку «--» и значение текущего экземпляра строки «aa--bb cc», метод возвращает массив, содержащий три элемента: «aa», «bb» и «копия».</target>       </trans-unit>
        <trans-unit id="3092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If this instance does not contain any of the strings in <ph id="ph1">`separator`</ph>, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">Если данный экземпляр не содержит строк в <ph id="ph1">`separator`</ph>, возвращаемый массив состоит из единственного элемента, содержащего данный экземпляр.</target>       </trans-unit>
        <trans-unit id="3093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> parameter is <ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> and the length of this instance is zero, the method returns an empty array.</source>
          <target state="translated">Если <ph id="ph1">`options`</ph> параметр <ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> и имеет нулевую длину этого экземпляра, метод возвращает пустой массив.</target>       </trans-unit>
        <trans-unit id="3094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter that consists of one or more characters.</source>
          <target state="translated">Каждый элемент <ph id="ph1">`separator`</ph> определяет отдельный разделитель, который состоит из одного или нескольких символов.</target>       </trans-unit>
        <trans-unit id="3095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> argument is <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Если <ph id="ph1">`options`</ph> аргумент <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>и два разделителя являются смежными или разделитель в начале или в конце этого экземпляра, соответствующий элемент массива содержит <ph id="ph3">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For example, if <ph id="ph1">`separator`</ph> includes  two elements, "-" and "_", the value of the string instance is "-_aa-<ph id="ph2">\_</ph>", and the value of   the <ph id="ph3">`options`</ph> argument is <ph id="ph4">&lt;xref:System.StringSplitOptions.None&gt;</ph>, the method returns a sting array with the following five elements:</source>
          <target state="translated">Например если <ph id="ph1">`separator`</ph> входят два элемента, «-» и имеет значение экземпляра строки «_», «- _aa -<ph id="ph2">\_</ph>» и значение <ph id="ph3">`options`</ph> аргумент является <ph id="ph4">&lt;xref:System.StringSplitOptions.None&gt;</ph>, метод возвращает массив проверяемого со следующих пяти элементов:</target>       </trans-unit>
        <trans-unit id="3097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that precedes the "-" substring at index 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, который представляет пустую строку, которая предшествует»-«подстроки с индексом 0.</target>       </trans-unit>
        <trans-unit id="3098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string between the "-" substring at index 0 and the "_" substring at index 1.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, который представляет пустую строку между»-«подстроки с индексом 0 и подстроку «_» с индексом 1.</target>       </trans-unit>
        <trans-unit id="3099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>"aa",</source>
          <target state="translated">«aa»</target>       </trans-unit>
        <trans-unit id="3100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that follows the "_" substring at index 4.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, который представляет пустую строку, которая следует за подстроку «_» с индекса 4.</target>       </trans-unit>
        <trans-unit id="3101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, which represents the empty string that follows the "-" substring at index 5.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>, который представляет пустую строку, которая следует за»-«подстроку по индексу 5.</target>       </trans-unit>
        <trans-unit id="3102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The separator array</source>
          <target state="translated">Массив разделителя</target>       </trans-unit>
        <trans-unit id="3103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If any of the elements in <ph id="ph1">`separator`</ph> consists of multiple characters, the entire substring is considered a delimiter.</source>
          <target state="translated">Если какие-либо элементы в <ph id="ph1">`separator`</ph> состоит из нескольких символов, вся подстрока считается разделитель.</target>       </trans-unit>
        <trans-unit id="3104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For example, if one of the elements in <ph id="ph1">`separator`</ph> is "10", attempting to split the string "This10is10a10string."</source>
          <target state="translated">Например, если один из элементов в <ph id="ph1">`separator`</ph> — «10», попытка разбить строку «This10is10a10string».</target>       </trans-unit>
        <trans-unit id="3105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>returns the following four-element array: { "This", "is", "a", "string."</source>
          <target state="translated">Возвращает массив следующих четырех элементов: {«This», «is», «», «string».</target>       </trans-unit>
        <trans-unit id="3106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>}.</source>
          <target state="translated">}.</target>       </trans-unit>
        <trans-unit id="3107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
          <target state="translated">Если <ph id="ph1">`separator`</ph> параметр <ph id="ph2">`null`</ph> или не содержит символы, пробелы считаются разделителями.</target>       </trans-unit>
        <trans-unit id="3108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Символы-разделители определяются Unicode standard и возврата <ph id="ph1">`true`</ph> , если они передаются <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter in the call to this method overload is <ph id="ph2">`null`</ph>, compiler overload resolution fails.</source>
          <target state="translated">Если <ph id="ph1">`separator`</ph> параметр в вызове перегрузка метода является <ph id="ph2">`null`</ph>, происходит сбой разрешения перегрузки компилятора.</target>       </trans-unit>
        <trans-unit id="3110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>To unambiguously identify the called method, your code must indicate the type of the <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Для однозначной идентификации, вызываемому методу, коде необходимо указать тип <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="3111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The following example shows several ways to unambiguously identify this overload.</source>
          <target state="translated">В следующем примере показано несколько способов для однозначной идентификации, эта перегрузка.</target>       </trans-unit>
        <trans-unit id="3112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Comparison details</source>
          <target state="translated">Сведения о сравнении</target>       </trans-unit>
        <trans-unit id="3113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method extracts the substrings in this string that are delimited by one or more of the strings in the <ph id="ph2">`separator`</ph> parameter, and returns those substrings as elements of an array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Метод извлекает подстроки данной строки, разделенные одним или несколькими строками в <ph id="ph2">`separator`</ph> параметра и возвращает эти подстроки в виде элементов в массиве.</target>       </trans-unit>
        <trans-unit id="3114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Метод ищет разделители, выполняя сравнения с использованием правил сортировки по порядковому номеру с учетом регистра.</target>       </trans-unit>
        <trans-unit id="3115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For more information about word, string, and ordinal sorts, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Дополнительные сведения о слова, строки и порядковым номерам см. в разделе <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> перечисления.</target>       </trans-unit>
        <trans-unit id="3116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method ignores any element of <ph id="ph2">`separator`</ph> whose value is <ph id="ph3">`null`</ph> or the empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Метод игнорирует какой-либо элемент <ph id="ph2">`separator`</ph> , значение которого является <ph id="ph3">`null`</ph> или пустая строка (»»).</target>       </trans-unit>
        <trans-unit id="3117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>To avoid ambiguous results when strings in <ph id="ph1">`separator`</ph> have characters in common, the <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> operation proceeds from the beginning to the end of the value of the instance, and matches the first element in <ph id="ph3">`separator`</ph> that is equal to a delimiter in the instance.</source>
          <target state="translated">Во избежание неопределенности результата при строки в <ph id="ph1">`separator`</ph> имеют общие, символы <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> операции перемещается от начала до конца значения экземпляра и находит первый элемент в <ph id="ph3">`separator`</ph> равен разделителем экземпляр.</target>       </trans-unit>
        <trans-unit id="3118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The order in which substrings are encountered in the instance takes precedence over the order of elements in <ph id="ph1">`separator`</ph>.</source>
          <target state="translated">Порядок обнаружения подстрок в экземпляре имеет приоритет над порядком элементов в <ph id="ph1">`separator`</ph>.</target>       </trans-unit>
        <trans-unit id="3119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>For example, consider an instance whose value is "abcdef".</source>
          <target state="translated">Например рассмотрим экземпляр, значение которого является «abcdef».</target>       </trans-unit>
        <trans-unit id="3120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the first element in <ph id="ph1">`separator`</ph> was "ef" and the second element was "bcde", the result of the split operation would be a string array that contains two elements, "a" and "f".</source>
          <target state="translated">Если первый элемент в <ph id="ph1">`separator`</ph> «ef», а второй элемент — «bcde», и результатом операции разделения были бы строковый массив, содержащий два элемента «a» и «f».</target>       </trans-unit>
        <trans-unit id="3121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>This is because the substring in the instance, "bcde", is encountered and matches an element in <ph id="ph1">`separator`</ph> before the substring "f" is encountered.</source>
          <target state="translated">Это происходит потому подстроки в экземпляре, «bcde» обнаружен и соответствующий элемент в <ph id="ph1">`separator`</ph> перед обнаружил подстроку «f».</target>       </trans-unit>
        <trans-unit id="3122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>However, if the first element of <ph id="ph1">`separator`</ph> was "bcd" and the second element was "bc", the result of the split operation would be a string array that contains two elements, "a" and "ef".</source>
          <target state="translated">Тем не менее если первый элемент <ph id="ph1">`separator`</ph> «bcd», а второй элемент — «bc», и результатом операции разделения были бы строковый массив, содержащий два элемента «a» и «ef».</target>       </trans-unit>
        <trans-unit id="3123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>This is because "bcd" is the first delimiter in <ph id="ph1">`separator`</ph> that matches a delimiter in the instance.</source>
          <target state="translated">Это происходит потому «bcd» является первым разделителем в <ph id="ph1">`separator`</ph> , соответствует разделителю в экземпляре.</target>       </trans-unit>
        <trans-unit id="3124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be a string array that contains two elements,  "a" and "def".</source>
          <target state="translated">Если порядок разделителей была отменена, так что первый элемент «bc», а вторым — «bcd», получим строковый массив, содержащий два элемента «a» и «def».</target>       </trans-unit>
        <trans-unit id="3125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Performance considerations</source>
          <target state="translated">Особенности производительности</target>       </trans-unit>
        <trans-unit id="3126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Методы выделить память для объекта, возвращаемого массива и <ph id="ph2">&lt;xref:System.String&gt;</ph> объект для каждого элемента массива.</target>       </trans-unit>
        <trans-unit id="3127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
          <target state="translated">Если приложение требует оптимальной производительности или распределением памяти играют важную роль в приложении, рассмотрите возможность использования <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> метод и при необходимости <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> метод для поиска подстроки в строке.</target>       </trans-unit>
        <trans-unit id="3128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">Если требуется разбить строку на символ-разделитель, используйте <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> метод нахождения знаков-разделителей в строке.</target>       </trans-unit>
        <trans-unit id="3129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">Если требуется разделить строку в строку разделителя, используйте <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> метод для обнаружения первого символа строки-разделителя.</target>       </trans-unit>
        <trans-unit id="3130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">Затем с помощью <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> метод, чтобы определить, равны ли знаки после первого знака остальные символы строки-разделителя.</target>       </trans-unit>
        <trans-unit id="3131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">Кроме того, если же набор символов используется для разделения строк в нескольких <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> вызовы методов, рекомендуется создать один массив и ссылки на него в каждом вызове метода.</target>       </trans-unit>
        <trans-unit id="3132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">Это значительно уменьшает дополнительную нагрузку, каждый вызов метода.</target>       </trans-unit>
        <trans-unit id="3133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The following example illustrates the difference in the arrays returned by calling a string's <ph id="ph1">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType&gt;</ph> method with its <ph id="ph2">`options`</ph> parameter equal to <ph id="ph3">&lt;xref:System.StringSplitOptions.None?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Следующий пример иллюстрирует разницу в массивах, возвращенный при вызове строка <ph id="ph1">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType&gt;</ph> метод с его <ph id="ph2">`options`</ph> параметра равно <ph id="ph3">&lt;xref:System.StringSplitOptions.None?displayProperty=nameWithType&gt;</ph> и <ph id="ph4">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>The following example defines an array of separators that include punctuation and white-space characters.</source>
          <target state="translated">В следующем примере определяется массив в качестве разделителей, включая знаки пунктуации и пробелы.</target>       </trans-unit>
        <trans-unit id="3135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Passing this array along with a value of <ph id="ph1">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph> to the <ph id="ph2">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph> method returns an array that consists of the individual words from the string.</source>
          <target state="translated">Передача массива вместе со значением такого <ph id="ph1">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph> для <ph id="ph2">&lt;xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29&gt;</ph> метод возвращает массив, состоящий из отдельные слова из строки.</target>       </trans-unit>
        <trans-unit id="3136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>Note that the method is called with the <ph id="ph1">`options`</ph> argument set to <ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Обратите внимание, что метод вызывается с <ph id="ph1">`options`</ph> аргументу присвоено <ph id="ph2">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>This prevents the returned array from including <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> values that represent empty substring matches between punctuation marks and white-space characters.</source>
          <target state="translated">Это предотвращает включая возвращаемый массив <ph id="ph1">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph> значения, представляющие пустой подстроку соответствия между знаки пунктуации и пробелы.</target>       </trans-unit>
        <trans-unit id="3138" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> не является одним из значений <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">В <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> и более ранних версий, если <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> методу передается <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> , <ph id="ph4">&lt;see langword="null" /&gt;</ph> или не содержит символов, метод использует несколько иной набор символов для разбиения строки, чем <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> выполняет метод для обрежьте строку.</target>       </trans-unit>
        <trans-unit id="3140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">В <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, оба метода используют идентичный набор пробельные символы Юникода.</target>       </trans-unit>
        <trans-unit id="3141" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Массив символов, разделяющий подстроки в данной строке, пустой массив, не содержащий разделителей, или <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3142" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>The maximum number of substrings to return.</source>
          <target state="translated">Максимальное число возвращаемых подстрок.</target>       </trans-unit>
        <trans-unit id="3143" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> to omit empty array elements from the array returned; or <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> to include empty array elements in the array returned.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph>, чтобы исключить пустые элементы из возвращаемого массива; или <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> для включения пустых элементов в возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="3144" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>Splits a string into a maximum number of substrings based on the characters in an array.</source>
          <target state="translated">Разбивает строку на максимальное число подстрок в зависимости от символов в массиве.</target>       </trans-unit>
        <trans-unit id="3145" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>An array whose elements contain the substrings in this string that are delimited by one or more characters in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">Массив, элементы которого содержат подстроки данной строки, разделенные одним или более знаками из <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3146" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="3147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>Delimiter characters are not included in the elements of the returned array.</source>
          <target state="translated">Символы-разделители не включаются в возвращаемый массив элементов.</target>       </trans-unit>
        <trans-unit id="3148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If this instance does not contain any of the characters in <ph id="ph1">`separator`</ph>, or the <ph id="ph2">`count`</ph> parameter is 1, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">Если данный экземпляр не содержит символов в <ph id="ph1">`separator`</ph>, или <ph id="ph2">`count`</ph> параметр равен 1, возвращаемый массив состоит из единственного элемента, содержащего данный экземпляр.</target>       </trans-unit>
        <trans-unit id="3149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
          <target state="translated">Если <ph id="ph1">`separator`</ph> параметр <ph id="ph2">`null`</ph> или не содержит символы, пробелы считаются разделителями.</target>       </trans-unit>
        <trans-unit id="3150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Символы-разделители определяются Unicode standard и возврата <ph id="ph1">`true`</ph> , если они передаются <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>However, if the <ph id="ph1">`separator`</ph> parameter in the call to this method overload is <ph id="ph2">`null`</ph>, compiler overload resolution fails.</source>
          <target state="translated">Однако если <ph id="ph1">`separator`</ph> параметр в вызове перегрузка метода является <ph id="ph2">`null`</ph>, происходит сбой разрешения перегрузки компилятора.</target>       </trans-unit>
        <trans-unit id="3152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>To unambiguously identify the called method, your code must indicate the type of the null.</source>
          <target state="translated">Для однозначной идентификации, вызываемому методу, коде необходимо указать тип null.</target>       </trans-unit>
        <trans-unit id="3153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>The following example shows several ways to unambiguously identify this overload.</source>
          <target state="translated">В следующем примере показано несколько способов для однозначной идентификации, эта перегрузка.</target>       </trans-unit>
        <trans-unit id="3154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`count`</ph> parameter is zero, or the <ph id="ph2">`options`</ph> parameter is <ph id="ph3">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> and the length of this instance is zero, an empty array is returned.</source>
          <target state="translated">Если <ph id="ph1">`count`</ph> параметр равен нулю, или <ph id="ph2">`options`</ph> параметр <ph id="ph3">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> и длины этого экземпляра равно нулю, возвращается пустой массив.</target>       </trans-unit>
        <trans-unit id="3155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter character.</source>
          <target state="translated">Каждый элемент <ph id="ph1">`separator`</ph> определяет отдельный знак-разделитель.</target>       </trans-unit>
        <trans-unit id="3156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> parameter is <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">Если <ph id="ph1">`options`</ph> параметр <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>и два разделителя являются смежными или разделитель в начале или в конце этого экземпляра, соответствующий элемент массива содержит <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If there are more than <ph id="ph1">`count`</ph> substrings in this instance, the first <ph id="ph2">`count`</ph> minus 1 substrings are returned in the first <ph id="ph3">`count`</ph> minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</source>
          <target state="translated">При наличии более чем <ph id="ph1">`count`</ph> подстроки данного экземпляра, первый <ph id="ph2">`count`</ph> минус 1 подстрок возвращаются в первом <ph id="ph3">`count`</ph> возвращается минус 1 элементах возвращаемого значения, а остальные символы в этом экземпляре за последние элемент возвращаемого значения.</target>       </trans-unit>
        <trans-unit id="3158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If <ph id="ph1">`count`</ph> is greater than the number of substrings, the available substrings are returned and no exception is thrown.</source>
          <target state="translated">Если <ph id="ph1">`count`</ph> больше, чем число подстрок, доступных подстроки возвращаются и исключение не возникает.</target>       </trans-unit>
        <trans-unit id="3159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>Performance Considerations</source>
          <target state="translated">Особенности производительности</target>       </trans-unit>
        <trans-unit id="3160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Методы выделить память для объекта, возвращаемого массива и <ph id="ph2">&lt;xref:System.String&gt;</ph> объект для каждого элемента массива.</target>       </trans-unit>
        <trans-unit id="3161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
          <target state="translated">Если приложение требует оптимальной производительности или распределением памяти играют важную роль в приложении, рассмотрите возможность использования <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> метод и при необходимости <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> метод для поиска подстроки в строке.</target>       </trans-unit>
        <trans-unit id="3162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">Если требуется разбить строку на символ-разделитель, используйте <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> метод нахождения знаков-разделителей в строке.</target>       </trans-unit>
        <trans-unit id="3163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">Если требуется разделить строку в строку разделителя, используйте <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> метод для обнаружения первого символа строки-разделителя.</target>       </trans-unit>
        <trans-unit id="3164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">Затем с помощью <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> метод, чтобы определить, равны ли знаки после первого знака остальные символы строки-разделителя.</target>       </trans-unit>
        <trans-unit id="3165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">Кроме того, если же набор символов используется для разделения строк в нескольких <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> вызовы методов, рекомендуется создать один массив и ссылки на него в каждом вызове метода.</target>       </trans-unit>
        <trans-unit id="3166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">Это значительно уменьшает дополнительную нагрузку, каждый вызов метода.</target>       </trans-unit>
        <trans-unit id="3167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph> enumeration to include or exclude substrings generated by the <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph> перечисления для включения или исключения подстроки, созданные <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3168" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> является отрицательным значением.</target>       </trans-unit>
        <trans-unit id="3169" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> не является одним из значений <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">В <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> и более ранних версий, если <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> методу передается <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> , <ph id="ph4">&lt;see langword="null" /&gt;</ph> или не содержит символов, метод использует несколько иной набор символов для разбиения строки, чем <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> выполняет метод для обрежьте строку.</target>       </trans-unit>
        <trans-unit id="3171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">В <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, оба метода используют идентичный набор пробельные символы Юникода.</target>       </trans-unit>
        <trans-unit id="3172" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Массив строк, разделяющих подстроки в данной строке, пустой массив, не содержащий разделителей, или <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3173" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The maximum number of substrings to return.</source>
          <target state="translated">Максимальное число возвращаемых подстрок.</target>       </trans-unit>
        <trans-unit id="3174" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph> to omit empty array elements from the array returned; or <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> to include empty array elements in the array returned.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /&gt;</ph>, чтобы исключить пустые элементы из возвращаемого массива; или <ph id="ph2">&lt;see cref="F:System.StringSplitOptions.None" /&gt;</ph> для включения пустых элементов в возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="3175" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Splits a string into a maximum number of substrings based on the strings in an array.</source>
          <target state="translated">Разбивает строку на максимальное число подстрок в зависимости от строк в массиве.</target>       </trans-unit>
        <trans-unit id="3176" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>You can specify whether the substrings include empty array elements.</source>
          <target state="translated">Можно указать, включают ли подстроки пустые элементы массива.</target>       </trans-unit>
        <trans-unit id="3177" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>An array whose elements contain the substrings in this string that are delimited by one or more strings in <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</source>
          <target state="translated">Массив, элементы которого содержат подстроки данной строки, разделенные одной или более строками из <ph id="ph1">&lt;paramref name="separator" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3178" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>For more information, see the Remarks section.</source>
          <target state="translated">Дополнительные сведения см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="3179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Return value details</source>
          <target state="translated">Сведения о возвращаемом значении</target>       </trans-unit>
        <trans-unit id="3180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Delimiter strings are not included in the elements of the returned array.</source>
          <target state="translated">Строки-разделители не включаются в возвращаемый массив элементов.</target>       </trans-unit>
        <trans-unit id="3181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If this instance does not contain any of the strings in <ph id="ph1">`separator`</ph>, or the <ph id="ph2">`count`</ph> parameter is 1, the returned array consists of a single element that contains this instance.</source>
          <target state="translated">Если данный экземпляр не содержит строк в <ph id="ph1">`separator`</ph>, или <ph id="ph2">`count`</ph> параметр равен 1, возвращаемый массив состоит из единственного элемента, содержащего данный экземпляр.</target>       </trans-unit>
        <trans-unit id="3182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`separator`</ph> parameter is <ph id="ph2">`null`</ph> or contains no characters, white-space characters are assumed to be the delimiters.</source>
          <target state="translated">Если <ph id="ph1">`separator`</ph> параметр <ph id="ph2">`null`</ph> или не содержит символы, пробелы считаются разделителями.</target>       </trans-unit>
        <trans-unit id="3183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>White-space characters are defined by the Unicode standard and return <ph id="ph1">`true`</ph> if they are passed to the <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Символы-разделители определяются Unicode standard и возврата <ph id="ph1">`true`</ph> , если они передаются <ph id="ph2">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>However, if the <ph id="ph1">`separator`</ph> parameter in the call to this method overload is <ph id="ph2">`null`</ph>, compiler overload resolution fails.</source>
          <target state="translated">Однако если <ph id="ph1">`separator`</ph> параметр в вызове перегрузка метода является <ph id="ph2">`null`</ph>, происходит сбой разрешения перегрузки компилятора.</target>       </trans-unit>
        <trans-unit id="3185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>To unambiguously identify the called method, your code must indicate the type of the <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Для однозначной идентификации, вызываемому методу, коде необходимо указать тип <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="3186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The following example shows several ways to unambiguously identify this overload.</source>
          <target state="translated">В следующем примере показано несколько способов для однозначной идентификации, эта перегрузка.</target>       </trans-unit>
        <trans-unit id="3187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`count`</ph> parameter is zero, or the <ph id="ph2">`options`</ph> parameter is <ph id="ph3">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> and the length of this instance is zero, an empty array is returned.</source>
          <target state="translated">Если <ph id="ph1">`count`</ph> параметр равен нулю, или <ph id="ph2">`options`</ph> параметр <ph id="ph3">&lt;xref:System.StringSplitOptions.RemoveEmptyEntries&gt;</ph> и длины этого экземпляра равно нулю, возвращается пустой массив.</target>       </trans-unit>
        <trans-unit id="3188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Each element of <ph id="ph1">`separator`</ph> defines a separate delimiter that consists of one or more characters.</source>
          <target state="translated">Каждый элемент <ph id="ph1">`separator`</ph> определяет отдельный разделитель, который состоит из одного или нескольких символов.</target>       </trans-unit>
        <trans-unit id="3189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If the <ph id="ph1">`options`</ph> parameter is <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">Если <ph id="ph1">`options`</ph> параметр <ph id="ph2">&lt;xref:System.StringSplitOptions.None&gt;</ph>и два разделителя являются смежными или разделитель в начале или в конце этого экземпляра, соответствующий элемент массива содержит <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If there are more than <ph id="ph1">`count`</ph> substrings in this instance, the first <ph id="ph2">`count`</ph> minus 1 substrings are returned in the first <ph id="ph3">`count`</ph> minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</source>
          <target state="translated">При наличии более чем <ph id="ph1">`count`</ph> подстроки данного экземпляра, первый <ph id="ph2">`count`</ph> минус 1 подстрок возвращаются в первом <ph id="ph3">`count`</ph> возвращается минус 1 элементах возвращаемого значения, а остальные символы в этом экземпляре за последние элемент возвращаемого значения.</target>       </trans-unit>
        <trans-unit id="3191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If <ph id="ph1">`count`</ph> is greater than the number of substrings, the available substrings are returned and no exception is thrown.</source>
          <target state="translated">Если <ph id="ph1">`count`</ph> больше, чем число подстрок, доступных подстроки возвращаются и исключение не возникает.</target>       </trans-unit>
        <trans-unit id="3192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The separator array</source>
          <target state="translated">Массив разделителя</target>       </trans-unit>
        <trans-unit id="3193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If any of the elements in <ph id="ph1">`separator`</ph> consists of multiple characters, the entire substring is considered a delimiter.</source>
          <target state="translated">Если какие-либо элементы в <ph id="ph1">`separator`</ph> состоит из нескольких символов, вся подстрока считается разделитель.</target>       </trans-unit>
        <trans-unit id="3194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>For example, if one of the elements in <ph id="ph1">`separator`</ph> is "10", attempting to split the string "This10is10a10string."</source>
          <target state="translated">Например, если один из элементов в <ph id="ph1">`separator`</ph> — «10», попытка разбить строку «This10is10a10string».</target>       </trans-unit>
        <trans-unit id="3195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>returns this four-element array: { "This", "is", "a", "string."</source>
          <target state="translated">Возвращает исходный массив четырех элементов: {«This», «is», «», «string».</target>       </trans-unit>
        <trans-unit id="3196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>}.</source>
          <target state="translated">}.</target>       </trans-unit>
        <trans-unit id="3197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Comparison details</source>
          <target state="translated">Сведения о сравнении</target>       </trans-unit>
        <trans-unit id="3198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method extracts the substrings in this string that are delimited by one or more of the strings in the <ph id="ph2">`separator`</ph> parameter, and returns those substrings as elements of an array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Метод извлекает подстроки данной строки, разделенные одним или несколькими строками в <ph id="ph2">`separator`</ph> параметра и возвращает эти подстроки в виде элементов в массиве.</target>       </trans-unit>
        <trans-unit id="3199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Метод ищет разделители, выполняя сравнения с использованием правил сортировки по порядковому номеру с учетом регистра.</target>       </trans-unit>
        <trans-unit id="3200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>For more information about word, string, and ordinal sorts, see the <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Дополнительные сведения о слова, строки и порядковым номерам см. в разделе <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph> перечисления.</target>       </trans-unit>
        <trans-unit id="3201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method ignores any element of <ph id="ph2">`separator`</ph> whose value is <ph id="ph3">`null`</ph> or the empty string ("").</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Метод игнорирует какой-либо элемент <ph id="ph2">`separator`</ph> , значение которого является <ph id="ph3">`null`</ph> или пустая строка (»»).</target>       </trans-unit>
        <trans-unit id="3202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>To avoid ambiguous results when strings in <ph id="ph1">`separator`</ph> have characters in common, the <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> method proceeds from the beginning to the end of the value of the instance, and matches the first element in <ph id="ph3">`separator`</ph> that is equal to a delimiter in the instance.</source>
          <target state="translated">Во избежание неопределенности результата при строки в <ph id="ph1">`separator`</ph> имеют общие, символы <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> метод перемещается от начала до конца значения экземпляра и находит первый элемент в <ph id="ph3">`separator`</ph> равен разделителем экземпляр.</target>       </trans-unit>
        <trans-unit id="3203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The order in which substrings are encountered in the instance takes precedence over the order of elements in <ph id="ph1">`separator`</ph>.</source>
          <target state="translated">Порядок обнаружения подстрок в экземпляре имеет приоритет над порядком элементов в <ph id="ph1">`separator`</ph>.</target>       </trans-unit>
        <trans-unit id="3204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>For example, consider an instance whose value is "abcdef".</source>
          <target state="translated">Например рассмотрим экземпляр, значение которого является «abcdef».</target>       </trans-unit>
        <trans-unit id="3205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If the first element in <ph id="ph1">`separator`</ph> was "ef" and the second element was "bcde", the result of the split operation would be "a" and "f".</source>
          <target state="translated">Если первый элемент в <ph id="ph1">`separator`</ph> «ef», а второй элемент — «bcde», и результатом операции разделения были бы «a» и «f».</target>       </trans-unit>
        <trans-unit id="3206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>This is because the substring in the instance, "bcde", is encountered and matches an element in <ph id="ph1">`separator`</ph> before the substring "f" is encountered.</source>
          <target state="translated">Это происходит потому подстроки в экземпляре, «bcde» обнаружен и соответствующий элемент в <ph id="ph1">`separator`</ph> перед обнаружил подстроку «f».</target>       </trans-unit>
        <trans-unit id="3207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>However, if the first element of <ph id="ph1">`separator`</ph> was "bcd" and the second element was "bc", the result of the split operation would be "a" and "ef".</source>
          <target state="translated">Тем не менее если первый элемент <ph id="ph1">`separator`</ph> «bcd», а второй элемент — «bc», и результатом операции разделения были бы «a» и «ef».</target>       </trans-unit>
        <trans-unit id="3208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>This is because "bcd" is the first delimiter in <ph id="ph1">`separator`</ph> that matches a delimiter in the instance.</source>
          <target state="translated">Это происходит потому «bcd» является первым разделителем в <ph id="ph1">`separator`</ph> , соответствует разделителю в экземпляре.</target>       </trans-unit>
        <trans-unit id="3209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be "a" and "def".</source>
          <target state="translated">Если порядок разделителей была отменена, так что первый элемент «bc», а вторым — «bcd», результат будет «a» и «def».</target>       </trans-unit>
        <trans-unit id="3210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Performance considerations</source>
          <target state="translated">Особенности производительности</target>       </trans-unit>
        <trans-unit id="3211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> methods allocate memory for the returned array object and a <ph id="ph2">&lt;xref:System.String&gt;</ph> object for each array element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> Методы выделить память для объекта, возвращаемого массива и <ph id="ph2">&lt;xref:System.String&gt;</ph> объект для каждого элемента массива.</target>       </trans-unit>
        <trans-unit id="3212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method, and optionally the <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> method, to locate a substring within a string.</source>
          <target state="translated">Если приложение требует оптимальной производительности или распределением памяти играют важную роль в приложении, рассмотрите возможность использования <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> метод и при необходимости <ph id="ph3">&lt;xref:System.String.Compare%2A&gt;</ph> метод для поиска подстроки в строке.</target>       </trans-unit>
        <trans-unit id="3213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If you are splitting a string at a separator character, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate a separator character in the string.</source>
          <target state="translated">Если требуется разбить строку на символ-разделитель, используйте <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> метод нахождения знаков-разделителей в строке.</target>       </trans-unit>
        <trans-unit id="3214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>If you are splitting a string at a separator string, use the <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> method to locate the first character of the separator string.</source>
          <target state="translated">Если требуется разделить строку в строку разделителя, используйте <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.IndexOfAny%2A&gt;</ph> метод для обнаружения первого символа строки-разделителя.</target>       </trans-unit>
        <trans-unit id="3215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>Then use the <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</source>
          <target state="translated">Затем с помощью <ph id="ph1">&lt;xref:System.String.Compare%2A&gt;</ph> метод, чтобы определить, равны ли знаки после первого знака остальные символы строки-разделителя.</target>       </trans-unit>
        <trans-unit id="3216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>In addition, if the same set of characters is used to split strings in multiple <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> method calls, consider creating a single array and referencing it in each method call.</source>
          <target state="translated">Кроме того, если же набор символов используется для разделения строк в нескольких <ph id="ph1">&lt;xref:System.String.Split%2A&gt;</ph> вызовы методов, рекомендуется создать один массив и ссылки на него в каждом вызове метода.</target>       </trans-unit>
        <trans-unit id="3217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>This significantly reduces the additional overhead of each method call.</source>
          <target state="translated">Это значительно уменьшает дополнительную нагрузку, каждый вызов метода.</target>       </trans-unit>
        <trans-unit id="3218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph> enumeration to include or exclude substrings generated by the <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.StringSplitOptions&gt;</ph> перечисления для включения или исключения подстроки, созданные <ph id="ph2">&lt;xref:System.String.Split%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3219" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is negative.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> является отрицательным значением.</target>       </trans-unit>
        <trans-unit id="3220" translate="yes" xml:space="preserve" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source><ph id="ph1">&lt;paramref name="options" /&gt;</ph> is not one of the <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="options" /&gt;</ph> не является одним из значений <ph id="ph2">&lt;see cref="T:System.StringSplitOptions" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> and earlier versions, if the <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> method is passed a <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> that is <ph id="ph4">&lt;see langword="null" /&gt;</ph> or contains no characters, the method uses a slightly different set of characters to split the string than the <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> method does to trim the string.</source>
          <target state="translated">В <ph id="ph1">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph> и более ранних версий, если <ph id="ph2">&lt;see cref="M:System.String.Split(System.Char[])" /&gt;</ph> методу передается <ph id="ph3">&lt;paramref name="separator" /&gt;</ph> , <ph id="ph4">&lt;see langword="null" /&gt;</ph> или не содержит символов, метод использует несколько иной набор символов для разбиения строки, чем <ph id="ph5">&lt;see cref="M:System.String.Trim(System.Char[])" /&gt;</ph> выполняет метод для обрежьте строку.</target>       </trans-unit>
        <trans-unit id="3222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)">
          <source>In the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, both methods use an identical set of Unicode white-space characters.</source>
          <target state="translated">В <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, оба метода используют идентичный набор пробельные символы Юникода.</target>       </trans-unit>
        <trans-unit id="3223" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Determines whether the beginning of this string instance matches a specified string.</source>
          <target state="translated">Определяет, совпадает ли начало данного экземпляра строки с указанной строкой.</target>       </trans-unit>
        <trans-unit id="3224" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String)">
          <source>The string to compare.</source>
          <target state="translated">Строка, подлежащая сравнению.</target>       </trans-unit>
        <trans-unit id="3225" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String)">
          <source>Determines whether the beginning of this string instance matches the specified string.</source>
          <target state="translated">Определяет, совпадает ли начало данного экземпляра строки с указанной строкой.</target>       </trans-unit>
        <trans-unit id="3226" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> matches the beginning of this string; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если параметр <ph id="ph2">&lt;paramref name="value" /&gt;</ph> соответствует началу данной строки; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>This method compares <ph id="ph1">`value`</ph> to the substring at the beginning of this instance that is the same length as <ph id="ph2">`value`</ph>, and returns an indication whether they are equal.</source>
          <target state="translated">Этот метод сравнивает <ph id="ph1">`value`</ph> с подстрокой, расположенной в начале данного экземпляра, имеют одинаковую длину поля как <ph id="ph2">`value`</ph>и возвращает значение, указывающее, равны ли они.</target>       </trans-unit>
        <trans-unit id="3228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be an empty string (<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>), must be a reference to this same instance, or must match the beginning of this instance.</source>
          <target state="translated">Как одинаковые, <ph id="ph1">`value`</ph> должен быть пустой строкой (<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>), должна быть ссылка на тот же экземпляр или должны соответствовать начала данного экземпляра.</target>       </trans-unit>
        <trans-unit id="3229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</source>
          <target state="translated">Этот метод выполняет сравнение по словам (с учетом регистра и культуры) с использованием текущего языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="3230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>The following example defines a <ph id="ph1">`StripStartTags`</ph> method that uses the <ph id="ph2">&lt;xref:System.String.StartsWith%28System.String%29&gt;</ph> method to remove HTML start tags from the beginning of a string.</source>
          <target state="translated">В следующем примере определяется <ph id="ph1">`StripStartTags`</ph> метод, который использует <ph id="ph2">&lt;xref:System.String.StartsWith%28System.String%29&gt;</ph> метод для удаления HTML открывающие теги с начала строки.</target>       </trans-unit>
        <trans-unit id="3231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>Note that the <ph id="ph1">`StripStartTags`</ph> method is called recursively to ensure that multiple HTML start tags at the beginning of the line are removed.</source>
          <target state="translated">Обратите внимание, что <ph id="ph1">`StripStartTags`</ph> метод вызывается рекурсивно, чтобы удалить несколько открывающие теги HTML в начале строки.</target>       </trans-unit>
        <trans-unit id="3232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>The example does not remove HTML tags embedded in a string.</source>
          <target state="translated">Пример не удаляет HTML-теги, которые внедряются в строку.</target>       </trans-unit>
        <trans-unit id="3233" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Как описано в статье <bpt id="p1">[</bpt>советы и рекомендации по использованию строк<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, рекомендуется избегать вызова методов сравнения строк, которые заменяют значения по умолчанию и вместо этого вызывают методы, которые требуют явного указания параметров.</target>       </trans-unit>
        <trans-unit id="3235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String)">
          <source>To determine whether a string begins with a particular substring by using the string comparison rules of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> parameter.</source>
          <target state="translated">Чтобы определить, начинается ли строка определенной подстрокой, используя правила сравнения строк для текущего языка и региональных параметров, вызовите <ph id="ph1">&lt;see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /&gt;</ph> перегрузка метода со значением <ph id="ph2">&lt;see cref="F:System.StringComparison.CurrentCulture" /&gt;</ph> для его <ph id="ph3">&lt;paramref name="comparisonType" /&gt;</ph> параметра.</target>       </trans-unit>
        <trans-unit id="3236" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The string to compare.</source>
          <target state="translated">Строка, подлежащая сравнению.</target>       </trans-unit>
        <trans-unit id="3237" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>One of the enumeration values that determines how this string and <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> are compared.</source>
          <target state="translated">Одно из значений перечисления, определяющее способ сравнения этой строки со значением <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="3238" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>Determines whether the beginning of this string instance matches the specified string when compared using the specified comparison option.</source>
          <target state="translated">Определяет, совпадает ли начало этого экземпляра строки с заданной строкой при сравнении с учетом заданного параметра сравнения.</target>       </trans-unit>
        <trans-unit id="3239" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this instance begins with <ph id="ph2">&lt;paramref name="value" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если данный экземпляр начинается со значения <ph id="ph2">&lt;paramref name="value" /&gt;</ph>; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The <ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph> method compares the <ph id="ph2">`value`</ph> parameter to the substring at the beginning of this string and returns a value that indicates whether they are equal.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph> Метод сравнивает <ph id="ph2">`value`</ph> параметра подстрокой в начале этой строки и возвращает значение, указывающее, равны ли они.</target>       </trans-unit>
        <trans-unit id="3241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be a reference to this same string, must be the empty string (""), or must match the beginning of this string.</source>
          <target state="translated">Как одинаковые, <ph id="ph1">`value`</ph> должен быть ссылкой на ту же строку, должен быть пустой строкой ("»), или необходимо соответствует началу данной строки.</target>       </trans-unit>
        <trans-unit id="3242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The type of comparison performed by the <ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph> method depends on the value of the <ph id="ph2">`comparisonType`</ph> parameter.</source>
          <target state="translated">Тип сравнения, выполняемые <ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph> метод зависит от значения <ph id="ph2">`comparisonType`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="3243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The comparison can use the conventions of the current culture (<ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>) or the invariant culture (<ph id="ph3">&lt;xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType&gt;</ph> and <ph id="ph4">&lt;xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>), or it can consist of a character-by-character comparison of code points (<ph id="ph5">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> or <ph id="ph6">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">Сравнение используются соглашения текущих региональных параметров (<ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>) или инвариантного языка и региональных параметров (<ph id="ph3">&lt;xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType&gt;</ph> и <ph id="ph4">&lt;xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>), или он может включать символ за символом сравнения кодовых точек (<ph id="ph5">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph> или <ph id="ph6">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="3244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The comparison can also be case-sensitive (<ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph>), or it can ignore case (<ph id="ph4">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">Сравнение может выполняться с учетом регистра (<ph id="ph1">&lt;xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType&gt;</ph>, или <ph id="ph3">&lt;xref:System.StringComparison.Ordinal?displayProperty=nameWithType&gt;</ph>), или он может не учитывать регистр (<ph id="ph4">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="3245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The following example searches for the string "the" at the beginning of a longer string that begins with the word "The".</source>
          <target state="translated">Следующий пример выполняет поиск строки «» в начале строки больше времени, который начинается со слова «».</target>       </trans-unit>
        <trans-unit id="3246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>As the output from the example shows, a call to the <ph id="ph1">&lt;xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29&gt;</ph> method that performs a culture-insensitive but case-sensitive comparison fails to match the string, while a call that performs a culture- and case-insensitive comparison matches the string.</source>
          <target state="translated">Как видно в результатах показано в примере вызов <ph id="ph1">&lt;xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29&gt;</ph> метод, который выполняет сравнение без учета языка и региональных параметров, но с учетом регистра не соответствует строке, во время вызова, который выполняет сравнение языка и региональных параметров и case insensitive соответствует строке.</target>       </trans-unit>
        <trans-unit id="3247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The following example determines whether a string starts with a particular substring.</source>
          <target state="translated">В следующем примере определяется, начинается ли строка определенной подстрокой.</target>       </trans-unit>
        <trans-unit id="3248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>It initializes a two-dimensional string array.</source>
          <target state="translated">Он инициализирует двухмерный массив.</target>       </trans-unit>
        <trans-unit id="3249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The first element in the second dimension contains a string, and the second element contains the string to search for at the start of the first string.</source>
          <target state="translated">Первый элемент второго измерения содержит строку, а второй элемент содержит строку для поиска в начале первой строки.</target>       </trans-unit>
        <trans-unit id="3250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</source>
          <target state="translated">Результаты зависят от выбора языка и региональных параметров, учитывается ли регистр и выполняется ли порядковое сравнение.</target>       </trans-unit>
        <trans-unit id="3251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source>Note that when the string instance contains a ligature, culture-sensitive comparisons with its consecutive characters successfully match.</source>
          <target state="translated">Обратите внимание, что когда экземпляр строки содержит то же время, сравнений с учетом языка и региональных параметров с его последовательные символы успешно соответствовать.</target>       </trans-unit>
        <trans-unit id="3252" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3253" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.StringComparison)">
          <source><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> is not a <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="comparisonType" /&gt;</ph> не является значением <ph id="ph2">&lt;see cref="T:System.StringComparison" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3254" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The string to compare.</source>
          <target state="translated">Строка, подлежащая сравнению.</target>       </trans-unit>
        <trans-unit id="3255" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore case during the comparison; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, чтобы не учитывать регистр при сравнении; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3256" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Cultural information that determines how this string and <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept> are compared.</source>
          <target state="translated">Связанные с языком и региональными параметрами сведения, определяющие, как выполняется сравнение этой строки и <bpt id="p1">&lt;c&gt;</bpt>value<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="3257" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the current culture is used.</source>
          <target state="translated">Если значением параметра <bpt id="p1">&lt;c&gt;</bpt>culture<ept id="p1">&lt;/c&gt;</ept> является <ph id="ph1">&lt;see langword="null" /&gt;</ph>, используются текущие язык и региональные параметры.</target>       </trans-unit>
        <trans-unit id="3258" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>Determines whether the beginning of this string instance matches the specified string when compared using the specified culture.</source>
          <target state="translated">Определяет, совпадает ли начало экземпляра строки с заданной строкой при сравнении с учетом заданного языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="3259" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="value" /&gt;</ph> parameter matches the beginning of this string; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если параметр <ph id="ph2">&lt;paramref name="value" /&gt;</ph> соответствует началу данной строки; в противном случае — <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>This method compares the <ph id="ph1">`value`</ph> parameter to the substring at the beginning of this string that is the same length as <ph id="ph2">`value`</ph>, and returns a value that indicates whether they are equal.</source>
          <target state="translated">Этот метод сравнивает <ph id="ph1">`value`</ph> параметра подстрокой в начале данной строки, имеют одинаковую длину поля как <ph id="ph2">`value`</ph>и возвращает значение, указывающее, равны ли они.</target>       </trans-unit>
        <trans-unit id="3261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>To be equal, <ph id="ph1">`value`</ph> must be an empty string (<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>), must be a reference to this same instance, or must match the beginning of this instance.</source>
          <target state="translated">Как одинаковые, <ph id="ph1">`value`</ph> должен быть пустой строкой (<ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>), должна быть ссылка на тот же экземпляр или должны соответствовать начала данного экземпляра.</target>       </trans-unit>
        <trans-unit id="3262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>This method performs a comparison using the specified casing and culture.</source>
          <target state="translated">Этот метод выполняет сравнение с помощью указанного регистра и языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="3263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The following example determines whether a string occurs at the beginning of another string.</source>
          <target state="translated">В следующем примере определяется, содержится ли строка в начале другой строки.</target>       </trans-unit>
        <trans-unit id="3264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph> method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.StartsWith%2A&gt;</ph> Метод вызывается несколько раз, используя учет регистра, учет регистра и различные языки и региональные параметры, влияющие на результаты поиска.</target>       </trans-unit>
        <trans-unit id="3265" translate="yes" xml:space="preserve" uid="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3266" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Retrieves a substring from this instance.</source>
          <target state="translated">Извлекает подстроку из данного экземпляра.</target>       </trans-unit>
        <trans-unit id="3267" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>This member is overloaded.</source>
          <target state="translated">Этот член перегружен.</target>       </trans-unit>
        <trans-unit id="3268" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>For complete information about this member, including syntax, usage, and examples, click a name in the overload list.</source>
          <target state="translated">Для получения полной информации о данном члене, включая синтаксис, использование и примеры, щелкните имя в списке перегрузок.</target>       </trans-unit>
        <trans-unit id="3269" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32)">
          <source>The zero-based starting character position of a substring in this instance.</source>
          <target state="translated">Отсчитываемая от нуля позиция первого знака подстроки в данном экземпляре.</target>       </trans-unit>
        <trans-unit id="3270" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32)">
          <source>Retrieves a substring from this instance.</source>
          <target state="translated">Извлекает подстроку из данного экземпляра.</target>       </trans-unit>
        <trans-unit id="3271" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32)">
          <source>The substring starts at a specified character position and continues to the end of the string.</source>
          <target state="translated">Подстрока начинается в указанном положении символов и продолжается до конца строки.</target>       </trans-unit>
        <trans-unit id="3272" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32)">
          <source>A string that is equivalent to the substring that begins at <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> in this instance, or <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> is equal to the length of this instance.</source>
          <target state="translated">Строка, эквивалентная подстроке, которая начинается с <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> в данном экземпляре, или <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>, если значение <ph id="ph3">&lt;paramref name="startIndex" /&gt;</ph> равно длине данного экземпляра.</target>       </trans-unit>
        <trans-unit id="3273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>You call the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to extract a substring from a string that begins at a specified character position and ends at the end of the string.</source>
          <target state="translated">Вызывается <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> метод для извлечения подстроки из строки, которая начинается с указанной позиции символа и заканчивается в конце строки.</target>       </trans-unit>
        <trans-unit id="3274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</source>
          <target state="translated">Позиция первого знака начинается с нуля; Другими словами первый символ в строке находится по индексу 0, индекс 1.</target>       </trans-unit>
        <trans-unit id="3275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>To extract a substring that begins at a specified character position and ends before to the end of the string, call the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method.</source>
          <target state="translated">Чтобы извлечь подстроке, которая начинается с указанной позиции символа и заканчивается перед до конца строки, вызовите <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Этот метод не изменяет значение текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="3277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>Instead, it returns a new string that begins at the <ph id="ph1">`startIndex`</ph> position in the current string.</source>
          <target state="translated">Вместо этого он возвращает новую строку, которая начинается с <ph id="ph1">`startIndex`</ph> позицию в текущей строке.</target>       </trans-unit>
        <trans-unit id="3278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>To extract a substring that begins with a particular character or character sequence, call a method such as  <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> to get the value of <ph id="ph3">`startIndex`</ph>.</source>
          <target state="translated">Чтобы извлечь подстроке, которая начинается с определенный символ или последовательность символов, вызвать метод, такой как <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> для получения значения <ph id="ph3">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="3279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The second example illustrates this; it extracts a key value that begins one character position after the "=" character.</source>
          <target state="translated">Во втором примере показано; он извлекает значение ключа, который начинается на одну позицию знака после символа «=».</target>       </trans-unit>
        <trans-unit id="3280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> is equal to zero, the method returns the original string unchanged.</source>
          <target state="translated">Если <ph id="ph1">`startIndex`</ph> равен нулю, этот метод возвращает исходную строку без изменений.</target>       </trans-unit>
        <trans-unit id="3281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The following example demonstrates obtaining a substring from a string.</source>
          <target state="translated">В следующем примере показано получение подстроки из строки.</target>       </trans-unit>
        <trans-unit id="3282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to separate key/value pairs that are delimited by an equals ("=") character.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> метод для разделения пар ключ значение, разделенные знак равенства («=») символов.</target>       </trans-unit>
        <trans-unit id="3283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method is used to get the position of the equals character in the string..</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> Метод используется для получения позиции знака равенства в строке...</target>       </trans-unit>
        <trans-unit id="3284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The call to the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> method extracts the key name., which starts from the first character in the string and extends for the number of characters returned by the call to the    <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> метод извлекает имени ключа., начинающийся с первого символа в строке, расширяет число символов, возвращаемых вызовом <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>The call to the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph> method then extracts the value assigned to the key.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph> метод затем извлекает значение ключа.</target>       </trans-unit>
        <trans-unit id="3286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32)">
          <source>It starts at one character position beyond the equals character and extends to the end of the string.</source>
          <target state="translated">Он начинается с символа на одну позицию за пределами знак равенства и расширяется до конца строки.</target>       </trans-unit>
        <trans-unit id="3287" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> is less than zero or greater than the length of this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> имеет значение меньше нуля или больше длины этого экземпляра.</target>       </trans-unit>
        <trans-unit id="3288" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The zero-based starting character position of a substring in this instance.</source>
          <target state="translated">Отсчитываемая от нуля позиция первого знака подстроки в данном экземпляре.</target>       </trans-unit>
        <trans-unit id="3289" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The number of characters in the substring.</source>
          <target state="translated">Число символов в подстроке.</target>       </trans-unit>
        <trans-unit id="3290" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>Retrieves a substring from this instance.</source>
          <target state="translated">Извлекает подстроку из данного экземпляра.</target>       </trans-unit>
        <trans-unit id="3291" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The substring starts at a specified character position and has a specified length.</source>
          <target state="translated">Подстрока начинается с указанной позиции знака и имеет указанную длину.</target>       </trans-unit>
        <trans-unit id="3292" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>A string that is equivalent to the substring of length <ph id="ph1">&lt;paramref name="length" /&gt;</ph> that begins at <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> in this instance, or <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph> if <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph> is equal to the length of this instance and <ph id="ph5">&lt;paramref name="length" /&gt;</ph> is zero.</source>
          <target state="translated">Строка, эквивалентная подстроке длиной <ph id="ph1">&lt;paramref name="length" /&gt;</ph>, которая начинается с <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph> в данном экземпляре, или <ph id="ph3">&lt;see cref="F:System.String.Empty" /&gt;</ph>, если значение <ph id="ph4">&lt;paramref name="startIndex" /&gt;</ph> равно длине данного экземпляра, а значение <ph id="ph5">&lt;paramref name="length" /&gt;</ph> равно нулю.</target>       </trans-unit>
        <trans-unit id="3293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>You call the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> method to extract a substring from a string that begins at a specified character position and ends before the end of the string.</source>
          <target state="translated">Вызывается <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> метод для извлечения подстроки из строки, которая начинается с указанной позиции символа и заканчивается до конца строки.</target>       </trans-unit>
        <trans-unit id="3294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</source>
          <target state="translated">Позиция первого знака начинается с нуля; Другими словами первый символ в строке находится по индексу 0, индекс 1.</target>       </trans-unit>
        <trans-unit id="3295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>To extract a substring that begins at a specified character position and continues to the end of the string, call the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph> method.</source>
          <target state="translated">Чтобы извлечь подстроку, которая начинается с указанной позиции знака и продолжается до конца строки, вызовите <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Этот метод не изменяет значение текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="3297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>Instead, it returns a new string with <ph id="ph1">`length`</ph> characters starting from the <ph id="ph2">`startIndex`</ph> position in the current string.</source>
          <target state="translated">Вместо этого возвращается новая строка с <ph id="ph1">`length`</ph> символов начиная с <ph id="ph2">`startIndex`</ph> позицию в текущей строке.</target>       </trans-unit>
        <trans-unit id="3298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The <ph id="ph1">`length`</ph> parameter represents the total number of characters to extract from the current string instance.</source>
          <target state="translated"><ph id="ph1">`length`</ph> Параметр представляет общее количество символов, извлекаемых из текущего экземпляра строки.</target>       </trans-unit>
        <trans-unit id="3299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>This includes the starting character found at index  <ph id="ph1">`startIndex`</ph>.</source>
          <target state="translated">Сюда входят начальный символ найден по индексу <ph id="ph1">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="3300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>In other words, the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method attempts to extract characters from index <ph id="ph2">`startIndex`</ph> to index <ph id="ph3">`startIndex`</ph><ph id="ph4"> + </ph><ph id="ph5">`length`</ph> - 1.</source>
          <target state="translated">Другими словами <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> метод пытается извлечь символы из индекса <ph id="ph2">`startIndex`</ph> индекс <ph id="ph3">`startIndex`</ph> <ph id="ph4"> + </ph> <ph id="ph5">`length`</ph> - 1.</target>       </trans-unit>
        <trans-unit id="3301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>To extract a substring that begins with a particular character or character sequence, call a method such as  <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> to get the value of <ph id="ph3">`startIndex`</ph>.</source>
          <target state="translated">Чтобы извлечь подстроке, которая начинается с определенный символ или последовательность символов, вызвать метод, такой как <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> для получения значения <ph id="ph3">`startIndex`</ph>.</target>       </trans-unit>
        <trans-unit id="3302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>If the substring extends from <ph id="ph1">`startIndex`</ph> to a specified character sequence, you can call a method such as  <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> to get the index of the ending character or character sequence.</source>
          <target state="translated">Если подстрока, начиная с позиции <ph id="ph1">`startIndex`</ph> в последовательность указанный символ можно вызвать метод например <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph3">&lt;xref:System.String.LastIndexOf%2A&gt;</ph> для получения индекса конечный символ или последовательность символов.</target>       </trans-unit>
        <trans-unit id="3303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>You can then convert that value to an index position in the string as follows:</source>
          <target state="translated">Можно затем преобразовать это значение позиции индекса в строке следующим образом:</target>       </trans-unit>
        <trans-unit id="3304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>If you've searched for a single character that is to mark the end of the substring, the <ph id="ph1">`length`</ph> parameter equals  <ph id="ph2">`endIndex`</ph><ph id="ph3"> - </ph><ph id="ph4">`startIndex`</ph> + 1, where <ph id="ph5">`endIndex`</ph> is the return value of the <ph id="ph6">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph7">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">При поиске одного символа, который является для обозначения конца подстроки, <ph id="ph1">`length`</ph> равняется <ph id="ph2">`endIndex`</ph> <ph id="ph3"> - </ph> <ph id="ph4">`startIndex`</ph> + 1, где <ph id="ph5">`endIndex`</ph> имеет возвращаемое значение <ph id="ph6">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph7">&lt;xref:System.String.IndexOf%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The following example extracts a continuous block of "b" characters from a string.</source>
          <target state="translated">Следующий пример извлекает непрерывный блок «b» символов из строки.</target>       </trans-unit>
        <trans-unit id="3306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>If you've searched for multiple characters that are to mark the end of the substring, the <ph id="ph1">`length`</ph> parameter equals  <ph id="ph2">`endIndex`</ph><ph id="ph3"> + </ph><ph id="ph4">`endMatchLength`</ph><ph id="ph5"> - </ph><ph id="ph6">`startIndex`</ph>, where <ph id="ph7">`endIndex`</ph> is the return value of the <ph id="ph8">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph9">&lt;xref:System.String.IndexOf%2A&gt;</ph> method., and <ph id="ph10">`endMatchLength`</ph> is the length of the character sequence that marks the end of the substring.</source>
          <target state="translated">При поиске для нескольких символов, чтобы отметить конец подстроки, <ph id="ph1">`length`</ph> равняется <ph id="ph2">`endIndex`</ph> <ph id="ph3"> + </ph> <ph id="ph4">`endMatchLength`</ph> <ph id="ph5"> - </ph> <ph id="ph6">`startIndex`</ph>, где <ph id="ph7">`endIndex`</ph> является возвращаемым значением <ph id="ph8">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph9">&lt;xref:System.String.IndexOf%2A&gt;</ph> метода. и <ph id="ph10">`endMatchLength`</ph> длина последовательности символов, обозначающая конец подстроки.</target>       </trans-unit>
        <trans-unit id="3307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The following example extracts a block of text that contains an XML <ph id="ph1">`&lt;definition&gt;`</ph> element.</source>
          <target state="translated">Следующий пример извлекает блок текста, который содержит XML <ph id="ph1">`&lt;definition&gt;`</ph> элемента.</target>       </trans-unit>
        <trans-unit id="3308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>If the character or character sequence is not included in the end of the substring, the <ph id="ph1">`length`</ph> parameter equals <ph id="ph2">`endIndex`</ph><ph id="ph3"> - </ph><ph id="ph4">`startIndex`</ph>, where <ph id="ph5">`endIndex`</ph> is the return value of the <ph id="ph6">&lt;xref:System.String.IndexOf%2A&gt;</ph> or <ph id="ph7">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Если символ или последовательность символов не включен в конец подстроки, <ph id="ph1">`length`</ph> равняется <ph id="ph2">`endIndex`</ph> <ph id="ph3"> - </ph> <ph id="ph4">`startIndex`</ph>, где <ph id="ph5">`endIndex`</ph> имеет возвращаемое значение <ph id="ph6">&lt;xref:System.String.IndexOf%2A&gt;</ph> или <ph id="ph7">&lt;xref:System.String.IndexOf%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`startIndex`</ph> is equal to zero and  equals the length of the current string, the method returns the original string unchanged.</source>
          <target state="translated">Если <ph id="ph1">`startIndex`</ph> равен нулю и equals, длина текущей строки, метод возвращает исходную строку без изменений.</target>       </trans-unit>
        <trans-unit id="3310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The following example illustrates a simple call to the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> method that extracts two characters from a string starting at the sixth character position (that is, at index five).</source>
          <target state="translated">В следующем примере показан простой вызов <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> метод, который извлекает двух символов из строки, начиная с шестой позиции символа (то есть в индексе пяти).</target>       </trans-unit>
        <trans-unit id="3311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> method in the following three cases to isolate substrings within a string.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> метод в следующих трех случаях для изоляции подстроки в строке.</target>       </trans-unit>
        <trans-unit id="3312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>In two cases the substrings are used in comparisons, and in the third case an exception is thrown because invalid parameters are specified.</source>
          <target state="translated">В двух случаях подстроки используются при сравнении, а в третьем случае создается исключение, так как указаны недопустимые параметры.</target>       </trans-unit>
        <trans-unit id="3313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>It extracts the single character and the third position in the string (at index 2) and compares it with a "c".</source>
          <target state="translated">Он извлекает один символ и третьей позиции в строке (с индексом 2) и сравнивает его с «c».</target>       </trans-unit>
        <trans-unit id="3314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>This comparison returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated">Это сравнение возвращает <ph id="ph1">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>It extracts zero characters starting at the fourth position in the string (at index 3) and passes it to the <ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> method.</source>
          <target state="translated">Он извлекает нулевых символов, начиная с четвертого позиции в строке (с индексом 3) и передает его <ph id="ph1">&lt;xref:System.String.IsNullOrEmpty%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>This returns true because the call to the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method returns <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Это значение true, так как вызов <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> возвращает <ph id="ph2">&lt;xref:System.String.Empty?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>It attempts to extract one character starting at the fourth position in the string.</source>
          <target state="translated">Пытается извлечь один знак, начиная с четвертого позиции в строке.</target>       </trans-unit>
        <trans-unit id="3318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>Because there is no character at that position, the method call throws an <ph id="ph1">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph> exception.</source>
          <target state="translated">Так как нет никакого символа в этой позиции, вызов метода создает исключение <ph id="ph1">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="3319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> method to separate key/value pairs that are delimited by an equals ("=") character.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.String.Substring%2A&gt;</ph> метод для разделения пар ключ значение, разделенные знак равенства («=») символов.</target>       </trans-unit>
        <trans-unit id="3320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> method is used to get the position of the equals character in the string..</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.IndexOf%2A&gt;</ph> Метод используется для получения позиции знака равенства в строке...</target>       </trans-unit>
        <trans-unit id="3321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The call to the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> method extracts the key name., which starts from the first character in the string and extends for the number of characters returned by the call to the    <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> method.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%2CSystem.Int32%29&gt;</ph> метод извлекает имени ключа., начинающийся с первого символа в строке, расширяет число символов, возвращаемых вызовом <ph id="ph2">&lt;xref:System.String.IndexOf%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>The call to the <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph> method then extracts the value assigned to the key.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.String.Substring%28System.Int32%29&gt;</ph> метод затем извлекает значение ключа.</target>       </trans-unit>
        <trans-unit id="3323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>It starts at one character position beyond the equals character and extends to the end of the string.</source>
          <target state="translated">Он начинается с символа на одну позицию за пределами знак равенства и расширяется до конца строки.</target>       </trans-unit>
        <trans-unit id="3324" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> plus <ph id="ph2">&lt;paramref name="length" /&gt;</ph> indicates a position not within this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> плюс <ph id="ph2">&lt;paramref name="length" /&gt;</ph> указывает на позицию за пределами данного экземпляра.</target>       </trans-unit>
        <trans-unit id="3325" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3326" translate="yes" xml:space="preserve" uid="M:System.String.Substring(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> или <ph id="ph2">&lt;paramref name="length" /&gt;</ph> меньше нуля.</target>       </trans-unit>
        <trans-unit id="3327" translate="yes" xml:space="preserve" uid="M:System.String.System#Collections#Generic#IEnumerable&amp;lt;char&amp;gt;#GetEnumerator">
          <source>Returns an enumerator that iterates through the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Возвращает перечислитель, выполняющий перебор элементов текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3328" translate="yes" xml:space="preserve" uid="M:System.String.System#Collections#Generic#IEnumerable&amp;lt;char&amp;gt;#GetEnumerator">
          <source>A strongly-typed enumerator that can be used to iterate through the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Строго типизированный перечислитель, который можно использовать для перебора элементов текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#Generic#IEnumerable&amp;lt;char&amp;gt;#GetEnumerator">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="3330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#Generic#IEnumerable&amp;lt;char&amp;gt;#GetEnumerator">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interface object.</source>
          <target state="translated">Он может использоваться только тогда, когда <ph id="ph1">&lt;xref:System.String&gt;</ph> экземпляр приводится к <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> объект интерфейса.</target>       </trans-unit>
        <trans-unit id="3331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#Generic#IEnumerable&amp;lt;char&amp;gt;#GetEnumerator">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph> method.</source>
          <target state="translated">Дополнительные сведения см. в описании метода <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3332" translate="yes" xml:space="preserve" uid="M:System.String.System#Collections#IEnumerable#GetEnumerator">
          <source>Returns an enumerator that iterates through the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Возвращает перечислитель, выполняющий перебор элементов текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3333" translate="yes" xml:space="preserve" uid="M:System.String.System#Collections#IEnumerable#GetEnumerator">
          <source>An enumerator that can be used to iterate through the current string.</source>
          <target state="translated">Перечислитель, который можно использовать для перебора элементов текущей строки.</target>       </trans-unit>
        <trans-unit id="3334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#IEnumerable#GetEnumerator">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="3335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#IEnumerable#GetEnumerator">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Collections.IEnumerable&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.String&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.Collections.IEnumerable&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#Collections#IEnumerable#GetEnumerator">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Дополнительные сведения см. в описании метода <ph id="ph1">&lt;xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3337" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>This parameter is ignored.</source>
          <target state="translated">Этот параметр не учитывается.</target>       </trans-unit>
        <trans-unit id="3338" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3339" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value of the current string is <ph id="ph2">&lt;see cref="F:System.Boolean.TrueString" /&gt;</ph>; <ph id="ph3">&lt;see langword="false" /&gt;</ph> if the value of the current string is <ph id="ph4">&lt;see cref="F:System.Boolean.FalseString" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значение текущей строки равно <ph id="ph2">&lt;see cref="F:System.Boolean.TrueString" /&gt;</ph>; <ph id="ph3">&lt;see langword="false" /&gt;</ph>, если значение текущей строки равно <ph id="ph4">&lt;see cref="F:System.Boolean.FalseString" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="3341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.String&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Взамен рекомендуется использовать заключается в вызове <ph id="ph1">&lt;xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType&gt;</ph> метода.</target>       </trans-unit>
        <trans-unit id="3343" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)">
          <source>The value of the current string is not <ph id="ph1">&lt;see cref="F:System.Boolean.TrueString" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Boolean.FalseString" /&gt;</ph>.</source>
          <target state="translated">Значение текущей строки не является <ph id="ph1">&lt;see cref="F:System.Boolean.TrueString" /&gt;</ph> или <ph id="ph2">&lt;see cref="F:System.Boolean.FalseString" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3344" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</target>       </trans-unit>
        <trans-unit id="3345" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3346" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Преобразованное значение текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="3348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.String&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Взамен рекомендуется использовать заключается в вызове <ph id="ph1">&lt;xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> метода.</target>       </trans-unit>
        <trans-unit id="3350" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">Не удалось выполнить анализ значения текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3351" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number greater than <ph id="ph2">&lt;see cref="F:System.Byte.MaxValue" /&gt;</ph> or less than <ph id="ph3">&lt;see cref="F:System.Byte.MinValue" /&gt;</ph>.</source>
          <target state="translated">Значением текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> является число, которое больше <ph id="ph2">&lt;see cref="F:System.Byte.MaxValue" /&gt;</ph> или меньше <ph id="ph3">&lt;see cref="F:System.Byte.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3352" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</target>       </trans-unit>
        <trans-unit id="3353" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3354" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>The character at index 0 in the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Знак с индексом 0 в текущем объекте <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="3356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.String&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Взамен рекомендуется использовать заключается в вызове <ph id="ph1">&lt;xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> метода.</target>       </trans-unit>
        <trans-unit id="3358" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</target>       </trans-unit>
        <trans-unit id="3359" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3360" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Преобразованное значение текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="3362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.String&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Взамен рекомендуется использовать заключается в вызове <ph id="ph1">&lt;xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> метода.</target>       </trans-unit>
        <trans-unit id="3364" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</target>       </trans-unit>
        <trans-unit id="3365" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3366" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Преобразованное значение текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="3368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.String&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Взамен рекомендуется использовать заключается в вызове <ph id="ph1">&lt;xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> метода.</target>       </trans-unit>
        <trans-unit id="3370" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">Не удалось выполнить анализ значения текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3371" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number less than <ph id="ph2">&lt;see cref="F:System.Decimal.MinValue" /&gt;</ph> or than <ph id="ph3">&lt;see cref="F:System.Decimal.MaxValue" /&gt;</ph> greater.</source>
          <target state="translated">Значением текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> является число, которое меньше <ph id="ph2">&lt;see cref="F:System.Decimal.MinValue" /&gt;</ph> или больше <ph id="ph3">&lt;see cref="F:System.Decimal.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3372" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</target>       </trans-unit>
        <trans-unit id="3373" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3374" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Преобразованное значение текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="3376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.String&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Взамен рекомендуется использовать заключается в вызове <ph id="ph1">&lt;xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> метода.</target>       </trans-unit>
        <trans-unit id="3378" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">Не удалось выполнить анализ значения текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3379" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number less than <ph id="ph2">&lt;see cref="F:System.Double.MinValue" /&gt;</ph> or greater than <ph id="ph3">&lt;see cref="F:System.Double.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Значением текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> является число, которое меньше <ph id="ph2">&lt;see cref="F:System.Double.MinValue" /&gt;</ph> или больше <ph id="ph3">&lt;see cref="F:System.Double.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3380" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</target>       </trans-unit>
        <trans-unit id="3381" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3382" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Преобразованное значение текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="3384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.String&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Взамен рекомендуется использовать заключается в вызове <ph id="ph1">&lt;xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> метода.</target>       </trans-unit>
        <trans-unit id="3386" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">Не удалось выполнить анализ значения текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3387" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number greater than <ph id="ph2">&lt;see cref="F:System.Int16.MaxValue" /&gt;</ph> or less than <ph id="ph3">&lt;see cref="F:System.Int16.MinValue" /&gt;</ph>.</source>
          <target state="translated">Значением текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> является число, которое больше <ph id="ph2">&lt;see cref="F:System.Int16.MaxValue" /&gt;</ph> или меньше <ph id="ph3">&lt;see cref="F:System.Int16.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3388" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</target>       </trans-unit>
        <trans-unit id="3389" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3390" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Преобразованное значение текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="3392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.String&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Взамен рекомендуется использовать заключается в вызове <ph id="ph1">&lt;xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> метода.</target>       </trans-unit>
        <trans-unit id="3394" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</target>       </trans-unit>
        <trans-unit id="3395" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3396" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Преобразованное значение текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="3398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.String&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Взамен рекомендуется использовать заключается в вызове <ph id="ph1">&lt;xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> метода.</target>       </trans-unit>
        <trans-unit id="3400" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</target>       </trans-unit>
        <trans-unit id="3401" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3402" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Преобразованное значение текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="3404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.String&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Взамен рекомендуется использовать заключается в вызове <ph id="ph1">&lt;xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> метода.</target>       </trans-unit>
        <trans-unit id="3406" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">Не удалось выполнить анализ значения текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3407" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number greater than <ph id="ph2">&lt;see cref="F:System.SByte.MaxValue" /&gt;</ph> or less than <ph id="ph3">&lt;see cref="F:System.SByte.MinValue" /&gt;</ph>.</source>
          <target state="translated">Значением текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> является число, которое больше <ph id="ph2">&lt;see cref="F:System.SByte.MaxValue" /&gt;</ph> или меньше <ph id="ph3">&lt;see cref="F:System.SByte.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3408" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</target>       </trans-unit>
        <trans-unit id="3409" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3410" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Преобразованное значение текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="3412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.String&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Взамен рекомендуется использовать заключается в вызове <ph id="ph1">&lt;xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> метода.</target>       </trans-unit>
        <trans-unit id="3414" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>The type of the returned object.</source>
          <target state="translated">Тип возвращаемого объекта.</target>       </trans-unit>
        <trans-unit id="3415" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</target>       </trans-unit>
        <trans-unit id="3416" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3417" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Преобразованное значение текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="3419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.String&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ChangeType%2A&gt;</ph> method.</source>
          <target state="translated">Взамен рекомендуется использовать заключается в вызове <ph id="ph1">&lt;xref:System.Convert.ChangeType%2A&gt;</ph> метода.</target>       </trans-unit>
        <trans-unit id="3421" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source><ph id="ph1">&lt;paramref name="type" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="type" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3422" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be converted to the type specified by the <ph id="ph2">&lt;paramref name="type" /&gt;</ph> parameter.</source>
          <target state="translated">Не удалось преобразовать значение текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> в тип, заданный в параметре <ph id="ph2">&lt;paramref name="type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3423" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</target>       </trans-unit>
        <trans-unit id="3424" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3425" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Преобразованное значение текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="3427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.String&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Взамен рекомендуется использовать заключается в вызове <ph id="ph1">&lt;xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> метода.</target>       </trans-unit>
        <trans-unit id="3429" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">Не удалось выполнить анализ значения текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3430" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number greater than <ph id="ph2">&lt;see cref="F:System.UInt16.MaxValue" /&gt;</ph> or less than <ph id="ph3">&lt;see cref="F:System.UInt16.MinValue" /&gt;</ph>.</source>
          <target state="translated">Значением текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> является число, которое больше <ph id="ph2">&lt;see cref="F:System.UInt16.MaxValue" /&gt;</ph> или меньше <ph id="ph3">&lt;see cref="F:System.UInt16.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3431" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</target>       </trans-unit>
        <trans-unit id="3432" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3433" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Преобразованное значение текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="3435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.String&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Взамен рекомендуется использовать заключается в вызове <ph id="ph1">&lt;xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> метода.</target>       </trans-unit>
        <trans-unit id="3437" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object cannot be parsed.</source>
          <target state="translated">Не удалось выполнить анализ значения текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3438" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)">
          <source>The value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object is a number greater <ph id="ph2">&lt;see cref="F:System.UInt32.MaxValue" /&gt;</ph> or less than <ph id="ph3">&lt;see cref="F:System.UInt32.MinValue" /&gt;</ph></source>
          <target state="translated">Значением текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> является число, которое больше <ph id="ph2">&lt;see cref="F:System.UInt32.MaxValue" /&gt;</ph> или меньше <ph id="ph3">&lt;see cref="F:System.UInt32.MinValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3439" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>An object that provides culture-specific formatting information.</source>
          <target state="translated">Объект, предоставляющий сведения о форматировании, связанные с языком и региональными параметрами.</target>       </trans-unit>
        <trans-unit id="3440" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" /&gt;</ph>.</source>
          <target state="translated">Описание этого члена см. в разделе <ph id="ph1">&lt;see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3441" translate="yes" xml:space="preserve" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>The converted value of the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Преобразованное значение текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="3443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.String&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.String&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.IConvertible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)">
          <source>The recommended alternative is to call the <ph id="ph1">&lt;xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Взамен рекомендуется использовать заключается в вызове <ph id="ph1">&lt;xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> метода.</target>       </trans-unit>
        <trans-unit id="3445" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Copies the characters in this instance to a Unicode character array.</source>
          <target state="translated">Копирует знаки данного экземпляра в массив знаков Юникода.</target>       </trans-unit>
        <trans-unit id="3446" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray">
          <source>Copies the characters in this instance to a Unicode character array.</source>
          <target state="translated">Копирует знаки данного экземпляра в массив знаков Юникода.</target>       </trans-unit>
        <trans-unit id="3447" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray">
          <source>A Unicode character array whose elements are the individual characters of this instance.</source>
          <target state="translated">Массив знаков Юникода, элементами которого являются отдельные знаки из данного экземпляра.</target>       </trans-unit>
        <trans-unit id="3448" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray">
          <source>If this instance is an empty string, the returned array is empty and has a zero length.</source>
          <target state="translated">Если этот экземпляр является пустой строкой, то возвращаемый массив пуст и его длина равна нулю.</target>       </trans-unit>
        <trans-unit id="3449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>This method copies each character (that is, each <ph id="ph1">&lt;xref:System.Char&gt;</ph> object) in a string to a character array.</source>
          <target state="translated">Этот метод копирует каждый символ (то есть каждый <ph id="ph1">&lt;xref:System.Char&gt;</ph> объект) в строке в массив символов.</target>       </trans-unit>
        <trans-unit id="3450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>The first character copied is at index zero of the returned character array; the last character copied is at index <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> – 1.</source>
          <target state="translated">Первый символ копируются, — с нулевым индексом массива возвращаемый знак. -последний скопированный знак в позиции <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> – 1.</target>       </trans-unit>
        <trans-unit id="3451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>To create a string from the characters in a character array, call the <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph> constructor.</source>
          <target state="translated">Чтобы создать строку из символов в массиве символов, вызовите <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%29&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="3452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>To create a byte array that contains the encoded characters in a string, instantiate the appropriate <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object and call its <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Чтобы создать массив байтов, содержащий закодированные символы в строке, создать экземпляр соответствующего <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> и вызовите его <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>Some of the standard encodings available in the .NET Framework include the following:</source>
          <target state="translated">Ниже приведены некоторые стандартные кодировки, доступные в .NET Framework:</target>       </trans-unit>
        <trans-unit id="3454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>Encoding</source>
          <target state="translated">кодировка</target>       </trans-unit>
        <trans-unit id="3455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>Object</source>
          <target state="translated">Object</target>       </trans-unit>
        <trans-unit id="3456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>ASCII</source>
          <target state="translated">ASCII</target>       </trans-unit>
        <trans-unit id="3457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>UTF-7</source>
          <target state="translated">UTF-7</target>       </trans-unit>
        <trans-unit id="3458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>       </trans-unit>
        <trans-unit id="3459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>UTF-16</source>
          <target state="translated">UTF-16</target>       </trans-unit>
        <trans-unit id="3460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>UTF-32</source>
          <target state="translated">UTF-32</target>       </trans-unit>
        <trans-unit id="3461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>For more information, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>кодировка символов в .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.String.ToCharArray%2A&gt;</ph> method to extract the characters in a string to a character array.</source>
          <target state="translated">В следующем примере вызывается <ph id="ph1">&lt;xref:System.String.ToCharArray%2A&gt;</ph> метод для извлечения символов в строке в массив символов.</target>       </trans-unit>
        <trans-unit id="3463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>It then displays the original string and the elements in the array.</source>
          <target state="translated">Затем отображает исходную строку и элементов в массиве.</target>       </trans-unit>
        <trans-unit id="3464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>The following example defines a string containing the characters that serve as delimiters in a delimited string.</source>
          <target state="translated">В следующем примере определяется строка, содержащая символы, которые служат в качестве разделителей в строке с разделителями.</target>       </trans-unit>
        <trans-unit id="3465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray">
          <source>It then calls the <ph id="ph1">&lt;xref:System.String.ToCharArray%2A&gt;</ph> method to create a character array that can be passed to the <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> method to separate the delimited string into its individual substrings.</source>
          <target state="translated">Затем он вызывает <ph id="ph1">&lt;xref:System.String.ToCharArray%2A&gt;</ph> метод для создания массива знаков, который может быть передан в <ph id="ph2">&lt;xref:System.String.Split%28System.Char%5B%5D%29&gt;</ph> метод для разделения строка с разделителями в его отдельных подстроки.</target>       </trans-unit>
        <trans-unit id="3466" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>The starting position of a substring in this instance.</source>
          <target state="translated">Начальная позиция подстроки в данном экземпляре.</target>       </trans-unit>
        <trans-unit id="3467" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>The length of the substring in this instance.</source>
          <target state="translated">Длина подстроки в данном экземпляре.</target>       </trans-unit>
        <trans-unit id="3468" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>Copies the characters in a specified substring in this instance to a Unicode character array.</source>
          <target state="translated">Копирует знаки из указанной подстроки данного экземпляра в массив знаков Юникода.</target>       </trans-unit>
        <trans-unit id="3469" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>A Unicode character array whose elements are the <ph id="ph1">&lt;paramref name="length" /&gt;</ph> number of characters in this instance starting from character position <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</source>
          <target state="translated">Массив знаков Юникода, элементами которого являются <ph id="ph1">&lt;paramref name="length" /&gt;</ph> знаков данного экземпляра начиная с позиции <ph id="ph2">&lt;paramref name="startIndex" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>This method copies the characters in a portion of a string to a character array.</source>
          <target state="translated">Этот метод копирует знаки в части строки в массив символов.</target>       </trans-unit>
        <trans-unit id="3471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>To create a string from a range of characters in a character array, call the  <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">Чтобы создать строку из диапазона символов в массиве символов, вызовите <ph id="ph1">&lt;xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="3472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>The <ph id="ph1">`startIndex`</ph> parameter is zero-based.</source>
          <target state="translated"><ph id="ph1">`startIndex`</ph> Параметра начинается с нуля.</target>       </trans-unit>
        <trans-unit id="3473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>That is, the index of the first character in the string instance is zero.</source>
          <target state="translated">Индекс первого символа в экземпляре строки является ноль.</target>       </trans-unit>
        <trans-unit id="3474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>If <ph id="ph1">`length`</ph> is zero, the returned array is empty and has a zero length.</source>
          <target state="translated">Если <ph id="ph1">`length`</ph> равен нулю, то возвращаемый массив пуст и имеет нулевую длину.</target>       </trans-unit>
        <trans-unit id="3475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>If this instance is <ph id="ph1">`null`</ph> or an empty string (""), the returned array is empty and has a zero length.</source>
          <target state="translated">Если этот экземпляр <ph id="ph1">`null`</ph> или является пустой строкой ("»), то возвращаемый массив пуст и имеет нулевую длину.</target>       </trans-unit>
        <trans-unit id="3476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>To create a byte array that contains the encoded characters in a portion of a string, instantiate the appropriate <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> object and call its <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated">Чтобы создать массив байтов, содержащий закодированные символы в часть строки, создать экземпляр соответствующего <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> и вызовите его <ph id="ph2">&lt;xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>Some of the standard encodings available in the .NET Framework include the following:</source>
          <target state="translated">Ниже приведены некоторые стандартные кодировки, доступные в .NET Framework:</target>       </trans-unit>
        <trans-unit id="3478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>Encoding</source>
          <target state="translated">кодировка</target>       </trans-unit>
        <trans-unit id="3479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>Object</source>
          <target state="translated">Object</target>       </trans-unit>
        <trans-unit id="3480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>ASCII</source>
          <target state="translated">ASCII</target>       </trans-unit>
        <trans-unit id="3481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>UTF-7</source>
          <target state="translated">UTF-7</target>       </trans-unit>
        <trans-unit id="3482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>       </trans-unit>
        <trans-unit id="3483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>UTF-16</source>
          <target state="translated">UTF-16</target>       </trans-unit>
        <trans-unit id="3484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>UTF-32</source>
          <target state="translated">UTF-32</target>       </trans-unit>
        <trans-unit id="3485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>кодировка символов в .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>The following example converts a substring within a string to an array of characters, then enumerates and displays the elements of the array.</source>
          <target state="translated">В следующем примере преобразует подстроку в строке в массив символов, а затем перечисляет и отображает элементы массива.</target>       </trans-unit>
        <trans-unit id="3487" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is less than zero.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> или <ph id="ph2">&lt;paramref name="length" /&gt;</ph> меньше нуля.</target>       </trans-unit>
        <trans-unit id="3488" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3489" translate="yes" xml:space="preserve" uid="M:System.String.ToCharArray(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> plus <ph id="ph2">&lt;paramref name="length" /&gt;</ph> is greater than the length of this instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="startIndex" /&gt;</ph> плюс <ph id="ph2">&lt;paramref name="length" /&gt;</ph> больше длины данного экземпляра.</target>       </trans-unit>
        <trans-unit id="3490" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a copy of this string converted to lowercase.</source>
          <target state="translated">Возвращает копию этой строки, переведенную в нижний регистр.</target>       </trans-unit>
        <trans-unit id="3491" translate="yes" xml:space="preserve" uid="M:System.String.ToLower">
          <source>Returns a copy of this string converted to lowercase.</source>
          <target state="translated">Возвращает копию этой строки, переведенную в нижний регистр.</target>       </trans-unit>
        <trans-unit id="3492" translate="yes" xml:space="preserve" uid="M:System.String.ToLower">
          <source>A string in lowercase.</source>
          <target state="translated">Строка в нижнем регистре.</target>       </trans-unit>
        <trans-unit id="3493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>This method takes into account the casing rules of the current culture.</source>
          <target state="translated">Этот метод учитывает правила определения регистра для текущего языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="3494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Этот метод не изменяет значение текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="3495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</source>
          <target state="translated">Вместо этого он возвращает новую строку, в которой все символы текущего экземпляра преобразуются в нижний регистр.</target>       </trans-unit>
        <trans-unit id="3496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>Security Considerations</source>
          <target state="translated">Вопросы безопасности</target>       </trans-unit>
        <trans-unit id="3497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>The casing operation that results from calling the <ph id="ph1">&lt;xref:System.String.ToLower&gt;</ph> method takes the casing conventions of the current culture into account.</source>
          <target state="translated">Операции учета регистра, полученный в результате вызова <ph id="ph1">&lt;xref:System.String.ToLower&gt;</ph> метод учитывает правила регистра текущего языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="3498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> methods.</source>
          <target state="translated">Если необходима версия верхний или нижний регистр идентификатора операционной системы, такие как имя файла с именем канала или раздел реестра, используйте <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="3499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>This produces the same result in every culture (unlike the <ph id="ph1">&lt;xref:System.String.ToLower&gt;</ph> method) and performs more efficiently.</source>
          <target state="translated">Это дает тот же результат каждого языка и региональных параметров (в отличие от <ph id="ph1">&lt;xref:System.String.ToLower&gt;</ph> метод) и работает более эффективно.</target>       </trans-unit>
        <trans-unit id="3500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>The following example converts several mixed case strings to lowercase.</source>
          <target state="translated">В следующем примере несколько строк со смешанным регистром преобразуется в нижний регистр.</target>       </trans-unit>
        <trans-unit id="3501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Как описано в статье <bpt id="p1">[</bpt>советы и рекомендации по использованию строк<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, рекомендуется избегать вызова методов преобразования регистра строк, которые заменяют значения по умолчанию и вместо этого вызывают методы, которые требуют явного указания параметров.</target>       </trans-unit>
        <trans-unit id="3502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower">
          <source>To convert a character to lowercase by using the casing conventions of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="P:System.Globalization.CultureInfo.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="culture" /&gt;</ph> parameter.</source>
          <target state="translated">Чтобы преобразовать символ в нижний регистр, используя правила учета регистра текущего языка и региональных параметров, вызовите <ph id="ph1">&lt;see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /&gt;</ph> перегрузка метода со значением <ph id="ph2">&lt;see cref="P:System.Globalization.CultureInfo.CurrentCulture" /&gt;</ph> для его <ph id="ph3">&lt;paramref name="culture" /&gt;</ph> параметра.</target>       </trans-unit>
        <trans-unit id="3503" translate="yes" xml:space="preserve" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>An object that supplies culture-specific casing rules.</source>
          <target state="translated">Объект, задающий правила определения регистра для языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="3504" translate="yes" xml:space="preserve" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>Returns a copy of this string converted to lowercase, using the casing rules of the specified culture.</source>
          <target state="translated">Возвращает копию этой строки, переведенную в нижний регистр, используя правила определения регистра заданного языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="3505" translate="yes" xml:space="preserve" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>The lowercase equivalent of the current string.</source>
          <target state="translated">Эквивалент текущей строки в нижнем регистре.</target>       </trans-unit>
        <trans-unit id="3506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>The casing rules of the culture specified by the <ph id="ph1">`culture`</ph> parameter determine the way the case of the string is changed.</source>
          <target state="translated">Правила определения регистра для языка и региональных параметров, заданные <ph id="ph1">`culture`</ph> определить параметр изменен способ изменения регистра строки.</target>       </trans-unit>
        <trans-unit id="3507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Этот метод не изменяет значение текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="3508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</source>
          <target state="translated">Вместо этого он возвращает новую строку, в которой все символы текущего экземпляра преобразуются в нижний регистр.</target>       </trans-unit>
        <trans-unit id="3509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>Security Considerations</source>
          <target state="translated">Вопросы безопасности</target>       </trans-unit>
        <trans-unit id="3510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>If you pass the <ph id="ph1">&lt;xref:System.String.ToLower%28System.Globalization.CultureInfo%29&gt;</ph> method a <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object other than <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>, the casing operation will take culture-specific rules into account.</source>
          <target state="translated">Если передать <ph id="ph1">&lt;xref:System.String.ToLower%28System.Globalization.CultureInfo%29&gt;</ph> метод <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> объект, отличный от <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>, регистр операция будет учтена правил, зависящих от языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="3511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
          <target state="translated">Если необходима версия верхний или нижний регистр идентификатора операционной системы, такие как имя файла с именем канала или раздел реестра, используйте <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>This produces the same result in every culture and performs more efficiently.</source>
          <target state="translated">Это дает тот же результат каждого языка и региональных параметров и работает более эффективно.</target>       </trans-unit>
        <trans-unit id="3513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>The following example converts two strings of uppercase characters to lowercase characters using the English-United States and Turkish-Turkey cultures, then compares the lowercase strings.</source>
          <target state="translated">В следующем примере две строки символов верхнего регистра в нижний регистр с использованием языков и региональных параметров Английский (США) и турецкий-Турция, а затем сравнивает строки в нижнем регистре.</target>       </trans-unit>
        <trans-unit id="3514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source>The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.</source>
          <target state="translated">Строки верхнего регистра идентичны, за исключением того, что для каждого вхождения Юникода LATIN CAPITAL LETTER I в одной строке, вторая строка содержит LATIN CAPITAL LETTER I с ТОЧКОЙ выше.</target>       </trans-unit>
        <trans-unit id="3515" translate="yes" xml:space="preserve" uid="M:System.String.ToLower(System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="culture" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3516" translate="yes" xml:space="preserve" uid="M:System.String.ToLowerInvariant">
          <source>Returns a copy of this <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object converted to lowercase using the casing rules of the invariant culture.</source>
          <target state="translated">Возвращает копию этого объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, переведенную в нижний регистр, используя правила учета регистра инвариантного языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="3517" translate="yes" xml:space="preserve" uid="M:System.String.ToLowerInvariant">
          <source>The lowercase equivalent of the current string.</source>
          <target state="translated">Эквивалент текущей строки в нижнем регистре.</target>       </trans-unit>
        <trans-unit id="3518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The invariant culture represents a culture that is culture-insensitive.</source>
          <target state="translated">Инвариантный язык и региональные параметры представляет язык и региональные параметры без учета языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="3519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>It is associated with the English language but not with a specific country or region.</source>
          <target state="translated">Он связан с английским языком, но не с определенной страны или региона.</target>       </trans-unit>
        <trans-unit id="3520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Дополнительные сведения см. в описании свойства <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> method.</source>
          <target state="translated">Если приложение зависит от регистра строки, изменяемого предсказуемым способом, не зависящим от текущего языка и региональных параметров, используйте <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> method is equivalent to <ph id="ph2">`ToLower(CultureInfo.InvariantCulture)`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> Метод эквивалентен методу <ph id="ph2">`ToLower(CultureInfo.InvariantCulture)`</ph>.</target>       </trans-unit>
        <trans-unit id="3523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</source>
          <target state="translated">Метод рекомендуется в том случае, если набор строк должен указываться в определенном порядке элемента управления пользовательского интерфейса.</target>       </trans-unit>
        <trans-unit id="3524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Этот метод не изменяет значение текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="3525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</source>
          <target state="translated">Вместо этого он возвращает новую строку, в которой все символы текущего экземпляра преобразуются в нижний регистр.</target>       </trans-unit>
        <trans-unit id="3526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>Security Considerations</source>
          <target state="translated">Вопросы безопасности</target>       </trans-unit>
        <trans-unit id="3527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> methods.</source>
          <target state="translated">Если необходима версия верхний или нижний регистр идентификатора операционной системы, такие как имя файла с именем канала или раздел реестра, используйте <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="3528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The following example defines a string array that contains a single word in a number of languages.</source>
          <target state="translated">В следующем примере определяется массив строк, содержащий одно слово на нескольких языках.</target>       </trans-unit>
        <trans-unit id="3529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> method is used to populate the elements of a parallel array with the case-insensitive version of each word.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> Метод используется для заполнения элементов в массиве, parallel с версией каждого слова без учета регистра.</target>       </trans-unit>
        <trans-unit id="3530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToLowerInvariant">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> method is used to sort the case-sensitive array based on the order of elements in the lowercase array to ensure that elements appear in the same order regardless of language.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> Метод используется для сортировки массива с учетом регистра, на основе порядка элементов в массиве нижнего регистра, чтобы убедиться, что элементы отображаются в том же порядке, независимо от языка.</target>       </trans-unit>
        <trans-unit id="3531" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Converts the value of this instance to a <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Преобразует значение данного экземпляра в <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3532" translate="yes" xml:space="preserve" uid="M:System.String.ToString">
          <source>Returns this instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>; no actual conversion is performed.</source>
          <target state="translated">Возвращает этот экземпляр <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>; реальное преобразование не осуществляется.</target>       </trans-unit>
        <trans-unit id="3533" translate="yes" xml:space="preserve" uid="M:System.String.ToString">
          <source>The current string.</source>
          <target state="translated">Текущая строка.</target>       </trans-unit>
        <trans-unit id="3534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString">
          <source>Because this method simply returns the current string unchanged, there is no need to call it directly.</source>
          <target state="translated">Так как этот метод просто возвращает текущую строку без изменений, нет необходимости вызывать его напрямую.</target>       </trans-unit>
        <trans-unit id="3535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString">
          <source>It is usually called implicitly in a composite formatting operation, as the example shows.</source>
          <target state="translated">Обычно она вызывается неявно в составного форматирования операции, как показано в примере.</target>       </trans-unit>
        <trans-unit id="3536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString">
          <source>The following example demonstrates the <ph id="ph1">&lt;xref:System.String.ToString%2A&gt;</ph> method.Note that the example does not explicitly call the <ph id="ph2">&lt;xref:System.String.ToString%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">&lt;xref:System.String.ToString%2A&gt;</ph> метод. Обратите внимание, что пример не вызывается явно <ph id="ph2">&lt;xref:System.String.ToString%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString">
          <source>Instead, the method is called implicitly by the <bpt id="p1">[</bpt>composite formatting<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> feature.</source>
          <target state="translated">Вместо этого метод неявно вызывается <bpt id="p1">[</bpt>составное форматирование<ept id="p1">](~/docs/standard/base-types/composite-formatting.md)</ept> компонентов.</target>       </trans-unit>
        <trans-unit id="3538" translate="yes" xml:space="preserve" uid="M:System.String.ToString(System.IFormatProvider)">
          <source>(Reserved) An object that supplies culture-specific formatting information.</source>
          <target state="translated">(Зарезервирован.) Объект, предоставляющий сведения о форматировании, связанные с определенным языком и региональными параметрами.</target>       </trans-unit>
        <trans-unit id="3539" translate="yes" xml:space="preserve" uid="M:System.String.ToString(System.IFormatProvider)">
          <source>Returns this instance of <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>; no actual conversion is performed.</source>
          <target state="translated">Возвращает этот экземпляр <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>; реальное преобразование не осуществляется.</target>       </trans-unit>
        <trans-unit id="3540" translate="yes" xml:space="preserve" uid="M:System.String.ToString(System.IFormatProvider)">
          <source>The current string.</source>
          <target state="translated">Текущая строка.</target>       </trans-unit>
        <trans-unit id="3541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString(System.IFormatProvider)">
          <source><ph id="ph1">`provider`</ph> is reserved, and does not currently participate in this operation.</source>
          <target state="translated"><ph id="ph1">`provider`</ph> зарезервирован и не участвует в настоящее время в этой операции.</target>       </trans-unit>
        <trans-unit id="3542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToString(System.IFormatProvider)">
          <source>Because this method simply returns the current string unchanged, there is no need to call it directly.</source>
          <target state="translated">Так как этот метод просто возвращает текущую строку без изменений, нет необходимости вызывать его напрямую.</target>       </trans-unit>
        <trans-unit id="3543" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a copy of this string converted to uppercase.</source>
          <target state="translated">Возвращает копию этой строки, переведенную в верхний регистр.</target>       </trans-unit>
        <trans-unit id="3544" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper">
          <source>Returns a copy of this string converted to uppercase.</source>
          <target state="translated">Возвращает копию этой строки, переведенную в верхний регистр.</target>       </trans-unit>
        <trans-unit id="3545" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper">
          <source>The uppercase equivalent of the current string.</source>
          <target state="translated">Эквивалент текущей строки в верхнем регистре.</target>       </trans-unit>
        <trans-unit id="3546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>This method uses the casing rules of the current culture to convert each character in the current instance to its uppercase equivalent.</source>
          <target state="translated">Этот метод использует правила определения регистра для текущего языка и региональных параметров для преобразования каждого символа в текущем экземпляре в его эквивалент в верхнем регистре.</target>       </trans-unit>
        <trans-unit id="3547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>If a character does not have an uppercase equivalent, it is included unchanged in the returned string.</source>
          <target state="translated">Если символ не имеет эквивалента в верхнем регистре, она будет включена без изменений в возвращаемой строке.</target>       </trans-unit>
        <trans-unit id="3548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Этот метод не изменяет значение текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="3549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</source>
          <target state="translated">Вместо этого он возвращает новую строку, в которой все символы текущего экземпляра преобразуются в верхний регистр.</target>       </trans-unit>
        <trans-unit id="3550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>The <ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> method is often used to convert a string to uppercase so that it can be used in a case-insensitive comparison.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> Метод часто используется для преобразования строки в верхний регистр, чтобы его можно использовать при сравнении без учета регистра.</target>       </trans-unit>
        <trans-unit id="3551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>A better method to perform case-insensitive comparison is to call a string comparison method that has a <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> parameter whose value you set to <ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph> for a culture-sensitive, case-insensitive comparison.</source>
          <target state="translated">Чтобы выполнить сравнение без учета регистра рекомендуется вызывать метод сравнения строк, который имеет <ph id="ph1">&lt;xref:System.StringComparison&gt;</ph> параметр, значение которого равно <ph id="ph2">&lt;xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType&gt;</ph> сравнение языка и региональных параметров, с учетом регистра.</target>       </trans-unit>
        <trans-unit id="3552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>Security Considerations</source>
          <target state="translated">Вопросы безопасности</target>       </trans-unit>
        <trans-unit id="3553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>The casing operation that results from calling the <ph id="ph1">&lt;xref:System.String.ToUpper&gt;</ph> method takes the casing conventions of the current culture into account.</source>
          <target state="translated">Операции учета регистра, полученный в результате вызова <ph id="ph1">&lt;xref:System.String.ToUpper&gt;</ph> метод учитывает правила регистра текущего языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="3554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
          <target state="translated">Если необходима версия верхний или нижний регистр идентификатора операционной системы, такие как имя файла с именем канала или раздел реестра, используйте <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>This produces the same result in every culture (unlike the <ph id="ph1">&lt;xref:System.String.ToUpper&gt;</ph> method) and performs more efficiently.</source>
          <target state="translated">Это дает тот же результат каждого языка и региональных параметров (в отличие от <ph id="ph1">&lt;xref:System.String.ToUpper&gt;</ph> метод) и работает более эффективно.</target>       </trans-unit>
        <trans-unit id="3556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> method to convert a series of one-character strings that contain each character in the Basic Latin, Latin-1 Supplement, and Latin Extended-A character sets.</source>
          <target state="translated">В следующем примере вызывается <ph id="ph1">&lt;xref:System.String.ToUpper%2A&gt;</ph> метода для преобразования ряда одного символа строк, содержащих каждый символ в наборах A расширенных символов Basic Latin, дополнительная латиница-1 и латиницы.</target>       </trans-unit>
        <trans-unit id="3557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>It then displays each string whose uppercase character is different from its lowercase character.</source>
          <target state="translated">Затем отображается каждая строка которого прописную букву отличается от его строчные буквы.</target>       </trans-unit>
        <trans-unit id="3558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>As explained in <bpt id="p1">[</bpt>Best Practices for Using Strings<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified.</source>
          <target state="translated">Как описано в статье <bpt id="p1">[</bpt>советы и рекомендации по использованию строк<ept id="p1">](~/docs/standard/base-types/best-practices-strings.md)</ept>, рекомендуется избегать вызова методов преобразования регистра строк, которые заменяют значения по умолчанию и вместо этого вызывают методы, которые требуют явного указания параметров.</target>       </trans-unit>
        <trans-unit id="3559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper">
          <source>To convert a string to uppercase by using the casing conventions of the current culture, call the <ph id="ph1">&lt;see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /&gt;</ph> method overload with a value of <ph id="ph2">&lt;see cref="P:System.Globalization.CultureInfo.CurrentCulture" /&gt;</ph> for its <ph id="ph3">&lt;paramref name="culture" /&gt;</ph> parameter.</source>
          <target state="translated">Чтобы преобразовать строку в верхний регистр, используя правила учета регистра текущего языка и региональных параметров, вызовите <ph id="ph1">&lt;see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /&gt;</ph> перегрузка метода со значением <ph id="ph2">&lt;see cref="P:System.Globalization.CultureInfo.CurrentCulture" /&gt;</ph> для его <ph id="ph3">&lt;paramref name="culture" /&gt;</ph> параметра.</target>       </trans-unit>
        <trans-unit id="3560" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>An object that supplies culture-specific casing rules.</source>
          <target state="translated">Объект, задающий правила определения регистра для языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="3561" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>Returns a copy of this string converted to uppercase, using the casing rules of the specified culture.</source>
          <target state="translated">Возвращает копию этой строки, переведенную в верхний регистр, используя правила определения регистра заданного языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="3562" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>The uppercase equivalent of the current string.</source>
          <target state="translated">Эквивалент текущей строки в верхнем регистре.</target>       </trans-unit>
        <trans-unit id="3563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>The casing rules of the culture specified by the <ph id="ph1">`culture`</ph> parameter determine the way the case of a string is changed.</source>
          <target state="translated">Правила определения регистра для языка и региональных параметров, заданные <ph id="ph1">`culture`</ph> определить параметр изменен способ изменения регистра строки.</target>       </trans-unit>
        <trans-unit id="3564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Этот метод не изменяет значение текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="3565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</source>
          <target state="translated">Вместо этого он возвращает новую строку, в которой все символы текущего экземпляра преобразуются в верхний регистр.</target>       </trans-unit>
        <trans-unit id="3566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>Security Considerations</source>
          <target state="translated">Вопросы безопасности</target>       </trans-unit>
        <trans-unit id="3567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>If you pass the <ph id="ph1">&lt;xref:System.String.ToUpper%28System.Globalization.CultureInfo%29&gt;</ph> method a <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object other than <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>, the casing operation will take culture-specific rules into account.</source>
          <target state="translated">Если передать <ph id="ph1">&lt;xref:System.String.ToUpper%28System.Globalization.CultureInfo%29&gt;</ph> метод <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> объект, отличный от <ph id="ph3">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>, регистр операция будет учтена правил, зависящих от языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="3568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
          <target state="translated">Если необходима версия верхний или нижний регистр идентификатора операционной системы, такие как имя файла с именем канала или раздел реестра, используйте <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>This produces the same result in every culture and performs more efficiently.</source>
          <target state="translated">Это дает тот же результат каждого языка и региональных параметров и работает более эффективно.</target>       </trans-unit>
        <trans-unit id="3570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>The following example converts a string of lowercase characters to two strings of uppercase characters using the English-United States and Turkish-Turkey cultures, then compares the uppercase strings.</source>
          <target state="translated">Следующий пример преобразует строку символов нижнего регистра в символы верхнего регистра, с использованием языков и региональных параметров Английский (США) и турецкий-Турция две строки, а затем сравнивает строки в верхний регистр.</target>       </trans-unit>
        <trans-unit id="3571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source>The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.</source>
          <target state="translated">Строки верхнего регистра идентичны, за исключением того, что для каждого вхождения Юникода LATIN CAPITAL LETTER I в одной строке, вторая строка содержит LATIN CAPITAL LETTER I с ТОЧКОЙ выше.</target>       </trans-unit>
        <trans-unit id="3572" translate="yes" xml:space="preserve" uid="M:System.String.ToUpper(System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="culture" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3573" translate="yes" xml:space="preserve" uid="M:System.String.ToUpperInvariant">
          <source>Returns a copy of this <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object converted to uppercase using the casing rules of the invariant culture.</source>
          <target state="translated">Возвращает копию этого объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, переведенную в верхний регистр, используя правила учета регистра инвариантного языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="3574" translate="yes" xml:space="preserve" uid="M:System.String.ToUpperInvariant">
          <source>The uppercase equivalent of the current string.</source>
          <target state="translated">Эквивалент текущей строки в верхнем регистре.</target>       </trans-unit>
        <trans-unit id="3575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The invariant culture represents a culture that is culture-insensitive.</source>
          <target state="translated">Инвариантный язык и региональные параметры представляет язык и региональные параметры без учета языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="3576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>It is associated with the English language but not with a specific country or region.</source>
          <target state="translated">Он связан с английским языком, но не с определенной страны или региона.</target>       </trans-unit>
        <trans-unit id="3577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Дополнительные сведения см. в описании свойства <ph id="ph1">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method.</source>
          <target state="translated">Если приложение зависит от регистра строки, изменяемого предсказуемым способом, не зависящим от текущего языка и региональных параметров, используйте <ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The <ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method is equivalent to <ph id="ph2">`ToUpper(CultureInfo.InvariantCulture)`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> Метод эквивалентен методу <ph id="ph2">`ToUpper(CultureInfo.InvariantCulture)`</ph>.</target>       </trans-unit>
        <trans-unit id="3580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</source>
          <target state="translated">Метод рекомендуется в том случае, если набор строк должен указываться в определенном порядке элемента управления пользовательского интерфейса.</target>       </trans-unit>
        <trans-unit id="3581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>This method does not modify the value of the current instance.</source>
          <target state="translated">Этот метод не изменяет значение текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="3582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</source>
          <target state="translated">Вместо этого он возвращает новую строку, в которой все символы текущего экземпляра преобразуются в верхний регистр.</target>       </trans-unit>
        <trans-unit id="3583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>Security Considerations</source>
          <target state="translated">Вопросы безопасности</target>       </trans-unit>
        <trans-unit id="3584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> methods.</source>
          <target state="translated">Если необходима версия верхний или нижний регистр идентификатора операционной системы, такие как имя файла с именем канала или раздел реестра, используйте <ph id="ph1">&lt;xref:System.String.ToLowerInvariant%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="3585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The following example defines a string array that contains a single word in a number of languages.</source>
          <target state="translated">В следующем примере определяется массив строк, содержащий одно слово на нескольких языках.</target>       </trans-unit>
        <trans-unit id="3586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The <ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> method is used to populate the elements of a parallel array with the case-insensitive version of each word.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.ToUpperInvariant%2A&gt;</ph> Метод используется для заполнения элементов в массиве, parallel с версией каждого слова без учета регистра.</target>       </trans-unit>
        <trans-unit id="3587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.ToUpperInvariant">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> method is used to sort the case-sensitive array based on the order of elements in the uppercase array to ensure that elements appear in the same order regardless of language.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType&gt;</ph> Метод используется для сортировки массива с учетом регистра, на основе порядка элементов в массиве верхнего регистра, чтобы убедиться, что элементы отображаются в том же порядке, независимо от языка.</target>       </trans-unit>
        <trans-unit id="3588" translate="yes" xml:space="preserve" uid="T:System.String">
          <source>Returns a new string in which all leading and trailing occurrences of a set of specified characters from the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object are removed.</source>
          <target state="translated">Возвращает новую строку, в которой удалены все начальные и конечные вхождения заданного набора знаков из текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3589" translate="yes" xml:space="preserve" uid="M:System.String.Trim">
          <source>Removes all leading and trailing white-space characters from the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Удаляет все начальные и конечные символы-разделители из текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3590" translate="yes" xml:space="preserve" uid="M:System.String.Trim">
          <source>The string that remains after all white-space characters are removed from the start and end of the current string.</source>
          <target state="translated">Строка, оставшаяся после удаления всех символов-разделителей из начала и конца текущей строки.</target>       </trans-unit>
        <trans-unit id="3591" translate="yes" xml:space="preserve" uid="M:System.String.Trim">
          <source>If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Если в текущем экземпляре невозможно усечь символы, метод возвращает текущий экземпляр без изменений.</target>       </trans-unit>
        <trans-unit id="3592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>The <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method removes from the current string all leading and trailing white-space characters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> Метод удаляет из текущей строки все начальные и конечные пробелы.</target>       </trans-unit>
        <trans-unit id="3593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>Each leading and trailing trim operation stops when a non-white-space character is encountered.</source>
          <target state="translated">Каждый начальные и завершающие операции удаления прекращается при обнаружении знака пустого пространства.</target>       </trans-unit>
        <trans-unit id="3594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>For example, if the current string is "   abc   xyz   ", the <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method returns "abc   xyz".</source>
          <target state="translated">Например, если текущая строка «abc "xyz» <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> метод возвращает «abc xyz».</target>       </trans-unit>
        <trans-unit id="3595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>To remove white-space characters between words in a string, use a <bpt id="p1">[</bpt>.NET Framework Regular Expressions<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</source>
          <target state="translated">Чтобы удалить пробелы между словами в строке, используйте <bpt id="p1">[</bpt>регулярные выражения .NET Framework<ept id="p1">](~/docs/standard/base-types/regular-expressions.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>If the <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method removes any characters from the current instance, this method does not modify the value of the current instance.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> метод удаляет все символы из текущего экземпляра, этот метод не изменяет значение текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="3597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>Instead, it returns a new string in which all leading and trailing white space characters found in the current instance are removed.</source>
          <target state="translated">Вместо этого он возвращает новую строку, в которой удалены все начальные и конечные символы пробелов, найдены в текущем экземпляре.</target>       </trans-unit>
        <trans-unit id="3598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>If the current string equals <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> or all the characters in the current instance consist of white-space characters, the method returns <ph id="ph2">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">Если значение текущей строки равно <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> или все символы в текущем экземпляре состоят из пробельные символы, метод возвращает <ph id="ph2">&lt;xref:System.String.Empty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>White-space characters are defined by the Unicode standard.</source>
          <target state="translated">Пробельные символы определены в стандарте Юникода.</target>       </trans-unit>
        <trans-unit id="3600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>The <ph id="ph1">&lt;xref:System.String.Trim&gt;</ph> method removes any leading and trailing characters that produce a return value of <ph id="ph2">`true`</ph> when they are passed to the <ph id="ph3">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Trim&gt;</ph> Метод удаляет все начальные и конечные символы, возвращающих возвращаемое значение <ph id="ph2">`true`</ph> при передаче в <ph id="ph3">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Trim?displayProperty=nameWithType&gt;</ph> method to remove any extra white space from strings entered by the user before concatenating them.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.String.Trim?displayProperty=nameWithType&gt;</ph> метод для удаления лишних пробелов из строк, введенных пользователем, перед их объединения.</target>       </trans-unit>
        <trans-unit id="3602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>The <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions maintain an internal list of white-space characters that this method trims.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> И более ранних версиях Ведение внутреннего списка пробельные символы, которые удаляются данным методом.</target>       </trans-unit>
        <trans-unit id="3603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, the method trims all Unicode white-space characters (that is, characters that produce a <ph id="ph2">&lt;see langword="true" /&gt;</ph> return value when they are passed to the <ph id="ph3">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> method).</source>
          <target state="translated">Начиная с <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, метод удаляет все символы-разделители в Юникоде (то есть символы, создающие <ph id="ph2">&lt;see langword="true" /&gt;</ph> возвращаемое значение, когда они передаются <ph id="ph3">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> метода).</target>       </trans-unit>
        <trans-unit id="3604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>Because of this change, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>and later versions does not remove.</source>
          <target state="translated">Из-за этого изменения <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> метод в <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> и более ранних версиях удаляет двух символов, НУЛЯ ШИРИНУ пробел (U + 200B) и НУЛЕВОЙ ШИРИНЫ неразрывный пробел (U + FEFF), <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> метод в <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>и более поздних версий не удалять.</target>       </trans-unit>
        <trans-unit id="3605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim">
          <source>In addition, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</source>
          <target state="translated">Кроме того <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> метод в <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> и более ранних версий не trim три пробельные символы Юникода: МОНГОЛЬСКИЙ ГЛАСНЫЕ РАЗДЕЛИТЕЛЯ (U + 180E), УЗКИХ неразрывный пробел (U + 202F) и средний МАТЕМАТИЧЕСКИХ пробел (U + 205F).</target>       </trans-unit>
        <trans-unit id="3606" translate="yes" xml:space="preserve" uid="M:System.String.Trim(System.Char[])">
          <source>An array of Unicode characters to remove, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Массив удаляемых знаков Юникода или <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3607" translate="yes" xml:space="preserve" uid="M:System.String.Trim(System.Char[])">
          <source>Removes all leading and trailing occurrences of a set of characters specified in an array from the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Удаляет все начальные и конечные вхождения набора знаков, заданного в виде массива, из текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3608" translate="yes" xml:space="preserve" uid="M:System.String.Trim(System.Char[])">
          <source>The string that remains after all occurrences of the characters in the <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> parameter are removed from the start and end of the current string.</source>
          <target state="translated">Строка, оставшаяся после удаления всех вхождений символов, заданных в параметре <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph>, из начала и конца текущей строки.</target>       </trans-unit>
        <trans-unit id="3609" translate="yes" xml:space="preserve" uid="M:System.String.Trim(System.Char[])">
          <source>If <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty array, white-space characters are removed instead.</source>
          <target state="translated">Если значением параметра <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> является <ph id="ph2">&lt;see langword="null" /&gt;</ph> или пустой массив, удаляются символы-разделители.</target>       </trans-unit>
        <trans-unit id="3610" translate="yes" xml:space="preserve" uid="M:System.String.Trim(System.Char[])">
          <source>If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Если в текущем экземпляре невозможно усечь символы, метод возвращает текущий экземпляр без изменений.</target>       </trans-unit>
        <trans-unit id="3611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method removes from the current string all leading and trailing characters that are in the <ph id="ph2">`trimChars`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> Метод удаляет из текущей строки все начальные и конечные символы, находящиеся в <ph id="ph2">`trimChars`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="3612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>Each leading and trailing trim operation stops when a character that is not in <ph id="ph1">`trimChars`</ph> is encountered.</source>
          <target state="translated">Каждый начальные и конечные trim остановки операции, если символ, который не находится в <ph id="ph1">`trimChars`</ph> встречается.</target>       </trans-unit>
        <trans-unit id="3613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>For example, if the current string is "123abc456xyz789" and <ph id="ph1">`trimChars`</ph> contains the digits from "1" through "9", the <ph id="ph2">&lt;xref:System.String.Trim%2A&gt;</ph> method returns "abc456xyz".</source>
          <target state="translated">Например, если текущая строка «123abc456xyz789» и <ph id="ph1">`trimChars`</ph> состоит из цифр от «1» до «9» <ph id="ph2">&lt;xref:System.String.Trim%2A&gt;</ph> метод возвращает «abc456xyz».</target>       </trans-unit>
        <trans-unit id="3614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>If the <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> method removes any characters from the current instance, this method does not modify the value of the current instance.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.String.Trim%2A&gt;</ph> метод удаляет все символы из текущего экземпляра, этот метод не изменяет значение текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="3615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>Instead, it returns a new string in which all leading and trailing <ph id="ph1">`trimChars`</ph> characters found in the current instance are removed.</source>
          <target state="translated">Вместо этого он возвращает новую строку, в которой все начальные и конечные <ph id="ph1">`trimChars`</ph> удалены символы, найденные в текущем экземпляре.</target>       </trans-unit>
        <trans-unit id="3616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>If the current string equals <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> or all the characters in the current instance consist of characters in the <ph id="ph2">`trimChars`</ph> array, the method returns <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</source>
          <target state="translated">Если значение текущей строки равно <ph id="ph1">&lt;xref:System.String.Empty&gt;</ph> или все символы в текущем экземпляре состоять из символов в <ph id="ph2">`trimChars`</ph> массива, метод возвращает <ph id="ph3">&lt;xref:System.String.Empty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>If <ph id="ph1">`trimChars`</ph> is <ph id="ph2">`null`</ph> or an empty array, this method removes any leading or trailing characters that result in the method returning <ph id="ph3">`true`</ph> when they are passed to the <ph id="ph4">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> method,</source>
          <target state="translated">Если <ph id="ph1">`trimChars`</ph> — <ph id="ph2">`null`</ph> или пустой массив, этот метод удаляет все начальные и конечные символы, возникающих при возврате метода <ph id="ph3">`true`</ph> при передаче в <ph id="ph4">&lt;xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType&gt;</ph> метода</target>       </trans-unit>
        <trans-unit id="3618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> method to remove space, asterisk (*), and apostrophe (') characters from a string.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType&gt;</ph> метод для удаления пространства, звездочка (*) и апостроф (') символов из строки.</target>       </trans-unit>
        <trans-unit id="3619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>The <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions maintains an internal list of white-space characters that this method trims if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> И более ранних версиях обслуживает внутренний список пробельные символы, которые удаляются данным методом, если <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> — <ph id="ph3">&lt;see langword="null" /&gt;</ph> или пустой массив.</target>       </trans-unit>
        <trans-unit id="3620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <ph id="ph4">&lt;see langword="true" /&gt;</ph> return value when they are passed to the <ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> method).</source>
          <target state="translated">Начиная с <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, если <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> — <ph id="ph3">&lt;see langword="null" /&gt;</ph> или пустой массив, метод удаляет все символы-разделители в Юникоде (то есть символы, создающие <ph id="ph4">&lt;see langword="true" /&gt;</ph> возвращаемое значение, когда они передаются <ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> метода).</target>       </trans-unit>
        <trans-unit id="3621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>Because of this change, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>and later versions does not remove.</source>
          <target state="translated">Из-за этого изменения <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> метод в <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> и более ранних версиях удаляет двух символов, НУЛЯ ШИРИНУ пробел (U + 200B) и НУЛЕВОЙ ШИРИНЫ неразрывный пробел (U + FEFF), <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> метод в <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>и более поздних версий не удалять.</target>       </trans-unit>
        <trans-unit id="3622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.Trim(System.Char[])">
          <source>In addition, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</source>
          <target state="translated">Кроме того <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> метод в <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> и более ранних версий не trim три пробельные символы Юникода: МОНГОЛЬСКИЙ ГЛАСНЫЕ РАЗДЕЛИТЕЛЯ (U + 180E), УЗКИХ неразрывный пробел (U + 202F) и средний МАТЕМАТИЧЕСКИХ пробел (U + 205F).</target>       </trans-unit>
        <trans-unit id="3623" translate="yes" xml:space="preserve" uid="M:System.String.TrimEnd(System.Char[])">
          <source>An array of Unicode characters to remove, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Массив удаляемых знаков Юникода или <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3624" translate="yes" xml:space="preserve" uid="M:System.String.TrimEnd(System.Char[])">
          <source>Removes all trailing occurrences of a set of characters specified in an array from the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Удаляет все конечные вхождения набора знаков, заданного в виде массива, из текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3625" translate="yes" xml:space="preserve" uid="M:System.String.TrimEnd(System.Char[])">
          <source>The string that remains after all occurrences of the characters in the <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> parameter are removed from the end of the current string.</source>
          <target state="translated">Строка, оставшаяся после удаления всех вхождений символов, заданных в параметре <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph>, из конца текущей строки.</target>       </trans-unit>
        <trans-unit id="3626" translate="yes" xml:space="preserve" uid="M:System.String.TrimEnd(System.Char[])">
          <source>If <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty array, Unicode white-space characters are removed instead.</source>
          <target state="translated">Если значением параметра <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> является <ph id="ph2">&lt;see langword="null" /&gt;</ph> или пустой массив, удаляются символы-разделители в Юникоде.</target>       </trans-unit>
        <trans-unit id="3627" translate="yes" xml:space="preserve" uid="M:System.String.TrimEnd(System.Char[])">
          <source>If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</source>
          <target state="translated">Если в текущем экземпляре невозможно усечь символы, метод возвращает текущий экземпляр без изменений.</target>       </trans-unit>
        <trans-unit id="3628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> method removes from the current string all trailing characters that are in the <ph id="ph2">`trimChars`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> Метод удаляет из текущей строки все конечные символы, которые находятся в <ph id="ph2">`trimChars`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="3629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>The trim operation stops when the first character that is not in <ph id="ph1">`trimChars`</ph> is encountered at the end of the string.</source>
          <target state="translated">Операции удаления прекращается, если первый символ, не находится в <ph id="ph1">`trimChars`</ph> встречается в конце строки.</target>       </trans-unit>
        <trans-unit id="3630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>For example, if the current string is "123abc456xyz789" and <ph id="ph1">`trimChars`</ph> contains the digits from "1" through "9", the <ph id="ph2">&lt;xref:System.String.TrimEnd%2A&gt;</ph> method returns "123abc456xyz".</source>
          <target state="translated">Например, если текущая строка «123abc456xyz789» и <ph id="ph1">`trimChars`</ph> состоит из цифр от «1» до «9» <ph id="ph2">&lt;xref:System.String.TrimEnd%2A&gt;</ph> метод возвращает «123abc456xyz».</target>       </trans-unit>
        <trans-unit id="3631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>If the <ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> method removes any characters from the current instance, this method does not modify the value of the current instance.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.String.TrimEnd%2A&gt;</ph> метод удаляет все символы из текущего экземпляра, этот метод не изменяет значение текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="3632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>Instead, it returns a new string in which all trailing characters found in <ph id="ph1">`trimChars`</ph> are removed from the current string.</source>
          <target state="translated">Вместо этого он возвращает новую строку, в которой все конечные символы, найденные в <ph id="ph1">`trimChars`</ph> удаляются из текущей строки.</target>       </trans-unit>
        <trans-unit id="3633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>The following example demonstrates how you can use the <ph id="ph1">&lt;xref:System.String.TrimEnd%28System.Char%5B%5D%29&gt;</ph> method to trim white space or punctuation marks from the end of a string.</source>
          <target state="translated">В следующем примере показано, как использовать <ph id="ph1">&lt;xref:System.String.TrimEnd%28System.Char%5B%5D%29&gt;</ph> метод усечения пробелы или знаки препинания в конце строки.</target>       </trans-unit>
        <trans-unit id="3634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>The <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions maintains an internal list of white-space characters that this method trims if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> И более ранних версиях обслуживает внутренний список пробельные символы, которые удаляются данным методом, если <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> — <ph id="ph3">&lt;see langword="null" /&gt;</ph> или пустой массив.</target>       </trans-unit>
        <trans-unit id="3635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <ph id="ph4">&lt;see langword="true" /&gt;</ph> return value when they are passed to the <ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> method).</source>
          <target state="translated">Начиная с <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, если <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> — <ph id="ph3">&lt;see langword="null" /&gt;</ph> или пустой массив, метод удаляет все символы-разделители в Юникоде (то есть символы, создающие <ph id="ph4">&lt;see langword="true" /&gt;</ph> возвращаемое значение, когда они передаются <ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> метода).</target>       </trans-unit>
        <trans-unit id="3636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>Because of this change, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> and later versions does not remove.</source>
          <target state="translated">Из-за этого изменения <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> метод в <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> и более ранних версиях удаляет двух символов, НУЛЯ ШИРИНУ пробел (U + 200B) и НУЛЕВОЙ ШИРИНЫ неразрывный пробел (U + FEFF), <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> метод в <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> и более поздних версий не удалять.</target>       </trans-unit>
        <trans-unit id="3637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimEnd(System.Char[])">
          <source>In addition, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</source>
          <target state="translated">Кроме того <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> метод в <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> и более ранних версий не trim три пробельные символы Юникода: МОНГОЛЬСКИЙ ГЛАСНЫЕ РАЗДЕЛИТЕЛЯ (U + 180E), УЗКИХ неразрывный пробел (U + 202F) и средний МАТЕМАТИЧЕСКИХ пробел (U + 205F).</target>       </trans-unit>
        <trans-unit id="3638" translate="yes" xml:space="preserve" uid="M:System.String.TrimStart(System.Char[])">
          <source>An array of Unicode characters to remove, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Массив удаляемых знаков Юникода или <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3639" translate="yes" xml:space="preserve" uid="M:System.String.TrimStart(System.Char[])">
          <source>Removes all leading occurrences of a set of characters specified in an array from the current <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object.</source>
          <target state="translated">Удаляет все начальные вхождения набора знаков, заданного в виде массива, из текущего объекта <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3640" translate="yes" xml:space="preserve" uid="M:System.String.TrimStart(System.Char[])">
          <source>The string that remains after all occurrences of characters in the <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> parameter are removed from the start of the current string.</source>
          <target state="translated">Строка, оставшаяся после удаления всех вхождений символов, заданных в параметре <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph>, из начала текущей строки.</target>       </trans-unit>
        <trans-unit id="3641" translate="yes" xml:space="preserve" uid="M:System.String.TrimStart(System.Char[])">
          <source>If <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or an empty array, white-space characters are removed instead.</source>
          <target state="translated">Если значением параметра <ph id="ph1">&lt;paramref name="trimChars" /&gt;</ph> является <ph id="ph2">&lt;see langword="null" /&gt;</ph> или пустой массив, удаляются символы-разделители.</target>       </trans-unit>
        <trans-unit id="3642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> method removes from the current string all leading characters that are in the <ph id="ph2">`trimChars`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> Метод удаляет из текущей строки все начальные символы, которые находятся в <ph id="ph2">`trimChars`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="3643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The trim operation stops when a character that is not in <ph id="ph1">`trimChars`</ph> is encountered.</source>
          <target state="translated">Операции удаления прекращается, если символ, который не находится в <ph id="ph1">`trimChars`</ph> встречается.</target>       </trans-unit>
        <trans-unit id="3644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>For example, if the current string is "123abc456xyz789" and <ph id="ph1">`trimChars`</ph> contains the digits from "1" through "9", the <ph id="ph2">&lt;xref:System.String.TrimStart%2A&gt;</ph> method returns "abc456xyz789".</source>
          <target state="translated">Например, если текущая строка «123abc456xyz789» и <ph id="ph1">`trimChars`</ph> состоит из цифр от «1» до «9» <ph id="ph2">&lt;xref:System.String.TrimStart%2A&gt;</ph> метод возвращает «abc456xyz789».</target>       </trans-unit>
        <trans-unit id="3645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>If the <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> method removes any characters from the current instance, this method does not modify the value of the current instance.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> метод удаляет все символы из текущего экземпляра, этот метод не изменяет значение текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="3646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>Instead, it returns a new string in which all leading white space characters found in the current instance are removed.</source>
          <target state="translated">Вместо этого он возвращает новую строку, в которой удалены все начальные символы пробелов, найдены в текущем экземпляре.</target>       </trans-unit>
        <trans-unit id="3647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> method to trim white space and comment characters from lines of source code.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> метод, чтобы обрезать пробелы и символы комментария из строки исходного кода.</target>       </trans-unit>
        <trans-unit id="3648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The <ph id="ph1">`StripComments`</ph> method wraps a call to <ph id="ph2">&lt;xref:System.String.TrimStart%2A&gt;</ph> and passes it a character array that contains a space and the comment character, which is an apostrophe ( ' ) in Visual Basic and a slash ( / ) in C#.</source>
          <target state="translated"><ph id="ph1">`StripComments`</ph> Метод создает оболочку для вызова <ph id="ph2">&lt;xref:System.String.TrimStart%2A&gt;</ph> и передает их в массив символов, содержит пробел и знак комментария, который является апостроф (') в Visual Basic и косая черта (/) в C#.</target>       </trans-unit>
        <trans-unit id="3649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The <ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> method is also called to remove leading white space when evaluating whether a string is a comment.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.String.TrimStart%2A&gt;</ph> Метод также вызывается для удаления начальных пробелов во время определения, является ли строка комментария.</target>       </trans-unit>
        <trans-unit id="3650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The following example then illustrates a call to the <ph id="ph1">`StripComments`</ph> method.</source>
          <target state="translated">В следующем примере показан вызов метода <ph id="ph1">`StripComments`</ph>.</target>       </trans-unit>
        <trans-unit id="3651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>The <ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions maintains an internal list of white-space characters that this method trims if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> И более ранних версиях обслуживает внутренний список пробельные символы, которые удаляются данным методом, если <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> — <ph id="ph3">&lt;see langword="null" /&gt;</ph> или пустой массив.</target>       </trans-unit>
        <trans-unit id="3652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, if <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <ph id="ph4">&lt;see langword="true" /&gt;</ph> return value when they are passed to the <ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> method).</source>
          <target state="translated">Начиная с <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, если <ph id="ph2">&lt;paramref name="trimChars" /&gt;</ph> — <ph id="ph3">&lt;see langword="null" /&gt;</ph> или пустой массив, метод удаляет все символы-разделители в Юникоде (то есть символы, создающие <ph id="ph4">&lt;see langword="true" /&gt;</ph> возвращаемое значение, когда они передаются <ph id="ph5">&lt;see cref="M:System.Char.IsWhiteSpace(System.Char)" /&gt;</ph> метода).</target>       </trans-unit>
        <trans-unit id="3653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>Because of this change, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> and later versions does not remove.</source>
          <target state="translated">Из-за этого изменения <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> метод в <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> и более ранних версиях удаляет двух символов, НУЛЯ ШИРИНУ пробел (U + 200B) и НУЛЕВОЙ ШИРИНЫ неразрывный пробел (U + FEFF), <ph id="ph3">&lt;see cref="M:System.String.Trim" /&gt;</ph> метод в <ph id="ph4">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> и более поздних версий не удалять.</target>       </trans-unit>
        <trans-unit id="3654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.String.TrimStart(System.Char[])">
          <source>In addition, the <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> method in the <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</source>
          <target state="translated">Кроме того <ph id="ph1">&lt;see cref="M:System.String.Trim" /&gt;</ph> метод в <ph id="ph2">[!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)]</ph> и более ранних версий не trim три пробельные символы Юникода: МОНГОЛЬСКИЙ ГЛАСНЫЕ РАЗДЕЛИТЕЛЯ (U + 180E), УЗКИХ неразрывный пробел (U + 202F) и средний МАТЕМАТИЧЕСКИХ пробел (U + 205F).</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>