<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Type.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5a40925048dd06746d1e1cda2a76aa4ecaae1b916.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a40925048dd06746d1e1cda2a76aa4ecaae1b916</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</source>
          <target state="translated">Представляет объявления типов для классов, интерфейсов, массивов, значений, перечислений параметров, определений универсальных типов и открытых или закрытых сконструированных универсальных типов.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><ph id="ph1">`Type`</ph> is the root of the <ph id="ph2">&lt;xref:System.Reflection&gt;</ph> functionality and is the primary way to access metadata.</source>
          <target state="translated"><ph id="ph1">`Type`</ph> является корневым элементом <ph id="ph2">&lt;xref:System.Reflection&gt;</ph> функциональные возможности и является основным способом доступа к метаданным.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Use the members of <ph id="ph1">&lt;xref:System.Type&gt;</ph> to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed.</source>
          <target state="translated">Использовать члены <ph id="ph1">&lt;xref:System.Type&gt;</ph> для получения сведений о объявление типа, об элементах типа (например, конструкторы, методы, поля, свойства и события класса), модуля и сборки, в которой развернут данный класс.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels.</source>
          <target state="translated">Разрешения не требуются для кода использовать отражение для получения сведений о типы и члены, независимо от их уровни доступа.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation.</source>
          <target state="translated">Разрешения не требуются для кода использовать отражение для доступа к открытым членам или другим членам, уровни доступа которых сделали бы их видимыми во время обычной компиляции.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
          <target state="translated">Тем не менее, использовать отражение для доступа к членам, которые обычно становятся недоступны, например к закрытым или внутренним методам или защищенным полям типа коду не наследует класс, код должен иметь <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">В разделе <bpt id="p1">[</bpt>рекомендации по безопасности для отражения<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><ph id="ph1">`Type`</ph> is an abstract base class that allows multiple implementations.</source>
          <target state="translated"><ph id="ph1">`Type`</ph> Представляет абстрактный базовый класс, который может быть создано несколько реализаций.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The system will always provide the derived class <ph id="ph1">`RuntimeType`</ph>.</source>
          <target state="translated">Система всегда выбирает производного класса <ph id="ph1">`RuntimeType`</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.</source>
          <target state="translated">В отражении все классы, начинающихся со слова среды выполнения каждого объекта в системе и поддерживают операции сравнения создаются только один раз.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>In multithreading scenarios, do not lock <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects in order to synchronize access to <ph id="ph2">`static`</ph> data.</source>
          <target state="translated">В сценариях многопоточность, не блокируют <ph id="ph1">&lt;xref:System.Type&gt;</ph> объекты для синхронизации доступа к <ph id="ph2">`static`</ph> данных.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Other code, over which you have no control, might also lock your class type.</source>
          <target state="translated">Другой код, в течение которого у вас нет контроля, также может заблокировать тип класса.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>This might result in a deadlock.</source>
          <target state="translated">Это может привести к взаимоблокировке.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Instead, synchronize access to static data by locking a private <ph id="ph1">`static`</ph> object.</source>
          <target state="translated">Вместо этого следует синхронизировать доступ к статическим данным, заблокировав закрытый <ph id="ph1">`static`</ph> объекта.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>A derived class can access protected members of the calling code's base classes.</source>
          <target state="translated">Производный класс может получить доступ к защищенные члены базовых классов вызывающего кода.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Also, access is allowed to assembly members of the calling code's assembly.</source>
          <target state="translated">Кроме того разрешен доступ к членам сборки вызывающего кода.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.</source>
          <target state="translated">Как правило если доступ разрешен в коде с ранним связыванием, то разрешены и в коде с поздним связыванием.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.</source>
          <target state="translated">Интерфейсы, расширяющие другие интерфейсы, не наследуют методы, определенные в расширенные интерфейсы.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>In this section:</source>
          <target state="translated">Содержание</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><bpt id="p1">[</bpt>What types does a Type object represent?<ept id="p1">](#WhatTypes)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Какие типы представляют тип объекта?<ept id="p1">](#WhatTypes)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><bpt id="p1">[</bpt>Retrieving a Type object<ept id="p1">](#Retrieve)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Получение тип объекта<ept id="p1">](#Retrieve)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><bpt id="p1">[</bpt>Comparing type objects for equality<ept id="p1">](#Equality)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Сравнение типов объектов на равенство<ept id="p1">](#Equality)</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>What types does a Type object represent?</source>
          <target state="translated">Какие типы представляют тип объекта?</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>This class is thread safe; multiple threads can concurrently read from an instance of this type.</source>
          <target state="translated">Этот класс является потокобезопасным; несколько потоков могут одновременно считывать из экземпляра данного типа.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Type&gt;</ph> class can represent any of the following types:</source>
          <target state="translated">Экземпляр <ph id="ph1">&lt;xref:System.Type&gt;</ph> класс может представлять любой из следующих типов:</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Classes</source>
          <target state="translated">Классы</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Value types</source>
          <target state="translated">Типы значений</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Arrays</source>
          <target state="translated">Массивы</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Interfaces</source>
          <target state="translated">интерфейсов,</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Enumerations</source>
          <target state="translated">Перечисления</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Delegates</source>
          <target state="translated">Делегаты</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Constructed generic types and generic type definitions</source>
          <target state="translated">Сконструированных универсальных типов и определений универсальных типов</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions</source>
          <target state="translated">Аргументы типа и типа параметров сконструированных универсальных типов, определений универсальных типов и определений универсальных методов</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Retrieving a Type object</source>
          <target state="translated">Получение тип объекта</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type&gt;</ph> object associated with a particular type can be obtained in the following ways:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type&gt;</ph> Объекта, связанного с определенным типом можно получить следующими способами:</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The instance <ph id="ph1">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents the type of an instance.</source>
          <target state="translated">Экземпляр <ph id="ph1">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph> возвращает <ph id="ph2">&lt;xref:System.Type&gt;</ph> , представляющий тип экземпляра.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Because all managed types derive from <ph id="ph1">&lt;xref:System.Object&gt;</ph>, the <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> method can be called on an instance of any type.</source>
          <target state="translated">Так как все управляемые типы являются производными от <ph id="ph1">&lt;xref:System.Object&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> метод может быть вызван на экземпляре любого типа.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph> method to determine the runtime type of each object in an object array.</source>
          <target state="translated">В следующем примере вызывается <ph id="ph1">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы определить тип каждого объекта в массив объектов среды выполнения.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The static <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> methods return a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a type specified by its fully qualified name.</source>
          <target state="translated">Статический <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> методы возвращают <ph id="ph2">&lt;xref:System.Type&gt;</ph> , представляющий тип, заданный полным именем.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType&gt;</ph> methods return <ph id="ph4">`Type`</ph> objects that represent the types defined in a module.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>, И <ph id="ph3">&lt;xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType&gt;</ph> методы возвращают <ph id="ph4">`Type`</ph> объекты, представляющие типы, определенные в модуле.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The first method can be used to obtain an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects for all the public and private types defined in a module.</source>
          <target state="translated">Первый метод может быть использован для получения массив <ph id="ph1">&lt;xref:System.Type&gt;</ph> объектов для всех открытых и закрытых типов, определенных в модуле.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>(You can obtain an instance of <ph id="ph1">`Module`</ph> through the <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType&gt;</ph> method, or through the <ph id="ph4">&lt;xref:System.Type.Module%2A?displayProperty=nameWithType&gt;</ph> property.)</source>
          <target state="translated">(Можно получить экземпляр <ph id="ph1">`Module`</ph> через <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType&gt;</ph> или <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType&gt;</ph> метода, либо с помощью <ph id="ph4">&lt;xref:System.Type.Module%2A?displayProperty=nameWithType&gt;</ph> свойство.)</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly?displayProperty=nameWithType&gt;</ph> object contains a number of methods to retrieve the classes defined in an assembly, including <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Assembly?displayProperty=nameWithType&gt;</ph> Объект содержит несколько методов для извлечения классы, определенные в сборке, в том числе <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType&gt;</ph>, и <ph id="ph4">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> method returns a filtered list of interface types supported by a type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> Метод возвращает отфильтрованный список типов интерфейсов, поддерживаемых типом.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetElementType%2A&gt;</ph> method returns a <ph id="ph2">`Type`</ph> object that represents the element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetElementType%2A&gt;</ph> Возвращает <ph id="ph2">`Type`</ph> объект, представляющий элемент.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetInterface%2A&gt;</ph> methods return <ph id="ph3">&lt;xref:System.Type&gt;</ph> objects representing the interface types supported by a type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> И <ph id="ph2">&lt;xref:System.Type.GetInterface%2A&gt;</ph> методы возвращают <ph id="ph3">&lt;xref:System.Type&gt;</ph> объекты, представляющие типы интерфейсов, поддерживаемых типом.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeArray%2A&gt;</ph> method returns an array of <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects representing the types specified by an arbitrary set of objects.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeArray%2A&gt;</ph> Метод возвращает массив <ph id="ph2">&lt;xref:System.Type&gt;</ph> объекты, представляющие типы, определенные системой произвольный набор объектов.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The objects are specified with an array of type <ph id="ph1">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">Объекты, указанные с помощью массива типа <ph id="ph1">&lt;xref:System.Object&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> methods are provided for COM interoperability.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> И <ph id="ph2">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> предоставляются методы для COM-взаимодействия.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>They return a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the type specified by a <ph id="ph2">`ProgID`</ph> or <ph id="ph3">`CLSID`</ph>.</source>
          <target state="translated">Они возвращают <ph id="ph1">&lt;xref:System.Type&gt;</ph> , представляющий тип, заданный параметром <ph id="ph2">`ProgID`</ph> или <ph id="ph3">`CLSID`</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromHandle%2A&gt;</ph> method is provided for interoperability.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeFromHandle%2A&gt;</ph> Метод предоставляется для обеспечения взаимодействия.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>It returns a <ph id="ph1">`Type`</ph> object that represents the type specified by a class handle.</source>
          <target state="translated">Он возвращает <ph id="ph1">`Type`</ph> , представляющий тип, указанный с помощью дескриптора класса.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The C# <ph id="ph1">`typeof`</ph> operator, the C++ <ph id="ph2">`typeid`</ph> operator, and the Visual Basic <ph id="ph3">`GetType`</ph> operator obtain the <ph id="ph4">`Type`</ph> object for a type.</source>
          <target state="translated">C# <ph id="ph1">`typeof`</ph> оператор C++ <ph id="ph2">`typeid`</ph> оператор и Visual Basic <ph id="ph3">`GetType`</ph> оператор получения <ph id="ph4">`Type`</ph> объекта для типа.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object representing a constructed generic type, which is an open constructed type if its <ph id="ph3">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph4">`true`</ph>, and a closed constructed type otherwise.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> Возвращает <ph id="ph2">&lt;xref:System.Type&gt;</ph> объект, представляющий сконструированный универсальный тип, являющийся открытым сконструированным типом, если его <ph id="ph3">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> возвращает <ph id="ph4">`true`</ph>, и закрытый сконструированный тип в противном случае.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>A generic type can be instantiated only if it is closed.</source>
          <target state="translated">Универсальный тип может быть создан только в том случае, если он закрыт.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.MakePointerType%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph> methods return <ph id="ph4">&lt;xref:System.Type&gt;</ph> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (<ph id="ph5">`ref`</ph> in C#, <ph id="ph6">`ByRef`</ph> in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.MakePointerType%2A&gt;</ph>, И <ph id="ph3">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph> методы возвращают <ph id="ph4">&lt;xref:System.Type&gt;</ph> объектов, которые представляют, соответственно, массив указанного типа, указатель заданного типа и типа ссылочного параметра (<ph id="ph5">`ref`</ph> в C# <ph id="ph6">`ByRef`</ph>в Visual Basic).</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Comparing type objects for equality</source>
          <target state="translated">Сравнение типов объектов на равенство</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents a type is unique; that is, two <ph id="ph2">&lt;xref:System.Type&gt;</ph> object references refer to the same object if and only if they represent the same type.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Type&gt;</ph> объект, представляющий тип уникален, то есть два <ph id="ph2">&lt;xref:System.Type&gt;</ph> объектные ссылки на тот же объект только в том случае, если они принадлежат к одному типу.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>This allows for comparison of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects using reference equality.</source>
          <target state="translated">Это позволяет сравнивать <ph id="ph1">&lt;xref:System.Type&gt;</ph> объекты с помощью равенство ссылок.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The following example compares the <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects that represent a number of integer values to determine whether they are of the same type.</source>
          <target state="translated">В следующем примере сравниваются <ph id="ph1">&lt;xref:System.Type&gt;</ph> объекты, представляющие количество целочисленных значений, чтобы определить, являются ли они того же типа.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The following  example shows a few representative features of <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">В следующем примере показано несколько типичных функций класса <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The C# <ph id="ph1">`typeof`</ph> operator (<ph id="ph2">`GetType`</ph> operator in Visual Basic, <ph id="ph3">`typeid`</ph> operator in Visual C++) is used to get a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object representing <ph id="ph5">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">C# <ph id="ph1">`typeof`</ph> оператор (<ph id="ph2">`GetType`</ph> оператор на языке Visual Basic <ph id="ph3">`typeid`</ph> оператор в Visual C++) используется для получения <ph id="ph4">&lt;xref:System.Type&gt;</ph> , представляющий <ph id="ph5">&lt;xref:System.String&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>From this <ph id="ph1">&lt;xref:System.Type&gt;</ph> object, the <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method is used to get a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> representing the <ph id="ph4">&lt;xref:System.String.Substring%2A&gt;</ph> overload that takes a starting location and a length.</source>
          <target state="translated">Из этого <ph id="ph1">&lt;xref:System.Type&gt;</ph> объекта, <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> метод используется для получения <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> представляющий <ph id="ph4">&lt;xref:System.String.Substring%2A&gt;</ph> перегрузка, которая принимает начальное расположение и длиной.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>To identify the overload signature, the code example creates a temporary array containing two <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects representing <ph id="ph2">`int`</ph> (<ph id="ph3">`Integer`</ph> in Visual Basic).</source>
          <target state="translated">Для идентификации сигнатуры перегрузки, в примере кода создается временный массив, содержащий два <ph id="ph1">&lt;xref:System.Type&gt;</ph> объектов представляющий <ph id="ph2">`int`</ph> (<ph id="ph3">`Integer`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>To be precise, the array contains two references to the instance of <ph id="ph1">&lt;xref:System.Type&gt;</ph> that represents <ph id="ph2">`int`</ph> in the current application domain.</source>
          <target state="translated">Точнее, массив содержит две ссылки на экземпляр <ph id="ph1">&lt;xref:System.Type&gt;</ph> , представляющий <ph id="ph2">`int`</ph> в текущем домене приложения.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>For any type, there is only one instance of <ph id="ph1">&lt;xref:System.Type&gt;</ph> per application domain.</source>
          <target state="translated">Для любого типа имеется только один экземпляр <ph id="ph1">&lt;xref:System.Type&gt;</ph> домена приложения.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The code example uses the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> to invoke the <ph id="ph2">&lt;xref:System.String.Substring%2A&gt;</ph> method on the string "Hello, World!", and displays the result.</source>
          <target state="translated">В примере кода используется <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> для вызова <ph id="ph2">&lt;xref:System.String.Substring%2A&gt;</ph> метод в строке «Hello, World!» и отображает результат.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>This type is thread safe.</source>
          <target state="translated">Данный тип потокобезопасен.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>When you inherit from <ph id="ph1">&lt;see langword="Type" /&gt;</ph>, you must override the following members:</source>
          <target state="translated">При наследовании от <ph id="ph1">&lt;see langword="Type" /&gt;</ph>, необходимо переопределить следующие члены:</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><ph id="ph1">&lt;see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /&gt;</ph> ,</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /&gt;</ph> ,</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Type.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> class.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.#ctor">
          <source>This constructor is invoked by derived classes during the construction of type objects.</source>
          <target state="translated">Этот конструктор вызывается производными классами во время создания типа объектов.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="P:System.Type.Assembly">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> in which the type is declared.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>, в котором объявлен тип.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="P:System.Type.Assembly">
          <source>For generic types, gets the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> in which the generic type is defined.</source>
          <target state="translated">Для универсальных типов возвращает объект сборки <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>, в которой определен универсальный тип.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> instance that describes the assembly containing the current type.</source>
          <target state="translated">Экземпляр <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>, описывающий сборку, которая содержит текущий тип.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.</source>
          <target state="translated">Для универсальных типов экземпляр описывает сборку, содержащую определение универсального типа, а не сборку, которая создала и использует определенный сконструированный тип.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a constructed generic type, this property returns the assembly that contains the generic type definition.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> объект представляет сконструированный универсальный тип, это свойство возвращает сборку, содержащую определение универсального типа.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition <ph id="ph1">`MyGenericStack&lt;T&gt;`</ph> (<ph id="ph2">`MyGenericStack(Of T)`</ph> in Visual Basic, <ph id="ph3">`generic&lt;T&gt; ref class MyGenericStack`</ph> in C++).</source>
          <target state="translated">Например, предположим, создается сборка с именем MyGenerics.dll, содержащую определение универсального типа <ph id="ph1">`MyGenericStack&lt;T&gt;`</ph> (<ph id="ph2">`MyGenericStack(Of T)`</ph> в Visual Basic <ph id="ph3">`generic&lt;T&gt; ref class MyGenericStack`</ph> в C++).</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>If you create an instance of <ph id="ph1">`MyGenericStack&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericStack(Of Integer)`</ph> in Visual Basic) in another assembly, the <ph id="ph3">&lt;xref:System.Type.Assembly%2A&gt;</ph> property for the constructed type returns an <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> object that represents MyGenerics.dll.</source>
          <target state="translated">При создании экземпляра <ph id="ph1">`MyGenericStack&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericStack(Of Integer)`</ph> в Visual Basic) в другой сборке, <ph id="ph3">&lt;xref:System.Type.Assembly%2A&gt;</ph> свойство для сконструированного типа возвращает <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> , представляющий MyGenerics.dll.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>Similarly, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents an unassigned generic parameter <ph id="ph2">`T`</ph>, this property returns the assembly that contains the generic type that defines <ph id="ph3">`T`</ph>.</source>
          <target state="translated">Аналогично Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет неприсвоенный универсальный параметр <ph id="ph2">`T`</ph>, это свойство возвращает сборку, которая содержит универсальный тип, определяющий <ph id="ph3">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>If the <ph id="ph1">&lt;xref:System.Type.Assembly%2A?displayProperty=nameWithType&gt;</ph> property is not available on a particular .NET implementation, such as .NET Core or the Universal Windows Platform, use the <ph id="ph2">&lt;xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType&gt;</ph> property instead.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Type.Assembly%2A?displayProperty=nameWithType&gt;</ph> свойство недоступно в конкретной реализации .NET, такие как .NET Core или универсальной платформы Windows, используйте <ph id="ph2">&lt;xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType&gt;</ph> свойство вместо него.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>This property is read-only.</source>
          <target state="translated">Это свойство доступно только для чтения.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>The following example displays the assembly name associated with the class and the fully qualified name of the type.</source>
          <target state="translated">Следующий пример отображает имя сборки, связанный с классом и полное имя типа.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="P:System.Type.AssemblyQualifiedName">
          <source>Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object was loaded.</source>
          <target state="translated">Возвращает имя типа с указанием сборки, включающее имя сборки, из которой был загружен объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The assembly-qualified name of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, which includes the name of the assembly from which the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> was loaded, or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if the current instance represents a generic type parameter.</source>
          <target state="translated">Имя объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> с указанием сборки, включающее имя сборки, из которой был загружен объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, или значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>, если текущий экземпляр представляет параметр универсального типа.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly.</source>
          <target state="translated">Имя сборки типа состоит из имени типа, включая пространство имен, используя запятую, следуют отображаемое имя сборки.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The display name of an assembly is obtained using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Отображаемое имя сборки, можно получить <ph id="ph1">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">В .NET Framework версии 2.0 архитектура процессора добавляется удостоверение сборки и может быть указан как часть строки имени сборки.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">Например «ProcessorArchitecture = msil».</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
          <target state="translated">Однако он не включен в строку, возвращаемую <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> свойства для обеспечения совместимости.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">См. раздел <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
          <target state="translated">Все компиляторы, поддерживающие среду порождают простое имя вложенного класса, а отражение создает искаженное имя, если запрос, в соответствии со следующими соглашениями.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Delimiter</source>
          <target state="translated">разделитель</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Meaning</source>
          <target state="translated">Значение</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
          <target state="translated">Обратная косая черта (<ph id="ph1">\\</ph>)</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Escape character.</source>
          <target state="translated">Escape-символ.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Comma (,)</source>
          <target state="translated">Запятая ()</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Precedes the Assembly name.</source>
          <target state="translated">Предшествует имени сборки.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Plus sign (+)</source>
          <target state="translated">Знак плюс (+)</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Precedes a nested class.</source>
          <target state="translated">Перед вложенным классом.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Period (.)</source>
          <target state="translated">Точка (.)</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Denotes namespace identifiers.</source>
          <target state="translated">Определяет идентификаторы пространства имен.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Brackets ([])</source>
          <target state="translated">квадратные скобки ([])</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>After a type name, denotes an array of that type.</source>
          <target state="translated">После имени типа обозначают массив этого типа.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>For a generic type, encloses the generic type argument list.</source>
          <target state="translated">Для универсального типа содержащего список аргументов универсального типа.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Within a type argument list, encloses an assembly-qualified type.</source>
          <target state="translated">В список аргументов типа содержащего типа с указанием сборки.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>For example, the assembly-qualified name for a class might look like this:</source>
          <target state="translated">Например имя сборки для класса может выглядеть следующим образом:</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
          <target state="translated">Если пространство имен содержится знак плюс, например TopNamespace.Sub+Namespace, а затем знак плюс (+) будет предшествовать escape-символ (<ph id="ph1">\\</ph>), чтобы он не будет интерпретироваться как разделитель вложения.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Reflection would emit this string as follows:</source>
          <target state="translated">Эта строка будет порождение отражения следующим образом:</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
          <target state="translated">Объект «++» становится «<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+» и»<ph id="ph4">\\</ph>«становится»<ph id="ph5">\\</ph><ph id="ph6">\\</ph>».</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Это полное имя можно сохранить и впоследствии использовано для загрузки <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
          <target state="translated">Чтобы найти и загрузить <ph id="ph1">&lt;xref:System.Type&gt;</ph>, используйте <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> либо с типом имени, либо только имя типа с указанием сборки.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> с типом имя только будет искать <ph id="ph2">&lt;xref:System.Type&gt;</ph> в сборке вызывающего, а затем в системе сборки.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> в сборке будет искать имя типа с указанием <ph id="ph2">&lt;xref:System.Type&gt;</ph> в любой сборке.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
          <target state="translated">Имена типов могут включать конечные символы, определяющие дополнительные сведения о типе, например, является ли тип ссылочным типом, типом указателя или тип массива.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
          <target state="translated">Чтобы получить имя типа без этих конечных символов, используйте <ph id="ph1">`t.GetElementType().ToString()`</ph>, где <ph id="ph2">`t`</ph> тип.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
          <target state="translated">Пробелы учитываются во всех компонентах имени типа, за исключением имени сборки.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
          <target state="translated">В имени сборки пробелы перед разделителем ',' учитываются, но пробелы после разделителя «,» игнорируются.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Generic arguments of generic types are themselves qualified by assembly name.</source>
          <target state="translated">Универсальные аргументы универсальных типов сами указываются с именем сборки.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>For example, in the assembly-qualified type name for <ph id="ph1">`MyGenericClass&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericClass(Of Integer)`</ph> in Visual Basic), <ph id="ph3">`int`</ph> is expanded to the assembly-qualified type name for <ph id="ph4">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">Например, в имя типа с указанием сборки для <ph id="ph1">`MyGenericClass&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericClass(Of Integer)`</ph> в Visual Basic), <ph id="ph3">`int`</ph> расширяется, чтобы имя типа с указанием сборки для <ph id="ph4">&lt;xref:System.Int32&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a generic parameter, this property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> объект представляет универсальный параметр, это свойство возвращает <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The following example displays the assembly name associated with the class and the fully qualified name of the type.</source>
          <target state="translated">Следующий пример отображает имя сборки, связанный с классом и полное имя типа.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The following example compares the strings returned by the <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> method and the <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> properties.</source>
          <target state="translated">В следующем примере сравниваются строки, возвращаемые <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> метод и <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, и <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="P:System.Type.Attributes">
          <source>Gets the attributes associated with the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает атрибуты, связанные с объектом <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.TypeAttributes" /&gt;</ph> object representing the attribute set of the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, unless the <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> represents a generic type parameter, in which case the value is unspecified.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.TypeAttributes" /&gt;</ph>, представляющий набор атрибутов типа <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, если <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> не представляет параметр универсального типа. В противном случае это значение не определено.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>Some members of the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration are masks that represent a group of values.</source>
          <target state="translated">Некоторые члены <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> перечисления являются маски, представляющие группы значений.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>Each group includes one member whose underlying value is zero.</source>
          <target state="translated">Каждая группа содержит один элемент, чье базовое значение равно нулю.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>For example, the underlying value of the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType&gt;</ph> member in the <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> group is zero, as is the <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> member in the <ph id="ph4">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> group.</source>
          <target state="translated">Например, базовое значение <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType&gt;</ph> члена в <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> группы равен нулю, поскольку <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> члена в <ph id="ph4">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> группы.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>Because of this, you must use the mask before testing for those values.</source>
          <target state="translated">Таким образом необходимо использовать маску перед проверкой на эти значения.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>The example provides an illustration.</source>
          <target state="translated">Иллюстрация приведена в примере.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>For most purposes, properties like <ph id="ph1">&lt;xref:System.Type.IsClass%2A&gt;</ph>,<ph id="ph2">&lt;xref:System.Type.IsAutoLayout%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsSpecialName%2A&gt;</ph> are easier to use than type attributes.</source>
          <target state="translated">В большинстве случаев свойства, такие как <ph id="ph1">&lt;xref:System.Type.IsClass%2A&gt;</ph>,<ph id="ph2">&lt;xref:System.Type.IsAutoLayout%2A&gt;</ph>, и <ph id="ph3">&lt;xref:System.Type.IsSpecialName%2A&gt;</ph> проще в использовании, чем атрибуты типа.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns the attributes of the generic type definition.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, это свойство возвращает атрибуты определения универсального типа.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>For example, the attributes returned for <ph id="ph1">`MyGenericClass&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericClass(Of Integer)`</ph> in Visual Basic) are the attributes of <ph id="ph3">`MyGenericClass&lt;T&gt;`</ph> (<ph id="ph4">`MyGenericClass(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">Например, атрибуты, возвращаемые для <ph id="ph1">`MyGenericClass&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericClass(Of Integer)`</ph> в Visual Basic) являются атрибутами <ph id="ph3">`MyGenericClass&lt;T&gt;`</ph> (<ph id="ph4">`MyGenericClass(Of T)`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type parameter — that is, if the <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph3">`true`</ph> — the <ph id="ph4">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> value returned by this property is unspecified.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр универсального типа — то есть если <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> возвращает <ph id="ph3">`true`</ph> — <ph id="ph4">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> значение, возвращаемое этим свойством не определено.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>The following example usesthe <ph id="ph1">&lt;xref:System.Type.Attributes%2A&gt;</ph> property.</source>
          <target state="translated">Следующий пример usesthe <ph id="ph1">&lt;xref:System.Type.Attributes%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="P:System.Type.BaseType">
          <source>Gets the type from which the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> directly inherits.</source>
          <target state="translated">Возвращает тип, для которого текущий объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> является непосредственным наследником.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> from which the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> directly inherits, or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if the current <ph id="ph4">&lt;see langword="Type" /&gt;</ph> represents the <ph id="ph5">&lt;see cref="T:System.Object" /&gt;</ph> class or an interface.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, прямым наследником которого является текущий объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, или <ph id="ph3">&lt;see langword="null" /&gt;</ph>, если текущий объект <ph id="ph4">&lt;see langword="Type" /&gt;</ph> представляет класс <ph id="ph5">&lt;see cref="T:System.Object" /&gt;</ph> или интерфейс.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The base type is the type from which the current type directly inherits.</source>
          <target state="translated">Базовый тип является типом, от которого непосредственно наследуется текущий тип.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source><ph id="ph1">&lt;xref:System.Object&gt;</ph> is the only type that does not have a base type, therefore <ph id="ph2">`null`</ph> is returned as the base type of <ph id="ph3">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object&gt;</ph> представляет собой единственный тип, у которого нет базового типа, поэтому <ph id="ph2">`null`</ph> возвращается как базовый тип <ph id="ph3">&lt;xref:System.Object&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>Interfaces inherit from zero or more base interfaces; therefore, this property returns <ph id="ph1">`null`</ph> if the <ph id="ph2">`Type`</ph> object represents an interface.</source>
          <target state="translated">Наследование интерфейсов из нуля или более базовых интерфейсов. Таким образом, это свойство возвращает <ph id="ph1">`null`</ph> Если <ph id="ph2">`Type`</ph> объект представляет интерфейс.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The base interfaces can be determined with <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph>.</source>
          <target state="translated">Базовые интерфейсы можно определить с помощью <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, the base type reflects the generic arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, базовый тип отражает универсальные аргументы.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>For example, consider the following declarations:</source>
          <target state="translated">В качестве примера рассмотрим следующие объявления:</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>For the constructed type <ph id="ph1">`C&lt;int&gt;`</ph> (<ph id="ph2">`C(Of Integer)`</ph> in Visual Basic), the <ph id="ph3">&lt;xref:System.Type.BaseType%2A&gt;</ph> property returns <ph id="ph4">`B&lt;int&gt;`</ph>.</source>
          <target state="translated">Для типа, созданного <ph id="ph1">`C&lt;int&gt;`</ph> (<ph id="ph2">`C(Of Integer)`</ph> в Visual Basic), <ph id="ph3">&lt;xref:System.Type.BaseType%2A&gt;</ph> возвращает <ph id="ph4">`B&lt;int&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type definition, <ph id="ph2">&lt;xref:System.Type.BaseType%2A&gt;</ph> returns the class constraint, that is, the class the type parameter must inherit.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр определения универсального типа, <ph id="ph2">&lt;xref:System.Type.BaseType%2A&gt;</ph> возвращает ограничение для класса, то есть параметр типа должен наследовать класс.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>If there is no class constraint, <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> returns <ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">При наличии без ограничения класса <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> возвращает <ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>This property is read-only.</source>
          <target state="translated">Это свойство доступно только для чтения.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The following example demonstrates using the <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> property.</source>
          <target state="translated">В следующем примере показано использование <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The following example uses recursion to list the complete inheritance hierarchy of each class found in an assembly.</source>
          <target state="translated">Следующий пример использует рекурсию для списка полная иерархия наследования для каждого класса в сборке.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The example defines a class named <ph id="ph1">`C`</ph> that derives from a class named <ph id="ph2">`B`</ph>, which, in turn, derives from a class named <ph id="ph3">`A`</ph>.</source>
          <target state="translated">В примере определяется класс с именем <ph id="ph1">`C`</ph> , производный от класса с именем <ph id="ph2">`B`</ph>, который, в свою очередь, является производным от класса с именем <ph id="ph3">`A`</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="P:System.Type.ContainsGenericParameters">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object has type parameters that have not been replaced by specific types.</source>
          <target state="translated">Возвращает значение, позволяющее определить, имеются ли у текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> параметры типа, которые не были замещены указанными типами.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object is itself a generic type parameter or has type parameters for which specific types have not been supplied; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> сам является параметром универсального типа или если для его параметров типа не предоставлены определенные типы; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type.</source>
          <target state="translated">Чтобы создать экземпляр типа, должен быть не определения универсального типа или открытые сконструированные типы в аргументах типа самого типа, в любой включающих его универсальных типов или во всех элементах типа.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>Another way of saying this is that when examined recursively, the type must contain no generic type parameters.</source>
          <target state="translated">— Другими словами, при рекурсивном, тип должен содержать никаких параметров универсального типа.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>Since types can be arbitrarily complex, making this determination is difficult.</source>
          <target state="translated">Поскольку типов может быть произвольным и довольно сложным, это сложно.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>For convenience and to reduce the chance of error, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot.</source>
          <target state="translated">Для удобства и уменьшить вероятность ошибок <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> свойство предоставляет стандартный способ различения закрытые сконструированные типы, которые могут быть созданы, и откройте созданных типов, которые нельзя.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>If the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>, the type cannot be instantiated.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> возвращает <ph id="ph2">`true`</ph>, тип не может быть создан.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property searches recursively for type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> Свойство выполняет рекурсивно для параметров типа.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>For example, it returns <ph id="ph1">`true`</ph> for an array whose elements are type <ph id="ph2">`A&lt;T&gt;`</ph> (<ph id="ph3">`A(Of T)`</ph> in Visual Basic), even though the array is not itself generic.</source>
          <target state="translated">Например, он возвращает <ph id="ph1">`true`</ph> для массива, элементы которого имеют тип <ph id="ph2">`A&lt;T&gt;`</ph> (<ph id="ph3">`A(Of T)`</ph> в Visual Basic), даже если массив не является универсальным.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>Contrast this with the behavior of the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property, which returns <ph id="ph2">`false`</ph> for arrays.</source>
          <target state="translated">Сравните это с поведением <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> свойство, которое возвращает <ph id="ph2">`false`</ph> для массивов.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>For a set of example classes and a table showing the values of the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property, see <ph id="ph2">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</source>
          <target state="translated">Для нескольких примеров классов и таблица, показывающая значения <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> свойство, в разделе <ph id="ph2">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>The following example defines a generic class with two type parameters and then defines a second generic class that derives from the first class.</source>
          <target state="translated">В следующем примере определяется универсальный класс с двумя параметрами типа и затем определяет второй универсальный класс, производный от первого класса.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>The derived class's base class has two type arguments: the first is <ph id="ph1">&lt;xref:System.Int32&gt;</ph> and the second is a type parameter of the derived type.</source>
          <target state="translated">Базовый класс для производного класса имеет два аргумента типа: первый — <ph id="ph1">&lt;xref:System.Int32&gt;</ph> , а второй — параметр типа производного типа.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>The example displays information about these generic classes, including the positions reported by the <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property.</source>
          <target state="translated">В примере отображаются сведения об этих универсальных классов, включая позициях сообщили <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="P:System.Type.DeclaringMethod">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> that represents the declaring method, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter of a generic method.</source>
          <target state="translated">Возвращает метод <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph>, который представляет объявляемый метод, если текущий <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> представляет параметр типа универсального метода.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>If the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter of a generic method, a <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> that represents declaring method; otherwise, <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Если текущий объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> представляет параметр типа универсального метода, класс <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph>, представляющий объявляемый метод; в противном случае — значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>The declaring method is a generic method definition.</source>
          <target state="translated">Объявляемый метод является определением универсального метода.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>That is, if <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> does not return <ph id="ph2">`null`</ph>, then <ph id="ph3">`DeclaringMethod.IsGenericMethodDefinition`</ph> returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">То есть если <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> не возвращает <ph id="ph2">`null`</ph>, затем <ph id="ph3">`DeclaringMethod.IsGenericMethodDefinition`</ph> возвращает <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>The <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> И <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> свойства идентификации определения универсального типа или определение универсального метода, в котором изначально был определен параметр универсального типа:</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, that <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> represents a generic method definition, and the current <ph id="ph4">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic method definition.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> возвращает <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> представляет определение универсального метода и текущий <ph id="ph4">&lt;xref:System.Type&gt;</ph> представляет параметр типа определения универсального метода.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns <ph id="ph2">`null`</ph>, then the <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property always returns a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object representing a generic type definition, and the current <ph id="ph5">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic type definition.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> возвращает <ph id="ph2">`null`</ph>, то <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> свойство всегда возвращает <ph id="ph4">&lt;xref:System.Type&gt;</ph> объект, представляющий определение универсального типа и текущий <ph id="ph5">&lt;xref:System.Type&gt;</ph> представляет параметр типа этого универсального типа Определение.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>Getting the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property on a type whose <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property is <ph id="ph3">`false`</ph> throws an <ph id="ph4">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">Получение <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> свойству типа которого <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> свойство <ph id="ph3">`false`</ph> вызывает <ph id="ph4">&lt;xref:System.InvalidOperationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> that is returned by the <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property is either a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> in the case of a generic method, or a <ph id="ph4">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> in the case of a generic constructor.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> , Возвращаемый <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> равно либо <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> в случае универсальному методу, или <ph id="ph4">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> в случае универсальный конструктор.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>In the .NET Framework version 2.0, generic constructors are not supported.</source>
          <target state="translated">Универсальные конструкторы в платформе .NET Framework версии 2.0 не поддерживаются.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>The following code example defines a class that has a generic method, assigns a type argument to the method, and invokes the resulting constructed generic method.</source>
          <target state="translated">В следующем примере кода определяет класс, который содержит универсальный метод, присваивается аргумент типа для метода и вызывает итоговый сконструированный универсальный метод.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>It also displays information about the generic method definition and the constructed method.</source>
          <target state="translated">Он также отображаются сведения об определении универсального метода и сконструированный метод.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>When displaying information about the type parameters of the generic method definition, in the <ph id="ph1">`DisplayGenericMethodInfo`</ph> method, the example code shows the value of the <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property for the method's generic type parameter.</source>
          <target state="translated">При отображении сведений о параметрах типа определения универсального метода, в <ph id="ph1">`DisplayGenericMethodInfo`</ph> метода, в примере кода показано значение <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> свойства для параметра универсального типа метода.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="P:System.Type.DeclaringType">
          <source>Gets the type that declares the current nested type or generic type parameter.</source>
          <target state="translated">Возвращает тип, объявивший текущий вложенный тип или параметр универсального типа.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the enclosing type, if the current type is a nested type; or the generic type definition, if the current type is a type parameter of a generic type; or the type that declares the generic method, if the current type is a type parameter of a generic method; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий включающий тип, если текущий тип является вложенным, или определение универсального типа, если текущий тип является параметром универсального типа, или тип, объявивший этот универсальный метод, если текущий тип является параметром типа универсального метода; в противном случае — значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a type parameter of a generic type, this property returns the generic type definition.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа универсального типа, это свойство возвращает определение универсального типа.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа универсального метода, это свойство возвращает тип, который содержит определение универсального метода.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the type is generic, the generic type definition is returned.</source>
          <target state="translated">Если тип универсален, возвращается определение универсального типа.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>That is, the following code returns the generic type definition of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> generic class, which contains the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.ConvertAll%2A&gt;</ph> generic method:</source>
          <target state="translated">То есть, следующий код возвращает определение универсального типа <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> универсальный класс, который содержит <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.ConvertAll%2A&gt;</ph> универсальный метод:</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, the <ph id="ph2">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или универсального метода <ph id="ph2">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> и <ph id="ph3">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> свойства идентификации определения универсального типа или определение универсального метода, где параметр универсального типа был определен изначально:</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, that <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> represents a generic method definition, and the current <ph id="ph4">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic method definition.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> возвращает <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> представляет определение универсального метода и текущий <ph id="ph4">&lt;xref:System.Type&gt;</ph> представляет параметр типа определения универсального метода.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns <ph id="ph2">`null`</ph>, then the <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property always returns a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object representing a generic type definition, and the current <ph id="ph5">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic type definition.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> возвращает <ph id="ph2">`null`</ph>, то <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> свойство всегда возвращает <ph id="ph4">&lt;xref:System.Type&gt;</ph> объект, представляющий определение универсального типа и текущий <ph id="ph5">&lt;xref:System.Type&gt;</ph> представляет параметр типа этого универсального типа Определение.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>Getting the <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property on a type whose <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property is <ph id="ph3">`false`</ph> throws an <ph id="ph4">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">Получение <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> свойству типа которого <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> свойство <ph id="ph3">`false`</ph> вызывает <ph id="ph4">&lt;xref:System.InvalidOperationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>This example displays the declaring type of a method in a derived class.</source>
          <target state="translated">Этот пример отображает объявляющий тип метода в производном классе.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="P:System.Type.DefaultBinder">
          <source>Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Возвращает ссылку на связыватель по умолчанию, который реализует внутренние правила выбора соответствующих членов, вызываемых методом <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>A reference to the default binder used by the system.</source>
          <target state="translated">Ссылка на связыватель, используемый в системе по умолчанию.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The default binder provided with the common language runtime is applicable in all but the most specialized circumstances.</source>
          <target state="translated">Связыватель по умолчанию, предоставляемый общеязыковой применима во всех но очень специфических ситуаций.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <ph id="ph1">&lt;xref:System.Reflection.Binder&gt;</ph> class and pass an instance of that type using the <ph id="ph2">`binder`</ph> parameter of one of the <ph id="ph3">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> overloads.</source>
          <target state="translated">Если нужен связыватель, следующим правила, которые отличаются от методов связывателя по умолчанию, определяющие тип, производный от <ph id="ph1">&lt;xref:System.Reflection.Binder&gt;</ph> и передайте экземпляр этого типа с помощью <ph id="ph2">`binder`</ph> параметр одного из <ph id="ph3">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> перегрузки.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Reflection models the accessibility rules of the common type system.</source>
          <target state="translated">Отражение моделирует правила доступности для системы общих типов.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>For example, if the caller is in the same assembly, the caller does not need special permissions for internal members.</source>
          <target state="translated">Например если вызывающий объект находится в той же сборке, вызывающий объект не нужны специальные разрешения для внутренних членов.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Otherwise, the caller needs <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
          <target state="translated">В противном случае вызывающая сторона должна <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>This is consistent with lookup of members that are protected, private, and so on.</source>
          <target state="translated">Это при поиске членов, которые защищены, закрытого и т. д.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The general principle is that <ph id="ph1">&lt;xref:System.Reflection.Binder.ChangeType%2A&gt;</ph> should perform only widening conversions, which never lose data.</source>
          <target state="translated">Представляет общий принцип, <ph id="ph1">&lt;xref:System.Reflection.Binder.ChangeType%2A&gt;</ph> должен выполнять только расширяющие преобразования, которые никогда не потерять данные.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer.</source>
          <target state="translated">Примером расширяющего преобразования является преобразование значение, которое является 32-разрядное целое число со знаком в значение, которое является 64-разрядное целое число со знаком.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>This is distinguished from a narrowing conversion, which may lose data.</source>
          <target state="translated">Этим оно отличается от сужающего преобразования, может произойти потеря данных.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.</source>
          <target state="translated">Примером сужающего преобразования является преобразование 64-разрядное целое число со знаком в 32-разрядное целое число со знаком.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The following table lists the conversions supported by the default binder.</source>
          <target state="translated">В следующей таблице перечислены преобразования, поддерживаемые связыватель по умолчанию.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Source Type</source>
          <target state="translated">Тип источника</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Target Type</source>
          <target state="translated">Тип целевого объекта</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Any type</source>
          <target state="translated">Любой тип</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Its base type.</source>
          <target state="translated">Базовый тип.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Any type</source>
          <target state="translated">Любой тип</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The interface it implements.</source>
          <target state="translated">Интерфейс, который его реализует.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Char</source>
          <target state="translated">Char</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Unt16, UInt32, Int32, UInt64, Int64, Single, Double</source>
          <target state="translated">Unt16, UInt32, Int32, UInt64, Int64, Single, Double</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Byte</source>
          <target state="translated">Byte</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</source>
          <target state="translated">Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>SByte</source>
          <target state="translated">SByte</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int16, Int32, Int64, Single, Double</source>
          <target state="translated">Int16, Int32, Int64, Single, Double</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt16</source>
          <target state="translated">UInt16</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt32, Int32, UInt64, Int64, Single, Double</source>
          <target state="translated">UInt32, Int32, UInt64, Int64, Single, Double</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int16</source>
          <target state="translated">Int16</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int32, Int64, Single, Double</source>
          <target state="translated">Int32, Int64, Single, Double</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt32</source>
          <target state="translated">UInt32</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt64, Int64, Single, Double</source>
          <target state="translated">UInt64, Int64, Single, Double</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int32</source>
          <target state="translated">Int32</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int64, Single, Double</source>
          <target state="translated">Int64, Single, Double</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt64</source>
          <target state="translated">UInt64</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Single, Double</source>
          <target state="translated">Single, Double</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int64</source>
          <target state="translated">Int64</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Single, Double</source>
          <target state="translated">Single, Double</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Single</source>
          <target state="translated">Single</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Double</source>
          <target state="translated">Double</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Non-reference</source>
          <target state="translated">Не ссылка</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>By-reference.</source>
          <target state="translated">По ссылке.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The following example gets the default binder from the <ph id="ph1">`DefaultBinder`</ph> property, and invokes a member of MyClass by passing the <ph id="ph2">`DefaultBinder`</ph> value as a parameter to <ph id="ph3">&lt;xref:System.Type.InvokeMember%2A&gt;</ph>.</source>
          <target state="translated">В следующем примере возвращается связыватель по умолчанию из <ph id="ph1">`DefaultBinder`</ph> свойство и вызывает член класса MyClass путем передачи <ph id="ph2">`DefaultBinder`</ph> значение в качестве параметра <ph id="ph3">&lt;xref:System.Type.InvokeMember%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="F:System.Type.Delimiter">
          <source>Separates names in the namespace of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Разделяет имена в пространстве имен класса <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="F:System.Type.Delimiter">
          <source>This field is read-only.</source>
          <target state="translated">Это поле доступно только для чтения.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="F:System.Type.EmptyTypes">
          <source>Represents an empty array of type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Представляет пустой массив типа <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="F:System.Type.EmptyTypes">
          <source>This field is read-only.</source>
          <target state="translated">Это поле доступно только для чтения.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.EmptyTypes">
          <source>The following code example shows the <ph id="ph1">`EmptyTypes`</ph> field used in one of the <ph id="ph2">`GetConstructor`</ph> methods to get a constructor that takes no parameters.</source>
          <target state="translated">В следующем примере кода показан <ph id="ph1">`EmptyTypes`</ph> поле, используемое в одном из <ph id="ph2">`GetConstructor`</ph> методы для получения конструктора, не принимающего параметры.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Determines if the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is the same as the underlying system type of the specified <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Определяет, совпадает ли базовый системный тип текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> с базовым системным типом указанного объекта <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> или <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source>The object whose underlying system type is to be compared with the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Объект, базовый системный тип которого сравнивается с базовым системным типом текущего типа <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source>For the comparison to succeed, <bpt id="p1">&lt;c&gt;</bpt>o<ept id="p1">&lt;/c&gt;</ept> must be able to be cast or converted to an object of type   <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Для успешного сравнения необходимо, чтобы параметр <bpt id="p1">&lt;c&gt;</bpt>o<ept id="p1">&lt;/c&gt;</ept> можно было привести к объекту типа <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> или преобразовать в объект такого типа.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source>Determines if the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object is the same as the underlying system type of the specified <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">Определяет, совпадает ли базовый системный тип текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> с базовым системным типом указанного объекта <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the underlying system type of <ph id="ph2">&lt;paramref name="o" /&gt;</ph> is the same as the underlying system type of the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если базовый системный тип параметра <ph id="ph2">&lt;paramref name="o" /&gt;</ph> совпадает с базовым системным типом текущего объекта <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; в противном случае — значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source>This method also returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if: .</source>
          <target state="translated">Этот метод также возвращает <ph id="ph1">&lt;see langword="false" /&gt;</ph> в следующих случаях:</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="o" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> cannot be cast or converted to a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="o" /&gt;</ph> невозможно привести к объекту <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> или преобразовать в такой объект.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Этот метод переопределяет метод <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>It casts <ph id="ph1">`o`</ph> to an object of type <ph id="ph2">&lt;xref:System.Type&gt;</ph> and calls the <ph id="ph3">&lt;xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Он приводит <ph id="ph1">`o`</ph> для объекта типа <ph id="ph2">&lt;xref:System.Type&gt;</ph> и вызывает <ph id="ph3">&lt;xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Type.Equals%28System.Object%29&gt;</ph> to compare various <ph id="ph2">&lt;xref:System.Type&gt;</ph> object instances with various <ph id="ph3">&lt;xref:System.Object&gt;</ph> instances.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.Type.Equals%28System.Object%29&gt;</ph> для сравнения различных <ph id="ph2">&lt;xref:System.Type&gt;</ph> объекта экземпляров с различными <ph id="ph3">&lt;xref:System.Object&gt;</ph> экземпляров.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>Two things are particularly worth noting about the example:</source>
          <target state="translated">Особенно необходимо отметить в примере приведены две вещи.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>The comparison of a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents an integer with a <ph id="ph2">&lt;xref:System.Reflection.TypeInfo&gt;</ph> object that represents an integer return <ph id="ph3">`true`</ph> because <ph id="ph4">&lt;xref:System.Reflection.TypeInfo&gt;</ph> is derived from <ph id="ph5">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Сравнение <ph id="ph1">&lt;xref:System.Type&gt;</ph> объект, который представляет собой целое число с <ph id="ph2">&lt;xref:System.Reflection.TypeInfo&gt;</ph> объект, который представляет возвращаемое целое <ph id="ph3">`true`</ph> из-за <ph id="ph4">&lt;xref:System.Reflection.TypeInfo&gt;</ph> является производным от <ph id="ph5">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>The comparison of a  <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents a <ph id="ph2">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> object (an open generic type) with a <ph id="ph3">`List(Of String)`</ph> object (a closed generic type) returns <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Сравнение <ph id="ph1">&lt;xref:System.Type&gt;</ph> , представляющий <ph id="ph2">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> объекта (открытый универсальный тип) с <ph id="ph3">`List(Of String)`</ph> возвращает объект (закрытого универсального типа) <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Type)">
          <source>The object whose underlying system type is to be compared with the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Объект, базовый системный тип которого сравнивается с базовым системным типом текущего типа <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Type)">
          <source>Determines if the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is the same as the underlying system type of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Позволяет определить, совпадает ли базовый системный тип текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> с базовым системным типом указанного объекта <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the underlying system type of <ph id="ph2">&lt;paramref name="o" /&gt;</ph> is the same as the underlying system type of the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если базовый системный тип параметра <ph id="ph2">&lt;paramref name="o" /&gt;</ph> совпадает с базовым системным типом текущего объекта <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; в противном случае — значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Type)">
          <source>The following example uses <ph id="ph1">`Equals`</ph> to compare two types.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">`Equals`</ph> для сравнения двух типов.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="F:System.Type.FilterAttribute">
          <source>Represents the member filter used on attributes.</source>
          <target state="translated">Предоставляет фильтр членов, используемый для атрибутов.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="F:System.Type.FilterAttribute">
          <source>This field is read-only.</source>
          <target state="translated">Это поле доступно только для чтения.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>This field holds a reference to the delegate used by the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method.</source>
          <target state="translated">Это поле содержит ссылку на делегат, используемый <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>The method encapsulated by this delegate takes two parameters: the first is a <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object and the second is an <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">Метод, инкапсулированный этим делегатом принимает два параметра: первый — <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> объекта, а второй — <ph id="ph2">`Object`</ph>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>The method determines whether the <ph id="ph1">`MemberInfo`</ph> object matches the criteria specified by the <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">Этот метод определяет, является ли <ph id="ph1">`MemberInfo`</ph> соответствует критериям, заданным в объект <ph id="ph2">`Object`</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>The <ph id="ph1">`Object`</ph> may be assigned the value of any one of the fields on the classes <ph id="ph2">&lt;xref:System.Reflection.FieldAttributes&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>, or <ph id="ph4">&lt;xref:System.Reflection.MethodImplAttributes&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`Object`</ph> Может быть присвоено значение любого из полей в классах <ph id="ph2">&lt;xref:System.Reflection.FieldAttributes&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>, или <ph id="ph4">&lt;xref:System.Reflection.MethodImplAttributes&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>For example, the <ph id="ph1">`Object`</ph> can be assigned the value of a field from <ph id="ph2">`FieldAttributes`</ph> such as Public.</source>
          <target state="translated">Например <ph id="ph1">`Object`</ph> может быть присвоено значение поля из <ph id="ph2">`FieldAttributes`</ph> такие как Public.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>In that case, when the <ph id="ph1">`FilterAttribute`</ph> delegate is invoked, it will return <ph id="ph2">`true`</ph> only if the method represented by the <ph id="ph3">`MemberInfo`</ph> object is decorated with the public field attribute in metadata.</source>
          <target state="translated">В этом случае, когда <ph id="ph1">`FilterAttribute`</ph> вызове делегата, он вернет <ph id="ph2">`true`</ph> только в том случае, если метод, представленный <ph id="ph3">`MemberInfo`</ph> объекта помечено атрибутом открытого поля в метаданных.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>The following example gets the <ph id="ph1">`FilterAttribute`</ph> delegate, passes it as a parameter to the <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method, and displays the specified members and their attributes.</source>
          <target state="translated">В следующем примере извлекается <ph id="ph1">`FilterAttribute`</ph> делегата, он передается в качестве параметра <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> метода и отображает заданные элементы и их атрибуты.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="F:System.Type.FilterName">
          <source>Represents the case-sensitive member filter used on names.</source>
          <target state="translated">Представляет фильтр членов с учетом регистра, применяемый к именам.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="F:System.Type.FilterName">
          <source>This field is read-only.</source>
          <target state="translated">Это поле доступно только для чтения.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>This field holds a reference to the delegate used by the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method.</source>
          <target state="translated">Это поле содержит ссылку на делегат, используемый <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>The method encapsulated by this delegate takes two parameters: the first is a <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object and the second is an <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">Метод, инкапсулированный этим делегатом принимает два параметра: первый — <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> объекта, а второй — <ph id="ph2">`Object`</ph>.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>The method determines whether the <ph id="ph1">`MemberInfo`</ph> object matches the criteria specified by the <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">Этот метод определяет, является ли <ph id="ph1">`MemberInfo`</ph> соответствует критериям, заданным в объект <ph id="ph2">`Object`</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>The <ph id="ph1">`Object`</ph> is assigned a string value, which may include a trailing "*" wildcard character.</source>
          <target state="translated"><ph id="ph1">`Object`</ph> Присваивается строковое значение, которое может содержать символ «*» подстановочный знак.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>Only wildcard end string matching is supported.</source>
          <target state="translated">Поддерживается только конец строки использование подстановочных знаков.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>For example, the <ph id="ph1">`Object`</ph> may be assigned the value "Byte*".</source>
          <target state="translated">Например <ph id="ph1">`Object`</ph> может быть присвоено значение «Byte *».</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>In that case, when the <ph id="ph1">`FilterName`</ph> delegate is invoked, it will return <ph id="ph2">`true`</ph> only if the method represented by the <ph id="ph3">`MemberInfo`</ph> object has a name that begins with "Byte".</source>
          <target state="translated">В этом случае, когда <ph id="ph1">`FilterName`</ph> вызове делегата, он вернет <ph id="ph2">`true`</ph> только в том случае, если метод, представленный <ph id="ph3">`MemberInfo`</ph> объект имеет имя, которое начинается с «Байт».</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>The following code example gets the methods associated with the user-defined <ph id="ph1">`Application`</ph> type.</source>
          <target state="translated">В следующем примере возвращаются методы, связанные с определяемой пользователем <ph id="ph1">`Application`</ph> типа.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="F:System.Type.FilterNameIgnoreCase">
          <source>Represents the case-insensitive member filter used on names.</source>
          <target state="translated">Представляет фильтр членов без учета регистра, применяемый к именам.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="F:System.Type.FilterNameIgnoreCase">
          <source>This field is read-only.</source>
          <target state="translated">Это поле доступно только для чтения.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>This field holds a reference to the delegate used by the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method.</source>
          <target state="translated">Это поле содержит ссылку на делегат, используемый <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>The method encapsulated by this delegate takes two parameters: the first is a <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object and the second is an <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">Метод, инкапсулированный этим делегатом принимает два параметра: первый — <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> объекта, а второй — <ph id="ph2">`Object`</ph>.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>The method determines whether the <ph id="ph1">`MemberInfo`</ph> object matches the criteria specified by the <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">Этот метод определяет, является ли <ph id="ph1">`MemberInfo`</ph> соответствует критериям, заданным в объект <ph id="ph2">`Object`</ph>.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>The <ph id="ph1">`Object`</ph> is assigned a string value, which may include a trailing "*" wildcard character.</source>
          <target state="translated"><ph id="ph1">`Object`</ph> Присваивается строковое значение, которое может содержать символ «*» подстановочный знак.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>Only wildcard end string matching is supported.</source>
          <target state="translated">Поддерживается только конец строки использование подстановочных знаков.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>For example, the <ph id="ph1">`Object`</ph> may be assigned the value "ByTe*".</source>
          <target state="translated">Например <ph id="ph1">`Object`</ph> может быть присвоено значение «ByTe *».</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>In that case, when the <ph id="ph1">`FilterName`</ph> delegate is invoked, it will return true only if the method represented by the <ph id="ph2">`MemberInfo`</ph> object has a name that begins with "byte", ignoring case.</source>
          <target state="translated">В этом случае, когда <ph id="ph1">`FilterName`</ph> делегат, вызываемый, возвратит значение true, только если метод, представленный <ph id="ph2">`MemberInfo`</ph> объект имеет имя, которое начинается с «byte», без учета регистра.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>The following example gets the <ph id="ph1">`MemberFilter`</ph> delegate, passes it as a parameter to the <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method, and displays the methods and their attributes of the <ph id="ph3">`String`</ph> class that begin with the letter "c", disregarding the case.</source>
          <target state="translated">В следующем примере извлекается <ph id="ph1">`MemberFilter`</ph> делегата, он передается в качестве параметра <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> метода и отображает методы и их атрибуты <ph id="ph3">`String`</ph> класс, начинающихся с буквы «c», не учитывается регистр.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>The delegate that compares the interfaces against <bpt id="p1">&lt;c&gt;</bpt>filterCriteria<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Делегат, сравнивающий интерфейсы с параметром <bpt id="p1">&lt;c&gt;</bpt>filterCriteria<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>The search criteria that determines whether an interface should be included in the returned array.</source>
          <target state="translated">Критерий поиска, определяющий, должен ли тот или иной интерфейс включаться в возвращаемый массив.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing a filtered list of interfaces implemented or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий отфильтрованный список интерфейсов, реализованных или наследуемых текущим объектом <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing a filtered list of the interfaces implemented or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or an empty array of type <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> if no interfaces matching the filter are implemented or inherited by the current <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий отфильтрованный список интерфейсов, которые реализует или наследует текущий объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, или пустой массив типа <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>, если после применения фильтра для текущего объекта <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph> не удалось найти соответствующие интерфейсы.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Этот метод может быть переопределен в производном классе.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType&gt;</ph> delegates supplied by the <ph id="ph3">&lt;xref:System.Reflection.Module?displayProperty=nameWithType&gt;</ph> class may also be used, in lieu of the <ph id="ph4">&lt;xref:System.Reflection.TypeFilter?displayProperty=nameWithType&gt;</ph> delegate.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType&gt;</ph> И <ph id="ph2">&lt;xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType&gt;</ph> предоставленных делегатов <ph id="ph3">&lt;xref:System.Reflection.Module?displayProperty=nameWithType&gt;</ph> класс может также использоваться, вместо <ph id="ph4">&lt;xref:System.Reflection.TypeFilter?displayProperty=nameWithType&gt;</ph> делегата.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.</source>
          <target state="translated">Все интерфейсы, реализованные этим классом, считаются во время поиска, где они были объявлены в базовом классе или в самом классе.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned).</source>
          <target state="translated">Этот метод выполняет поиск иерархии базового класса, возвращая сопоставления интерфейсами каждый класс реализует, а также все сопоставления каждый из этих интерфейсов реализует интерфейсы (то есть возвращается транзитивное замыкание сопоставления интерфейсов).</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>No duplicate interfaces are returned.</source>
          <target state="translated">Каждый интерфейс возвращается.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или универсального метода <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> поиск всех интерфейсов, объявленных в ограничения, накладываемые на параметр типа и все интерфейсы наследуется через интерфейсы объявлено в соответствии с ограничениями.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type argument of a generic type, <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> searches all the interfaces implemented by the type, whether or not they match constraints.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет аргумент типа универсального типа, <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> ищет все интерфейсы, реализованные этим типом ли они соответствуют ограничениям.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> can return generic interfaces, even on types that are not generic.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> может возвращать универсальных интерфейсов, даже для типов, которые не являются универсальными.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>For example, a nongeneric type might implement <ph id="ph1">`IEnumerable&lt;int&gt;`</ph> (<ph id="ph2">`IEnumerable(Of Integer)`</ph> in Visual Basic).</source>
          <target state="translated">Например, может реализовать неуниверсальный тип <ph id="ph1">`IEnumerable&lt;int&gt;`</ph> (<ph id="ph2">`IEnumerable(Of Integer)`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>The following example finds the specified interface implemented or inherited by the specified type, and then displays the interface names.</source>
          <target state="translated">В следующем примере вычисляется указанный интерфейс реализован или унаследованные указанным типом, а затем отображает имена интерфейсов.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source><ph id="ph1">&lt;paramref name="filter" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="filter" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>A static initializer is invoked and throws an exception.</source>
          <target state="translated">Статический инициализатор вызывается и создает исключение.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>An object that indicates the type of member to search for.</source>
          <target state="translated">Объект, указывающий тип члена, который нужно найти.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Нуль, чтобы было возвращено значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The delegate that does the comparisons, returning <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the member currently being inspected matches the <bpt id="p1">&lt;c&gt;</bpt>filterCriteria<ept id="p1">&lt;/c&gt;</ept> and <ph id="ph2">&lt;see langword="false" /&gt;</ph> otherwise.</source>
          <target state="translated">Делегат, выполняющий сравнение и возвращающий <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если проверяемый член соответствует условиям, заданным в параметре <bpt id="p1">&lt;c&gt;</bpt>filterCriteria<ept id="p1">&lt;/c&gt;</ept>, и <ph id="ph2">&lt;see langword="false" /&gt;</ph> в противном случае.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>You can use the <ph id="ph1">&lt;see langword="FilterAttribute" /&gt;</ph>, <ph id="ph2">&lt;see langword="FilterName" /&gt;</ph>, and <ph id="ph3">&lt;see langword="FilterNameIgnoreCase" /&gt;</ph> delegates supplied by this class.</source>
          <target state="translated">Можно использовать делегаты <ph id="ph1">&lt;see langword="FilterAttribute" /&gt;</ph>, <ph id="ph2">&lt;see langword="FilterName" /&gt;</ph> и <ph id="ph3">&lt;see langword="FilterNameIgnoreCase" /&gt;</ph>, предоставляемые этим классом.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The first uses the fields of <ph id="ph1">&lt;see langword="FieldAttributes" /&gt;</ph>, <ph id="ph2">&lt;see langword="MethodAttributes" /&gt;</ph>, and <ph id="ph3">&lt;see langword="MethodImplAttributes" /&gt;</ph> as search criteria, and the other two delegates use <ph id="ph4">&lt;see langword="String" /&gt;</ph> objects as the search criteria.</source>
          <target state="translated">Первый делегат в качестве условий поиска использует поля классов <ph id="ph1">&lt;see langword="FieldAttributes" /&gt;</ph>, <ph id="ph2">&lt;see langword="MethodAttributes" /&gt;</ph> и <ph id="ph3">&lt;see langword="MethodImplAttributes" /&gt;</ph>, а два других делегата — объекты <ph id="ph4">&lt;see langword="String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The search criteria that determines whether a member is returned in the array of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects.</source>
          <target state="translated">Условие поиска, определяющее, будет ли член включен в возвращаемый массив объектов <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The fields of <ph id="ph1">&lt;see langword="FieldAttributes" /&gt;</ph>, <ph id="ph2">&lt;see langword="MethodAttributes" /&gt;</ph>, and <ph id="ph3">&lt;see langword="MethodImplAttributes" /&gt;</ph> can be used in conjunction with the <ph id="ph4">&lt;see langword="FilterAttribute" /&gt;</ph> delegate supplied by this class.</source>
          <target state="translated">Поля классов <ph id="ph1">&lt;see langword="FieldAttributes" /&gt;</ph>, <ph id="ph2">&lt;see langword="MethodAttributes" /&gt;</ph> и <ph id="ph3">&lt;see langword="MethodImplAttributes" /&gt;</ph> могут использоваться вместе с делегатом <ph id="ph4">&lt;see langword="FilterAttribute" /&gt;</ph>, предоставляемым этим классом.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Returns a filtered array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects of the specified member type.</source>
          <target state="translated">Возвращает отфильтрованный массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, тип которого совпадает с указанным типом члена.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>A filtered array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects of the specified member type.</source>
          <target state="translated">Отфильтрованный массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, имеющих тип указанного члена.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have members of type <ph id="ph3">&lt;paramref name="memberType" /&gt;</ph> that match the filter criteria.</source>
          <target state="translated">Пустой массив объектов типа <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, если у текущего типа <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> нет членов типа <ph id="ph3">&lt;paramref name="memberType" /&gt;</ph>, удовлетворяющих условиям фильтра.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Этот метод может быть переопределен в производном классе.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">Элементы включают свойства, методы, поля, события и т. д.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги фильтра можно использовать для определения члены, которые нужно включить в поиск:</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Необходимо указать либо <ph id="ph1">`BindingFlags.Instance`</ph> или <ph id="ph2">`BindingFlags.Static`</ph> для получения возврата.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Specify <ph id="ph1">`BindingFlags.Instance`</ph> to include instance members in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Instance`</ph> для включения при поиске членов экземпляра.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Specify <ph id="ph1">`BindingFlags.Static`</ph> to include static members in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Static`</ph> для включения в поиск статические члены.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Public`</ph> для включения в поиск открытых членов.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.NonPublic`</ph> для включения в поиск закрытым членам (то есть частных, внутренних и защищенные члены).</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> модификатор флаги можно использовать для изменения условий поиска:</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> для поиска только члены, объявленные в <ph id="ph2">&lt;xref:System.Type&gt;</ph>, не унаследованные члены группы.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Valid values for <ph id="ph1">&lt;xref:System.Type.MemberType%2A&gt;</ph> are defined in <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph>.</source>
          <target state="translated">Допустимые значения для <ph id="ph1">&lt;xref:System.Type.MemberType%2A&gt;</ph> определены в <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>If no such members are found, an empty array is returned.</source>
          <target state="translated">Если такие члены не найдены, возвращается пустой массив.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>To get the class initializer (.cctor) using this method, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Чтобы получить инициализатора класса (CCTOR), с помощью этого метода, необходимо указать <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">Можно также получить с помощью инициализатора класса <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type or generic method, <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> processes any members declared by the class constraint and the interface constraints of the type parameter.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа универсального типа или универсального метода <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> обрабатывает все члены, объявленные ограничения класса и ограничений интерфейса параметра типа.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The following example finds all the members in a class that match the specified search criteria, and then displays the matched members.</source>
          <target state="translated">В следующем примере осуществляется поиск всех членов класса, соответствующих указанным условиям поиска, а затем отображает сопоставленные элементы.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source><ph id="ph1">&lt;paramref name="filter" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="filter" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="P:System.Type.FullName">
          <source>Gets the fully qualified name of the type, including its namespace but not its assembly.</source>
          <target state="translated">Возвращает полное имя типа, включая пространство имен, но не сборку.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The fully qualified name of the type, including its namespace but not its assembly; or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the current instance represents a generic type parameter, an array type, pointer type, or <ph id="ph2">&lt;see langword="byref" /&gt;</ph> type based on a type parameter, or a generic type that is not a generic type definition but contains unresolved type parameters.</source>
          <target state="translated">Полное имя типа, включая пространство имен, но не сборку; или значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>, если текущий экземпляр представляет параметр универсального типа, тип массива, тип указателя, тип <ph id="ph2">&lt;see langword="byref" /&gt;</ph> на основе параметра типа либо универсальный тип, который, хотя и не является определением универсального типа, содержит неразрешенные параметры типа.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>For example, the fully qualified name of the <ph id="ph1">&lt;xref:System.String&gt;</ph> type is <ph id="ph2">`System.String`</ph>.</source>
          <target state="translated">Например, полное имя <ph id="ph1">&lt;xref:System.String&gt;</ph> тип — <ph id="ph2">`System.String`</ph>.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>Contrast this with the assembly-qualified name returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, which consists of the full name plus the full assembly name.</source>
          <target state="translated">Сравните это с имя сборки, возвращаемое функцией <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> свойство, которое состоит из полного имени и полного имени сборки.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>If the current type represents a closed generic type, the type arguments in the string returned by the <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name.</source>
          <target state="translated">Если текущий тип представляет закрытого универсального типа, аргументы типа в строке, возвращаемый методом <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> свойства определяются их полное имя сборки, несмотря на то, что строковое представление универсального типа не квалифицируется его full имя сборки.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.</source>
          <target state="translated">В следующем примере показано различие в свойстве полное имя для типа, представляющий определение универсального типа и один из них представляет закрытого универсального типа.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>This property returns <ph id="ph1">`null`</ph> if:</source>
          <target state="translated">Это свойство возвращает <ph id="ph1">`null`</ph> если:</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a type parameter of a generic type.</source>
          <target state="translated">Текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа универсального типа.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example retrieves the type parameter of the <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> type and attempts to display its <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> property.</source>
          <target state="translated">В следующем примере извлекается параметру типа <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> тип и пытается отобразить его <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents an array type, a pointer  type, or a <ph id="ph2">`byref`</ph> type that is based on a generic type parameter.</source>
          <target state="translated">Текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> объект представляет тип массива, тип указателя или <ph id="ph2">`byref`</ph> тип, основанный на параметр универсального типа.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example defines a generic type, <ph id="ph1">`Generictype1&lt;T&gt;`</ph>, with three methods: <ph id="ph2">`Display(T[])`</ph>, which is passed an array of type T; <ph id="ph3">`HandleT(T)`</ph>, which is passed a T object; and <ph id="ph4">`ChangeValue(ref T)`</ph>, which is passed a T object by reference.</source>
          <target state="translated">В следующем примере определяется универсальный тип, <ph id="ph1">`Generictype1&lt;T&gt;`</ph>, три метода: <ph id="ph2">`Display(T[])`</ph>, который передается в массив типа T; <ph id="ph3">`HandleT(T)`</ph>, который передается объект; и <ph id="ph4">`ChangeValue(ref T)`</ph>, передаваемый по ссылке объект.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>Because C# and Visual Basic do not allow us to define T as a pointer in the <ph id="ph1">`HandleT`</ph> method, we have to call the <ph id="ph2">&lt;xref:System.Type.MakePointerType%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Type&gt;</ph> object that represents the method's parameter type to create a pointer to a generic type.</source>
          <target state="translated">C# и Visual Basic не допускает нам определить как указатель в T <ph id="ph1">`HandleT`</ph> метода нужно вызвать <ph id="ph2">&lt;xref:System.Type.MakePointerType%2A&gt;</ph> метод <ph id="ph3">&lt;xref:System.Type&gt;</ph> , представляющий тип параметра метода для создания указателя на универсальный тип.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The output from the example shows that in all three cases, the <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> property is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Выходные данные примера показано, что во всех трех случаях <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> свойство <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The current type contains generic type parameters that have not been replaced by specific types (that is, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>), but the type is not a generic type definition (that is, the <ph id="ph3">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property returns <ph id="ph4">`false`</ph></source>
          <target state="translated">Текущий тип содержит параметры универсального типа, которые не были заменены определенных типов (т. е <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> возвращает <ph id="ph2">`true`</ph>), но тип не является определением универсального типа (т. е <ph id="ph3">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> возвращает свойство <ph id="ph4">`false`</ph></target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>In the following example, <ph id="ph1">`Derived&lt;T&gt;`</ph> inherits from <ph id="ph2">`Base&lt;T&gt;`</ph>.</source>
          <target state="translated">В следующем примере <ph id="ph1">`Derived&lt;T&gt;`</ph> наследует от <ph id="ph2">`Base&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> property obtains the  <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents the base type of <ph id="ph3">`Derived&lt;T&gt;`</ph>, and its <ph id="ph4">&lt;xref:System.Type.FullName%2A&gt;</ph> property returns <ph id="ph5">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> Свойство получает <ph id="ph2">&lt;xref:System.Type&gt;</ph> , представляющий базовый тип <ph id="ph3">`Derived&lt;T&gt;`</ph>и его <ph id="ph4">&lt;xref:System.Type.FullName%2A&gt;</ph> возвращает <ph id="ph5">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>To get a <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> that is not <ph id="ph2">`null`</ph>, you can use the <ph id="ph3">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method to get the generic type definition, as the example illustrates.</source>
          <target state="translated">Для получения <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> , не <ph id="ph2">`null`</ph>, можно использовать <ph id="ph3">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> метод для получения определения универсального типа, как показано в примере.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>This property is read-only.</source>
          <target state="translated">Это свойство доступно только для чтения.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example displays the full name of the specified type.</source>
          <target state="translated">Следующий пример отображает полное имя указанного типа.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example compares the strings returned by the <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> method and the <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> properties.</source>
          <target state="translated">В следующем примере сравниваются строки, возвращаемые <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> метод и <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, и <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterAttributes">
          <source>Gets a combination of <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> flags that describe the covariance and special constraints of the current generic type parameter.</source>
          <target state="translated">Возвращает сочетание флагов <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph>, описывающих ковариацию и особые ограничения текущего параметра универсального типа.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> values that describes the covariance and special constraints of the current generic type parameter.</source>
          <target state="translated">Побитовое сочетание значений <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph>, которое описывает ковариацию и особые ограничения текущего параметра универсального типа.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints.</source>
          <target state="translated">Значение этого свойства содержит флаги, описывающие, является ли текущий параметр универсального типа является ковариантным и флаги, описывающие особые ограничения.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType&gt;</ph> value to select the covariance flags, and use the <ph id="ph2">&lt;xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType&gt;</ph> value to select the constraint flags.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType&gt;</ph> выберите флаги ковариации и использовать <ph id="ph2">&lt;xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType&gt;</ph> значения для выбора флагов ограничений.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>The following code example defines a generic type <ph id="ph1">`Test`</ph> with two type parameters that have different constraints.</source>
          <target state="translated">В следующем примере кода определяется универсальный тип <ph id="ph1">`Test`</ph> с двумя параметрами типов, которые имеют различные ограничения.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>When the program executes, the constraints are examined using the <ph id="ph1">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph> method.</source>
          <target state="translated">При выполнении программы ограничения проверяются с помощью <ph id="ph1">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph> свойство и <ph id="ph2">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterAttributes">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object is not a generic type parameter.</source>
          <target state="translated">Текущий объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> не является параметром универсального типа.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterAttributes">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">То есть свойство <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> возвращает значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterAttributes">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">Вызванный метод не поддерживается в базовом классе.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterPosition">
          <source>Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type parameter of a generic type or a generic method.</source>
          <target state="translated">Возвращает позицию параметра типа в списке параметров универсального типа или метода, который объявил параметр, если объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> представляет параметр универсального типа или метода.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The position of a type parameter in the type parameter list of the generic type or method that defines the parameter.</source>
          <target state="translated">Позиция параметра типа в списке параметров типа универсального типа или метода, которые задали этот параметр.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>Position numbers begin at 0.</source>
          <target state="translated">Нумерация позиций начинается с 0.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> Свойство возвращает позицию параметра типа в списке параметров определения универсального типа или определение универсального метода где параметр типа был определен изначально.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> properties identify the generic type or method definition:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> И <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> свойства указывают на определении универсального типа или метода:</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, that <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> represents a generic method definition, and the current <ph id="ph4">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic method definition.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> возвращает <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> представляет определение универсального метода и текущий <ph id="ph4">&lt;xref:System.Type&gt;</ph> представляет параметр типа определения универсального метода.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns <ph id="ph2">`null`</ph>, then the <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property always returns a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object representing a generic type definition, and the current <ph id="ph5">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic type definition.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> возвращает <ph id="ph2">`null`</ph>, то <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> свойство всегда возвращает <ph id="ph4">&lt;xref:System.Type&gt;</ph> объект, представляющий определение универсального типа и текущий <ph id="ph5">&lt;xref:System.Type&gt;</ph> представляет параметр типа этого универсального типа Определение.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>To provide the correct context for the value of the <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property, it is necessary to identify the generic type or method a type parameter belongs to.</source>
          <target state="translated">Чтобы обеспечить правильный контекст для значения <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> свойства, это необходимо для определения универсального типа или метода, параметр типа относится к.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>For example, consider the return value of the generic method <ph id="ph1">`GetSomething`</ph> in the following code:</source>
          <target state="translated">Например, рассмотрим возвращаемое значение метода <ph id="ph1">`GetSomething`</ph> в следующем коде:</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The type returned by <ph id="ph1">`GetSomething`</ph> depends on the type arguments supplied to class <ph id="ph2">`A`</ph> and to <ph id="ph3">`GetSomething`</ph> itself.</source>
          <target state="translated">Тип, возвращаемый <ph id="ph1">`GetSomething`</ph> зависит от аргументов типа, предоставленный для класса <ph id="ph2">`A`</ph> и <ph id="ph3">`GetSomething`</ph> сам.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>You can obtain a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for <ph id="ph2">`GetSomething`</ph>, and from that you can obtain the return type.</source>
          <target state="translated">Вы можете получить <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> для <ph id="ph2">`GetSomething`</ph>, и в, вы можете получить тип возвращаемого значения.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>When you examine the type parameters of the return type, <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> returns 0 for both.</source>
          <target state="translated">При проверке параметров типа, возвращаемого типа <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> возвращает 0 для обоих.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The position of <ph id="ph1">`V`</ph> is 0 because <ph id="ph2">`V`</ph> is the first type parameter in the type parameter list for class <ph id="ph3">`A`</ph>.</source>
          <target state="translated">Положение <ph id="ph1">`V`</ph> равно 0, поскольку <ph id="ph2">`V`</ph> является первым параметром типа в списке параметров типа для класса <ph id="ph3">`A`</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The position of <ph id="ph1">`X`</ph> is 0 because <ph id="ph2">`X`</ph> is the first type parameter in the type parameter list for <ph id="ph3">`GetSomething`</ph>.</source>
          <target state="translated">Положение <ph id="ph1">`X`</ph> равно 0, поскольку <ph id="ph2">`X`</ph> является первым параметром типа в списке параметров типа для <ph id="ph3">`GetSomething`</ph>.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>Calling the <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property causes an exception if the current <ph id="ph2">&lt;xref:System.Type&gt;</ph> does not represent a type parameter.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> свойство вызывает исключение, если текущий <ph id="ph2">&lt;xref:System.Type&gt;</ph> не представляет параметр типа.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>When you examine the type arguments of an open constructed type, use the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell which are type parameters and which are types.</source>
          <target state="translated">При проверке аргументами типа в открытом сконструированном типе использовать <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> свойства, о которой являются параметрами типа и которые являются типами.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> for a type parameter; you can then use the <ph id="ph3">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> method to obtain its position and use the <ph id="ph4">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> properties to determine the generic method or type definition that defines it.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> Возвращает <ph id="ph2">`true`</ph> для параметра типа; затем можно использовать <ph id="ph3">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> метод для получения его положение и использования <ph id="ph4">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> и <ph id="ph5">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> свойства определения универсального метода, либо тип, определяющий его определения .</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The following example defines a generic class with two type parameters and defines a second generic class that derives from the first class.</source>
          <target state="translated">В следующем примере определяется универсальный класс с двумя параметрами типа и определяет второй универсальный класс, производный от первого класса.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The derived class's base class has two type arguments: the first is <ph id="ph1">&lt;xref:System.Int32&gt;</ph>, and the second is a type parameter of the derived type.</source>
          <target state="translated">Базовый класс для производного класса имеет два аргумента типа: первый — <ph id="ph1">&lt;xref:System.Int32&gt;</ph>, и второй является параметром типа производного типа.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The example displays information about these generic classes, including the positions reported by the <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property.</source>
          <target state="translated">В примере отображаются сведения об этих универсальных классов, включая позициях сообщили <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterPosition">
          <source>The current type does not represent a type parameter.</source>
          <target state="translated">Текущий тип не представляет параметр типа.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterPosition">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">То есть <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> возвращает <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="P:System.Type.GenericTypeArguments">
          <source>Gets an array of the generic type arguments for this type.</source>
          <target state="translated">Возвращает массив аргументов универсального типа для этого типа.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>An array of the generic type arguments for this type.</source>
          <target state="translated">Массив аргументов универсального типа для этого типа.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type.</source>
          <target state="translated">Это свойство возвращает только аргументы универсального типа; то есть типы, которые были указаны для параметров универсального типа для текущего типа.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>If the current type is a generic type definition, this property returns an empty array.</source>
          <target state="translated">Если текущий тип является определением универсального типа, это свойство возвращает пустой массив.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type.</source>
          <target state="translated">При использовании универсального типа другого универсального типа или универсального метода, некоторые из его аргументов универсального типа могут быть параметров универсального типа для включающего метода или типа.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>To get the generic type parameters of a type that represents a generic type definition, use the <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Для получения параметров универсального типа для типа, представляющий определение универсального типа, используйте <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>To get a <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> object for the current <ph id="ph2">&lt;xref:System.Type&gt;</ph> object, use the <ph id="ph3">&lt;xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType&gt;</ph> extension method.</source>
          <target state="translated">Для получения <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> для текущего <ph id="ph2">&lt;xref:System.Type&gt;</ph> , используйте <ph id="ph3">&lt;xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType&gt;</ph> метода расширения.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Type.GetArrayRank">
          <source>Gets the number of dimensions in an array.</source>
          <target state="translated">Возвращает размерность массива.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Type.GetArrayRank">
          <source>An integer that contains the number of dimensions in the current type.</source>
          <target state="translated">Целое число, указывающее на количество измерений текущего типа.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetArrayRank">
          <source>The following example displays the number of dimensions in an array.</source>
          <target state="translated">Следующий пример отображает число измерений в массиве.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Type.GetArrayRank">
          <source>The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.</source>
          <target state="translated">Функциональность этого метода не поддерживается в базовом классе и должна быть реализована в производном классе.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Type.GetArrayRank">
          <source>The current type is not an array.</source>
          <target state="translated">Текущий тип не является массивом.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Type.GetAttributeFlagsImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> property and gets a bitmask indicating the attributes associated with the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">При переопределении в производном классе реализует свойство <ph id="ph1">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> и возвращает битовую маску, позволяющую определить атрибуты, связанные с объектом <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Type.GetAttributeFlagsImpl">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.TypeAttributes" /&gt;</ph> object representing the attribute set of the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Reflection.TypeAttributes" /&gt;</ph>, представляющий набор атрибутов объекта <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific constructor of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает определенный конструктор текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the desired constructor.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, предоставляющих число, порядок и тип параметров нужного конструктора.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects, to get a constructor that takes no parameters.</source>
          <target state="translated">Пустой массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> для получения конструктора, не имеющего параметров.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>Such an empty array is provided by the <ph id="ph1">&lt;see langword="static" /&gt;</ph> field <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>.</source>
          <target state="translated">Подобный пустой массив предоставляется полем <ph id="ph1">&lt;see langword="static" /&gt;</ph> с описателем <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>Searches for a public instance constructor whose parameters match the types in the specified array.</source>
          <target state="translated">Выполняет поиск открытого конструктора экземпляра, параметры которого соответствуют типам, содержащимся в указанном массиве.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект, представляющий открытый конструктор экземпляра, параметры которого соответствуют типам, указанным в массиве типов параметров, если такой конструктор найден; в противном случае — <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>This method overload looks for public instance constructors and cannot be used to obtain a class initializer (.cctor).</source>
          <target state="translated">Эта перегрузка метода выполняет поиск открытых конструкторов экземпляра и не может использоваться для получения инициализатора класса (.cctor).</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>To get a class initializer, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Чтобы получить инициализатор класса, используйте перегрузку, которая использует <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>и укажите <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">Можно также получить с помощью инициализатора класса <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>If the requested constructor is non-public, this method returns <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Если запрашиваемый конструктор не является открытым, этот метод возвращает <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">Необходимо указывать все параметры при поиске конструкторов и методов.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Параметры можно опустить только в том случае, при вызове метода.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method always returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод всегда возвращает <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>The following example obtains the type of <ph id="ph1">`MyClass`</ph>, gets the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object, and displays the constructor signature.</source>
          <target state="translated">В следующем примере извлекается тип <ph id="ph1">`MyClass`</ph>, возвращает <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> объекта и отображается подпись конструктора.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Один из элементов в <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="types" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Нуль, чтобы было возвращено значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Пустая ссылка (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> в Visual Basic) для использования свойства <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the constructor to get.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, предоставляющий число, порядок и тип параметров, извлекаемых конструктором.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</source>
          <target state="translated">Пустой массив объектов типа <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (то есть Type[] types = new Type[0]), если требуется получить конструктор, который не имеет параметров.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the parameter type array.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph>, представляющих атрибуты, связанные с соответствующим элементом в массиве типов параметра.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">Связыватель по умолчанию не обрабатывает этот параметр.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
          <target state="translated">Выполняет поиск конструктора, параметры которого соответствуют указанным типам аргументов и модификаторам, используя заданные ограничения привязки.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> object representing the constructor that matches the specified requirements, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Если поиск выполнен удачно, возвращается объект <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>, представляющий конструктор, который соответствует указанным требованиям; в противном случае возвращается значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
          <target state="translated">Если точное соответствие не существует, <ph id="ph1">`binder`</ph> попытается преобразовать типы параметров, указанные в <ph id="ph2">`types`</ph> массива, чтобы найти совпадение.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">Если <ph id="ph1">`binder`</ph> не удалось найти подходящий конструктор, затем <ph id="ph2">`null`</ph> возвращается.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги фильтра можно использовать для определения конструкторов, включаемых в поиск:</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Необходимо указать либо <ph id="ph1">`BindingFlags.Instance`</ph> или <ph id="ph2">`BindingFlags.Static`</ph> для получения возврата.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Public`</ph> для включения в поиск открытых конструкторов.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.NonPublic`</ph> необходимо включить в поиск закрытые конструкторы (то есть закрытые, внутренние и защищенные).</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To get the class initializer (.cctor) using this method overload, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Чтобы получить инициализатора класса (CCTOR), с помощью этой перегрузки метода, необходимо указать <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">Можно также получить с помощью инициализатора класса <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">Необходимо указывать все параметры при поиске конструкторов и методов.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Параметры можно опустить только в том случае, при вызове метода.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method always returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод всегда возвращает <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following program obtains the type of <ph id="ph1">`MyClass1`</ph> class, gets the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object matching the specified binding flags, and displays the signature of the constructor.</source>
          <target state="translated">В следующем коде определяется тип <ph id="ph1">`MyClass1`</ph> класса возвращает <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> объекта, соответствующих указанным флагам привязки и отображается подпись конструктора.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Один из элементов в <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="types" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> и <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> имеют разную длину.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Нуль, чтобы было возвращено значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Пустая ссылка (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> в Visual Basic) для использования свойства <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</source>
          <target state="translated">Объект, определяющий набор применяемых правил, касающихся порядка и расположения аргументов, способа передачи возвращаемого значения, регистров, используемых для аргументов, и очистки стека.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the constructor to get.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, предоставляющий число, порядок и тип параметров, извлекаемых конструктором.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</source>
          <target state="translated">Пустой массив объектов типа <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (то есть Type[] types = new Type[0]), если требуется получить конструктор, который не имеет параметров.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph>, представляющих атрибуты, связанные с соответствующим элементом в массиве <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">Связыватель по умолчанию не обрабатывает этот параметр.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
          <target state="translated">Выполняет поиск конструктора с параметрами, соответствующими указанным модификаторам и типам аргументов, с учетом заданных ограничений по привязке и соглашений о вызовах.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the constructor that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Если поиск выполнен удачно, возвращается объект, представляющий конструктор, который соответствует указанным требованиям; в противном случае возвращается значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Несмотря на то что связыватель по умолчанию не обрабатывает <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> ( <ph id="ph2">`modifiers`</ph> параметр), можно использовать абстрактный <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> класс, чтобы написать собственный связыватель, обрабатывающий <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
          <target state="translated">Если точное соответствие не существует, <ph id="ph1">`binder`</ph> попытается преобразовать типы параметров, указанные в <ph id="ph2">`types`</ph> массива, чтобы найти совпадение.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">Если <ph id="ph1">`binder`</ph> не удалось найти подходящий конструктор, затем <ph id="ph2">`null`</ph> возвращается.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги фильтра можно использовать для определения конструкторов, включаемых в поиск:</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Необходимо указать либо <ph id="ph1">`BindingFlags.Instance`</ph> или <ph id="ph2">`BindingFlags.Static`</ph> для получения возврата.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Public`</ph> для включения в поиск открытых конструкторов.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.NonPublic`</ph> необходимо включить в поиск закрытые конструкторы (то есть закрытые, внутренние и защищенные).</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To get the class initializer (.cctor) using this method, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Чтобы получить инициализатора класса (CCTOR), с помощью этого метода, необходимо указать <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">Можно также получить с помощью инициализатора класса <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">В следующей таблице показаны, какие члены базового класса возвращаются <ph id="ph1">`Get`</ph> методов при отражении в типе.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Member Type</source>
          <target state="translated">Тип члена</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Non-Static</source>
          <target state="translated">Нестатический</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Constructor</source>
          <target state="translated">Конструктор</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Field</source>
          <target state="translated">Поле</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Поле всегда равно по имени и подписи.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Event</source>
          <target state="translated">событие</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Method</source>
          <target state="translated">Метод</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Nested Type</source>
          <target state="translated">Вложенный тип</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Property</source>
          <target state="translated">Свойство.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>This is a binary comparison.</source>
          <target state="translated">Это двоичное сравнение.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Для отражения свойства и события, которые по имени и подписи.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Пользовательские атрибуты не являются частью системы общих типов.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">Необходимо указывать все параметры при поиске конструкторов и методов.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Параметры можно опустить только в том случае, при вызове метода.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method always returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод всегда возвращает <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following example obtains the type of <ph id="ph1">`MyClass1`</ph>, gets the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object that matches the specified binding flags, and displays the constructor signature.</source>
          <target state="translated">В следующем примере извлекается тип <ph id="ph1">`MyClass1`</ph>, возвращает <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> объекта, который соответствует указанным флагам привязки и отображается подпись конструктора.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Один из элементов в <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="types" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> и <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> имеют разную длину.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Нуль, чтобы было возвращено значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Пустая ссылка (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> в Visual Basic) для использования свойства <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</source>
          <target state="translated">Объект, определяющий набор применяемых правил, касающихся порядка и расположения аргументов, способа передачи возвращаемого значения, регистров, используемых для аргументов, и очистки стека.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the constructor to get.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, предоставляющий число, порядок и тип параметров, извлекаемых конструктором.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</source>
          <target state="translated">Пустой массив объектов типа <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (то есть Type[] types = new Type[0]), если требуется получить конструктор, который не имеет параметров.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph>, представляющих атрибуты, связанные с соответствующим элементом в массиве <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">Связыватель по умолчанию не обрабатывает этот параметр.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
          <target state="translated">При переопределении в производном классе ищет конструктор, параметры которого соответствуют указанным типам аргументов и модификаторам, используя для этого заданные ограничения привязки и соглашение о вызовах.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> object representing the constructor that matches the specified requirements, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Если поиск выполнен удачно, возвращается объект <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>, представляющий конструктор, который соответствует указанным требованиям; в противном случае возвращается значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Несмотря на то что связыватель по умолчанию не обрабатывает <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> ( <ph id="ph2">`modifiers`</ph> параметр), можно использовать абстрактный <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> класс, чтобы написать собственный связыватель, обрабатывающий <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
          <target state="translated">Если точное соответствие не существует, <ph id="ph1">`binder`</ph> попытается преобразовать типы параметров, указанные в <ph id="ph2">`types`</ph> массива, чтобы найти совпадение.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">Если <ph id="ph1">`binder`</ph> не удалось найти подходящий конструктор, затем <ph id="ph2">`null`</ph> возвращается.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги фильтра можно использовать для определения конструкторов, включаемых в поиск:</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Необходимо указать либо <ph id="ph1">`BindingFlags.Instance`</ph> или <ph id="ph2">`BindingFlags.Static`</ph> для получения возврата.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Public`</ph> для включения в поиск открытых конструкторов.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.NonPublic`</ph> необходимо включить в поиск закрытые конструкторы (то есть закрытые, внутренние и защищенные).</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>This method implements <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>.</source>
          <target state="translated">Этот метод реализует <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Один из элементов в <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="types" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> и <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> имеют разную длину.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The current type is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</source>
          <target state="translated">Текущий тип является объектом <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> или <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the constructors of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает конструкторы текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors">
          <source>Returns all the public constructors defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает все открытые конструкторы, определенные для текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objects representing all the public instance constructors defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, but not including the type initializer (static constructor).</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>, представляющий все открытые конструкторы экземпляров, определенные для текущего типа <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, за исключением инициализатора типа (статический конструктор).</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors">
          <source>If no public instance constructors are defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, or if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter in the definition of a generic type or generic method, an empty array of type <ph id="ph3">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> is returned.</source>
          <target state="translated">Если для текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> открытые конструкторы экземпляров не определены или если текущий объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> представляет параметр типа в определении универсального типа или метода, возвращается пустой массив типа <ph id="ph3">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method does not return constructors in a particular order, such as declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> Метод не возвращает конструкторы в определенном порядке, например порядке объявления.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Your code must not depend on the order in which constructors are returned, because that order varies.</source>
          <target state="translated">Код не должен зависеть от порядка, в котором возвращаются конструкторы, так как этот порядок меняется.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">В следующей таблице показаны, какие члены базового класса возвращаются <ph id="ph1">`Get`</ph> методов при отражении в типе.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Member Type</source>
          <target state="translated">Тип члена</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Non-Static</source>
          <target state="translated">Нестатический</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Constructor</source>
          <target state="translated">Конструктор</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Field</source>
          <target state="translated">Поле</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Поле всегда равно по имени и подписи.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Event</source>
          <target state="translated">событие</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Method</source>
          <target state="translated">Метод</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Nested Type</source>
          <target state="translated">Вложенный тип</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Property</source>
          <target state="translated">Свойство.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>This is a binary comparison.</source>
          <target state="translated">Это двоичное сравнение.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Для отражения свойства и события, которые по имени и подписи.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Пользовательские атрибуты не являются частью системы общих типов.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>This method overload calls the <ph id="ph1">&lt;xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29&gt;</ph> method overload, with <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Эта перегрузка метода вызывает <ph id="ph1">&lt;xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29&gt;</ph> перегрузка метода с <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>It will not find class initializers (.cctor).</source>
          <target state="translated">Его не удастся найти инициализаторы класса (.cctor).</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>To find class initializers, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Чтобы найти инициализаторы класса, используйте перегрузку, которая использует <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>и укажите <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">Можно также получить с помощью инициализатора класса <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> объекты с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>For example, if class <ph id="ph1">`C&lt;T&gt;`</ph> has a constructor <ph id="ph2">`C(T t1)`</ph> (<ph id="ph3">`Sub New(ByVal t1 As T)`</ph> in Visual Basic), calling <ph id="ph4">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> on <ph id="ph5">`C&lt;int&gt;`</ph> returns a <ph id="ph6">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> that represents <ph id="ph7">`C(int t1)`</ph> in C# (<ph id="ph8">`Sub New(ByVal t1 As Integer)`</ph> in Visual Basic).</source>
          <target state="translated">Например если класс <ph id="ph1">`C&lt;T&gt;`</ph> имеет конструктор <ph id="ph2">`C(T t1)`</ph> (<ph id="ph3">`Sub New(ByVal t1 As T)`</ph> в Visual Basic), вызов <ph id="ph4">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> на <ph id="ph5">`C&lt;int&gt;`</ph> возвращает <ph id="ph6">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> , представляющий <ph id="ph7">`C(int t1)`</ph> в C# (<ph id="ph8">`Sub New(ByVal t1 As Integer)`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type parameter, the <ph id="ph2">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method returns an empty array.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр универсального типа, <ph id="ph2">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> метод возвращает пустой массив.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>This example shows the output of the <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> overload from a class that has two instance constructors and one static constructor.</source>
          <target state="translated">В этом примере показан результат выполнения <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> перегрузки из класса, который имеет два конструктора экземпляра и один статический конструктор.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The output of this code is:</source>
          <target state="translated">Результат выполнения этого кода является:</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Because the <ph id="ph1">&lt;xref:System.Type.GetConstructors&gt;</ph> overload uses only <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, the static constructor is neither counted by the <ph id="ph4">`for`</ph> expression nor evaluated by <ph id="ph5">`IsStatic`</ph>.</source>
          <target state="translated">Поскольку <ph id="ph1">&lt;xref:System.Type.GetConstructors&gt;</ph> перегрузка использует только <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> и <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, статический конструктор не подсчитывается <ph id="ph4">`for`</ph> выражения и не вычисляется <ph id="ph5">`IsStatic`</ph>.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>To find static constructors, use the <ph id="ph1">&lt;xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29&gt;</ph> overload, and pass the combination (logical <ph id="ph2">`OR`</ph>) of <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, as shown in the following code example:</source>
          <target state="translated">Чтобы найти статические конструкторы, используйте <ph id="ph1">&lt;xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29&gt;</ph> перегружать и передать сочетания (логические <ph id="ph2">`OR`</ph>) из <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, как показано в следующем примере кода:</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Now the output is:</source>
          <target state="translated">Теперь выводится следующий результат:</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>True</source>
          <target state="translated">Да</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Нуль, чтобы было возвращено значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the constructors defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified <ph id="ph2">&lt;see langword="BindingFlags" /&gt;</ph>.</source>
          <target state="translated">При переопределении в производном классе ищет конструкторы, определенные для текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, с использованием указанного объекта <ph id="ph2">&lt;see langword="BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objects representing all constructors defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints, including the type initializer if it is defined.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>, представляющий все конструкторы, определенные для текущего объекта <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> и удовлетворяющие указанным ограничениям привязки, в том числе и инициализатор типа, если он определен.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Returns an empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> if no constructors are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, if none of the defined constructors match the binding constraints, or if the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter in the definition of a generic type or generic method.</source>
          <target state="translated">Возвращает пустой массив типа <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>, если для текущего типа <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> не определены конструкторы, если ни один из определенных конструкторов не соответствует ограничениям привязки или если текущий тип <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> представляет параметр типа в определении универсального типа или метода.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method does not return constructors in a particular order, such as declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> Метод не возвращает конструкторы в определенном порядке, например порядке объявления.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which constructors are returned, because that order varies.</source>
          <target state="translated">Код не должен зависеть от порядка, в котором возвращаются конструкторы, так как этот порядок меняется.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`bindingAttr`</ph> can be used to specify whether to return only public constructors or both public and non-public constructors.</source>
          <target state="translated"><ph id="ph1">`bindingAttr`</ph> можно использовать для указания, нужно ли возвращать только открытые конструкторы или открытые и закрытые конструкторы.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
          <target state="translated">Если точное соответствие не существует, <ph id="ph1">`binder`</ph> попытается преобразовать типы параметров, указанные в <ph id="ph2">`types`</ph> массива, чтобы найти совпадение.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">Если <ph id="ph1">`binder`</ph> не удалось найти подходящий конструктор, затем <ph id="ph2">`null`</ph> возвращается.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги фильтра можно использовать для определения конструкторов, включаемых в поиск:</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Необходимо указать либо <ph id="ph1">`BindingFlags.Instance`</ph> или <ph id="ph2">`BindingFlags.Static`</ph> для получения возврата.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Public`</ph> для включения в поиск открытых конструкторов.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.NonPublic`</ph> необходимо включить в поиск закрытые конструкторы (то есть закрытые, внутренние и защищенные).</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Constructors of base classes are not returned.</source>
          <target state="translated">Конструкторы базовых классов не возвращаются.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>To get the class initializer (.cctor) using this method overload, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Чтобы получить инициализатора класса (CCTOR), с помощью этой перегрузки метода, необходимо указать <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">Можно также получить с помощью инициализатора класса <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> объекты с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>For example, if class <ph id="ph1">`C&lt;T&gt;`</ph> has a constructor <ph id="ph2">`C(T t1)`</ph> (<ph id="ph3">`Sub New(ByVal t1 As T)`</ph> in Visual Basic), calling <ph id="ph4">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> on <ph id="ph5">`C&lt;int&gt;`</ph> returns a <ph id="ph6">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> that represents <ph id="ph7">`C(int t1)`</ph> in C# (<ph id="ph8">`Sub New(ByVal t1 As Integer)`</ph> in Visual Basic).</source>
          <target state="translated">Например если класс <ph id="ph1">`C&lt;T&gt;`</ph> имеет конструктор <ph id="ph2">`C(T t1)`</ph> (<ph id="ph3">`Sub New(ByVal t1 As T)`</ph> в Visual Basic), вызов <ph id="ph4">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> на <ph id="ph5">`C&lt;int&gt;`</ph> возвращает <ph id="ph6">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> , представляющий <ph id="ph7">`C(int t1)`</ph> в C# (<ph id="ph8">`Sub New(ByVal t1 As Integer)`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type parameter, the <ph id="ph2">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method returns an empty array.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр универсального типа, <ph id="ph2">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> метод возвращает пустой массив.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>This example shows the output of the <ph id="ph1">&lt;xref:System.Type.GetConstructors&gt;</ph> overload from a class that has two instance constructors and one static constructor.</source>
          <target state="translated">В этом примере показан результат выполнения <ph id="ph1">&lt;xref:System.Type.GetConstructors&gt;</ph> перегрузки из класса, который имеет два конструктора экземпляра и один статический конструктор.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>The output of this code is:</source>
          <target state="translated">Результат выполнения этого кода является:</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Because the <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> overload uses only <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance&gt;</ph>, the static constructor is neither counted by the <ph id="ph4">`for`</ph> expression nor evaluated by <ph id="ph5">`IsStatic`</ph>.</source>
          <target state="translated">Поскольку <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> перегрузка использует только <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public&gt;</ph> и <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance&gt;</ph>, статический конструктор не подсчитывается <ph id="ph4">`for`</ph> выражения и не вычисляется <ph id="ph5">`IsStatic`</ph>.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>To find static constructors, use the <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> overload, and pass it the combination (logical OR) of <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, as shown in the following code example:</source>
          <target state="translated">Чтобы найти статические конструкторы, используйте <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> перегружать и передать его сочетание (логическое или) <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, как показано в следующем примере кода:</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Now the output is:</source>
          <target state="translated">Теперь выводится следующий результат:</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>True</source>
          <target state="translated">Да</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.Type.GetDefaultMembers">
          <source>Searches for the members defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> whose <ph id="ph2">&lt;see cref="T:System.Reflection.DefaultMemberAttribute" /&gt;</ph> is set.</source>
          <target state="translated">Выполняет поиск членов, определенных для текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, для которого задан атрибут <ph id="ph2">&lt;see cref="T:System.Reflection.DefaultMemberAttribute" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Type.GetDefaultMembers">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing all default members of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, представляющий все члены по умолчанию текущего объекта <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Type.GetDefaultMembers">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Type.GetDefaultMembers">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have default members.</source>
          <target state="translated">Пустой массив типа <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, если у текущего типа <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> нет членов по умолчанию.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph> Метод не возвращает элементы в определенном порядке, например алфавитном или в порядке объявления.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">Код не должен зависеть от порядка, в котором возвращаются члены, так как этот порядок меняется.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Этот метод может быть переопределен в производном классе.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">Элементы включают свойства, методы, поля, события и т. д.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">В следующей таблице показаны, какие члены базового класса возвращаются <ph id="ph1">`Get`</ph> методов при отражении в типе.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Member Type</source>
          <target state="translated">Тип члена</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Non-Static</source>
          <target state="translated">Нестатический</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Constructor</source>
          <target state="translated">Конструктор</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Field</source>
          <target state="translated">Поле</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Поле всегда равно по имени и подписи.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Event</source>
          <target state="translated">событие</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Method</source>
          <target state="translated">Метод</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Nested Type</source>
          <target state="translated">Вложенный тип</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Property</source>
          <target state="translated">Свойство.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>This is a binary comparison.</source>
          <target state="translated">Это двоичное сравнение.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Для отражения свойства и события, которые по имени и подписи.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Пользовательские атрибуты не являются частью системы общих типов.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> объекты с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>For example, if class <ph id="ph1">`C&lt;T&gt;`</ph> has a property <ph id="ph2">`P`</ph> that returns <ph id="ph3">`T`</ph>, calling <ph id="ph4">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph> on <ph id="ph5">`C&lt;int&gt;`</ph> returns <ph id="ph6">`int P`</ph> in C# (<ph id="ph7">`Property P As Integer`</ph> in Visual Basic).</source>
          <target state="translated">Например если класс <ph id="ph1">`C&lt;T&gt;`</ph> имеет свойство <ph id="ph2">`P`</ph> , возвращающий <ph id="ph3">`T`</ph>, вызов <ph id="ph4">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph> на <ph id="ph5">`C&lt;int&gt;`</ph> возвращает <ph id="ph6">`int P`</ph> в C# (<ph id="ph7">`Property P As Integer`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или члены <ph id="ph2">&lt;xref:System.Object&gt;</ph> при наличии без ограничения класса.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The following example obtains the default member information of <ph id="ph1">`MyClass`</ph> and displays the default members.</source>
          <target state="translated">В следующем примере извлекается информация об элементе по умолчанию из <ph id="ph1">`MyClass`</ph> и отображает элементы по умолчанию.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Type.GetElementType">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the object encompassed or referred to by the current array, pointer or reference type.</source>
          <target state="translated">При переопределении в производном классе возвращает тип <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> объекта, на который ссылается данный массив, указатель или ссылка или который инкапсулирован в этих объектах.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.Type.GetElementType">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the object encompassed or referred to by the current array, pointer, or reference type, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.</source>
          <target state="translated">Тип объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, на который ссылается данный массив, указатель или ссылка или который инкапсулирован в этих объектах, или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если текущий объект <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> не является массивом или указателем, не передается по ссылке либо представляет универсальный тип или параметр типа в определении универсального типа или метода.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetElementType">
          <source>This method returns <ph id="ph1">`null`</ph> for the <ph id="ph2">&lt;xref:System.Array&gt;</ph> class.</source>
          <target state="translated">Этот метод возвращает <ph id="ph1">`null`</ph> для <ph id="ph2">&lt;xref:System.Array&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetElementType">
          <source>The following example demonstrates using the <ph id="ph1">`GetElementType`</ph> method.</source>
          <target state="translated">В следующем примере показано использование <ph id="ph1">`GetElementType`</ph> метода.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>The value whose name is to be retrieved.</source>
          <target state="translated">Значение, имя которой требуется извлечь.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>Returns the name of the constant that has the specified value, for the current enumeration type.</source>
          <target state="translated">Возвращает имя константы с заданным значением для текущего типа перечисления.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>The name of the member of the current enumeration type that has the specified value, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no such constant is found.</source>
          <target state="translated">Имя члена текущего типа перечисления, имеющего указанное значение, или <ph id="ph1">&lt;see langword="null" /&gt;</ph>, если такая константа не найдена.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>The current type is not an enumeration.</source>
          <target state="translated">Текущий тип не является перечислением.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is neither of the current type nor does it have the same underlying type as the current type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> не принадлежит к текущему типу и не имеет тот же базовый тип, что и текущий тип.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumNames">
          <source>Returns the names of the members of the current enumeration type.</source>
          <target state="translated">Возвращает имена членов текущего типа перечисления.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumNames">
          <source>An array that contains the names of the members of the enumeration.</source>
          <target state="translated">Массив, который содержит имена членов перечисления.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEnumNames">
          <source>The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants.</source>
          <target state="translated">Элементы массива, возвращаемого значения сортируются по двоичным значениям (то есть значениям без знака) констант перечисления.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEnumNames">
          <source>If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.</source>
          <target state="translated">Если массив содержит перечислимые константы с тем же значением, порядок соответствующих им имен не определен.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumNames">
          <source>The current type is not an enumeration.</source>
          <target state="translated">Текущий тип не является перечислением.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>Returns the underlying type of the current enumeration type.</source>
          <target state="translated">Возвращает базовый тип текущего типа перечисления.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>The underlying type of the current enumeration.</source>
          <target state="translated">Базовый тип текущего перечисления.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEnumUnderlyingType">
          <source>By default, the underlying type of an enumeration in C# and Visual Basic is <ph id="ph1">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">По умолчанию является базовым типом перечисления в C# и Visual Basic <ph id="ph1">&lt;xref:System.Int32&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEnumUnderlyingType">
          <source>Other integer types can be specified.</source>
          <target state="translated">Можно указать другие целочисленные типы.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>The current type is not an enumeration.</source>
          <target state="translated">Текущий тип не является перечислением.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>The enumeration type is not valid, because it contains more than one instance field.</source>
          <target state="translated">Тип перечисления не является допустимым, так как содержит более одного поля экземпляра.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumValues">
          <source>Returns an array of the values of the constants in the current enumeration type.</source>
          <target state="translated">Возвращает массив значений констант в текущем типе перечисления.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumValues">
          <source>An array that contains the values.</source>
          <target state="translated">Массив, содержащий значения.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumValues">
          <source>The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.</source>
          <target state="translated">Элементы массива сортируются по двоичным значениям (то есть значениям без знака) констант перечисления.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumValues">
          <source>The current type is not an enumeration.</source>
          <target state="translated">Текущий тип не является перечислением.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific event declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает определенное событие, которое объявлено или унаследовано в текущем объекте <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String)">
          <source>The string containing the name of an event that is declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Строка, содержащая имя события, которое объявлено или унаследовано текущим типом <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String)">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> object representing the specified public event.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>, представляющий указанное открытое событие.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String)">
          <source>The object representing the specified public event that is declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект, представляющий указанное открытое событие, которое объявлено или унаследовано в текущем объекте <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, если такое событие найдено; в противном случае — <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
          <target state="translated">Событие считается открытым для отражения, если у него есть хотя бы один метод или метод доступа, который является общим.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">В противном случае считается закрытым события, и необходимо использовать <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (в Visual Basic, объединять значения с использованием <ph id="ph4">`Or`</ph>) для его получения.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Поиск <ph id="ph1">`name`</ph> учитывается регистр.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The search includes public static and public instance events.</source>
          <target state="translated">Поиск включает в себя открытый статический и открытый экземпляр события.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">В следующей таблице показаны, какие члены базового класса возвращаются <ph id="ph1">`Get`</ph> методов при отражении в типе.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Member Type</source>
          <target state="translated">Тип члена</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Non-Static</source>
          <target state="translated">Нестатический</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Constructor</source>
          <target state="translated">Конструктор</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Field</source>
          <target state="translated">Поле</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Поле всегда равно по имени и подписи.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Event</source>
          <target state="translated">событие</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Method</source>
          <target state="translated">Метод</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Nested Type</source>
          <target state="translated">Вложенный тип</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Property</source>
          <target state="translated">Свойство.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>This is a binary comparison.</source>
          <target state="translated">Это двоичное сравнение.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Для отражения свойства и события, которые по имени и подписи.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Пользовательские атрибуты не являются частью системы общих типов.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод ищет события ограничения класса.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The following example creates an <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> object and gets the event for a button class for the specified event.</source>
          <target state="translated">В следующем примере создается <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> объекта и возвращает событие класса button для указанного события.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of an event which is declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Строка, содержащая имя события, которое объявлено или унаследовано текущим типом <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Нуль, чтобы было возвращено значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> object representing the specified event, using the specified binding constraints.</source>
          <target state="translated">При переопределении в производном классе возвращает объект <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>, представляющий указанное событие, используя для этого указанные ограничения привязки.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The object representing the specified event that is declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект, представляющий указанное событие, которое объявлено или унаследовано текущим типом <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, если такое событие найдено; <ph id="ph2">&lt;see langword="null" /&gt;</ph> в противном случае.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which events to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги фильтра можно использовать для определения, какие события необходимо включить в поиск:</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Необходимо указать либо <ph id="ph1">`BindingFlags.Instance`</ph> или <ph id="ph2">`BindingFlags.Static`</ph> для получения возврата.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public events in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Public`</ph> для включения в поиск открытые события.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public events (that is, private, internal, and protected events) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.NonPublic`</ph> для включения в поиск события не являющиеся открытыми (то есть, закрытые, внутренние и защищенные события).</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> для включения <ph id="ph2">`public`</ph> и <ph id="ph3">`protected`</ph> статические члены вверх по иерархии; <ph id="ph4">`private`</ph> статические члены в наследуемых классах не включаются.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> модификатор флаги можно использовать для изменения условий поиска:</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> Чтобы игнорировать регистр <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the events declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not events that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> для поиска только события, объявленные на <ph id="ph2">&lt;xref:System.Type&gt;</ph>, не события унаследованные.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
          <target state="translated">Событие считается открытым для отражения, если у него есть хотя бы один метод или метод доступа, который является общим.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">В противном случае считается закрытым события, и необходимо использовать <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (в Visual Basic, объединять значения с использованием <ph id="ph4">`Or`</ph>) для его получения.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод ищет события ограничения класса.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> method to search a type for a public or non-public event named "Click" that is not <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</source>
          <target state="translated">Следующий пример кода использует <ph id="ph1">&lt;xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> метод для поиска типа открытый или неоткрытый события с именем «Щелкните», не <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the events that are declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает события, которые объявлены или унаследованы текущим объектом <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents">
          <source>Returns all the public events that are declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает все открытые события, которые объявлены или унаследованы текущим объектом <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing all the public events which are declared or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>, представляющий все открытые события, которые объявлены или унаследованы текущим объектом <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have public events.</source>
          <target state="translated">Пустой массив типа <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>, если в текущем объекте <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> нет открытых событий.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
          <target state="translated">Событие считается открытым для отражения, если у него есть хотя бы один метод или метод доступа, который является общим.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">В противном случае считается закрытым события, и необходимо использовать <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (в Visual Basic, объединять значения с использованием <ph id="ph4">`Or`</ph>) для его получения.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetEvents%2A&gt;</ph> method does not return events in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetEvents%2A&gt;</ph> Метод не возвращает события в определенном порядке, например алфавитном или в порядке объявления.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Your code must not depend on the order in which events are returned, because that order varies.</source>
          <target state="translated">Код не должен зависеть от порядка, в котором возвращаются события, так как этот порядок меняется.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Этот метод может быть переопределен в производном классе.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">В следующей таблице показаны, какие члены базового класса возвращаются <ph id="ph1">`Get`</ph> методов при отражении в типе.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Member Type</source>
          <target state="translated">Тип члена</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Non-Static</source>
          <target state="translated">Нестатический</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Constructor</source>
          <target state="translated">Конструктор</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Field</source>
          <target state="translated">Поле</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Поле всегда равно по имени и подписи.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Event</source>
          <target state="translated">событие</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Method</source>
          <target state="translated">Метод</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Nested Type</source>
          <target state="translated">Вложенный тип</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Property</source>
          <target state="translated">Свойство.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>This is a binary comparison.</source>
          <target state="translated">Это двоичное сравнение.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Для отражения свойства и события, которые по имени и подписи.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Пользовательские атрибуты не являются частью системы общих типов.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> объекты с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод ищет события ограничения класса.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The following example obtains an array of <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects, gets all the events for a <ph id="ph2">`Button`</ph> class, and displays the event names.</source>
          <target state="translated">В следующем примере извлекается массив <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> объектов, возвращает все события для <ph id="ph2">`Button`</ph> класса и отображаются имена событий.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>To compile the Visual Basic example, use the following command line:</source>
          <target state="translated">Чтобы скомпилировать этот пример Visual Basic, используйте следующую командную строку:</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Нуль, чтобы было возвращено значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for events that are declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">При переопределении в производном классе ищет события, которые объявлены или унаследованы текущим объектом <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, используя указанные ограничения привязки.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing all events that are declared or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>, представляющий все события, которые объявлены или унаследованы данным объектом <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> и удовлетворяют указанным ограничениям привязки.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have events, or if none of the events match the binding constraints.</source>
          <target state="translated">Пустой массив типа <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>, если у текущего типа <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> нет событий или ни одно событие не удовлетворяет ограничениям привязки.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetEvents%2A&gt;</ph> method does not return events in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetEvents%2A&gt;</ph> Метод не возвращает события в определенном порядке, например алфавитном или в порядке объявления.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which events are returned, because that order varies.</source>
          <target state="translated">Код не должен зависеть от порядка, в котором возвращаются события, так как этот порядок меняется.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which events to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги фильтра можно использовать для определения, какие события необходимо включить в поиск:</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Необходимо указать либо <ph id="ph1">`BindingFlags.Instance`</ph> или <ph id="ph2">`BindingFlags.Static`</ph> для получения возврата.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public events in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Public`</ph> для включения в поиск открытые события.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public events (that is, private, internal, and protected events) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.NonPublic`</ph> для включения в поиск события не являющиеся открытыми (то есть, закрытые, внутренние и защищенные события).</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Only protected and internal events on base classes are returned; private events on base classes are not returned.</source>
          <target state="translated">Только защищенные и внутренние события базовых классов, возвращаются; Закрытые события базовых классов не возвращаются.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> для включения <ph id="ph2">`public`</ph> и <ph id="ph3">`protected`</ph> статические члены вверх по иерархии; <ph id="ph4">`private`</ph> статические члены в наследуемых классах не включаются.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> модификатор флаги можно использовать для изменения условий поиска:</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the events declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not events that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> для поиска только события, объявленные на <ph id="ph2">&lt;xref:System.Type&gt;</ph>, не события унаследованные.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
          <target state="translated">Событие считается открытым для отражения, если у него есть хотя бы один метод или метод доступа, который является общим.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">В противном случае считается закрытым события, и необходимо использовать <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (в Visual Basic, объединять значения с использованием <ph id="ph4">`Or`</ph>) для его получения.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> объекты с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод ищет события ограничения класса.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>The following example obtains an array of <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects that match the specified binding flags, gets all the events for a <ph id="ph2">`Button`</ph> class, and displays the event names.</source>
          <target state="translated">В следующем примере извлекается массив <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> объектов, соответствующих указанным флагам привязки, возвращаются все события <ph id="ph2">`Button`</ph> класса и отображаются имена событий.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>To compile the Visual Basic example, use the following command line:</source>
          <target state="translated">Чтобы скомпилировать этот пример Visual Basic, используйте следующую командную строку:</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific field of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает указанное поле текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source>The string containing the name of the data field to get.</source>
          <target state="translated">Строка, содержащая имя искомого поля данных.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source>Searches for the public field with the specified name.</source>
          <target state="translated">Выполняет поиск открытого поля с заданным именем.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source>An object representing the public field with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект, представляющий открытое поле с указанным именем, если такое свойство есть, или <ph id="ph1">&lt;see langword="null" /&gt;</ph>, если такого свойства нет.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Поиск <ph id="ph1">`name`</ph> учитывается регистр.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>The search includes public static and public instance fields.</source>
          <target state="translated">При поиске учитываются открытые статические и открытые поля экземпляра.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод ищет поля ограничения класса.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>The following example gets the <ph id="ph1">`Type`</ph> object for the specified class, obtains the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object for the field, and displays the value of the field.</source>
          <target state="translated">В следующем примере извлекается <ph id="ph1">`Type`</ph> объекта для заданного класса, получает <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> объекта в поле и выводится значение поля.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source>This <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object is a <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> whose <ph id="ph3">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method has not yet been called.</source>
          <target state="translated">Этот объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> является объектом <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>, чей метод <ph id="ph3">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> еще не вызывался.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the data field to get.</source>
          <target state="translated">Строка, содержащая имя искомого поля данных.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Нуль, чтобы было возвращено значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Searches for the specified field, using the specified binding constraints.</source>
          <target state="translated">Выполняет поиск указанного поля, используя заданные ограничения привязки.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>An object representing the field that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект, предоставляющий поле, которое соответствует указанным требованиям, если такое свойство найдено; в противном случае возвращается <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">В следующей таблице показаны, какие члены базового класса возвращаются <ph id="ph1">`Get`</ph> методов при отражении в типе.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Member Type</source>
          <target state="translated">Тип члена</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Non-Static</source>
          <target state="translated">Нестатический</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Constructor</source>
          <target state="translated">Конструктор</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Field</source>
          <target state="translated">Поле</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Поле всегда равно по имени и подписи.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Event</source>
          <target state="translated">событие</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Method</source>
          <target state="translated">Метод</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Nested Type</source>
          <target state="translated">Вложенный тип</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Property</source>
          <target state="translated">Свойство.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>This is a binary comparison.</source>
          <target state="translated">Это двоичное сравнение.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Для отражения свойства и события, которые по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Пользовательские атрибуты не являются частью системы общих типов.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which fields to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги фильтра можно использовать для определения полей, включаемых в поиск:</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Необходимо указать либо <ph id="ph1">`BindingFlags.Instance`</ph> или <ph id="ph2">`BindingFlags.Static`</ph> для получения возврата.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public fields in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Public`</ph> для включения в поиск открытые поля.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public fields (that is, private, internal, and protected fields) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.NonPublic`</ph> для включения в поиск неоткрытые поля (то есть, закрытые, внутренние и защищенные).</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> для включения <ph id="ph2">`public`</ph> и <ph id="ph3">`protected`</ph> статические члены вверх по иерархии; <ph id="ph4">`private`</ph> статические члены в наследуемых классах не включаются.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> модификатор флаги можно использовать для изменения условий поиска:</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> Чтобы игнорировать регистр <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the fields declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not fields that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> для поиска только поля, объявленные в <ph id="ph2">&lt;xref:System.Type&gt;</ph>, не поля унаследованные.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод ищет поля ограничения класса.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The following example gets the <ph id="ph1">`Type`</ph> object for the specified class, obtains the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object for the field that matches the specified binding flags, and displays the value of the field.</source>
          <target state="translated">В следующем примере извлекается <ph id="ph1">`Type`</ph> объекта для заданного класса, получает <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> объекта для поля, которое соответствует указанным флагам привязки и отображает значение поля.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the fields of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает поля текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields">
          <source>Returns all the public fields of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает все открытые поля текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects representing all the public fields defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, представляющий все открытые поля, определенные для текущего объекта <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, if no public fields are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Пустой массив типа <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, если для текущего типа <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> открытые поля не определены.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetFields%2A&gt;</ph> Метод не возвращает поля в определенном порядке, например алфавитном или в порядке объявления.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Your code must not depend on the order in which fields are returned, because that order varies.</source>
          <target state="translated">Код не должен зависеть от порядка, в котором возвращаются поля, так как этот порядок меняется.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">В следующей таблице показаны, какие члены базового класса возвращаются <ph id="ph1">`Get`</ph> методов при отражении в типе.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Member Type</source>
          <target state="translated">Тип члена</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Non-Static</source>
          <target state="translated">Нестатический</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Constructor</source>
          <target state="translated">Конструктор</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Field</source>
          <target state="translated">Поле</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Поле всегда равно по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Event</source>
          <target state="translated">событие</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Method</source>
          <target state="translated">Метод</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Nested Type</source>
          <target state="translated">Вложенный тип</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Property</source>
          <target state="translated">Свойство.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>This is a binary comparison.</source>
          <target state="translated">Это двоичное сравнение.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Для отражения свойства и события, которые по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Пользовательские атрибуты не являются частью системы общих типов.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> объекты с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод выполняет поиск открытого поля ограничения класса.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The following example shows a use of the <ph id="ph1">`GetFields()`</ph> method.</source>
          <target state="translated">В следующем примере показано использование <ph id="ph1">`GetFields()`</ph> метода.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Нуль, чтобы было возвращено значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the fields defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">При переопределении в производном классе ищет поля, определенные для текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, используя указанные ограничения привязки.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects representing all fields defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, представляющий все поля, определенные для текущего типа <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> и удовлетворяющие указанным ограничениям привязки.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, if no fields are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or if none of the defined fields match the binding constraints.</source>
          <target state="translated">Пустой массив типа <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, если для текущего объекта <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> не определены поля или ни одно из определенных полей не удовлетворяет ограничениям привязки.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetFields%2A&gt;</ph> Метод не возвращает поля в определенном порядке, например алфавитном или в порядке объявления.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which fields are returned, because that order varies.</source>
          <target state="translated">Код не должен зависеть от порядка, в котором возвращаются поля, так как этот порядок меняется.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which fields to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги фильтра можно использовать для определения полей, включаемых в поиск:</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Необходимо указать либо <ph id="ph1">`BindingFlags.Instance`</ph> или <ph id="ph2">`BindingFlags.Static`</ph> для получения возврата.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public fields in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Public`</ph> для включения в поиск открытые поля.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public fields (that is, private, internal, and protected fields) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.NonPublic`</ph> для включения в поиск неоткрытые поля (то есть, закрытые, внутренние и защищенные).</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Only protected and internal fields on base classes are returned; private fields on base classes are not returned.</source>
          <target state="translated">Только защищенные и внутренние поля базовых классов, возвращаются; закрытые поля базовых классов не возвращаются.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> для включения <ph id="ph2">`public`</ph> и <ph id="ph3">`protected`</ph> статические члены вверх по иерархии; <ph id="ph4">`private`</ph> статические члены в наследуемых классах не включаются.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> модификатор флаги можно использовать для изменения условий поиска:</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the fields declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not fields that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> для поиска только поля, объявленные в <ph id="ph2">&lt;xref:System.Type&gt;</ph>, не поля унаследованные.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> объекты с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод выполняет поиск открытого поля ограничения класса.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>The following example shows a use of the <ph id="ph1">`GetFields(BindingFlags)`</ph> method.</source>
          <target state="translated">В следующем примере показано использование <ph id="ph1">`GetFields(BindingFlags)`</ph> метода.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.</source>
          <target state="translated">Возвращает массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, которые представляют аргументы закрытого универсального типа или параметры определения универсального типа.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a generic type.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, которые представляют аргументы универсального типа.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>Returns an empty array if the current type is not a generic type.</source>
          <target state="translated">Возвращает пустой массив, если текущий тип не является универсальным.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>The array elements are returned in the order in which they appear in the list of type arguments for the generic type.</source>
          <target state="translated">Элементы массива возвращаются в порядке, в котором они отображаются в списке аргументов типа для универсального типа.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>If the current type is a closed constructed type (that is, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>), the array returned by the <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method contains the types that have been assigned to the generic type parameters of the generic type definition.</source>
          <target state="translated">Если текущий тип является закрытым сконструированным типом (то есть <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> возвращает <ph id="ph2">`false`</ph>), массив, возвращаемый методом <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> метод содержит типы, которые были назначены параметры универсального типа в определении универсального типа .</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>If the current type is a generic type definition, the array contains the type parameters.</source>
          <target state="translated">Если текущий тип является определением универсального типа, массив содержит параметры типа.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>If the current type is an open constructed type (that is, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters.</source>
          <target state="translated">Если текущий тип является открытым сконструированным типом (то есть <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> возвращает <ph id="ph2">`true`</ph>) в определенные типы не были назначены все параметры типа и параметров типа включающего универсального типа или метода, содержит массив типы и параметры типа.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell them apart.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> свойство, чтобы отличить друг от друга.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>For a demonstration of this scenario, see the code example for the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property.</source>
          <target state="translated">Для демонстрации этого сценария, см. пример кода для <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method to display the type arguments of a constructed type and the type parameters of its generic type definition.</source>
          <target state="translated">Следующий пример кода использует <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> метод для отображения аргументов типа сконструированного типа и параметров типа определения универсального типа.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property.</source>
          <target state="translated">Данный пример кода является частью большего примера, приведенного для <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>See the larger example for sample output.</source>
          <target state="translated">Далее приведен пример большего пример выходных данных.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">Вызванный метод не поддерживается в базовом классе.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">Реализацию должны обеспечивать производные классы.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericParameterConstraints">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the constraints on the current generic type parameter.</source>
          <target state="translated">Возвращает массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, которые представляют ограничения, накладываемые на параметр текущего универсального типа.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericParameterConstraints">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the constraints on the current generic type parameter.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, которые представляют ограничения, накладываемые на параметр текущего универсального типа.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>Each constraint on a generic type parameter is expressed as a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object.</source>
          <target state="translated">Каждое ограничение на параметр универсального типа выражается как <ph id="ph1">&lt;xref:System.Type&gt;</ph> объект.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsClass%2A&gt;</ph> property to determine whether a constraint is the base class constraint; if the property returns <ph id="ph2">`false`</ph>, the constraint is an interface constraint.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Type.IsClass%2A&gt;</ph> свойства, чтобы определить, является ли ограничение ограничению базового класса; Если свойство возвращает <ph id="ph2">`false`</ph>, это ограничение является ограничением интерфейса.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>If a type parameter has no class constraint and no interface constraints, an empty array is returned.</source>
          <target state="translated">Если параметр типа без ограничения класса и интерфейса, возвращается пустой массив.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>The following code example defines a generic type <ph id="ph1">`Test`</ph> with two type parameters that have different constraints.</source>
          <target state="translated">В следующем примере кода определяется универсальный тип <ph id="ph1">`Test`</ph> с двумя параметрами типов, которые имеют различные ограничения.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>When the program executes, the constraints are examined using the <ph id="ph1">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph> method.</source>
          <target state="translated">При выполнении программы ограничения проверяются с помощью <ph id="ph1">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph> свойство и <ph id="ph2">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericParameterConstraints">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object is not a generic type parameter.</source>
          <target state="translated">Текущий объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> не является параметром универсального типа.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericParameterConstraints">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">То есть свойство <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> возвращает значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a generic type definition from which the current generic type can be constructed.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий определение универсального типа, на основе которого можно сконструировать текущий универсальный тип.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a generic type from which the current type can be constructed.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий универсальный тип, на основе которого можно сконструировать текущий тип.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>A generic type definition is a template from which other types can be constructed.</source>
          <target state="translated">Определение универсального типа — это шаблон, из которого можно сконструировать другие типы.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>For example, from the generic type definition <ph id="ph1">`G&lt;T&gt;`</ph> (expressed in C# syntax; <ph id="ph2">`G(Of T)`</ph> in Visual Basic or <ph id="ph3">`generic &lt;typename T&gt; ref class G`</ph> in C++) you can construct and instantiate the type <ph id="ph4">`G&lt;int&gt;`</ph> (<ph id="ph5">`G(Of Integer)`</ph> in Visual Basic).</source>
          <target state="translated">Например, в определении универсального типа <ph id="ph1">`G&lt;T&gt;`</ph> (выраженная в синтаксис C#; <ph id="ph2">`G(Of T)`</ph> в Visual Basic или <ph id="ph3">`generic &lt;typename T&gt; ref class G`</ph> в C++) можно создать и создать экземпляр типа <ph id="ph4">`G&lt;int&gt;`</ph> (<ph id="ph5">`G(Of Integer)`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>Given a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing this constructed type, the <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method returns the generic type definition.</source>
          <target state="translated">Получает <ph id="ph1">&lt;xref:System.Type&gt;</ph> объект, представляющий это сконструированный тип, <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> метод возвращает определение универсального типа.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>If two constructed types are created from the same generic type definition, using the same type arguments, the <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method returns the same <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for both types.</source>
          <target state="translated">Если два сконструированные типы создаются из одного определения универсального типа, используя те же аргументы типа <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> метод возвращает тот же <ph id="ph2">&lt;xref:System.Type&gt;</ph> объекта для обоих типов.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>If you call the <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that already represents a generic type definition, it returns the current <ph id="ph3">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">При вызове метода <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> метод <ph id="ph2">&lt;xref:System.Type&gt;</ph> объект, который уже представляет определение универсального типа, возвращается текущий <ph id="ph3">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>An array of generic types is not itself generic.</source>
          <target state="translated">Массив универсальных типов не сам является универсальным.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>In the C# code <ph id="ph1">`A&lt;int&gt;[] v;`</ph> or the Visual Basic code <ph id="ph2">`Dim v() As A(Of Integer)`</ph>, the type of variable <ph id="ph3">`v`</ph> is not generic.</source>
          <target state="translated">В коде C# <ph id="ph1">`A&lt;int&gt;[] v;`</ph> или Visual Basic <ph id="ph2">`Dim v() As A(Of Integer)`</ph>, тип переменной <ph id="ph3">`v`</ph> не является универсальным.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>Use <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> to determine whether a type is generic before calling <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> для определения, является ли тип универсальным перед вызовом <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>The following code example creates an instance of a constructed type by using ordinary instance creation and then uses the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> methods to retrieve the constructed type and the generic type definition.</source>
          <target state="translated">В следующем примере кода создается экземпляр сконструированного типа с помощью обычного создания экземпляра, а затем использует <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> методы для получения сконструированного типа и определения универсального типа.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>This example uses the generic <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> type; the constructed type represents a <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph3">`Test`</ph> objects with string keys.</source>
          <target state="translated">В этом примере используется универсальный <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> тип, представляющий сконструированный тип <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> из <ph id="ph3">`Test`</ph> объектов, содержащих строковые ключи.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>The current type is not a generic type.</source>
          <target state="translated">Текущий тип не является универсальным.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsGenericType" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">То есть <ph id="ph1">&lt;see cref="P:System.Type.IsGenericType" /&gt;</ph> возвращает <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">Вызванный метод не поддерживается в базовом классе.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">Реализацию должны обеспечивать производные классы.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="M:System.Type.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Возвращает хэш-код данного экземпляра.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" uid="M:System.Type.GetHashCode">
          <source>The hash code for this instance.</source>
          <target state="translated">Хэш-код данного экземпляра.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetHashCode">
          <source>This method overrides <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Этот метод переопределяет метод <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetHashCode">
          <source>The following example displays the hash code of the <ph id="ph1">`System.Windows.Forms.Button`</ph> class.</source>
          <target state="translated">В следующем примере отображается хэш-код <ph id="ph1">`System.Windows.Forms.Button`</ph> класса.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific interface implemented or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает определенный интерфейс, реализуемый или наследуемый текущим объектом <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>The string containing the name of the interface to get.</source>
          <target state="translated">Строка, содержащая имя искомого интерфейса.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>For generic interfaces, this is the mangled name.</source>
          <target state="translated">Для универсальных интерфейсов это искаженное имя.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>Searches for the interface with the specified name.</source>
          <target state="translated">Выполняет поиск интерфейса с заданным именем.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>An object representing the interface with the specified name, implemented or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект, представляющий интерфейс с заданным именем, который реализуется или наследуется текущим объектом <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, если такой интерфейс существует; в противном случае — значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Поиск <ph id="ph1">`name`</ph> учитывается регистр.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Type&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Type&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет ограничения интерфейса, а также все интерфейсы, унаследованные от класса или интерфейса ограничений.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>For generic interfaces, the <ph id="ph1">`name`</ph> parameter is the mangled name, ending with a grave accent (<ph id="ph2">\`</ph>) and the number of type parameters.</source>
          <target state="translated">Для универсальных интерфейсов <ph id="ph1">`name`</ph> параметр является искаженное имя, заканчивающееся грависом (<ph id="ph2">\`</ph>) и число параметров типа.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>This is true for both generic interface definitions and constructed generic interfaces.</source>
          <target state="translated">Это верно для определений универсального интерфейса и сконструированных универсальных интерфейсов.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>For example, to find <ph id="ph1">`IExample&lt;T&gt;`</ph> (<ph id="ph2">`IExample(Of T)`</ph> in Visual Basic) or <ph id="ph3">`IExample&lt;string&gt;`</ph> (<ph id="ph4">`IExample(Of String)`</ph> in Visual Basic), search for <ph id="ph5">``"IExample`1"``</ph>.</source>
          <target state="translated">Например, чтобы найти <ph id="ph1">`IExample&lt;T&gt;`</ph> (<ph id="ph2">`IExample(Of T)`</ph> в Visual Basic) или <ph id="ph3">`IExample&lt;string&gt;`</ph> (<ph id="ph4">`IExample(Of String)`</ph> в Visual Basic), поиск <ph id="ph5">``"IExample`1"``</ph>.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%29&gt;</ph> method to search the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> class for the <ph id="ph3">&lt;xref:System.Runtime.Serialization.IDeserializationCallback&gt;</ph> interface, and lists the methods of the interface.</source>
          <target state="translated">Следующий пример кода использует <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%29&gt;</ph> метод для поиска <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> класса для <ph id="ph3">&lt;xref:System.Runtime.Serialization.IDeserializationCallback&gt;</ph> интерфейс и списки методов интерфейса.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>The code example also demonstrates the <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29&gt;</ph> method overload and the <ph id="ph2">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> method.</source>
          <target state="translated">В примере также показано <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29&gt;</ph> перегрузка метода и <ph id="ph2">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a type that implements the same generic interface with different type arguments.</source>
          <target state="translated">Текущий объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> представляет тип, реализующий тот же универсальный интерфейс, но с другими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The string containing the name of the interface to get.</source>
          <target state="translated">Строка, содержащая имя искомого интерфейса.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>For generic interfaces, this is the mangled name.</source>
          <target state="translated">Для универсальных интерфейсов это искаженное имя.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore the case of that part of <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, чтобы игнорировать регистр той части параметра <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept>, в которой задается простое имя интерфейса (регистр в части, соответствующей пространству имен, должен соблюдаться).</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to perform a case-sensitive search for all parts of <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="false" /&gt;</ph> для поиска с учетом регистра всех частей параметра <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.</source>
          <target state="translated">При переопределении в производном классе ищет интерфейс с заданным именем, позволяющий определить, нужно ли выполнять поиск без учета регистра.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>An object representing the interface with the specified name, implemented or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект, представляющий интерфейс с заданным именем, который реализуется или наследуется текущим объектом <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, если такой интерфейс существует; в противном случае — значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The <ph id="ph1">`ignoreCase`</ph> parameter applies only to the simple interface name, not to the namespace.</source>
          <target state="translated"><ph id="ph1">`ignoreCase`</ph> Параметр применяется только к простое имя интерфейса, не к пространству имен.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The portion of <ph id="ph1">`name`</ph> that specifies the namespace must have the correct case, or the interface will not be found.</source>
          <target state="translated">Часть <ph id="ph1">`name`</ph> , задающий пространства имен должны иметь правильный регистр или интерфейс не будет найден.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>For example, the string "System.icomparable" finds the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> interface, but the string "system.icomparable" does not.</source>
          <target state="translated">Например, строка «System.icomparable» находит <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> не поддерживает интерфейс, но строка «system.icomparable».</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Type&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Type&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет ограничения интерфейса, а также все интерфейсы, унаследованные от класса или интерфейса ограничений.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>For generic interfaces, the <ph id="ph1">`name`</ph> parameter is the mangled name, ending with a grave accent (<ph id="ph2">\`</ph>) and the number of type parameters.</source>
          <target state="translated">Для универсальных интерфейсов <ph id="ph1">`name`</ph> параметр является искаженное имя, заканчивающееся грависом (<ph id="ph2">\`</ph>) и число параметров типа.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>This is true for both generic interface definitions and constructed generic interfaces.</source>
          <target state="translated">Это верно для определений универсального интерфейса и сконструированных универсальных интерфейсов.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>For example, to find <ph id="ph1">`IExample&lt;T&gt;`</ph> (<ph id="ph2">`IExample(Of T)`</ph> in Visual Basic) or <ph id="ph3">`IExample&lt;string&gt;`</ph> (<ph id="ph4">`IExample(Of String)`</ph> in Visual Basic), search for <ph id="ph5">`"IExample`</ph>1"`.</source>
          <target state="translated">Например, чтобы найти <ph id="ph1">`IExample&lt;T&gt;`</ph> (<ph id="ph2">`IExample(Of T)`</ph> в Visual Basic) или <ph id="ph3">`IExample&lt;string&gt;`</ph> (<ph id="ph4">`IExample(Of String)`</ph> в Visual Basic), поиск <ph id="ph5">`"IExample`</ph>1"".</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29&gt;</ph> method to perform a case-insensitive search of the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> class for the <ph id="ph3">&lt;xref:System.Collections.IEnumerable&gt;</ph> interface.</source>
          <target state="translated">Следующий пример кода использует <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29&gt;</ph> способ выполнения поиска без учета регистра из <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> класса для <ph id="ph3">&lt;xref:System.Collections.IEnumerable&gt;</ph> интерфейса.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The code example also demonstrates the <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%29&gt;</ph> method overload and the <ph id="ph2">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> method.</source>
          <target state="translated">В примере также показано <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%29&gt;</ph> перегрузка метода и <ph id="ph2">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a type that implements the same generic interface with different type arguments.</source>
          <target state="translated">Текущий объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> представляет тип, реализующий тот же универсальный интерфейс, но с другими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The interface type to retrieve a mapping for.</source>
          <target state="translated">Тип интерфейса, для которого требуется извлечь сопоставление.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>Returns an interface mapping for the specified interface type.</source>
          <target state="translated">Возвращает сопоставление для интерфейса заданного типа.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>An object that represents the interface mapping for <ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph>.</source>
          <target state="translated">Объект, представляющий сопоставление интерфейса для <ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The interface map denotes how an interface is mapped into the actual members on a class that implements that interface.</source>
          <target state="translated">Карта интерфейса указывает сопоставление интерфейса в фактических члены класса, реализующего этот интерфейс.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <ph id="ph2">&lt;xref:System.Reflection.InterfaceMapping&gt;</ph> returned by this method.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, параметры заменяются соответствующими аргументами типа в элементах <ph id="ph2">&lt;xref:System.Reflection.InterfaceMapping&gt;</ph> возвращаемый этим методом.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> method to determine how the <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> interface maps to <ph id="ph3">&lt;xref:System.Globalization.CultureInfo&gt;</ph> methods, and how the <ph id="ph4">&lt;xref:System.IAppDomainSetup&gt;</ph> interface maps to <ph id="ph5">&lt;xref:System.AppDomainSetup&gt;</ph> properties.</source>
          <target state="translated">В следующем примере вызывается <ph id="ph1">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> метод, чтобы определить, как <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> сопоставляется интерфейс <ph id="ph3">&lt;xref:System.Globalization.CultureInfo&gt;</ph> методов и как <ph id="ph4">&lt;xref:System.IAppDomainSetup&gt;</ph> сопоставляется интерфейс <ph id="ph5">&lt;xref:System.AppDomainSetup&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>Note that, because the <ph id="ph1">&lt;xref:System.IAppDomainSetup&gt;</ph> interface defines a set of properties, the returned <ph id="ph2">&lt;xref:System.Reflection.InterfaceMapping&gt;</ph> object includes separate <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects for a property's get and set accessors.</source>
          <target state="translated">Обратите внимание, что, поскольку <ph id="ph1">&lt;xref:System.IAppDomainSetup&gt;</ph> интерфейс определяет набор свойств, возвращенном <ph id="ph2">&lt;xref:System.Reflection.InterfaceMapping&gt;</ph> объект включает в себя отдельные <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объектов для get свойства и методы доступа set.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> is not implemented by the current type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> не реализуется текущим типом.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> parameter does not refer to an interface.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> не ссылается на интерфейс.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> is a generic interface, and the current type is an array type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> является универсальным интерфейсом, а текущий тип является типом массива.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a generic type parameter; that is, <ph id="ph2">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Текущий объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> представляет параметр универсального типа. Это означает, что значение параметра <ph id="ph2">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> равно <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">Вызванный метод не поддерживается в базовом классе.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">Реализацию должны обеспечивать производные классы.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>When overridden in a derived class, gets all the interfaces implemented or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">При переопределении в производном классе возвращает все интерфейсы, реализуемые или наследуемые текущим объектом <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing all the interfaces implemented or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий все интерфейсы, реализуемые или наследуемые текущим типом <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if no interfaces are implemented or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Пустой массив типа <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> в случае отсутствия интерфейсов, реализуемых или наследуемых текущим типом <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> method does not return interfaces in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> Метод не возвращает интерфейсы в определенном порядке, например алфавитном или в порядке объявления.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>Your code must not depend on the order in which interfaces are returned, because that order varies.</source>
          <target state="translated">Код не должен зависеть от порядка, в котором возвращаются интерфейсы, так как этот порядок меняется.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Type&gt;</ph> объекты с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет ограничения интерфейса, а также все интерфейсы, унаследованные от класса или интерфейса ограничений.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>The following example gets the type of the specified class and displays all the interfaces that the type implements or inherits.</source>
          <target state="translated">Следующий пример возвращает тип указанного класса и отображает все интерфейсы, которые тип реализует или наследует.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>To compile the Visual Basic example, use the following compiler commands:</source>
          <target state="translated">Чтобы скомпилировать этот пример Visual Basic, используйте следующие команды компилятора:</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>A static initializer is invoked and throws an exception.</source>
          <target state="translated">Статический инициализатор вызывается и создает исключение.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the specified members of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Получает указанные члены текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String)">
          <source>The string containing the name of the public members to get.</source>
          <target state="translated">Строка, содержащая имя искомых открытых членов.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String)">
          <source>Searches for the public members with the specified name.</source>
          <target state="translated">Выполняет поиск открытого члена с заданным именем.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public members with the specified name, if found; otherwise, an empty array.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, представляющий открытые члены с заданным именем, если такие члены есть, и пустой массив, если таких членов нет.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Поиск <ph id="ph1">`name`</ph> учитывается регистр.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The search includes public static and public instance members.</source>
          <target state="translated">Поиск включает элементы открытый статический и открытый экземпляр.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">Элементы включают свойства, методы, поля, события и т. д.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> Метод не возвращает элементы в определенном порядке, например алфавитном или в порядке объявления.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">Код не должен зависеть от порядка, в котором возвращаются члены, так как этот порядок меняется.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>This method overload will not find class initializers (.cctor).</source>
          <target state="translated">Эта перегрузка метода не найдет инициализаторы класса (CCTOR).</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>To find class initializers, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Чтобы найти инициализаторы класса, используйте перегрузку, которая использует <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>и укажите <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">Можно также получить с помощью инициализатора класса <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">В следующей таблице показаны, какие члены базового класса возвращаются <ph id="ph1">`Get`</ph> методов при отражении в типе.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Member Type</source>
          <target state="translated">Тип члена</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Non-Static</source>
          <target state="translated">Нестатический</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Constructor</source>
          <target state="translated">Конструктор</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Field</source>
          <target state="translated">Поле</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Поле всегда равно по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Event</source>
          <target state="translated">событие</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Method</source>
          <target state="translated">Метод</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Nested Type</source>
          <target state="translated">Вложенный тип</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Property</source>
          <target state="translated">Свойство.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>This is a binary comparison.</source>
          <target state="translated">Это двоичное сравнение.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Для отражения свойства и события, которые по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Пользовательские атрибуты не являются частью системы общих типов.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или члены <ph id="ph2">&lt;xref:System.Object&gt;</ph> при наличии без ограничения класса.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Универсальные методы не включать аргументы типа в <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Например, код C# <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> ищет элемент с именем текст «<ph id="ph2">`MyMethod&lt;int&gt;`</ph>», а не для метода с именем <ph id="ph3">`MyMethod`</ph> , имеет один аргумент универсального типа <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The following example displays all the members of the <ph id="ph1">`String`</ph> class that start with the letter C.</source>
          <target state="translated">В следующем примере отображаются все члены <ph id="ph1">`String`</ph> которых начинаются с буквы C.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the members to get.</source>
          <target state="translated">Строка, содержащая имя для поиска элементов.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return an empty array.</source>
          <target state="translated">Ноль для возвращения пустого массива.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Searches for the specified members, using the specified binding constraints.</source>
          <target state="translated">Выполняет поиск указанных членов, используя заданные ограничения привязки.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public members with the specified name, if found; otherwise, an empty array.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, представляющий открытые члены с заданным именем, если такие члены есть, и пустой массив, если таких членов нет.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Этот метод может быть переопределен в производном классе.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">Элементы включают свойства, методы, поля, события и т. д.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> Метод не возвращает элементы в определенном порядке, например алфавитном или в порядке объявления.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">Код не должен зависеть от порядка, в котором возвращаются члены, так как этот порядок меняется.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги фильтра можно использовать для определения члены, которые нужно включить в поиск:</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Необходимо указать либо <ph id="ph1">`BindingFlags.Instance`</ph> или <ph id="ph2">`BindingFlags.Static`</ph> для получения возврата.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Public`</ph> для включения в поиск открытых членов.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.NonPublic`</ph> для включения в поиск закрытым членам (то есть частных, внутренних и защищенные члены).</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> для включения <ph id="ph2">`public`</ph> и <ph id="ph3">`protected`</ph> статические члены вверх по иерархии; <ph id="ph4">`private`</ph> статические члены в наследуемых классах не включаются.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> модификатор флаги можно использовать для изменения условий поиска:</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> Чтобы игнорировать регистр <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> для поиска только члены, объявленные в <ph id="ph2">&lt;xref:System.Type&gt;</ph>, не унаследованные члены группы.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for <ph id="ph1">`name`</ph>, and <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic) for <ph id="ph7">`bindingAttr`</ph>.</source>
          <target state="translated">Чтобы получить инициализатора класса (CCTOR), с помощью этой перегрузки метода, необходимо указать «.cctor» для <ph id="ph1">`name`</ph>, и <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> в Visual Basic) для <ph id="ph7">`bindingAttr`</ph>.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">Можно также получить с помощью инициализатора класса <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или члены <ph id="ph2">&lt;xref:System.Object&gt;</ph> при наличии без ограничения класса.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Универсальные методы не включать аргументы типа в <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Например, код C# <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> ищет элемент с именем текст «<ph id="ph2">`MyMethod&lt;int&gt;`</ph>», а не для метода с именем <ph id="ph3">`MyMethod`</ph> , имеет один аргумент универсального типа <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The following example displays all the public static members of the <ph id="ph1">`myString`</ph> class that start with the letter C.</source>
          <target state="translated">Следующий пример отображает все открытые статические члены <ph id="ph1">`myString`</ph> которых начинаются с буквы C.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The string containing the name of the members to get.</source>
          <target state="translated">Строка, содержащая имя для поиска элементов.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The value to search for.</source>
          <target state="translated">Значение, которое нужно найти.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Zero, to return an empty array.</source>
          <target state="translated">Ноль для возвращения пустого массива.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Searches for the specified members of the specified member type, using the specified binding constraints.</source>
          <target state="translated">Ищет указанные члены заданного типа, используя установленные ограничения привязки.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public members with the specified name, if found; otherwise, an empty array.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, представляющий открытые члены с заданным именем, если такие члены есть, и пустой массив, если таких членов нет.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">Элементы включают свойства, методы, поля, события и т. д.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> Метод не возвращает элементы в определенном порядке, например алфавитном или в порядке объявления.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">Код не должен зависеть от порядка, в котором возвращаются члены, так как этот порядок меняется.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги фильтра можно использовать для определения члены, которые нужно включить в поиск:</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Необходимо указать либо <ph id="ph1">`BindingFlags.Instance`</ph> или <ph id="ph2">`BindingFlags.Static`</ph> для получения возврата.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Public`</ph> для включения в поиск открытых членов.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.NonPublic`</ph> для включения в поиск закрытым членам (то есть частных, внутренних и защищенные члены).</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> для включения <ph id="ph2">`public`</ph> и <ph id="ph3">`protected`</ph> статические члены вверх по иерархии; <ph id="ph4">`private`</ph> статические члены в наследуемых классах не включаются.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> модификатор флаги можно использовать для изменения условий поиска:</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> Чтобы игнорировать регистр <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> для поиска только члены, объявленные в <ph id="ph2">&lt;xref:System.Type&gt;</ph>, не унаследованные члены группы.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for <ph id="ph1">`name`</ph>, <ph id="ph2">&lt;xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType&gt;</ph> for <ph id="ph3">`type`</ph>, and  <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph7">`Or`</ph><ph id="ph8">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic) for <ph id="ph9">`bindingAttr`</ph>.</source>
          <target state="translated">Чтобы получить инициализатора класса (CCTOR), с помощью этой перегрузки метода, необходимо указать «.cctor» для <ph id="ph1">`name`</ph>, <ph id="ph2">&lt;xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType&gt;</ph> для <ph id="ph3">`type`</ph>, и <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph7">`Or`</ph> <ph id="ph8">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> в Visual Basic) для <ph id="ph9">`bindingAttr`</ph>.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">Можно также получить с помощью инициализатора класса <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или члены <ph id="ph2">&lt;xref:System.Object&gt;</ph> при наличии без ограничения класса.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Универсальные методы не включать аргументы типа в <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Например, код C# <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> ищет элемент с именем текст «<ph id="ph2">`MyMethod&lt;int&gt;`</ph>», а не для метода с именем <ph id="ph3">`MyMethod`</ph> , имеет один аргумент универсального типа <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The following example displays all the methods of the <ph id="ph1">`myString`</ph> class that start with the letter C.</source>
          <target state="translated">В следующем примере отображаются все методы <ph id="ph1">`myString`</ph> которых начинаются с буквы C.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>A derived class must provide an implementation.</source>
          <target state="translated">Реализацию должен обеспечивать производный класс.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the members (properties, methods, fields, events, and so on) of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает члены (свойства, методы, поля, события и т. д.) текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers">
          <source>Returns all the public members of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает все открытые члены текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing all the public members of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, представляющий все открытые члены текущего типа <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have public members.</source>
          <target state="translated">Пустой массив типа <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, если у текущего типа <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> нет открытых членов.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">Элементы включают свойства, методы, поля, события и т. д.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph> Метод не возвращает элементы в определенном порядке, например алфавитном или в порядке объявления.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">Код не должен зависеть от порядка, в котором возвращаются члены, так как этот порядок меняется.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>This method overload calls the <ph id="ph1">&lt;xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29&gt;</ph> method overload, with <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (<ph id="ph5">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph><ph id="ph6">`Or`</ph><ph id="ph7">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph><ph id="ph8">`Or`</ph><ph id="ph9">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Эта перегрузка метода вызывает <ph id="ph1">&lt;xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29&gt;</ph> перегрузка метода с <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (<ph id="ph5">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> <ph id="ph6">`Or`</ph> <ph id="ph7">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> <ph id="ph8">`Or`</ph> <ph id="ph9">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>It will not find class initializers (.cctor).</source>
          <target state="translated">Его не удастся найти инициализаторы класса (.cctor).</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>To find class initializers, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Чтобы найти инициализаторы класса, используйте перегрузку, которая использует <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>и укажите <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">Можно также получить с помощью инициализатора класса <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">В следующей таблице показаны, какие члены базового класса возвращаются <ph id="ph1">`Get`</ph> методов при отражении в типе.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Member Type</source>
          <target state="translated">Тип члена</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Non-Static</source>
          <target state="translated">Нестатический</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Constructor</source>
          <target state="translated">Конструктор</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Field</source>
          <target state="translated">Поле</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Поле всегда равно по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Event</source>
          <target state="translated">событие</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Method</source>
          <target state="translated">Метод</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Nested Type</source>
          <target state="translated">Вложенный тип</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Property</source>
          <target state="translated">Свойство.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>This is a binary comparison.</source>
          <target state="translated">Это двоичное сравнение.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Для отражения свойства и события, которые по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Пользовательские атрибуты не являются частью системы общих типов.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> объекты с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или члены <ph id="ph2">&lt;xref:System.Object&gt;</ph> при наличии без ограничения класса.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.Type.GetMembers&gt;</ph> method overload to collect information about all public members of a specified class.</source>
          <target state="translated">В следующем примере кода демонстрируется использование <ph id="ph1">&lt;xref:System.Type.GetMembers&gt;</ph> перегрузка метода для сбора сведений о все открытые члены указанного класса.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Zero (<ph id="ph1">&lt;see cref="F:System.Reflection.BindingFlags.Default" /&gt;</ph>), to return an empty array.</source>
          <target state="translated">Ноль (<ph id="ph1">&lt;see cref="F:System.Reflection.BindingFlags.Default" /&gt;</ph>) для возвращения пустого массива.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the members defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">При переопределении в производном классе ищет члены, определенные для текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, используя указанные ограничения привязки.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing all members defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, представляющий все члены, определенные для текущего типа <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> и удовлетворяющие указанным ограничениям привязки.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, if no members are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or if none of the defined members match the binding constraints.</source>
          <target state="translated">Пустой массив типа <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, если для текущего объекта <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> не определены члены или ни один из определенных членов не удовлетворяет ограничениям привязки.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">Элементы включают свойства, методы, поля, события и т. д.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph> Метод не возвращает элементы в определенном порядке, например алфавитном или в порядке объявления.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">Код не должен зависеть от порядка, в котором возвращаются члены, так как этот порядок меняется.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги фильтра можно использовать для определения члены, которые нужно включить в поиск:</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Необходимо указать либо <ph id="ph1">`BindingFlags.Instance`</ph> или <ph id="ph2">`BindingFlags.Static`</ph> для получения возврата.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Public`</ph> для включения в поиск открытых членов.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.NonPublic`</ph> для включения в поиск закрытым членам (то есть частных, внутренних и защищенные члены).</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Only protected and internal members on base classes are returned; private members on base classes are not returned.</source>
          <target state="translated">Только защищенные внутренние члены базовых классов возвращаются и; закрытые члены базовых классов не возвращаются.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> для включения <ph id="ph2">`public`</ph> и <ph id="ph3">`protected`</ph> статические члены вверх по иерархии; <ph id="ph4">`private`</ph> статические члены в наследуемых классах не включаются.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> модификатор флаги можно использовать для изменения условий поиска:</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> для поиска только члены, объявленные в <ph id="ph2">&lt;xref:System.Type&gt;</ph>, не унаследованные члены группы.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Calling this method with only the <ph id="ph1">`Public`</ph> flag or only the <ph id="ph2">`NonPublic`</ph> flag will return the specified members and does not require any other flags.</source>
          <target state="translated">Вызов этого метода только с <ph id="ph1">`Public`</ph> флаг или только <ph id="ph2">`NonPublic`</ph> флаг Возвращает указанные члены и дополнительные флаги не требуются.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>To get the class initializer (.cctor) using this method overload, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Чтобы получить инициализатора класса (CCTOR), с помощью этой перегрузки метода, необходимо указать <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">Можно также получить с помощью инициализатора класса <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий объект T:System.Type представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> объекты с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или члены <ph id="ph2">&lt;xref:System.Object&gt;</ph> при наличии без ограничения класса.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29&gt;</ph> method overload to collect information about all public instance members of a specified class.</source>
          <target state="translated">В следующем примере кода демонстрируется использование <ph id="ph1">&lt;xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29&gt;</ph> перегрузка метода для сбора сведений обо всех членах открытого экземпляра указанного класса.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific method of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает заданный метод текущего класса <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source>The string containing the name of the public method to get.</source>
          <target state="translated">Строка, содержащая имя искомого открытого метода.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source>Searches for the public method with the specified name.</source>
          <target state="translated">Выполняет поиск открытого метода с заданным именем.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source>An object that represents the public method with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект, представляющий открытый метод с заданным именем, если такой метод есть, и <ph id="ph1">&lt;see langword="null" /&gt;</ph>, если такого метода нет.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Поиск <ph id="ph1">`name`</ph> учитывается регистр.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>The search includes public static and public instance methods.</source>
          <target state="translated">При поиске учитываются открытые статические и открытые методы экземпляра.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>If a method is overloaded and has more than one public method, the <ph id="ph1">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> exception.</source>
          <target state="translated">Если метод перегружен и имеет несколько открытых методов, <ph id="ph1">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph> вызывает исключение <ph id="ph2">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>In the following example, an exception is thrown because there is more than one public overload of the <ph id="ph1">&lt;xref:System.Int32.ToString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">В следующем примере создается исключение, так как присутствует более одного открытого перегрузка <ph id="ph1">&lt;xref:System.Int32.ToString%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>On the other hand, because the <ph id="ph1">`Person.ToString`</ph> method overrides  <ph id="ph2">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> and therefore is not overloaded, the <ph id="ph3">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph> method is able to retrieve the <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">С другой стороны так как <ph id="ph1">`Person.ToString`</ph> переопределения методов <ph id="ph2">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> и поэтому не перегружен, <ph id="ph3">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph> метод способен получить <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>You can do one of the following to retrieve a specific method:</source>
          <target state="translated">Необходимо выполнить одно из следующих действий, чтобы получить определенный метод:</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> method and specify a <ph id="ph2">`bindingAttr`</ph> argument that uniquely identifies the method.</source>
          <target state="translated">Вызовите <ph id="ph1">&lt;xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> метод и укажите <ph id="ph2">`bindingAttr`</ph> аргумент, который однозначно определяет метод.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  <ph id="ph1">`bindingAttr`</ph> argument  of <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph><ph id="ph3">`Or`</ph><ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Например, если вызывается исключение, поскольку тип имеет статический и экземпляр перегрузку, можно указать <ph id="ph1">`bindingAttr`</ph> аргумент <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> <ph id="ph3">`Or`</ph> <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>Call an overload of the <ph id="ph1">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method that includes a <ph id="ph2">`types`</ph> parameter which defines the types of the method's parameters.</source>
          <target state="translated">Вызовите перегрузку <ph id="ph1">&lt;xref:System.Type.GetMethod%2A&gt;</ph> метод, который включает в себя <ph id="ph2">`types`</ph> параметр, который определяет типы параметров метода.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetMethods&gt;</ph> method to retrieve an array containing all of the public methods belonging to a type.</source>
          <target state="translated">Вызовите <ph id="ph1">&lt;xref:System.Type.GetMethods&gt;</ph> метод, чтобы получить массив, содержащий все открытые методы, принадлежащие типу.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>You can then iterate it to identify the duplicate methods named <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Затем можно последовательно его для идентификации повторяющихся методов, с именем <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий объект T:System.Type представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <ph id="ph2">&lt;xref:System.Object&gt;</ph> при наличии без ограничения класса.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Универсальные методы не включать аргументы типа в <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Например, код C# <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> ищет элемент с именем текст «<ph id="ph2">`MyMethod&lt;int&gt;`</ph>», а не для метода с именем <ph id="ph3">`MyMethod`</ph> , имеет один аргумент универсального типа <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>The following example gets a method named <ph id="ph1">`MethodA`</ph>.</source>
          <target state="translated">В следующем примере извлекается метод с именем <ph id="ph1">`MethodA`</ph>.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source>More than one method is found with the specified name.</source>
          <target state="translated">Найдено несколько методов с указанным именем.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the method to get.</source>
          <target state="translated">Строка, содержащая имя искомого метода.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Нуль, чтобы было возвращено значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Searches for the specified method, using the specified binding constraints.</source>
          <target state="translated">Выполняет поиск указанного метода, используя заданные ограничения привязки.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Если поиск выполнен удачно, возвращается объект, предоставляющий метод, который соответствует указанным требованиям; в противном случае возвращается <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги фильтра можно использовать для определения методов, включаемых в поиск:</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> in order to get a return.</source>
          <target state="translated">Необходимо указать либо <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> для получения возврата.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> to include public methods in the search.</source>
          <target state="translated">Укажите <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> для включения в поиск открытых методов.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to include non-public methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> для включения в поиск неоткрытые методы (то есть, закрытые, внутренние и защищенные методы).</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType&gt;</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Укажите <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType&gt;</ph> для включения <ph id="ph2">`public`</ph> и <ph id="ph3">`protected`</ph> статические члены вверх по иерархии; <ph id="ph4">`private`</ph> статические члены в наследуемых классах не включаются.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> модификатор флаги можно использовать для изменения условий поиска:</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType&gt;</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType&gt;</ph> Чтобы игнорировать регистр <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> для поиска только методы, объявленные на <ph id="ph2">&lt;xref:System.Type&gt;</ph>, не методы, унаследованные.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>If a method is overloaded and more than one overload meets the constraints specified by the <ph id="ph1">`bindingAttr`</ph> argument, the method throws an <ph id="ph2">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> exception.</source>
          <target state="translated">Если метод перегружен, более одного перегруженного метода соответствует ограничениям, указанным по <ph id="ph1">`bindingAttr`</ph> аргумент, метод создает <ph id="ph2">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>In the following example, an exception is thrown because:</source>
          <target state="translated">В следующем примере создается исключение из-за:</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">`TestClass`</ph> type has two public instance overloads of the <ph id="ph2">`DisplayValue`</ph> method, <ph id="ph3">`DisplayValue(String)`</ph> and <ph id="ph4">`DisplayValue(String, Object[])`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestClass`</ph> Тип имеет две перегрузки открытого экземпляра <ph id="ph2">`DisplayValue`</ph> метода <ph id="ph3">`DisplayValue(String)`</ph> и <ph id="ph4">`DisplayValue(String, Object[])`</ph>.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">`TestClass`</ph> type has two public instance overloads of the <ph id="ph2">`Equals`</ph> method,  one of which is inherited from <ph id="ph3">&lt;xref:System.Object&gt;</ph>: <ph id="ph4">`Equals(TestClass)`</ph> and <ph id="ph5">`Equals(Object)`</ph>.</source>
          <target state="translated"><ph id="ph1">`TestClass`</ph> Тип имеет две перегрузки открытого экземпляра <ph id="ph2">`Equals`</ph> метода, один из которых наследуется от <ph id="ph3">&lt;xref:System.Object&gt;</ph>: <ph id="ph4">`Equals(TestClass)`</ph> и <ph id="ph5">`Equals(Object)`</ph>.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>You can do one of the following to retrieve a specific method:</source>
          <target state="translated">Необходимо выполнить одно из следующих действий, чтобы получить определенный метод:</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Change the binding constraints.</source>
          <target state="translated">Измените ограничения привязки.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>In the previous example, attempting to retrieve a public instance <ph id="ph1">`Equals`</ph> method that is declared by the type and not inherited successfully retrieves <ph id="ph2">`Equals(TestClass)`</ph>.</source>
          <target state="translated">В предыдущем примере предпринимается попытка извлечь открытый экземпляр <ph id="ph1">`Equals`</ph> возвращает метод, объявленный тип и не унаследован успешно <ph id="ph2">`Equals(TestClass)`</ph>.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Call an overload of the <ph id="ph1">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method that includes a <ph id="ph2">`types`</ph> parameter which defines the types of the method's parameters.</source>
          <target state="translated">Вызовите перегрузку <ph id="ph1">&lt;xref:System.Type.GetMethod%2A&gt;</ph> метод, который включает в себя <ph id="ph2">`types`</ph> параметр, который определяет типы параметров метода.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29&gt;</ph> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes.</source>
          <target state="translated">Вызовите <ph id="ph1">&lt;xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29&gt;</ph> метод, чтобы получить массив, содержащий все методы, принадлежащие типу с атрибутами указанную привязку.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>You can then iterate it to identify the duplicate methods named <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Затем можно последовательно его для идентификации повторяющихся методов, с именем <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>This approach is illustrated in the previous example's handler for the <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> exception.</source>
          <target state="translated">Этот подход показан в предыдущем примере обработчик <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> исключение.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <ph id="ph2">&lt;xref:System.Object&gt;</ph> при наличии без ограничения класса.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Универсальные методы не включать аргументы типа в <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Например, код C# <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> ищет элемент с именем текст «<ph id="ph2">`MyMethod&lt;int&gt;`</ph>», а не для метода с именем <ph id="ph3">`MyMethod`</ph> , имеет один аргумент универсального типа <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The following example gets the method that matches the specified binding flags.</source>
          <target state="translated">Следующий пример возвращает метод, который соответствует указанным флагам привязки.</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">Найдено несколько методов с указанным именем и соответствующих указанным ограничениям привязки.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The string containing the name of the public method to get.</source>
          <target state="translated">Строка, содержащая имя искомого открытого метода.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, предоставляющий число, порядок и тип параметров искомого метода.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects (as provided by the <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> field) to get a method that takes no parameters.</source>
          <target state="translated">Пустой массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (в соответствии со значением поля <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>) для получения метода, не принимающего параметры.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>Searches for the specified public method whose parameters match the specified argument types.</source>
          <target state="translated">Ищет указанный открытый метод, параметры которого соответствуют заданным типам аргументов.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>An object representing the public method whose parameters match the specified argument types, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект, представляющий открытый метод, параметры которого соответствуют указанным типам аргументов, если они существуют, и <ph id="ph1">&lt;see langword="null" /&gt;</ph>, если их нет.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Поиск <ph id="ph1">`name`</ph> учитывается регистр.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The search includes public static and public instance methods.</source>
          <target state="translated">При поиске учитываются открытые статические и открытые методы экземпляра.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">Необходимо указывать все параметры при поиске конструкторов и методов.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Параметры можно опустить только в том случае, при вызове метода.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <ph id="ph2">&lt;xref:System.Object&gt;</ph> при наличии без ограничения класса.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The <ph id="ph1">`name`</ph> parameter cannot include type arguments.</source>
          <target state="translated"><ph id="ph1">`name`</ph> Параметра не может содержать аргументов типа.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>For example, the C# code <ph id="ph1">`GetMethod("MyGenericMethod&lt;int&gt;")`</ph> searches for a method with the text name "<ph id="ph2">`MyGenericMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyGenericMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Например, код C# <ph id="ph1">`GetMethod("MyGenericMethod&lt;int&gt;")`</ph> ищет метод с именем текст «<ph id="ph2">`MyGenericMethod&lt;int&gt;`</ph>», а не для метода с именем <ph id="ph3">`MyGenericMethod`</ph> , имеет один аргумент универсального типа <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>Instead, use <ph id="ph1">`GetMethod("MyGenericMethod")`</ph> with the appropriate parameter in the <ph id="ph2">`types`</ph> array.</source>
          <target state="translated">Вместо этого используйте <ph id="ph1">`GetMethod("MyGenericMethod")`</ph> с помощью соответствующего параметра в <ph id="ph2">`types`</ph> массива.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The following example finds specific overloads of <ph id="ph1">`MethodA`</ph>, specifying a variety of argument types.</source>
          <target state="translated">В следующем примере вычисляется заданной перегрузки метода <ph id="ph1">`MethodA`</ph>, указание различных типов аргументов.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The <ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> example requires the <ph id="ph2">`/unsafe`</ph> compiler option.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> Примера требуется <ph id="ph2">`/unsafe`</ph> параметр компилятора.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The following example retrieves <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects that represent the <ph id="ph2">`Add`</ph> methods  of a non-generic type (the <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> class), an open generic type (the <ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class), and a closed generic type (the <ph id="ph5">`List(Of String)`</ph> type.</source>
          <target state="translated">В следующем примере извлекается <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объекты, представляющие <ph id="ph2">`Add`</ph> методы, не являющегося универсальным типа ( <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> класса), открытым универсальным типом ( <ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph> класса) и закрытый универсальный тип ( <ph id="ph5">`List(Of String)`</ph> типа.</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The example defines a <ph id="ph1">`GetAddMethod`</ph> method that retrieves the appropriate <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">В примере определяется <ph id="ph1">`GetAddMethod`</ph> метод, который получает соответствующий <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>To provide the <ph id="ph1">`types`</ph> argument for an open generic type, it calls the <ph id="ph2">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Для обеспечения <ph id="ph1">`types`</ph> аргумент открытый универсальный тип, он вызывает <ph id="ph2">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>To provide the <ph id="ph1">`types`</ph> argument for a closed generic type, it retrieves the value of the <ph id="ph2">&lt;xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Для обеспечения <ph id="ph1">`types`</ph> аргумент для закрытого универсального типа, он возвращает значение <ph id="ph2">&lt;xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>More than one method is found with the specified name and specified parameters.</source>
          <target state="translated">Найдено несколько методов с указанным именем и заданными параметрами.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Один из элементов в <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="types" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the public method to get.</source>
          <target state="translated">Строка, содержащая имя искомого открытого метода.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, предоставляющий число, порядок и тип параметров искомого метода.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects (as provided by the <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> field) to get a method that takes no parameters.</source>
          <target state="translated">Пустой массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (в соответствии со значением поля <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>) для получения метода, не принимающего параметры.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph>, представляющих атрибуты, связанные с соответствующим элементом в массиве <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated">Используется только при вызове посредством COM-взаимодействия. При этом обрабатываются только параметры, переданные по ссылке.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">Связыватель по умолчанию не обрабатывает этот параметр.</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified public method whose parameters match the specified argument types and modifiers.</source>
          <target state="translated">Выполняет поиск указанного открытого метода, параметры которого соответствуют указанным типам аргументов и модификаторам.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the public method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Если поиск выполнен успешно, возвращается объект, представляющий открытый метод, который соответствует указанным требованиям; в противном случае возвращается <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Несмотря на то что связыватель по умолчанию не обрабатывает <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> ( <ph id="ph2">`modifiers`</ph> параметр), можно использовать абстрактный <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> класс, чтобы написать собственный связыватель, обрабатывающий <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Поиск <ph id="ph1">`name`</ph> учитывается регистр.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The search includes public static and public instance methods.</source>
          <target state="translated">При поиске учитываются открытые статические и открытые методы экземпляра.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">Необходимо указывать все параметры при поиске конструкторов и методов.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Параметры можно опустить только в том случае, при вызове метода.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий объект T:System.Type представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <ph id="ph2">&lt;xref:System.Object&gt;</ph> при наличии без ограничения класса.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Универсальные методы не включать аргументы типа в <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the C# code <ph id="ph1">`GetMethod("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Например, код C# <ph id="ph1">`GetMethod("MyMethod&lt;int&gt;")`</ph> ищет элемент с именем текст «<ph id="ph2">`MyMethod&lt;int&gt;`</ph>», а не для метода с именем <ph id="ph3">`MyMethod`</ph> , имеет один аргумент универсального типа <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Instead, use <ph id="ph1">`GetMethod("MyMethod")`</ph> with the appropriate parameter in the <ph id="ph2">`types`</ph> array.</source>
          <target state="translated">Вместо этого используйте <ph id="ph1">`GetMethod("MyMethod")`</ph> с помощью соответствующего параметра в <ph id="ph2">`types`</ph> массива.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one method is found with the specified name and specified parameters.</source>
          <target state="translated">Найдено несколько методов с указанным именем и заданными параметрами.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Один из элементов в <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="types" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the method to get.</source>
          <target state="translated">Строка, содержащая имя искомого метода.</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Нуль, чтобы было возвращено значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Пустая ссылка (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> в Visual Basic) для использования свойства <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, предоставляющий число, порядок и тип параметров искомого метода.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects (as provided by the <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> field) to get a method that takes no parameters.</source>
          <target state="translated">Пустой массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (в соответствии со значением поля <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>) для получения метода, не принимающего параметры.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph>, представляющих атрибуты, связанные с соответствующим элементом в массиве <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated">Используется только при вызове посредством COM-взаимодействия. При этом обрабатываются только параметры, переданные по ссылке.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">Связыватель по умолчанию не обрабатывает этот параметр.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
          <target state="translated">Ищет заданный метод, параметры которого соответствуют указанным типам аргументов и модификаторам, используя установленные ограничения привязки.</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Если поиск выполнен удачно, возвращается объект, предоставляющий метод, который соответствует указанным требованиям; в противном случае возвращается <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Несмотря на то что связыватель по умолчанию не обрабатывает <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> ( <ph id="ph2">`modifiers`</ph> параметр), можно использовать абстрактный <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> класс, чтобы написать собственный связыватель, обрабатывающий <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги фильтра можно использовать для определения методов, включаемых в поиск:</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Необходимо указать либо <ph id="ph1">`BindingFlags.Instance`</ph> или <ph id="ph2">`BindingFlags.Static`</ph> для получения возврата.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Public`</ph> для включения в поиск открытых методов.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include nonpublic methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.NonPublic`</ph> для включения закрытых методов (то есть, закрытые, внутренние и защищенные методы) в поиск.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> для включения <ph id="ph2">`public`</ph> и <ph id="ph3">`protected`</ph> статические члены вверх по иерархии; <ph id="ph4">`private`</ph> статические члены в наследуемых классах не включаются.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> модификатор флаги можно использовать для изменения условий поиска:</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> Чтобы игнорировать регистр <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> для поиска только методы, объявленные на <ph id="ph2">&lt;xref:System.Type&gt;</ph>, не методы, унаследованные.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">Необходимо указывать все параметры при поиске конструкторов и методов.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Параметры можно опустить только в том случае, при вызове метода.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий объект T:System.Type представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <ph id="ph2">&lt;xref:System.Object&gt;</ph> при наличии без ограничения класса.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Универсальные методы не включать аргументы типа в <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Например, код C# <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> ищет элемент с именем текст «<ph id="ph2">`MyMethod&lt;int&gt;`</ph>», а не для метода с именем <ph id="ph3">`MyMethod`</ph> , имеет один аргумент универсального типа <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following example finds specific overloads of <ph id="ph1">`MethodA`</ph>, specifying binding constraints and a variety of argument types.</source>
          <target state="translated">В следующем примере вычисляется заданной перегрузки метода <ph id="ph1">`MethodA`</ph>, указав ограничений привязки и различных типов аргументов.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The <ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> example requires the <ph id="ph2">`/unsafe`</ph> compiler option.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> Примера требуется <ph id="ph2">`/unsafe`</ph> параметр компилятора.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">Найдено несколько методов с указанным именем и соответствующих указанным ограничениям привязки.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Один из элементов в <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="types" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the method to get.</source>
          <target state="translated">Строка, содержащая имя искомого метода.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Нуль, чтобы было возвращено значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Пустая ссылка (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> в Visual Basic) для использования свойства <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.</source>
          <target state="translated">Объект, определяющий набор применяемых правил, касающихся порядка и расположения аргументов, способа передачи возвращаемого значения, регистров, используемых для аргументов, и способа очистки стека.</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, предоставляющий число, порядок и тип параметров искомого метода.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects (as provided by the <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> field) to get a method that takes no parameters.</source>
          <target state="translated">Пустой массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (в соответствии со значением поля <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>) для получения метода, не принимающего параметры.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph>, представляющих атрибуты, связанные с соответствующим элементом в массиве <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated">Используется только при вызове посредством COM-взаимодействия. При этом обрабатываются только параметры, переданные по ссылке.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">Связыватель по умолчанию не обрабатывает этот параметр.</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
          <target state="translated">Ищет метод с параметрами, соответствующими указанным модификаторам и типам аргументов, с учетом заданных ограничений привязки и соглашений о вызовах.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Если поиск выполнен удачно, возвращается объект, предоставляющий метод, который соответствует указанным требованиям; в противном случае возвращается <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Несмотря на то что связыватель по умолчанию не обрабатывает <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> ( <ph id="ph2">`modifiers`</ph> параметр), можно использовать абстрактный <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> класс, чтобы написать собственный связыватель, обрабатывающий <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`GetXXX`</ph> methods when reflecting on a type.</source>
          <target state="translated">В следующей таблице показаны, какие члены базового класса возвращаются <ph id="ph1">`GetXXX`</ph> методов при отражении в типе.</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Member Type</source>
          <target state="translated">Тип члена</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Non-Static</source>
          <target state="translated">Нестатический</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Constructor</source>
          <target state="translated">Конструктор</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Field</source>
          <target state="translated">Поле</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Поле всегда равно по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Event</source>
          <target state="translated">событие</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Method</source>
          <target state="translated">Метод</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Nested Type</source>
          <target state="translated">Вложенный тип</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Property</source>
          <target state="translated">Свойство.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>This is a binary comparison.</source>
          <target state="translated">Это двоичное сравнение.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Для отражения свойства и события, которые по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Пользовательские атрибуты не являются частью системы общих типов.</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги фильтра можно использовать для определения методов, включаемых в поиск:</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Необходимо указать либо <ph id="ph1">`BindingFlags.Instance`</ph> или <ph id="ph2">`BindingFlags.Static`</ph> для получения возврата.</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Public`</ph> для включения в поиск открытых методов.</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include nonpublic methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.NonPublic`</ph> для включения закрытых методов (то есть, закрытые, внутренние и защищенные методы) в поиск.</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> для включения <ph id="ph2">`public`</ph> и <ph id="ph3">`protected`</ph> статические члены вверх по иерархии; <ph id="ph4">`private`</ph> статические члены в наследуемых классах не включаются.</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> модификатор флаги можно использовать для изменения условий поиска:</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> Чтобы игнорировать регистр <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> для поиска только методы, объявленные на <ph id="ph2">&lt;xref:System.Type&gt;</ph>, не методы, унаследованные.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">Необходимо указывать все параметры при поиске конструкторов и методов.</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Параметры можно опустить только в том случае, при вызове метода.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий объект T:System.Type представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <ph id="ph2">&lt;xref:System.Object&gt;</ph> при наличии без ограничения класса.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Универсальные методы не включать аргументы типа в <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Например, код C# <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> ищет элемент с именем текст «<ph id="ph2">`MyMethod&lt;int&gt;`</ph>», а не для метода с именем <ph id="ph3">`MyMethod`</ph> , имеет один аргумент универсального типа <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following example finds specific overloads of <ph id="ph1">`MethodA`</ph>, specifying binding constraints, calling conventions, and a variety of argument types.</source>
          <target state="translated">В следующем примере вычисляется заданной перегрузки метода <ph id="ph1">`MethodA`</ph>, указав ограничениям привязки, соглашения о вызовах и различных типов аргументов.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The <ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> example requires the <ph id="ph2">`/unsafe`</ph> compiler option.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> Примера требуется <ph id="ph2">`/unsafe`</ph> параметр компилятора.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">Найдено несколько методов с указанным именем и соответствующих указанным ограничениям привязки.</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Один из элементов в <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="types" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the method to get.</source>
          <target state="translated">Строка, содержащая имя искомого метода.</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Нуль, чтобы было возвращено значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Пустая ссылка (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> в Visual Basic) для использования свойства <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.</source>
          <target state="translated">Объект, который задает набор правил, используемых в зависимости от порядка и расположения аргументов, способа передачи возвращаемого значения, регистров, используемых для аргументов, и процесса очистки стека.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, предоставляющий число, порядок и тип параметров искомого метода.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</source>
          <target state="translated">Пустой массив объектов типа <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (то есть Type[] types = new Type[0]), если требуется получить метод, который не имеет параметров.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, arguments are not matched.</source>
          <target state="translated">Если значение параметра <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> равно <ph id="ph1">&lt;see langword="null" /&gt;</ph>, аргументы не проверяются на соответствие условиям.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph>, представляющих атрибуты, связанные с соответствующим элементом в массиве <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">Связыватель по умолчанию не обрабатывает этот параметр.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
          <target state="translated">При переопределении в производном классе ищет указанный метод, параметры которого соответствуют указанным типам аргументов и модификаторам, используя для этого заданные ограничения привязки и соглашение о вызовах.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Если поиск выполнен удачно, возвращается объект, предоставляющий метод, который соответствует указанным требованиям; в противном случае возвращается <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Несмотря на то что связыватель по умолчанию не обрабатывает <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> ( <ph id="ph2">`modifiers`</ph> параметр), можно использовать абстрактный <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> класс, чтобы написать собственный связыватель, обрабатывающий <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If <ph id="ph1">`types`</ph> is <ph id="ph2">`null`</ph>, arguments are not matched.</source>
          <target state="translated">Если значение параметра <ph id="ph1">`types`</ph> равно <ph id="ph2">`null`</ph>, аргументы метода не проверяются на соответствие условиям.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги фильтра можно использовать для определения методов, включаемых в поиск:</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Необходимо указать либо <ph id="ph1">`BindingFlags.Instance`</ph> или <ph id="ph2">`BindingFlags.Static`</ph> для получения возврата.</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Public`</ph> для включения в поиск открытых методов.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.NonPublic`</ph> для включения в поиск неоткрытые методы (то есть, закрытые, внутренние и защищенные методы).</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> для включения <ph id="ph2">`public`</ph> и <ph id="ph3">`protected`</ph> статические члены вверх по иерархии; <ph id="ph4">`private`</ph> статические члены в наследуемых классах не включаются.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> модификатор флаги можно использовать для изменения условий поиска:</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> Чтобы игнорировать регистр <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> для поиска только методы, объявленные на <ph id="ph2">&lt;xref:System.Type&gt;</ph>, не методы, унаследованные.</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">Найдено несколько методов с указанным именем и соответствующих указанным ограничениям привязки.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="types" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> и <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> имеют разную длину.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The current type is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</source>
          <target state="translated">Текущий тип является объектом <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> или <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the methods of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает методы текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods">
          <source>Returns all the public methods of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает все открытые методы текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects representing all the public methods defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, представляющий все открытые методы, определенные для текущего объекта <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, if no public methods are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Пустой массив типа <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, если для текущего типа <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> открытые методы не определены.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMethods%2A&gt;</ph> method does not return methods in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetMethods%2A&gt;</ph> Метод не возвращает методы в определенном порядке, например алфавитном или в порядке объявления.</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Your code must not depend on the order in which methods are returned, because that order varies.</source>
          <target state="translated">Код не должен зависеть от порядка, в котором возвращаются методы, так как этот порядок меняется.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Constructors are not included in the array of methods returned by this call.</source>
          <target state="translated">Конструкторы не включаются в массив методов, возвращаемый при вызове этого метода.</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Make a separate call to <ph id="ph1">`GetConstructors()`</ph> to get the constructor methods.</source>
          <target state="translated">Убедитесь в отдельный вызов <ph id="ph1">`GetConstructors()`</ph> для получения методов конструктора.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">В следующей таблице показаны, какие члены базового класса возвращаются <ph id="ph1">`Get`</ph> методов при отражении в типе.</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Member Type</source>
          <target state="translated">Тип члена</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Non-Static</source>
          <target state="translated">Нестатический</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Constructor</source>
          <target state="translated">Конструктор</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Field</source>
          <target state="translated">Поле</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Поле всегда равно по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Event</source>
          <target state="translated">событие</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Method</source>
          <target state="translated">Метод</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Nested Type</source>
          <target state="translated">Вложенный тип</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Property</source>
          <target state="translated">Свойство.</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>This is a binary comparison.</source>
          <target state="translated">Это двоичное сравнение.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Для отражения свойства и события, которые по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Пользовательские атрибуты не являются частью системы общих типов.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">Необходимо указывать все параметры при поиске конструкторов и методов.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Параметры можно опустить только в том случае, при вызове метода.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий объект T:System.Type представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объекты с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <ph id="ph2">&lt;xref:System.Object&gt;</ph> при наличии без ограничения класса.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Нуль, чтобы было возвращено значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the methods defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">При переопределении в производном классе ищет методы, определенные для текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, используя указанные ограничения привязки.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects representing all methods defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, представляющий все методы, определенные для текущего типа <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> и удовлетворяющие указанным ограничениям привязки.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, if no methods are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or if none of the defined methods match the binding constraints.</source>
          <target state="translated">Пустой массив типа <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, если для текущего объекта <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> не определены методы или ни один из определенных методов не удовлетворяет ограничениям привязки.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMethods%2A&gt;</ph> method does not return methods in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetMethods%2A&gt;</ph> Метод не возвращает методы в определенном порядке, например алфавитном или в порядке объявления.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which methods are returned, because that order varies.</source>
          <target state="translated">Код не должен зависеть от порядка, в котором возвращаются методы, так как этот порядок меняется.</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги фильтра можно использовать для определения методов, включаемых в поиск:</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Необходимо указать либо <ph id="ph1">`BindingFlags.Instance`</ph> или <ph id="ph2">`BindingFlags.Static`</ph> для получения возврата.</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Public`</ph> для включения в поиск открытых методов.</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.NonPublic`</ph> для включения в поиск неоткрытые методы (то есть, закрытые, внутренние и защищенные методы).</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Only protected and internal methods on base classes are returned; private methods on base classes are not returned.</source>
          <target state="translated">Только защищенные и внутренние методы базовых классов, возвращаются; закрытые методы базовых классов не возвращаются.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> для включения <ph id="ph2">`public`</ph> и <ph id="ph3">`protected`</ph> статические члены вверх по иерархии; <ph id="ph4">`private`</ph> статические члены в наследуемых классах не включаются.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> модификатор флаги можно использовать для изменения условий поиска:</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> для поиска только методы, объявленные на <ph id="ph2">&lt;xref:System.Type&gt;</ph>, не методы, унаследованные.</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">Необходимо указывать все параметры при поиске конструкторов и методов.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Параметры можно опустить только в том случае, при вызове метода.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий объект T:System.Type представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объекты с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <ph id="ph2">&lt;xref:System.Object&gt;</ph> при наличии без ограничения класса.</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>The following example creates a class with two public methods and one protected method, creates a <ph id="ph1">`Type`</ph> object corresponding to <ph id="ph2">`MyTypeClass`</ph>, gets all public and non-public methods, and displays their names.</source>
          <target state="translated">Следующий пример создает класс с два открытых метода и один защищенный метод, создает <ph id="ph1">`Type`</ph> объект, соответствующий <ph id="ph2">`MyTypeClass`</ph>, возвращает все открытые и неоткрытые методы и отображаются их имена.</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific type nested within the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает определенный тип, вложенный в текущий объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String)">
          <source>The string containing the name of the nested type to get.</source>
          <target state="translated">Строка, содержащая имя искомого вложенного типа.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String)">
          <source>Searches for the public nested type with the specified name.</source>
          <target state="translated">Выполняет поиск открытого вложенного типа с заданным именем.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String)">
          <source>An object representing the public nested type with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект, представляющий открытый вложенный тип с указанным именем, если тип есть, и <ph id="ph1">&lt;see langword="null" /&gt;</ph>, если такого типа нет.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Поиск <ph id="ph1">`name`</ph> учитывается регистр.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Use the simple name of the nested class for <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Можно использовать простое имя вложенного класса для <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Do not qualify it with the name of the outer class.</source>
          <target state="translated">Не уточните его, указав имя внешнего класса.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic arguments.</source>
          <target state="translated">Для универсального вложенного класса следует использовать искаженное имя — то есть присоединения грависом и число универсальных аргументов.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>For example, use the string "Inner<ph id="ph1">\`</ph>1" to get the generic nested class <ph id="ph2">`Inner&lt;T&gt;`</ph> (<ph id="ph3">`Inner(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">Например, используйте строку «внутреннее<ph id="ph1">\`</ph>1» для получения универсального вложенных классов <ph id="ph2">`Inner&lt;T&gt;`</ph> (<ph id="ph3">`Inner(Of T)`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Do not include language-specific syntax for type parameters.</source>
          <target state="translated">Не включайте особый синтаксис для параметров типа.</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">В следующей таблице показаны, какие члены базового класса возвращаются <ph id="ph1">`Get`</ph> методов при отражении в типе.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Member Type</source>
          <target state="translated">Тип члена</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Non-Static</source>
          <target state="translated">Нестатический</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Constructor</source>
          <target state="translated">Конструктор</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Field</source>
          <target state="translated">Поле</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Поле всегда равно по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Event</source>
          <target state="translated">событие</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Method</source>
          <target state="translated">Метод</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Nested Type</source>
          <target state="translated">Вложенный тип</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Property</source>
          <target state="translated">Свойство.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах.</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>This is a binary comparison.</source>
          <target state="translated">Это двоичное сравнение.</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Для отражения свойства и события, которые по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Пользовательские атрибуты не являются частью системы общих типов.</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод ищет вложенные типы ограничения класса.</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
          <target state="translated">Если вложенный тип является универсальным, этот метод возвращает определение универсального типа.</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
          <target state="translated">Это верно, даже если включающий универсальный тип является закрытым сконструированным типом.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет универсальный тип, определенный в C#, Visual Basic или C++, его вложенные типы являются универсальными, даже если они не имеют своих собственных имеет тех универсальных параметров.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">Это не всегда справедливо для вложенных типов, определенных в динамических сборках или скомпилированных с <bpt id="p1">[</bpt>Ilasm.exe (ассемблер IL)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
          <target state="translated">Сведения о вложенных универсальных типов и конструировании вложенных универсальных типов из их определений универсальных типов см. в разделе <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the nested type to get.</source>
          <target state="translated">Строка, содержащая имя искомого вложенного типа.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Нуль, чтобы было возвращено значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</source>
          <target state="translated">При переопределении в производном классе ищет указанный вложенный тип, используя заданные ограничения привязки.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>An object representing the nested type that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Если поиск выполнен успешно, возвращается объект, предоставляющий вложенный тип, который соответствует указанным требованиям; в противном случае возвращается <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Use the simple name of the nested class for <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Можно использовать простое имя вложенного класса для <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Do not qualify it with the name of the outer class.</source>
          <target state="translated">Не уточните его, указав имя внешнего класса.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic parameters.</source>
          <target state="translated">Для универсального вложенного класса следует использовать искаженное имя — то есть присоединения грависом и число универсальных параметров.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>For example, use the string "Inner<ph id="ph1">\`</ph>1" to get the generic nested class <ph id="ph2">`Inner&lt;T&gt;`</ph> (<ph id="ph3">`Inner(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">Например, используйте строку «внутреннее<ph id="ph1">\`</ph>1» для получения универсального вложенных классов <ph id="ph2">`Inner&lt;T&gt;`</ph> (<ph id="ph3">`Inner(Of T)`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Do not include language-specific syntax for type parameters.</source>
          <target state="translated">Не включайте особый синтаксис для параметров типа.</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which nested types to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> фильтра флаги, которые можно использовать для определения, какие вложенные типы будут включены в поиск:</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to get a return.</source>
          <target state="translated">Необходимо указать либо <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> для получения возврата.</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> to include public nested types in the search.</source>
          <target state="translated">Укажите <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> для включения в поиск открытые вложенные типы.</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> для включения при поиске не являющиеся открытыми вложенные типы (то есть, закрытые, внутренние и защищенные вложенные типы).</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>This method returns only the nested types of the current type.</source>
          <target state="translated">Этот метод возвращает только вложенные типы текущего типа.</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>It does not search the base classes of the current type.</source>
          <target state="translated">Он не выполняет поиск базовые классы для текущего типа.</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <ph id="ph1">&lt;xref:System.Type.GetNestedType%2A&gt;</ph> at each level.</source>
          <target state="translated">Чтобы найти типы, вложенные в базовых классах, необходимо пройти в иерархии наследования, вызов <ph id="ph1">&lt;xref:System.Type.GetNestedType%2A&gt;</ph> на каждом уровне.</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> are ignored.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> игнорируются.</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Calling this method with only the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> flag or only the <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> flag will return the specified nested types and does not require any other flags.</source>
          <target state="translated">Вызов этого метода только с <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> флаг или только <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> флаг возвратит все указанные вложенные типы и другие флаги не требуются.</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод ищет вложенные типы ограничения класса.</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
          <target state="translated">Если вложенный тип является универсальным, этот метод возвращает определение универсального типа.</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
          <target state="translated">Это верно, даже если включающий универсальный тип является закрытым сконструированным типом.</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет универсальный тип, определенный в C#, Visual Basic или C++, его вложенные типы являются универсальными, даже если они не имеют своих собственных имеет тех универсальных параметров.</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">Это не всегда справедливо для вложенных типов, определенных в динамических сборках или скомпилированных с <bpt id="p1">[</bpt>Ilasm.exe (ассемблер IL)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
          <target state="translated">Сведения о вложенных универсальных типов и конструировании вложенных универсальных типов из их определений универсальных типов см. в разделе <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the types nested within the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает типы, вложенные в текущий объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes">
          <source>Returns the public types nested in the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает открытые типы, вложенные в текущий объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the public types nested in the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> (the search is not recursive), or an empty array of type <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> if no public types are nested in the current <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий открытые типы, вложенные в текущий объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> (нерекурсивный поиск), или пустой массив типа <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>, если в текущий объект <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph> не вложен ни один открытый тип.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> method does not return types in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> Метод не возвращает типы в определенном порядке, например алфавитном или в порядке объявления.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Your code must not depend on the order in which types are returned, because that order varies.</source>
          <target state="translated">Код не должен зависеть от порядка, в котором возвращаются типы, так как этот порядок меняется.</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Only the public types immediately nested in the current type are returned; the search is not recursive.</source>
          <target state="translated">Возвращаются только открытые типы, непосредственно вложенные в текущий тип; Поиск не является рекурсивным.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">В следующей таблице показаны, какие члены базового класса возвращаются <ph id="ph1">`Get`</ph> методов при отражении в типе.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Member Type</source>
          <target state="translated">Тип члена</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Non-Static</source>
          <target state="translated">Нестатический</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Constructor</source>
          <target state="translated">Конструктор</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Field</source>
          <target state="translated">Поле</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Поле всегда равно по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Event</source>
          <target state="translated">событие</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Method</source>
          <target state="translated">Метод</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Nested Type</source>
          <target state="translated">Вложенный тип</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Property</source>
          <target state="translated">Свойство.</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах.</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>This is a binary comparison.</source>
          <target state="translated">Это двоичное сравнение.</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Для отражения свойства и события, которые по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Пользовательские атрибуты не являются частью системы общих типов.</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод ищет вложенные типы ограничения класса.</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
          <target state="translated">Если вложенный тип является универсальным, этот метод возвращает определение универсального типа.</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
          <target state="translated">Это верно, даже если включающий универсальный тип является закрытым сконструированным типом.</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет универсальный тип, определенный в C#, Visual Basic или C++, его вложенные типы являются универсальными, даже если они не имеют своих собственных имеет тех универсальных параметров.</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">Это не всегда справедливо для вложенных типов, определенных в динамических сборках или скомпилированных с <bpt id="p1">[</bpt>Ilasm.exe (ассемблер IL)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
          <target state="translated">Сведения о вложенных универсальных типов и конструировании вложенных универсальных типов из их определений универсальных типов см. в разделе <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The following example defines a nested class and a <ph id="ph1">`struct`</ph> in <ph id="ph2">`MyClass`</ph>, and then obtains objects of the nested types using the type of <ph id="ph3">`MyClass`</ph>.</source>
          <target state="translated">В следующем примере определяется класс является вложенным и <ph id="ph1">`struct`</ph> в <ph id="ph2">`MyClass`</ph>, а затем происходит получение объектов из вложенных типов, с использованием типа <ph id="ph3">`MyClass`</ph>.</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Нуль, чтобы было возвращено значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the types nested in the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">При переопределении в производном классе ищет типы, вложенные в текущий объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, используя заданные ограничения привязки.</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing all the types nested in the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints (the search is not recursive), or an empty array of type <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>, if no nested types are found that match the binding constraints.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий все типы, вложенные в текущий объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, удовлетворяющий заданным ограничениям привязки (нерекурсивный поиск), или пустой массив типа <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>, если вложенные типы, удовлетворяющие ограничениям привязки, не найдены.</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>The search for nested types is not recursive.</source>
          <target state="translated">Поиск вложенных типов не является рекурсивным.</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> method does not return types in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> Метод не возвращает типы в определенном порядке, например алфавитном или в порядке объявления.</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which types are returned, because that order varies.</source>
          <target state="translated">Код не должен зависеть от порядка, в котором возвращаются типы, так как этот порядок меняется.</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which nested types to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> фильтра флаги, которые можно использовать для определения, какие вложенные типы будут включены в поиск:</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to get a return.</source>
          <target state="translated">Необходимо указать либо <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> или <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> для получения возврата.</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> to include public nested types in the search.</source>
          <target state="translated">Укажите <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> для включения в поиск открытые вложенные типы.</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> для включения при поиске не являющиеся открытыми вложенные типы (то есть, закрытые, внутренние и защищенные вложенные типы).</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This method returns only the nested types of the current type.</source>
          <target state="translated">Этот метод возвращает только вложенные типы текущего типа.</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>It does not search the base classes of the current type.</source>
          <target state="translated">Он не выполняет поиск базовые классы для текущего типа.</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> at each level.</source>
          <target state="translated">Чтобы найти типы, вложенные в базовых классах, необходимо пройти в иерархии наследования, вызов <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> на каждом уровне.</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> are ignored.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> игнорируются.</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Calling this method with only the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> flag or only the <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> flag will return the specified nested types and does not require any other flags.</source>
          <target state="translated">Вызов этого метода только с <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> флаг или только <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> флаг возвратит все указанные вложенные типы и другие флаги не требуются.</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод ищет вложенные типы ограничения класса.</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
          <target state="translated">Если вложенный тип является универсальным, этот метод возвращает определение универсального типа.</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
          <target state="translated">Это верно, даже если включающий универсальный тип является закрытым сконструированным типом.</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет универсальный тип, определенный в C#, Visual Basic или C++, его вложенные типы являются универсальными, даже если они не имеют своих собственных имеет тех универсальных параметров.</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">Это не всегда справедливо для вложенных типов, определенных в динамических сборках или скомпилированных с <bpt id="p1">[</bpt>Ilasm.exe (ассемблер IL)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
          <target state="translated">Сведения о вложенных универсальных типов и конструировании вложенных универсальных типов из их определений универсальных типов см. в разделе <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>The following example creates two nested public classes and two nested protected classes, and displays information for classes that match the specified binding constraints.</source>
          <target state="translated">Следующий пример создает два вложенных открытых классов и два вложенных защищенных класса и выводятся сведения о классах, которые соответствуют указанным ограничениям привязки.</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the properties of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает свойства текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties">
          <source>Returns all the public properties of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает все открытые свойства текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> objects representing all public properties of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph>, представляющий все открытые свойства текущего типа <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have public properties.</source>
          <target state="translated">Пустой массив типа <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph>, если у текущего типа <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> нет открытых свойств.</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Calling this overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29&gt;</ph> overload with a <ph id="ph2">`bindingAttr`</ph> argument equal to <ph id="ph3">`BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public`</ph> in C# and  <ph id="ph4">`BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public`</ph> in Visual Basic.</source>
          <target state="translated">Вызов этой перегрузки, аналогичен вызову <ph id="ph1">&lt;xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29&gt;</ph> перегрузка с <ph id="ph2">`bindingAttr`</ph> аргумент равен <ph id="ph3">`BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public`</ph> в C# и <ph id="ph4">`BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public`</ph> в Visual Basic.</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>It returns all public instance and static properties, both those defined by the type represented by the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object as well as those inherited from its base types.</source>
          <target state="translated">Возвращает все открытые экземпляры и статических свойств, как те, которые определены по типу, представленному текущим <ph id="ph1">&lt;xref:System.Type&gt;</ph> объекта, а также те, унаследованных из его базовых типов.</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения.</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">В противном случае свойство считается закрытым, а должны использовать <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (в Visual Basic, объединять значения с использованием <ph id="ph4">`Or`</ph>) для его получения.</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetProperties%2A&gt;</ph> method does not return properties in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetProperties%2A&gt;</ph> Метод не возвращает свойства определенного порядка, например алфавитного или в порядке объявления.</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Your code must not depend on the order in which properties are returned, because that order varies.</source>
          <target state="translated">Код не должен зависеть от порядка, в котором возвращаются свойства, так как этот порядок меняется.</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">В следующей таблице показаны, какие члены базового класса возвращаются <ph id="ph1">`Get`</ph> методов при отражении в типе.</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Member Type</source>
          <target state="translated">Тип члена</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Non-Static</source>
          <target state="translated">Нестатический</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Constructor</source>
          <target state="translated">Конструктор</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Field</source>
          <target state="translated">Поле</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Поле всегда равно по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Event</source>
          <target state="translated">событие</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Method</source>
          <target state="translated">Метод</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Nested Type</source>
          <target state="translated">Вложенный тип</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Property</source>
          <target state="translated">Свойство.</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах.</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>This is a binary comparison.</source>
          <target state="translated">Это двоичное сравнение.</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Для отражения свойства и события, которые по имени и подписи.</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Пользовательские атрибуты не являются частью системы общих типов.</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий объект T:System.Type представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph1">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> объекты с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The following example demonstrates the use of the <ph id="ph1">`GetProperties`</ph> method.</source>
          <target state="translated">В следующем примере иллюстрируется использование метода <ph id="ph1">`GetProperties`</ph>.</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Нуль, чтобы было возвращено значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the properties of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">При переопределении в производном классе ищет свойства текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, используя указанные ограничения привязки.</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> objects representing all properties of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph>, представляющий все свойства текущего типа <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, которые удовлетворяют указанным ограничениям привязки.</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have properties, or if none of the properties match the binding constraints.</source>
          <target state="translated">Пустой массив типа <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph>, если у текущего типа <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> нет свойств или ни одно свойство не удовлетворяет ограничениям привязки.</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения.</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">В противном случае свойство считается закрытым, а должны использовать <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (в Visual Basic, объединять значения с использованием <ph id="ph4">`Or`</ph>) для его получения.</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetProperties%2A&gt;</ph> method does not return properties in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetProperties%2A&gt;</ph> Метод не возвращает свойства определенного порядка, например алфавитного или в порядке объявления.</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which properties are returned, because that order varies.</source>
          <target state="translated">Код не должен зависеть от порядка, в котором возвращаются свойства, так как этот порядок меняется.</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which nested types to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> фильтра флаги, которые можно использовать для определения, какие вложенные типы будут включены в поиск:</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Необходимо указать либо <ph id="ph1">`BindingFlags.Instance`</ph> или <ph id="ph2">`BindingFlags.Static`</ph> для получения возврата.</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Public`</ph> для включения в поиск открытые свойства.</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.NonPublic`</ph> для включения в поиск закрытые свойства (то есть, закрытые, внутренние и защищенные).</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Only protected and internal properties on base classes are returned; private properties on base classes are not returned.</source>
          <target state="translated">Только защищенные и внутренние свойства базовых классов, возвращаются; частные свойства базовых классов не возвращаются.</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> для включения <ph id="ph2">`public`</ph> и <ph id="ph3">`protected`</ph> статические члены вверх по иерархии; <ph id="ph4">`private`</ph> статические члены в наследуемых классах не включаются.</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> модификатор флаги можно использовать для изменения условий поиска:</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> для поиска только свойства, объявленные в <ph id="ph2">&lt;xref:System.Type&gt;</ph>, не те свойства, унаследованные.</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения.</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">В противном случае свойство считается закрытым, а должны использовать <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (в Visual Basic, объединять значения с использованием <ph id="ph4">`Or`</ph>) для его получения.</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий объект T:System.Type представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph1">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> объекты с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>The following example defines a class named <ph id="ph1">`PropertyClass`</ph> that includes six properties: two are public, one is private, one is protected, one is internal (<ph id="ph2">`Friend`</ph> in Visual Basic), and one is protected internal (<ph id="ph3">`Protected Friend`</ph> in Visual Basic).</source>
          <target state="translated">В следующем примере определяется класс с именем <ph id="ph1">`PropertyClass`</ph> , включает шесть свойств: два являются открытыми, один является закрытым, один защищен, один внутренний (<ph id="ph2">`Friend`</ph> в Visual Basic), и один protected internal (<ph id="ph3">`Protected Friend`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>It then displays some basic property information (the property name and type, whether it is read/write, and the visibility of its <ph id="ph1">`get`</ph> and <ph id="ph2">`set`</ph> accessors) for the properties that match the specified binding constraints.</source>
          <target state="translated">Отобразятся сведения о некоторых основных свойств (имя свойства и тип, следует ли — чтение и запись и видимость его <ph id="ph1">`get`</ph> и <ph id="ph2">`set`</ph> методы доступа) для свойства, которые соответствуют указанным ограничениям привязки.</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific property of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает указанное свойство текущего класса <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">Строка, содержащая искомое имя открытого свойства.</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source>Searches for the public property with the specified name.</source>
          <target state="translated">Выполняет поиск открытого свойства с заданным именем.</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source>An object representing the public property with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект, представляющий открытое свойство с заданным именем, если такое свойство есть, и <ph id="ph1">&lt;see langword="null" /&gt;</ph>, если такого свойства нет.</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Поиск <ph id="ph1">`name`</ph> учитывается регистр.</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">При поиске учитываются открытые статические и открытые свойства экземпляра.</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения.</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">В противном случае свойство считается закрытым, а должны использовать <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (в Visual Basic, объединять значения с использованием <ph id="ph4">`Or`</ph>) для его получения.</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Situations in which <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> occurs include the following:</source>
          <target state="translated">В ситуациях, когда <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> происходит включают следующее:</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>A type contains two indexed properties that have the same name but different numbers of parameters.</source>
          <target state="translated">Тип содержит два индексированные свойства, имеющие одинаковое имя, но различное число параметров.</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>To resolve the ambiguity, use an overload of the <ph id="ph1">&lt;xref:System.Type.GetProperty%2A&gt;</ph> method that specifies parameter types.</source>
          <target state="translated">Для устранения неоднозначности, используйте перегрузку <ph id="ph1">&lt;xref:System.Type.GetProperty%2A&gt;</ph> метод, который задает типы параметров.</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>A derived type declares a property that hides an inherited property with the same name, by using the <ph id="ph1">`new`</ph> modifier (<ph id="ph2">`Shadows`</ph> in Visual Basic).</source>
          <target state="translated">Производный тип объявляет свойство, которое скрывает унаследованное свойство с тем же именем, используя <ph id="ph1">`new`</ph> модификатор (<ph id="ph2">`Shadows`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>To resolve the ambiguity, use the <ph id="ph1">&lt;xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> method overload and add the <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> flag to restrict the search to members that are not inherited.</source>
          <target state="translated">Для устранения неоднозначности используйте <ph id="ph1">&lt;xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> перегрузки метода и добавьте <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> флаг для ограничения поиска к элементам, которые не наследуются.</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Indexers and Default Properties</source>
          <target state="translated">Индексаторы и свойства по умолчанию</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, и <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> обладают упрощенным синтаксисом для доступа к индексированным свойствам и разрешить индексированного свойства по умолчанию, для его типа.</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">Например если переменная <ph id="ph1">`myList`</ph> ссылается на <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, синтаксис <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> в Visual Basic) извлекает элемент с индексом 3.</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>You can overload the property.</source>
          <target state="translated">Данное свойство можно перегрузить.</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">В C# эта функция вызывается индексатором и нельзя ссылаться по имени.</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">По умолчанию индексатор C# отображается в метаданных как индексированное свойство с именем «Item».</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">Тем не менее, можно использовать класс библиотеки разработчик <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> атрибут, чтобы изменить имя индексатора в метаданных.</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">Например <ph id="ph1">&lt;xref:System.String&gt;</ph> класс имеет индекс с именем <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">Индексированные свойства, созданные с помощью языков, отличных от C# могут иметь имена отличные от элемента, а также.</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">Чтобы определить, является ли тип имеет свойство по умолчанию, используйте <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> метод для проверки на наличие <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> атрибута.</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">Если тип имеет <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> свойство возвращает имя свойства по умолчанию.</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>The following example retrieves the <ph id="ph1">`Type`</ph> object of a user-defined class, retrieves a property of that class, and displays the property name.</source>
          <target state="translated">В следующем примере извлекается <ph id="ph1">`Type`</ph> объекта пользовательский класс, извлекается свойство этого класса и отображается имя этого свойства.</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Internally, this property is referred to in the metadata by the name "Item."</source>
          <target state="translated">Это свойство имеет внутреннее в метаданных с именем «Item».</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Any attempt to get <ph id="ph1">`PropertyInfo`</ph> using reflection must specify this internal name in order to correctly return the <ph id="ph2">`PropertyInfo`</ph> property.</source>
          <target state="translated">Любая попытка получить <ph id="ph1">`PropertyInfo`</ph> с помощью отражения необходимо указать это внутреннее имя, чтобы правильно возвращает <ph id="ph2">`PropertyInfo`</ph> свойство.</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source>More than one property is found with the specified name.</source>
          <target state="translated">Найдено несколько свойств с указанным именем.</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the property to get.</source>
          <target state="translated">Строка, содержащий имя искомого свойства.</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Нуль, чтобы было возвращено значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Searches for the specified property, using the specified binding constraints.</source>
          <target state="translated">Ищет указанное свойство, используя заданные ограничения привязки.</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>An object representing the property that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект, предоставляющий свойство, которое соответствует указанным требованиям, если такое свойство найдено; в противном случае возвращается <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения.</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">В противном случае свойство считается закрытым, а должны использовать <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (в Visual Basic, объединять значения с использованием <ph id="ph4">`Or`</ph>) для его получения.</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which properties to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги фильтра можно использовать для определения, какие свойства будут включены в поиск:</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Необходимо указать либо <ph id="ph1">`BindingFlags.Instance`</ph> или <ph id="ph2">`BindingFlags.Static`</ph> для получения возврата.</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Public`</ph> для включения в поиск открытые свойства.</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.NonPublic`</ph> для включения в поиск закрытые свойства (то есть, закрытые, внутренние и защищенные).</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> для включения <ph id="ph2">`public`</ph> и <ph id="ph3">`protected`</ph> статические члены вверх по иерархии; <ph id="ph4">`private`</ph> статические члены в наследуемых классах не включаются.</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> модификатор флаги можно использовать для изменения условий поиска:</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> Чтобы игнорировать регистр <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> для поиска только свойства, объявленные в <ph id="ph2">&lt;xref:System.Type&gt;</ph>, не те свойства, унаследованные.</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Situations in which <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> occurs include the following:</source>
          <target state="translated">В ситуациях, когда <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> происходит включают следующее:</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>A type contains two indexed properties that have the same name but different numbers of parameters.</source>
          <target state="translated">Тип содержит два индексированные свойства, имеющие одинаковое имя, но различное число параметров.</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>To resolve the ambiguity, use an overload of the <ph id="ph1">&lt;xref:System.Type.GetProperty%2A&gt;</ph> method that specifies parameter types.</source>
          <target state="translated">Для устранения неоднозначности, используйте перегрузку <ph id="ph1">&lt;xref:System.Type.GetProperty%2A&gt;</ph> метод, который задает типы параметров.</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>A derived type declares a property that hides an inherited property with the same name, using the <ph id="ph1">`new`</ph> modifier (<ph id="ph2">`Shadows`</ph> in Visual Basic).</source>
          <target state="translated">Производный тип объявляет свойство, которое скрывает унаследованное свойство с тем же именем, используя <ph id="ph1">`new`</ph> модификатор (<ph id="ph2">`Shadows`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>To resolve the ambiguity, include <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> to restrict the search to members that are not inherited.</source>
          <target state="translated">Чтобы устранить неоднозначность, включите <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> для ограничения поиска к элементам, которые не наследуются.</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Indexers and Default Properties</source>
          <target state="translated">Индексаторы и свойства по умолчанию</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, и <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> обладают упрощенным синтаксисом для доступа к индексированным свойствам и разрешить индексированного свойства по умолчанию, для его типа.</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">Например если переменная <ph id="ph1">`myList`</ph> ссылается на <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, синтаксис <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> в Visual Basic) извлекает элемент с индексом 3.</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>You can overload the property.</source>
          <target state="translated">Данное свойство можно перегрузить.</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">В C# эта функция вызывается индексатором и нельзя ссылаться по имени.</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">По умолчанию индексатор C# отображается в метаданных как индексированное свойство с именем «Item».</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">Тем не менее, можно использовать класс библиотеки разработчик <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> атрибут, чтобы изменить имя индексатора в метаданных.</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">Например <ph id="ph1">&lt;xref:System.String&gt;</ph> класс имеет индекс с именем <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">Индексированные свойства, созданные с помощью языков, отличных от C# могут иметь имена отличные от элемента, а также.</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">Чтобы определить, является ли тип имеет свойство по умолчанию, используйте <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> метод для проверки на наличие <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> атрибута.</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">Если тип имеет <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> свойство возвращает имя свойства по умолчанию.</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>The following example retrieves the type of a user-defined class, retrieves a property of that class and displays the property name in accordance with the specified binding constraints.</source>
          <target state="translated">В следующем примере извлекается тип пользовательского класса, извлекается свойство этого класса и отображается имя этого свойства в соответствии с учетом заданных ограничений привязки.</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>More than one property is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">Найдено несколько свойств с указанным именем, соответствующих указанным ограничениям привязки.</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">Строка, содержащая искомое имя открытого свойства.</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The return type of the property.</source>
          <target state="translated">Тип возвращаемого значения свойства.</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>Searches for the public property with the specified name and return type.</source>
          <target state="translated">Выполняет поиск открытого свойства с заданным именем и типом возвращаемого значения.</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>An object representing the public property with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект, представляющий открытое свойство с заданным именем, если такое свойство есть, и <ph id="ph1">&lt;see langword="null" /&gt;</ph>, если такого свойства нет.</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения.</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">В противном случае свойство считается закрытым, а должны использовать <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (в Visual Basic, объединять значения с использованием <ph id="ph4">`Or`</ph>) для его получения.</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Поиск <ph id="ph1">`name`</ph> учитывается регистр.</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">При поиске учитываются открытые статические и открытые свойства экземпляра.</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>Indexers and Default Properties</source>
          <target state="translated">Индексаторы и свойства по умолчанию</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, и <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> обладают упрощенным синтаксисом для доступа к индексированным свойствам и разрешить индексированного свойства по умолчанию, для его типа.</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">Например если переменная <ph id="ph1">`myList`</ph> ссылается на <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, синтаксис <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> в Visual Basic) извлекает элемент с индексом 3.</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>You can overload the property.</source>
          <target state="translated">Данное свойство можно перегрузить.</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">В C# эта функция вызывается индексатором и нельзя ссылаться по имени.</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">По умолчанию индексатор C# отображается в метаданных как индексированное свойство с именем «Item».</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">Тем не менее, можно использовать класс библиотеки разработчик <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> атрибут, чтобы изменить имя индексатора в метаданных.</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">Например <ph id="ph1">&lt;xref:System.String&gt;</ph> класс имеет индекс с именем <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">Индексированные свойства, созданные с помощью языков, отличных от C# могут иметь имена отличные от элемента, а также.</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">Чтобы определить, является ли тип имеет свойство по умолчанию, используйте <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> метод для проверки на наличие <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> атрибута.</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">Если тип имеет <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> свойство возвращает имя свойства по умолчанию.</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The following example defines a class with one property and retrieves the name and type of the property.</source>
          <target state="translated">В следующем примере определяется класс с одним свойством и извлекаются имя и тип свойства.</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>More than one property is found with the specified name.</source>
          <target state="translated">Найдено несколько свойств с указанным именем.</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="returnType" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, или параметр <ph id="ph3">&lt;paramref name="returnType" /&gt;</ph> имеет значение <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">Строка, содержащая искомое имя открытого свойства.</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, предоставляющий число, порядок и тип параметров искомого индексированного свойства.</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">Пустой массив объектов типа <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (то есть Type[] types = new Type[0]), если требуется получить неиндексированное свойство.</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>Searches for the specified public property whose parameters match the specified argument types.</source>
          <target state="translated">Ищет указанное открытое свойство, параметры которого соответствуют указанным типам аргументов.</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>An object representing the public property whose parameters match the specified argument types, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект, представляющий открытое свойство, параметры которого соответствуют указанным условиям, если такое свойство существует, и <ph id="ph1">&lt;see langword="null" /&gt;</ph>, если такого свойства нет.</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения.</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">В противном случае свойство считается закрытым, а должны использовать <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (в Visual Basic, объединять значения с использованием <ph id="ph4">`Or`</ph>) для его получения.</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Поиск <ph id="ph1">`name`</ph> учитывается регистр.</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">При поиске учитываются открытые статические и открытые свойства экземпляра.</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>Indexers and Default Properties</source>
          <target state="translated">Индексаторы и свойства по умолчанию</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, и <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> обладают упрощенным синтаксисом для доступа к индексированным свойствам и разрешить индексированного свойства по умолчанию, для его типа.</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">Например если переменная <ph id="ph1">`myList`</ph> ссылается на <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, синтаксис <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> в Visual Basic) извлекает элемент с индексом 3.</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>You can overload the property.</source>
          <target state="translated">Данное свойство можно перегрузить.</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">В C# эта функция вызывается индексатором и нельзя ссылаться по имени.</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">По умолчанию индексатор C# отображается в метаданных как индексированное свойство с именем «Item».</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">Тем не менее, можно использовать класс библиотеки разработчик <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> атрибут, чтобы изменить имя индексатора в метаданных.</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">Например <ph id="ph1">&lt;xref:System.String&gt;</ph> класс имеет индекс с именем <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">Индексированные свойства, созданные с помощью языков, отличных от C# могут иметь имена отличные от элемента, а также.</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">Чтобы определить, является ли тип имеет свойство по умолчанию, используйте <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> метод для проверки на наличие <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> атрибута.</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">Если тип имеет <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> свойство возвращает имя свойства по умолчанию.</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>The following example retrieves the <ph id="ph1">`Type`</ph> object of a user-defined class, retrieves the property of that class, and displays the property name and type of the property as specified by the arguments passed to <ph id="ph2">`GetProperty`</ph>.</source>
          <target state="translated">В следующем примере извлекается <ph id="ph1">`Type`</ph> объекта пользовательский класс, извлекается свойство этого класса и отображается имя свойства и тип свойства, заданные аргументы, передаваемые <ph id="ph2">`GetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>More than one property is found with the specified name and matching the specified argument types.</source>
          <target state="translated">Найдено несколько свойств с указанным именем и соответствующих указанным типам аргументов.</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="types" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>An element of <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Элемент <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">Строка, содержащая искомое имя открытого свойства.</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>The return type of the property.</source>
          <target state="translated">Тип возвращаемого значения свойства.</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, предоставляющий число, порядок и тип параметров искомого индексированного свойства.</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">Пустой массив объектов типа <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (то есть Type[] types = new Type[0]), если требуется получить неиндексированное свойство.</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>Searches for the specified public property whose parameters match the specified argument types.</source>
          <target state="translated">Ищет указанное открытое свойство, параметры которого соответствуют указанным типам аргументов.</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>An object representing the public property whose parameters match the specified argument types, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект, представляющий открытое свойство, параметры которого соответствуют указанным условиям, если такое свойство существует, и <ph id="ph1">&lt;see langword="null" /&gt;</ph>, если такого свойства нет.</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения.</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">В противном случае свойство считается закрытым, а должны использовать <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (в Visual Basic, объединять значения с использованием <ph id="ph4">`Or`</ph>) для его получения.</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Поиск <ph id="ph1">`name`</ph> учитывается регистр.</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">При поиске учитываются открытые статические и открытые свойства экземпляра.</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>Indexers and Default Properties</source>
          <target state="translated">Индексаторы и свойства по умолчанию</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, и <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> обладают упрощенным синтаксисом для доступа к индексированным свойствам и разрешить индексированного свойства по умолчанию, для его типа.</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">Например если переменная <ph id="ph1">`myList`</ph> ссылается на <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, синтаксис <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> в Visual Basic) извлекает элемент с индексом 3.</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>You can overload the property.</source>
          <target state="translated">Данное свойство можно перегрузить.</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">В C# эта функция вызывается индексатором и нельзя ссылаться по имени.</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">По умолчанию индексатор C# отображается в метаданных как индексированное свойство с именем «Item».</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">Тем не менее, можно использовать класс библиотеки разработчик <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> атрибут, чтобы изменить имя индексатора в метаданных.</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">Например <ph id="ph1">&lt;xref:System.String&gt;</ph> класс имеет индекс с именем <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">Индексированные свойства, созданные с помощью языков, отличных от C# могут иметь имена отличные от элемента, а также.</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">Чтобы определить, является ли тип имеет свойство по умолчанию, используйте <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> метод для проверки на наличие <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> атрибута.</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">Если тип имеет <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> свойство возвращает имя свойства по умолчанию.</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>More than one property is found with the specified name and matching the specified argument types.</source>
          <target state="translated">Найдено несколько свойств с указанным именем и соответствующих указанным типам аргументов.</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="types" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>An element of <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Элемент <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">Строка, содержащая искомое имя открытого свойства.</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The return type of the property.</source>
          <target state="translated">Тип возвращаемого значения свойства.</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, предоставляющий число, порядок и тип параметров искомого индексированного свойства.</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">Пустой массив объектов типа <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (то есть Type[] types = new Type[0]), если требуется получить неиндексированное свойство.</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph>, представляющих атрибуты, связанные с соответствующим элементом в массиве <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">Связыватель по умолчанию не обрабатывает этот параметр.</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified public property whose parameters match the specified argument types and modifiers.</source>
          <target state="translated">Ищет заданное открытое свойство, параметры которого соответствуют указанным типам аргументов и модификаторам.</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the public property that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект, представляющий открытое свойство, которое соответствует указанным требованиям, если такое свойство найдено; в противном случае возвращается <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения.</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">В противном случае свойство считается закрытым, а должны использовать <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (в Visual Basic, объединять значения с использованием <ph id="ph4">`Or`</ph>) для его получения.</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Несмотря на то что связыватель по умолчанию не обрабатывает <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> ( <ph id="ph2">`modifiers`</ph> параметр), можно использовать абстрактный <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> класс, чтобы написать собственный связыватель, обрабатывающий <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Поиск <ph id="ph1">`name`</ph> учитывается регистр.</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">При поиске учитываются открытые статические и открытые свойства экземпляра.</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Indexers and Default Properties</source>
          <target state="translated">Индексаторы и свойства по умолчанию</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, и <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> обладают упрощенным синтаксисом для доступа к индексированным свойствам и разрешить индексированного свойства по умолчанию, для его типа.</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">Например если переменная <ph id="ph1">`myList`</ph> ссылается на <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, синтаксис <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> в Visual Basic) извлекает элемент с индексом 3.</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can overload the property.</source>
          <target state="translated">Данное свойство можно перегрузить.</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">В C# эта функция вызывается индексатором и нельзя ссылаться по имени.</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">По умолчанию индексатор C# отображается в метаданных как индексированное свойство с именем «Item».</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">Тем не менее, можно использовать класс библиотеки разработчик <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> атрибут, чтобы изменить имя индексатора в метаданных.</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">Например <ph id="ph1">&lt;xref:System.String&gt;</ph> класс имеет индекс с именем <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">Индексированные свойства, созданные с помощью языков, отличных от C# могут иметь имена отличные от элемента, а также.</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">Чтобы определить, является ли тип имеет свойство по умолчанию, используйте <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> метод для проверки на наличие <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> атрибута.</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">Если тип имеет <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> свойство возвращает имя свойства по умолчанию.</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following example obtains a <ph id="ph1">`Type`</ph> object corresponding to <ph id="ph2">`MyPropertyClass`</ph>, and the indexed property of this class is retrieved using the arguments passed to the <ph id="ph3">`GetProperty`</ph> method.</source>
          <target state="translated">В следующем примере извлекается <ph id="ph1">`Type`</ph> объект, соответствующий <ph id="ph2">`MyPropertyClass`</ph>, и индексированного свойства этого класса, извлекаются с помощью аргументы, передаваемые <ph id="ph3">`GetProperty`</ph> метод.</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one property is found with the specified name and matching the specified argument types and modifiers.</source>
          <target state="translated">Найдено несколько свойств с указанным именем и соответствующих указанным типам аргументов и модификаторам.</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="types" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> и <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> имеют разную длину.</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An element of <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Элемент <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the property to get.</source>
          <target state="translated">Строка, содержащий имя искомого свойства.</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Нуль, чтобы было возвращено значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Пустая ссылка (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> в Visual Basic) для использования свойства <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The return type of the property.</source>
          <target state="translated">Тип возвращаемого значения свойства.</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, предоставляющий число, порядок и тип параметров искомого индексированного свойства.</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">Пустой массив объектов типа <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (то есть Type[] types = new Type[0]), если требуется получить неиндексированное свойство.</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph>, представляющих атрибуты, связанные с соответствующим элементом в массиве <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">Связыватель по умолчанию не обрабатывает этот параметр.</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
          <target state="translated">Ищет свойство с параметрами, соответствующими указанным модификаторам и типам аргументов, с учетом заданных ограничений привязки.</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the property that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект, предоставляющий свойство, которое соответствует указанным требованиям, если такое свойство найдено; в противном случае возвращается <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения.</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">В противном случае свойство считается закрытым, а должны использовать <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (в Visual Basic, объединять значения с использованием <ph id="ph4">`Or`</ph>) для его получения.</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Несмотря на то что связыватель по умолчанию не обрабатывает <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> ( <ph id="ph2">`modifiers`</ph> параметр), можно использовать абстрактный <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> класс, чтобы написать собственный связыватель, обрабатывающий <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">В следующей таблице показаны, какие члены базового класса возвращаются <ph id="ph1">`Get`</ph> методов при отражении в типе.</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Member Type</source>
          <target state="translated">Тип члена</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Non-Static</source>
          <target state="translated">Нестатический</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Constructor</source>
          <target state="translated">Конструктор</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Field</source>
          <target state="translated">Поле</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Поле всегда равно по имени и подписи.</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Event</source>
          <target state="translated">событие</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Method</source>
          <target state="translated">Метод</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Nested Type</source>
          <target state="translated">Вложенный тип</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Property</source>
          <target state="translated">Свойство.</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах.</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>This is a binary comparison.</source>
          <target state="translated">Это двоичное сравнение.</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Для отражения свойства и события, которые по имени и подписи.</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Пользовательские атрибуты не являются частью системы общих типов.</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which properties to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги фильтра можно использовать для определения, какие свойства будут включены в поиск:</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Необходимо указать либо <ph id="ph1">`BindingFlags.Instance`</ph> или <ph id="ph2">`BindingFlags.Static`</ph> для получения возврата.</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Public`</ph> для включения в поиск открытые свойства.</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.NonPublic`</ph> для включения в поиск закрытые свойства (то есть, закрытые, внутренние и защищенные).</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> для включения <ph id="ph2">`public`</ph> и <ph id="ph3">`protected`</ph> статические члены вверх по иерархии; <ph id="ph4">`private`</ph> статические члены в наследуемых классах не включаются.</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> модификатор флаги можно использовать для изменения условий поиска:</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> Чтобы игнорировать регистр <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> для поиска только свойства, объявленные в <ph id="ph2">&lt;xref:System.Type&gt;</ph>, не те свойства, унаследованные.</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, этот метод возвращает <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> с параметрами типа, заменены соответствующими аргументами типа.</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Indexers and Default Properties</source>
          <target state="translated">Индексаторы и свойства по умолчанию</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, и <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> обладают упрощенным синтаксисом для доступа к индексированным свойствам и разрешить индексированного свойства по умолчанию, для его типа.</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">Например если переменная <ph id="ph1">`myList`</ph> ссылается на <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, синтаксис <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> в Visual Basic) извлекает элемент с индексом 3.</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can overload the property.</source>
          <target state="translated">Данное свойство можно перегрузить.</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">В C# эта функция вызывается индексатором и нельзя ссылаться по имени.</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">По умолчанию индексатор C# отображается в метаданных как индексированное свойство с именем «Item».</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">Тем не менее, можно использовать класс библиотеки разработчик <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> атрибут, чтобы изменить имя индексатора в метаданных.</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">Например <ph id="ph1">&lt;xref:System.String&gt;</ph> класс имеет индекс с именем <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">Индексированные свойства, созданные с помощью языков, отличных от C# могут иметь имена отличные от элемента, а также.</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">Чтобы определить, является ли тип имеет свойство по умолчанию, используйте <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> метод для проверки на наличие <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> атрибута.</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">Если тип имеет <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> свойство возвращает имя свойства по умолчанию.</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one property is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">Найдено несколько свойств с указанным именем, соответствующих указанным ограничениям привязки.</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="types" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> и <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> имеют разную длину.</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An element of <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Элемент <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the property to get.</source>
          <target state="translated">Строка, содержащий имя искомого свойства.</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Нуль, чтобы было возвращено значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженного члена, приведение типов аргументов и вызов члена с помощью отражения.</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Пустая ссылка (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> в Visual Basic) для использования свойства <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The return type of the property.</source>
          <target state="translated">Тип возвращаемого значения свойства.</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, предоставляющий число, порядок и тип параметров искомого индексированного свойства.</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">Пустой массив объектов типа <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (то есть Type[] types = new Type[0]), если требуется получить неиндексированное свойство.</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph>, представляющих атрибуты, связанные с соответствующим элементом в массиве <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">Связыватель по умолчанию не обрабатывает этот параметр.</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
          <target state="translated">При переопределении в производном классе выполняет поиск заданного свойства, параметры которого соответствуют типам и модификаторам заданных аргументов, с использованием заданных ограничений привязки.</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the property that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Объект, предоставляющий свойство, которое соответствует указанным требованиям, если такое свойство найдено; в противном случае возвращается <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Несмотря на то что связыватель по умолчанию не обрабатывает <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> ( <ph id="ph2">`modifiers`</ph> параметр), можно использовать абстрактный <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> класс, чтобы написать собственный связыватель, обрабатывающий <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which properties to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги фильтра можно использовать для определения, какие свойства будут включены в поиск:</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Необходимо указать либо <ph id="ph1">`BindingFlags.Instance`</ph> или <ph id="ph2">`BindingFlags.Static`</ph> для получения возврата.</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Public`</ph> для включения в поиск открытые свойства.</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.NonPublic`</ph> для включения в поиск закрытые свойства (то есть, закрытые, внутренние и защищенные).</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> для включения <ph id="ph2">`public`</ph> и <ph id="ph3">`protected`</ph> статические члены вверх по иерархии; <ph id="ph4">`private`</ph> статические члены в наследуемых классах не включаются.</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> модификатор флаги можно использовать для изменения условий поиска:</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> Чтобы игнорировать регистр <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> для поиска только свойства, объявленные в <ph id="ph2">&lt;xref:System.Type&gt;</ph>, не те свойства, унаследованные.</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one property is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">Найдено несколько свойств с указанным именем, соответствующих указанным ограничениям привязки.</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="name" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Один из элементов в <ph id="ph1">&lt;paramref name="types" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="types" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated">Массив <ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> является многомерным.</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> и <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> имеют разную длину.</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The current type is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>, <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.EnumBuilder" /&gt;</ph>, or <ph id="ph3">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</source>
          <target state="translated">Текущий тип является объектом <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>, <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.EnumBuilder" /&gt;</ph> или <ph id="ph3">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the specified type.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, предоставляющий указанный тип.</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" uid="M:System.Type.GetType">
          <source>Gets the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает текущий <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" uid="M:System.Type.GetType">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Текущий контекст <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" uid="M:System.Type.GetType">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Инициализатор класса вызывается и создает исключение.</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>The assembly-qualified name of the type to get.</source>
          <target state="translated">Имя искомого типа с указанием сборки.</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</source>
          <target state="translated">См. раздел <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">Если тип находится в выполняемой в данный момент сборке или библиотеке Mscorlib.dll, достаточно предоставить имя типа с указанием пространства имен.</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with the specified name, performing a case-sensitive search.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> с указанным именем, учитывая при поиске регистр.</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>The type with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Тип с указанным именем, если он существует; в противном случае — значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for a type in another assembly, if you know its namespace-qualified name.</source>
          <target state="translated">Можно использовать <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> метод, чтобы получить <ph id="ph2">&lt;xref:System.Type&gt;</ph> объекта для типа в другой сборке, если известно его имя, уточненное пространством имен.</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> causes loading of the assembly specified in <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> включает загрузку сборки, указанной в <ph id="ph2">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>You can also load an assembly using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method, and then use the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> methods of the <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> class to get <ph id="ph5">&lt;xref:System.Type&gt;</ph> objects.</source>
          <target state="translated">Можно также загрузить сборку с помощью <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> метода, а затем использовать <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> или <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> методы <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> класса, чтобы получить <ph id="ph5">&lt;xref:System.Type&gt;</ph> объектов.</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If a type is in an assembly known to your program at compile time, it is more efficient to use  in C#, <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic, or  in C++.</source>
          <target state="translated">Если тип находится в сборке, во время компиляции неизвестен программу, это более эффективно использовать в C# <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> Visual Basic или C++.</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If <ph id="ph1">`typeName`</ph> cannot be found, the call to the <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%29&gt;</ph> method returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Если <ph id="ph1">`typeName`</ph> не удается найти, вызов <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%29&gt;</ph> возвращает <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>It does not throw an exception.</source>
          <target state="translated">Он не вызывает исключение.</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To control whether an exception is thrown, call an overload of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method that has a <ph id="ph2">`throwOnError`</ph> parameter.</source>
          <target state="translated">Для управления ли исключение, вызовите перегрузку <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> метода, имеющего <ph id="ph2">`throwOnError`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> only works on assemblies loaded from disk.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> работает только для сборок, загруженных с диска.</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If you call <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> to look up a type defined in a dynamic assembly defined using the <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, you might get inconsistent behavior.</source>
          <target state="translated">При вызове метода <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> для поиска типа, определенного в динамической сборке, определяются с помощью <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> службы, могут быть неверными.</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The behavior depends on whether the dynamic assembly is persistent, that is, created using the <ph id="ph1">`RunAndSave`</ph> or <ph id="ph2">`Save`</ph> access modes of the <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Поведение зависит от динамической сборке постоянно, то есть, созданные с помощью <ph id="ph1">`RunAndSave`</ph> или <ph id="ph2">`Save`</ph> режимов доступа <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> перечисления.</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If the dynamic assembly is persistent and has been written to disk before <ph id="ph1">`GetType`</ph> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</source>
          <target state="translated">Если динамическая сборка является постоянным и была записана на диск перед <ph id="ph1">`GetType`</ph> — вызывается, загрузчик найдет сохраненную сборку на диске, загрузит ее и извлекает тип из этой сборки.</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If the assembly has not been saved to disk when <ph id="ph1">`GetType`</ph> is called, the method returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Если сборка не были сохранены на диск, когда <ph id="ph1">`GetType`</ph> вызывается, метод возвращает <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`GetType`</ph> does not understand transient dynamic assemblies; therefore, calling <ph id="ph2">`GetType`</ph> to retrieve a type in a transient dynamic assembly returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> не распознает временные динамические сборки; Таким образом, вызов <ph id="ph2">`GetType`</ph> для извлечения типа в нерегулярная Возвращает динамическую сборку <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To use <ph id="ph1">`GetType`</ph> on a dynamic module, subscribe to the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> event and call <ph id="ph3">`GetType`</ph> before saving.</source>
          <target state="translated">Для использования <ph id="ph1">`GetType`</ph> на динамический модуль, Подпишитесь на <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> событий и вызовов <ph id="ph3">`GetType`</ph> перед сохранением.</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Otherwise, you will get two copies of the assembly in memory.</source>
          <target state="translated">В противном случае вы получите две копии сборки в памяти.</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">В следующей таблице показаны, какие члены базового класса возвращаются <ph id="ph1">`Get`</ph> методов при отражении в типе.</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Member Type</source>
          <target state="translated">Тип члена</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Non-Static</source>
          <target state="translated">Нестатический</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Constructor</source>
          <target state="translated">Конструктор</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Field</source>
          <target state="translated">Поле</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Поле всегда равно по имени и подписи.</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Event</source>
          <target state="translated">событие</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Method</source>
          <target state="translated">Метод</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Nested Type</source>
          <target state="translated">Вложенный тип</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Property</source>
          <target state="translated">Свойство.</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах.</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>This is a binary comparison.</source>
          <target state="translated">Это двоичное сравнение.</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Для отражения свойства и события, которые по имени и подписи.</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Пользовательские атрибуты не являются частью системы общих типов.</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</source>
          <target state="translated">Массивы или COM-типов не производится, если они уже были загружены в таблицу доступных классов.</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`typeName`</ph> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</source>
          <target state="translated"><ph id="ph1">`typeName`</ph> может быть имя типа с указанием его пространство имен или имя с указанием сборки, которая включает спецификацию имени сборки.</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>See <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</source>
          <target state="translated">См. раздел <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If <ph id="ph1">`typeName`</ph> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</source>
          <target state="translated">Если <ph id="ph1">`typeName`</ph> включает пространство имен, но не имя сборки, этот метод выполняет поиск только в сборке вызывающего объекта и библиотеки Mscorlib.dll, в указанном порядке.</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</source>
          <target state="translated">Если полное имя сборки частичную или полную typeName, этот метод ищет в указанной сборке.</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If the assembly has a strong name, a complete assembly name is required.</source>
          <target state="translated">Если сборка имеет строгое имя, требуется указать полное имя сборки.</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> Свойство возвращает имя полного имени типа, включая вложенные типы, имя сборки и аргументы универсального типа.</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
          <target state="translated">Все компиляторы, поддерживающие общеязыковая среда выполнения будет выдавать простое имя вложенного класса, а отражение создает искаженное имя, если запрос, в соответствии со следующими соглашениями.</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">В .NET Framework версии 2.0 архитектура процессора добавляется удостоверение сборки и может быть указан как часть строки имени сборки.</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">Например «ProcessorArchitecture = msil».</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
          <target state="translated">Однако он не включен в строку, возвращаемую <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> свойства для обеспечения совместимости.</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>You can also load types by creating an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and passing it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Можно также загрузить типы путем создания <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> объекта и передачи его в соответствующую перегрузку <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>You can then use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> method to load types from the assembly.</source>
          <target state="translated">Затем можно использовать <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы загрузить типы из сборки.</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>See also <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">См. также раздел <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Delimiter</source>
          <target state="translated">разделитель</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Meaning</source>
          <target state="translated">Значение</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
          <target state="translated">Обратная косая черта (<ph id="ph1">\\</ph>)</target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Escape character.</source>
          <target state="translated">Escape-символ.</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Backtick (`)</source>
          <target state="translated">Обратный апостроф (')</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</source>
          <target state="translated">Предшествует одной или нескольких цифр, представляющее число параметров типа, расположенное в конце имени универсального типа.</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Brackets ([])</source>
          <target state="translated">квадратные скобки ([])</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</source>
          <target state="translated">Заключите список аргументов универсального типа для сконструированного универсального типа; в список аргументов типа заключите типа с указанием сборки.</target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Comma (,)</source>
          <target state="translated">Запятая ()</target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Precedes the Assembly name.</source>
          <target state="translated">Предшествует имени сборки.</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Period (.)</source>
          <target state="translated">Точка (.)</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Denotes namespace identifiers.</source>
          <target state="translated">Определяет идентификаторы пространства имен.</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Plus sign (+)</source>
          <target state="translated">Знак плюс (+)</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Precedes a nested class.</source>
          <target state="translated">Перед вложенным классом.</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, the fully qualified name for a class might look like this:</source>
          <target state="translated">Например полное имя класса может выглядеть следующим образом:</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
          <target state="translated">Если было TopNamespace.Sub+Namespace, то строка будет иметь предшествовать знак плюс (+) с escape-символом (<ph id="ph1">\\</ph>), чтобы он не будет интерпретироваться как разделитель вложения.</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Reflection emits this string as follows:</source>
          <target state="translated">Отражение преобразует эту строку следующим образом:</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
          <target state="translated">Объект «++» становится «<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+» и»<ph id="ph4">\\</ph>«становится»<ph id="ph5">\\</ph><ph id="ph6">\\</ph>».</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Это полное имя можно сохранить и впоследствии использовано для загрузки <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
          <target state="translated">Чтобы найти и загрузить <ph id="ph1">&lt;xref:System.Type&gt;</ph>, используйте <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> либо с типом имени, либо только имя типа с указанием сборки.</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> с типом имя только будет искать <ph id="ph2">&lt;xref:System.Type&gt;</ph> в сборке вызывающего, а затем в системе сборки.</target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> в сборке будет искать имя типа с указанием <ph id="ph2">&lt;xref:System.Type&gt;</ph> в любой сборке.</target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
          <target state="translated">Имена типов могут включать конечные символы, определяющие дополнительные сведения о типе, например, является ли тип ссылочным типом, типом указателя или тип массива.</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
          <target state="translated">Чтобы получить имя типа без этих конечных символов, используйте <ph id="ph1">`t.GetElementType().ToString()`</ph>, где <ph id="ph2">`t`</ph> тип.</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
          <target state="translated">Пробелы учитываются во всех компонентах имени типа, за исключением имени сборки.</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
          <target state="translated">В имени сборки пробелы перед разделителем ',' учитываются, но пробелы после разделителя «,» игнорируются.</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The name of a generic type ends with a backtick (<ph id="ph1">\`</ph>) followed by digits representing the number of generic type arguments.</source>
          <target state="translated">Имя универсального типа заканчивается обратной кавычкой (<ph id="ph1">\`</ph>) следуют цифры, представляющее число аргументов универсального типа.</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</source>
          <target state="translated">Искажение имени предназначено для обеспечения поддержки универсальных типов с тем же именем, но с различным количеством параметров типа, выполняемых в той же области.</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, reflection returns the mangled names <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tuple<ph id="ph3">`2`</ph> from the generic methods <ph id="ph4">`Tuple(Of T)`</ph> and <ph id="ph5">`Tuple(Of T0, T1)`</ph> in Visual Basic, or <ph id="ph6">`Tuple&lt;T&gt;`</ph> and Tuple<ph id="ph7">`\&lt;T0, T1&gt;`</ph> in Visual C#.</source>
          <target state="translated">Например, отражения возвращает поврежденных имен <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>кортежа<ph id="ph3">`2`</ph> из универсальных методах <ph id="ph4">`Tuple(Of T)`</ph> и <ph id="ph5">`Tuple(Of T0, T1)`</ph> в Visual Basic или <ph id="ph6">`Tuple&lt;T&gt;`</ph> и кортежа<ph id="ph7">`\&lt;T0, T1&gt;`</ph> в Visual C#.</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</source>
          <target state="translated">Для универсальных типов список аргументов типа заключается в квадратные скобки и аргументы типа разделяются запятыми.</target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, a generic <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> has two type parameters.</source>
          <target state="translated">Например, универсальный <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> имеет два параметра типа.</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph> might be represented as follows:</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> из <ph id="ph2">`MyType`</ph> с ключами типа <ph id="ph3">&lt;xref:System.String&gt;</ph> может быть представлен следующим образом:</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</source>
          <target state="translated">Для указания типа с указанием сборки в список аргументов типа, заключите тип сборки в квадратные скобки.</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</source>
          <target state="translated">Запятые, разделяющие части имени сборки, в противном случае интерпретируются как разделители дополнительных аргументов типа.</target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> fromMyAssembly.dll, with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph>, might be specified as follows:</source>
          <target state="translated">Например <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> из <ph id="ph2">`MyType`</ph> fromMyAssembly.dll с ключами типа <ph id="ph3">&lt;xref:System.String&gt;</ph>, может быть указан следующим образом:</target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</source>
          <target state="translated">Тип с указанием сборки можно заключать в скобки, только в том случае, когда он появится в списке параметров типа.</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</source>
          <target state="translated">Правила для поиска в сборках уточненных и неуточненных типы в списках параметров типа совпадают правилам для уточненных и неуточненных неуниверсальных типов.</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Nullable types are a special case of generic types.</source>
          <target state="translated">Типы, допускающие значения NULL являются особыми случаями универсальных типов.</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, a nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph> is represented by the string "System.Nullable`1[System.Int32]".</source>
          <target state="translated">Например, для типа <ph id="ph1">&lt;xref:System.Int32&gt;</ph> представленный строкой «System.Nullable'1[System.Int32]».</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>In C#, C++, and Visual Basic you can also get nullable types using type operators.</source>
          <target state="translated">В C#, C++ и Visual Basic можно также получить с помощью операторов типов типы nullable.</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, the nullable <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> type is returned by <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> in C#, by <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++, and by <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.</source>
          <target state="translated">Например, типа <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> возвращаемый тип <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> в C#, <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> в C++ и по <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> в Visual Basic.</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The following table shows the syntax you use with <ph id="ph1">`GetType`</ph> for various types.</source>
          <target state="translated">В следующей таблице показаны синтаксис, можно использовать с <ph id="ph1">`GetType`</ph> для различных типов.</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To Get</source>
          <target state="translated">Для получения</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Use</source>
          <target state="translated">Использовать</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph></source>
          <target state="translated">Допускающие значения NULL <ph id="ph1">&lt;xref:System.Int32&gt;</ph></target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An unmanaged pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Неуправляемый указатель <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An unmanaged pointer to a pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Неуправляемый указатель на указатель на <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A managed pointer or reference to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Управляемый указатель или ссылка на <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Note that unlike pointers, references are limited to one level.</source>
          <target state="translated">Обратите внимание, что ссылки, в отличие от указателей, ограничены одним уровнем.</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A parent class and a nested class</source>
          <target state="translated">Родительский класс и вложенного класса</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A one-dimensional array with a lower bound of 0</source>
          <target state="translated">Одномерный массив с нижней границей, равной 0</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A one-dimensional array with an unknown lower bound</source>
          <target state="translated">Одномерный массив с неизвестной нижней границей</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An n-dimensional array</source>
          <target state="translated">N мерный массив</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A comma (,) inside the brackets a total of n-1 times.</source>
          <target state="translated">Запятая (,) внутри квадратных скобок n-1 раз.</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, <ph id="ph1">`System.Object[,,]`</ph> represents a three-dimensional <ph id="ph2">`Object`</ph> array.</source>
          <target state="translated">Например <ph id="ph1">`System.Object[,,]`</ph> представляет трехмерный массив <ph id="ph2">`Object`</ph> массива.</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An array of one-dimensional arrays</source>
          <target state="translated">Массив одномерные массивы</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A rectangular two-dimensional array with unknown lower bounds</source>
          <target state="translated">Прямоугольный двухмерный массив с неизвестными нижними границами</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A generic type with one type argument</source>
          <target state="translated">Универсальный тип с одним аргументом типа</target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")"</target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A generic type with two type arguments</source>
          <target state="translated">Универсальный тип с двумя аргументами типа</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A generic type with two assembly-qualified type arguments</source>
          <target state="translated">Универсальный тип с двумя аргументами типа сборки</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An assembly-qualified generic type with an assembly-qualified type argument</source>
          <target state="translated">Сборки универсального типа с аргументом типа сборки</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A generic type whose type argument is a generic type with two type arguments</source>
          <target state="translated">Универсальный тип, имеющий аргумент типа является универсальным типом с двумя аргументами типа</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The following example retrieves the type of <ph id="ph1">`System.Int32`</ph> and uses that type object to display the <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> property of <ph id="ph3">`System.Int32`</ph>.</source>
          <target state="translated">В следующем примере извлекается тип <ph id="ph1">`System.Int32`</ph> и используется для отображения этого объекта <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> свойство <ph id="ph3">`System.Int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Инициализатор класса вызывается и создает исключение.</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет универсальный тип, имеющий тип указателя, тип <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> или <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> в качестве одного из его аргументов типа.</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет универсальный тип, который содержит неправильное количество аргументов типа.</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет массив <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated">Вместо этого в <bpt id="p1">[</bpt>.NET для приложений Магазина Windows<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> или в <bpt id="p2">[</bpt>переносимой библиотеке классов<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept> перехватите исключение базового класса <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">Сборка или одна из ее зависимостей найдена, но не может быть загружена.</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">Сборка или одна из ее зависимостей является недопустимой.</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</source>
          <target state="translated">В текущий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка была скомпилирована в более поздней версии.</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The assembly-qualified name of the type to get.</source>
          <target state="translated">Имя искомого типа с указанием сборки.</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</source>
          <target state="translated">См. раздел <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">Если тип находится в выполняемой в данный момент сборке или библиотеке Mscorlib.dll, достаточно предоставить имя типа с указанием пространства имен.</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, чтобы создать исключение, если тип не удается найти; значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>, чтобы вернуть значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Specifying <ph id="ph1">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated">Кроме того, при указании значения <ph id="ph1">&lt;see langword="false" /&gt;</ph> подавляются некоторые другие условия возникновения исключений, но не все из них.</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">См. раздел "Исключения".</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> с заданным именем, выполняя поиск с учетом регистра и указывая, будет ли создаваться исключение в случае невозможности найти тип.</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The type with the specified name.</source>
          <target state="translated">Тип с указанным именем.</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">Если тип не найден, параметр <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> определяет дальнейшее действие — возврат значения <ph id="ph2">&lt;see langword="null" /&gt;</ph> или создание исключения.</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</source>
          <target state="translated">В некоторых случаях исключение создается независимо от значения параметра <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">См. раздел "Исключения".</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for a type in another assembly, if the you know its namespace-qualified name.</source>
          <target state="translated">Можно использовать <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> метод, чтобы получить <ph id="ph2">&lt;xref:System.Type&gt;</ph> объекта для типа в другой сборке, если известно его имя, уточненное пространством имен.</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> causes loading of the assembly specified in <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> включает загрузку сборки, указанной в <ph id="ph2">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>You can also load an assembly using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method, and then use the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> methods of the <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> class to get <ph id="ph5">&lt;xref:System.Type&gt;</ph> objects.</source>
          <target state="translated">Можно также загрузить сборку с помощью <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> метода, а затем использовать <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> или <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> методы <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> класса, чтобы получить <ph id="ph5">&lt;xref:System.Type&gt;</ph> объектов.</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If a type is in an assembly known to your program at compile time, it is more efficient to use <ph id="ph1">`typeof`</ph> in C#, <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic, or <ph id="ph3">`typeid`</ph> in C++.</source>
          <target state="translated">Если тип находится в сборке, во время компиляции неизвестен программу, это более эффективно использовать <ph id="ph1">`typeof`</ph> в C# <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> в Visual Basic или <ph id="ph3">`typeid`</ph> в C++.</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`GetType`</ph> only works on assemblies loaded from disk.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> работает только для сборок, загруженных с диска.</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If you call <ph id="ph1">`GetType`</ph> to look up a type defined in a dynamic assembly defined using the <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, you might get inconsistent behavior.</source>
          <target state="translated">При вызове метода <ph id="ph1">`GetType`</ph> для поиска типа, определенного в динамической сборке, определяются с помощью <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> службы, могут быть неверными.</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The behavior depends on whether the dynamic assembly is persistent, that is, created using the <ph id="ph1">`RunAndSave`</ph> or <ph id="ph2">`Save`</ph> access modes of the <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Поведение зависит от динамической сборке постоянно, то есть, созданные с помощью <ph id="ph1">`RunAndSave`</ph> или <ph id="ph2">`Save`</ph> режимов доступа <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> перечисления.</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the dynamic assembly is persistent and has been written to disk before <ph id="ph1">`GetType`</ph> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</source>
          <target state="translated">Если динамическая сборка является постоянным и была записана на диск перед <ph id="ph1">`GetType`</ph> — вызывается, загрузчик найдет сохраненную сборку на диске, загрузит ее и извлекает тип из этой сборки.</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the assembly has not been saved to disk when <ph id="ph1">`GetType`</ph> is called, the method returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Если сборка не были сохранены на диск, когда <ph id="ph1">`GetType`</ph> вызывается, метод возвращает <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`GetType`</ph> does not understand transient dynamic assemblies; therefore, calling <ph id="ph2">`GetType`</ph> to retrieve a type in a transient dynamic assembly returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> не распознает временные динамические сборки; Таким образом, вызов <ph id="ph2">`GetType`</ph> для извлечения типа в нерегулярная Возвращает динамическую сборку <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To use <ph id="ph1">`GetType`</ph> on a dynamic module, subscribe to the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> event and call <ph id="ph3">`GetType`</ph> before saving.</source>
          <target state="translated">Для использования <ph id="ph1">`GetType`</ph> на динамический модуль, Подпишитесь на <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> событий и вызовов <ph id="ph3">`GetType`</ph> перед сохранением.</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Otherwise, you will get two copies of the assembly in memory.</source>
          <target state="translated">В противном случае вы получите две копии сборки в памяти.</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</source>
          <target state="translated"><ph id="ph1">`throwOnError`</ph> Параметр указывает, что произойдет, если тип не найден, а также подавляются некоторые другие условия возникновения исключений, как описано в раздел "исключения".</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Some exceptions are thrown regardless of the value of <ph id="ph1">`throwOnError`</ph>.</source>
          <target state="translated">Некоторые исключения выдаются независимо от значения <ph id="ph1">`throwOnError`</ph>.</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, if the type is found but cannot be loaded, a <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Например, если тип присутствует, но не может быть загружена <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> возникает, даже если <ph id="ph2">`throwOnError`</ph> — <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">В следующей таблице показаны, какие члены базового класса возвращаются <ph id="ph1">`Get`</ph> методов при отражении в типе.</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Member Type</source>
          <target state="translated">Тип члена</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Non-Static</source>
          <target state="translated">Нестатический</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Constructor</source>
          <target state="translated">Конструктор</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Field</source>
          <target state="translated">Поле</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Поле всегда равно по имени и подписи.</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Event</source>
          <target state="translated">событие</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Method</source>
          <target state="translated">Метод</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Nested Type</source>
          <target state="translated">Вложенный тип</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Property</source>
          <target state="translated">Свойство.</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах.</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>This is a binary comparison.</source>
          <target state="translated">Это двоичное сравнение.</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Для отражения свойства и события, которые по имени и подписи.</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Пользовательские атрибуты не являются частью системы общих типов.</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</source>
          <target state="translated">Массивы или COM-типов не производится, если они уже были загружены в таблицу доступных классов.</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`typeName`</ph> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</source>
          <target state="translated"><ph id="ph1">`typeName`</ph> может быть имя типа с указанием его пространство имен или имя с указанием сборки, которая включает спецификацию имени сборки.</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</source>
          <target state="translated">См. раздел <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</source>
          <target state="translated">Если <ph id="ph1">`typeName`</ph> включает пространство имен, но не имя сборки, этот метод выполняет поиск только в сборке вызывающего объекта и библиотеки Mscorlib.dll, в указанном порядке.</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</source>
          <target state="translated">Если полное имя сборки частичную или полную typeName, этот метод ищет в указанной сборке.</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the assembly has a strong name, a complete assembly name is required.</source>
          <target state="translated">Если сборка имеет строгое имя, требуется указать полное имя сборки.</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property returns a fully qualified type name including nested types, the assembly name, and generic arguments.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> Свойство возвращает полное имя, включая вложенные типы, имя сборки и универсальные аргументы.</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
          <target state="translated">Все компиляторы, поддерживающие общеязыковая среда выполнения будет выдавать простое имя вложенного класса, а отражение создает искаженное имя, если запрос, в соответствии со следующими соглашениями.</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">В .NET Framework версии 2.0 архитектура процессора добавляется удостоверение сборки и может быть указан как часть строки имени сборки.</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">Например «ProcessorArchitecture = msil».</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
          <target state="translated">Однако он не включен в строку, возвращаемую <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> свойства для обеспечения совместимости.</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>You can also load types by creating an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and passing it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Можно также загрузить типы путем создания <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> объекта и передачи его в соответствующую перегрузку <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>You can then use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> method to load types from the assembly.</source>
          <target state="translated">Затем можно использовать <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы загрузить типы из сборки.</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See also <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">См. также раздел <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Delimiter</source>
          <target state="translated">разделитель</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Meaning</source>
          <target state="translated">Значение</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
          <target state="translated">Обратная косая черта (<ph id="ph1">\\</ph>)</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Escape character.</source>
          <target state="translated">Escape-символ.</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Backtick (`)</source>
          <target state="translated">Обратный апостроф (')</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</source>
          <target state="translated">Предшествует одной или нескольких цифр, представляющее число параметров типа, расположенное в конце имени универсального типа.</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Brackets ([])</source>
          <target state="translated">квадратные скобки ([])</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</source>
          <target state="translated">Заключите список аргументов универсального типа для сконструированного универсального типа; в список аргументов типа заключите типа с указанием сборки.</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Comma (,)</source>
          <target state="translated">Запятая ()</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Precedes the Assembly name.</source>
          <target state="translated">Предшествует имени сборки.</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Period (.)</source>
          <target state="translated">Точка (.)</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Denotes namespace identifiers.</source>
          <target state="translated">Определяет идентификаторы пространства имен.</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Plus sign (+)</source>
          <target state="translated">Знак плюс (+)</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Precedes a nested class.</source>
          <target state="translated">Перед вложенным классом.</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, the fully qualified name for a class might look like this:</source>
          <target state="translated">Например полное имя класса может выглядеть следующим образом:</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
          <target state="translated">Если было TopNamespace.Sub+Namespace, то строка будет иметь предшествовать знак плюс (+) с escape-символом (<ph id="ph1">\\</ph>), чтобы он не будет интерпретироваться как разделитель вложения.</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Reflection emits this string as follows:</source>
          <target state="translated">Отражение преобразует эту строку следующим образом:</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
          <target state="translated">Объект «++» становится «<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+» и»<ph id="ph4">\\</ph>«становится»<ph id="ph5">\\</ph><ph id="ph6">\\</ph>».</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Это полное имя можно сохранить и впоследствии использовано для загрузки <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
          <target state="translated">Чтобы найти и загрузить <ph id="ph1">&lt;xref:System.Type&gt;</ph>, используйте <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> либо с типом имени, либо только имя типа с указанием сборки.</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> с типом имя только будет искать <ph id="ph2">&lt;xref:System.Type&gt;</ph> в сборке вызывающего, а затем в системе сборки.</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> в сборке будет искать имя типа с указанием <ph id="ph2">&lt;xref:System.Type&gt;</ph> в любой сборке.</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
          <target state="translated">Имена типов могут включать конечные символы, определяющие дополнительные сведения о типе, например, является ли тип ссылочным типом, типом указателя или тип массива.</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
          <target state="translated">Чтобы получить имя типа без этих конечных символов, используйте <ph id="ph1">`t.GetElementType().ToString()`</ph>, где <ph id="ph2">`t`</ph> тип.</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
          <target state="translated">Пробелы учитываются во всех компонентах имени типа, за исключением имени сборки.</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
          <target state="translated">В имени сборки пробелы перед разделителем ',' учитываются, но пробелы после разделителя «,» игнорируются.</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The name of a generic type ends with a backtick (<ph id="ph1">\`</ph>) followed by digits representing the number of generic type arguments.</source>
          <target state="translated">Имя универсального типа заканчивается обратной кавычкой (<ph id="ph1">\`</ph>) следуют цифры, представляющее число аргументов универсального типа.</target>       </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</source>
          <target state="translated">Искажение имени предназначено для обеспечения поддержки универсальных типов с тем же именем, но с различным количеством параметров типа, выполняемых в той же области.</target>       </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, reflection returns the mangled names <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tuple<ph id="ph3">`2`</ph> from the generic methods <ph id="ph4">`Tuple(Of T)`</ph> and <ph id="ph5">`Tuple(Of T0, T1)`</ph> in Visual Basic, or <ph id="ph6">`Tuple&lt;T&gt;`</ph> and Tuple<ph id="ph7">`\&lt;T0, T1&gt;`</ph> in Visual C#.</source>
          <target state="translated">Например, отражения возвращает поврежденных имен <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>кортежа<ph id="ph3">`2`</ph> из универсальных методах <ph id="ph4">`Tuple(Of T)`</ph> и <ph id="ph5">`Tuple(Of T0, T1)`</ph> в Visual Basic или <ph id="ph6">`Tuple&lt;T&gt;`</ph> и кортежа<ph id="ph7">`\&lt;T0, T1&gt;`</ph> в Visual C#.</target>       </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</source>
          <target state="translated">Для универсальных типов список аргументов типа заключается в квадратные скобки и аргументы типа разделяются запятыми.</target>       </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, a generic <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> has two type parameters.</source>
          <target state="translated">Например, универсальный <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> имеет два параметра типа.</target>       </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph> might be represented as follows:</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> из <ph id="ph2">`MyType`</ph> с ключами типа <ph id="ph3">&lt;xref:System.String&gt;</ph> может быть представлен следующим образом:</target>       </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</source>
          <target state="translated">Для указания типа с указанием сборки в список аргументов типа, заключите тип сборки в квадратные скобки.</target>       </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</source>
          <target state="translated">Запятые, разделяющие части имени сборки, в противном случае интерпретируются как разделители дополнительных аргументов типа.</target>       </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> from MyAssembly.dll, with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph>, might be specified as follows:</source>
          <target state="translated">Например <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> из <ph id="ph2">`MyType`</ph> из MyAssembly.dll с ключами типа <ph id="ph3">&lt;xref:System.String&gt;</ph>, может быть указан следующим образом:</target>       </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</source>
          <target state="translated">Тип с указанием сборки можно заключать в скобки, только в том случае, когда он появится в списке параметров типа.</target>       </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</source>
          <target state="translated">Правила для поиска в сборках уточненных и неуточненных типы в списках параметров типа совпадают правилам для уточненных и неуточненных неуниверсальных типов.</target>       </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Nullable types are a special case of generic types.</source>
          <target state="translated">Типы, допускающие значения NULL являются особыми случаями универсальных типов.</target>       </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, a nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph> is represented by the string "System.Nullable`1[System.Int32]".</source>
          <target state="translated">Например, для типа <ph id="ph1">&lt;xref:System.Int32&gt;</ph> представленный строкой «System.Nullable'1[System.Int32]».</target>       </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In C#, C++, and Visual Basic you can also get nullable types using type operators.</source>
          <target state="translated">В C#, C++ и Visual Basic можно также получить с помощью операторов типов типы nullable.</target>       </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, the nullable <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> type is returned by <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> in C#, by <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++, and by <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.</source>
          <target state="translated">Например, типа <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> возвращаемый тип <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> в C#, <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> в C++ и по <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> в Visual Basic.</target>       </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The following table shows the syntax you use with <ph id="ph1">`GetType`</ph> for various types.</source>
          <target state="translated">В следующей таблице показаны синтаксис, можно использовать с <ph id="ph1">`GetType`</ph> для различных типов.</target>       </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To Get</source>
          <target state="translated">Для получения</target>       </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Use</source>
          <target state="translated">Использовать</target>       </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph></source>
          <target state="translated">Допускающие значения NULL <ph id="ph1">&lt;xref:System.Int32&gt;</ph></target>       </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</target>       </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An unmanaged pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Неуправляемый указатель <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An unmanaged pointer to a pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Неуправляемый указатель на указатель на <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A managed pointer or reference to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Управляемый указатель или ссылка на <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</target>       </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Note that unlike pointers, references are limited to one level.</source>
          <target state="translated">Обратите внимание, что ссылки, в отличие от указателей, ограничены одним уровнем.</target>       </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A parent class and a nested class</source>
          <target state="translated">Родительский класс и вложенного класса</target>       </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A one-dimensional array with a lower bound of 0</source>
          <target state="translated">Одномерный массив с нижней границей, равной 0</target>       </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A one-dimensional array with an unknown lower bound</source>
          <target state="translated">Одномерный массив с неизвестной нижней границей</target>       </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An n-dimensional array</source>
          <target state="translated">N мерный массив</target>       </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A comma (,) inside the brackets a total of n-1 times.</source>
          <target state="translated">Запятая (,) внутри квадратных скобок n-1 раз.</target>       </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, <ph id="ph1">`System.Object[,,]`</ph> represents a three-dimensional <ph id="ph2">`Object`</ph> array.</source>
          <target state="translated">Например <ph id="ph1">`System.Object[,,]`</ph> представляет трехмерный массив <ph id="ph2">`Object`</ph> массива.</target>       </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A two-dimensional array's array</source>
          <target state="translated">Двумерный массив массивов</target>       </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A rectangular two-dimensional array with unknown lower bounds</source>
          <target state="translated">Прямоугольный двухмерный массив с неизвестными нижними границами</target>       </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A generic type with one type argument</source>
          <target state="translated">Универсальный тип с одним аргументом типа</target>       </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")"</target>       </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A generic type with two type arguments</source>
          <target state="translated">Универсальный тип с двумя аргументами типа</target>       </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</target>       </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A generic type with two assembly-qualified type arguments</source>
          <target state="translated">Универсальный тип с двумя аргументами типа сборки</target>       </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</target>       </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An assembly-qualified generic type with an assembly-qualified type argument</source>
          <target state="translated">Сборки универсального типа с аргументом типа сборки</target>       </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</target>       </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A generic type whose type argument is a generic type with two type arguments</source>
          <target state="translated">Универсальный тип, имеющий аргумент типа является универсальным типом с двумя аргументами типа</target>       </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></target>       </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The following example retrieves the type of <ph id="ph1">`System.Int32`</ph> and uses that type object to display the <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> property of <ph id="ph3">`System.Int32`</ph>.</source>
          <target state="translated">В следующем примере извлекается тип <ph id="ph1">`System.Int32`</ph> и используется для отображения этого объекта <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> свойство <ph id="ph3">`System.Int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If a type object refers to an assembly that does not exist, this example throws an exception.</source>
          <target state="translated">Если тип объекта содержит ссылку на сборку, которая не существует, этот пример создает исключение.</target>       </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Инициализатор класса вызывается и создает исключение.</target>       </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и тип не найден.</target>       </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> содержит недопустимые знаки, например внедренные табуляции.</target>       </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> является пустой строкой.</target>       </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> представляет тип массива с недопустимым размером.</target>       </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет массив <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> содержит недопустимый синтаксис.</target>       </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, "MyType[,*,]".</source>
          <target state="translated">Например, "MyType[,*,]".</target>       </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет универсальный тип, имеющий тип указателя, тип <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> или <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> в качестве одного из его аргументов типа.</target>       </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет универсальный тип, который содержит неправильное количество аргументов типа.</target>       </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</target>       </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и не удалось найти сборку либо одну из ее зависимостей.</target>       </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated">Вместо этого в <bpt id="p1">[</bpt>.NET для приложений Магазина Windows<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> или в <bpt id="p2">[</bpt>переносимой библиотеке классов<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept> перехватите исключение базового класса <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">Сборка или одна из ее зависимостей найдена, но не может быть загружена.</target>       </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">Сборка или одна из ее зависимостей является недопустимой.</target>       </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</source>
          <target state="translated">В текущий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка была скомпилирована в более поздней версии.</target>       </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly-qualified name of the type to get.</source>
          <target state="translated">Имя искомого типа с указанием сборки.</target>       </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</source>
          <target state="translated">См. раздел <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">Если тип находится в выполняемой в данный момент сборке или библиотеке Mscorlib.dll, достаточно предоставить имя типа с указанием пространства имен.</target>       </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.Specifying <ph id="ph4">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, чтобы при невозможности найти тип создавалось исключение; значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>, чтобы возвращалось значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>. При задании значения <ph id="ph4">&lt;see langword="false" /&gt;</ph> также подавляются некоторые другие условия исключения, однако не все.</target>       </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">См. раздел "Исключения".</target>       </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a case-insensitive search for <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>, <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a case-sensitive search for <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, чтобы не учитывать регистр при поиске <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>; значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>, чтобы учитывать регистр при поиске <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> с указанным именем, позволяющий определить, будет ли создаваться исключение в случае невозможности найти тип и будет ли учитываться регистр при поиске.</target>       </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The type with the specified name.</source>
          <target state="translated">Тип с указанным именем.</target>       </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">Если тип не найден, параметр <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> определяет дальнейшее действие — возврат значения <ph id="ph2">&lt;see langword="null" /&gt;</ph> или создание исключения.</target>       </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</source>
          <target state="translated">В некоторых случаях исключение создается независимо от значения параметра <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">См. раздел "Исключения".</target>       </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for a type in another assembly, if the you know its namespace-qualified name.</source>
          <target state="translated">Можно использовать <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> метод, чтобы получить <ph id="ph2">&lt;xref:System.Type&gt;</ph> объекта для типа в другой сборке, если известно его имя, уточненное пространством имен.</target>       </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> causes loading of the assembly specified in <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> включает загрузку сборки, указанной в <ph id="ph2">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>You can also load an assembly using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method, and then use the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> methods of the <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> class to get <ph id="ph5">&lt;xref:System.Type&gt;</ph> objects.</source>
          <target state="translated">Можно также загрузить сборку с помощью <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> метода, а затем использовать <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> или <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> методы <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> класса, чтобы получить <ph id="ph5">&lt;xref:System.Type&gt;</ph> объектов.</target>       </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If a type is in an assembly known to your program at compile time, it is more efficient to use <ph id="ph1">`typeof`</ph> in C#, <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic, or <ph id="ph3">`typeid`</ph> in C++.</source>
          <target state="translated">Если тип находится в сборке, во время компиляции неизвестен программу, это более эффективно использовать <ph id="ph1">`typeof`</ph> в C# <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> в Visual Basic или <ph id="ph3">`typeid`</ph> в C++.</target>       </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`GetType`</ph> only works on assemblies loaded from disk.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> работает только для сборок, загруженных с диска.</target>       </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If you call <ph id="ph1">`GetType`</ph> to look up a type defined in a dynamic assembly defined using the <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, you might get inconsistent behavior.</source>
          <target state="translated">При вызове метода <ph id="ph1">`GetType`</ph> для поиска типа, определенного в динамической сборке, определяются с помощью <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> службы, могут быть неверными.</target>       </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The behavior depends on whether the dynamic assembly is persistent, that is, created using the <ph id="ph1">`RunAndSave`</ph> or <ph id="ph2">`Save`</ph> access modes of the <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Поведение зависит от динамической сборке постоянно, то есть, созданные с помощью <ph id="ph1">`RunAndSave`</ph> или <ph id="ph2">`Save`</ph> режимов доступа <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> перечисления.</target>       </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the dynamic assembly is persistent and has been written to disk before <ph id="ph1">`GetType`</ph> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</source>
          <target state="translated">Если динамическая сборка является постоянным и была записана на диск перед <ph id="ph1">`GetType`</ph> — вызывается, загрузчик найдет сохраненную сборку на диске, загрузит ее и извлекает тип из этой сборки.</target>       </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the assembly has not been saved to disk when <ph id="ph1">`GetType`</ph> is called, the method returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Если сборка не были сохранены на диск, когда <ph id="ph1">`GetType`</ph> вызывается, метод возвращает <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`GetType`</ph> does not understand transient dynamic assemblies; therefore, calling <ph id="ph2">`GetType`</ph> to retrieve a type in a transient dynamic assembly returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> не распознает временные динамические сборки; Таким образом, вызов <ph id="ph2">`GetType`</ph> для извлечения типа в нерегулярная Возвращает динамическую сборку <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To use <ph id="ph1">`GetType`</ph> on a dynamic module, subscribe to the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> event and call <ph id="ph3">`GetType`</ph> before saving.</source>
          <target state="translated">Для использования <ph id="ph1">`GetType`</ph> на динамический модуль, Подпишитесь на <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> событий и вызовов <ph id="ph3">`GetType`</ph> перед сохранением.</target>       </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Otherwise, you will get two copies of the assembly in memory.</source>
          <target state="translated">В противном случае вы получите две копии сборки в памяти.</target>       </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</source>
          <target state="translated"><ph id="ph1">`throwOnError`</ph> Параметр указывает, что произойдет, если тип не найден, а также подавляются некоторые другие условия возникновения исключений, как описано в раздел "исключения".</target>       </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Some exceptions are thrown regardless of the value of <ph id="ph1">`throwOnError`</ph>.</source>
          <target state="translated">Некоторые исключения выдаются независимо от значения <ph id="ph1">`throwOnError`</ph>.</target>       </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, if the type is found but cannot be loaded, a <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Например, если тип присутствует, но не может быть загружена <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> возникает, даже если <ph id="ph2">`throwOnError`</ph> — <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">В следующей таблице показаны, какие члены базового класса возвращаются <ph id="ph1">`Get`</ph> методов при отражении в типе.</target>       </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Member Type</source>
          <target state="translated">Тип члена</target>       </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Static</source>
          <target state="translated">Static</target>       </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Non-Static</source>
          <target state="translated">Нестатический</target>       </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Constructor</source>
          <target state="translated">Конструктор</target>       </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Field</source>
          <target state="translated">Поле</target>       </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Поле всегда равно по имени и подписи.</target>       </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Event</source>
          <target state="translated">событие</target>       </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Method</source>
          <target state="translated">Метод</target>       </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Yes.</source>
          <target state="translated">Да.</target>       </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.</target>       </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Nested Type</source>
          <target state="translated">Вложенный тип</target>       </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Property</source>
          <target state="translated">Свойство.</target>       </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Not applicable</source>
          <target state="translated">Неприменимо</target>       </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Правило системы общих типов является наследование же, что методы, которые реализуют свойство.</target>       </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Отражении свойства по имени и подписи.</target>       </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See note 2 below.</source>
          <target state="translated">См. Примечание 2 ниже.</target>       </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах.</target>       </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>This is a binary comparison.</source>
          <target state="translated">Это двоичное сравнение.</target>       </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Для отражения свойства и события, которые по имени и подписи.</target>       </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.</target>       </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Пользовательские атрибуты не являются частью системы общих типов.</target>       </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</source>
          <target state="translated">Массивы или COM-типов не производится, если они уже были загружены в таблицу доступных классов.</target>       </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`typeName`</ph> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</source>
          <target state="translated"><ph id="ph1">`typeName`</ph> может быть имя типа с указанием его пространство имен или имя с указанием сборки, которая включает спецификацию имени сборки.</target>       </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</source>
          <target state="translated">См. раздел <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</source>
          <target state="translated">Если <ph id="ph1">`typeName`</ph> включает пространство имен, но не имя сборки, этот метод выполняет поиск только в сборке вызывающего объекта и библиотеки Mscorlib.dll, в указанном порядке.</target>       </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</source>
          <target state="translated">Если полное имя сборки частичную или полную typeName, этот метод ищет в указанной сборке.</target>       </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the assembly has a strong name, a complete assembly name is required.</source>
          <target state="translated">Если сборка имеет строгое имя, требуется указать полное имя сборки.</target>       </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property returns a fully qualified type name including nested types, the assembly name, and type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> Свойство возвращает имя полного имени типа, включая вложенные типы, имя сборки и аргументы типа.</target>       </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
          <target state="translated">Все компиляторы, поддерживающие общеязыковая среда выполнения будет выдавать простое имя вложенного класса, а отражение создает искаженное имя, если запрос, в соответствии со следующими соглашениями.</target>       </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">В .NET Framework версии 2.0 архитектура процессора добавляется удостоверение сборки и может быть указан как часть строки имени сборки.</target>       </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">Например «ProcessorArchitecture = msil».</target>       </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
          <target state="translated">Однако он не включен в строку, возвращаемую <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> свойства для обеспечения совместимости.</target>       </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>You can also load types by creating an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and passing it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Можно также загрузить типы путем создания <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> объекта и передачи его в соответствующую перегрузку <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>You can then use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> method to load types from the assembly.</source>
          <target state="translated">Затем можно использовать <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы загрузить типы из сборки.</target>       </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See also <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">См. также раздел <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Delimiter</source>
          <target state="translated">разделитель</target>       </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Meaning</source>
          <target state="translated">Значение</target>       </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
          <target state="translated">Обратная косая черта (<ph id="ph1">\\</ph>)</target>       </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Escape character.</source>
          <target state="translated">Escape-символ.</target>       </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Backtick (`)</source>
          <target state="translated">Обратный апостроф (')</target>       </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</source>
          <target state="translated">Предшествует одной или нескольких цифр, представляющее число параметров типа, расположенное в конце имени универсального типа.</target>       </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Brackets ([])</source>
          <target state="translated">квадратные скобки ([])</target>       </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</source>
          <target state="translated">Заключите список аргументов универсального типа для сконструированного универсального типа; в список аргументов типа заключите типа с указанием сборки.</target>       </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Comma (,)</source>
          <target state="translated">Запятая ()</target>       </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Precedes the Assembly name.</source>
          <target state="translated">Предшествует имени сборки.</target>       </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Period (.)</source>
          <target state="translated">Точка (.)</target>       </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Denotes namespace identifiers.</source>
          <target state="translated">Определяет идентификаторы пространства имен.</target>       </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Plus sign (+)</source>
          <target state="translated">Знак плюс (+)</target>       </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Precedes a nested class.</source>
          <target state="translated">Перед вложенным классом.</target>       </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, the fully qualified name for a class might look like this:</source>
          <target state="translated">Например полное имя класса может выглядеть следующим образом:</target>       </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
          <target state="translated">Если было TopNamespace.Sub+Namespace, то строка будет иметь предшествовать знак плюс (+) с escape-символом (<ph id="ph1">\\</ph>), чтобы он не будет интерпретироваться как разделитель вложения.</target>       </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Reflection emits this string as follows:</source>
          <target state="translated">Отражение преобразует эту строку следующим образом:</target>       </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
          <target state="translated">Объект «++» становится «<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+» и»<ph id="ph4">\\</ph>«становится»<ph id="ph5">\\</ph><ph id="ph6">\\</ph>».</target>       </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Это полное имя можно сохранить и впоследствии использовано для загрузки <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
          <target state="translated">Чтобы найти и загрузить <ph id="ph1">&lt;xref:System.Type&gt;</ph>, используйте <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> либо с типом имени, либо только имя типа с указанием сборки.</target>       </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> с типом имя только будет искать <ph id="ph2">&lt;xref:System.Type&gt;</ph> в сборке вызывающего, а затем в системе сборки.</target>       </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> в сборке будет искать имя типа с указанием <ph id="ph2">&lt;xref:System.Type&gt;</ph> в любой сборке.</target>       </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
          <target state="translated">Имена типов могут включать конечные символы, определяющие дополнительные сведения о типе, например, является ли тип ссылочным типом, типом указателя или тип массива.</target>       </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
          <target state="translated">Чтобы получить имя типа без этих конечных символов, используйте <ph id="ph1">`t.GetElementType().ToString()`</ph>, где <ph id="ph2">`t`</ph> тип.</target>       </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
          <target state="translated">Пробелы учитываются во всех компонентах имени типа, за исключением имени сборки.</target>       </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
          <target state="translated">В имени сборки пробелы перед разделителем ',' учитываются, но пробелы после разделителя «,» игнорируются.</target>       </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The name of a generic type ends with a backtick (<ph id="ph1">\`</ph>) followed by digits representing the number of generic type arguments.</source>
          <target state="translated">Имя универсального типа заканчивается обратной кавычкой (<ph id="ph1">\`</ph>) следуют цифры, представляющее число аргументов универсального типа.</target>       </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</source>
          <target state="translated">Искажение имени предназначено для обеспечения поддержки универсальных типов с тем же именем, но с различным количеством параметров типа, выполняемых в той же области.</target>       </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, reflection returns the mangled names <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tuple<ph id="ph3">`2`</ph> from the generic methods <ph id="ph4">`Tuple(Of T)`</ph> and <ph id="ph5">`Tuple(Of T0, T1)`</ph> in Visual Basic, or <ph id="ph6">`Tuple&lt;T&gt;`</ph> and Tuple<ph id="ph7">`\&lt;T0, T1&gt;`</ph> in Visual C#.</source>
          <target state="translated">Например, отражения возвращает поврежденных имен <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>кортежа<ph id="ph3">`2`</ph> из универсальных методах <ph id="ph4">`Tuple(Of T)`</ph> и <ph id="ph5">`Tuple(Of T0, T1)`</ph> в Visual Basic или <ph id="ph6">`Tuple&lt;T&gt;`</ph> и кортежа<ph id="ph7">`\&lt;T0, T1&gt;`</ph> в Visual C#.</target>       </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</source>
          <target state="translated">Для универсальных типов список аргументов типа заключается в квадратные скобки и аргументы типа разделяются запятыми.</target>       </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, a generic <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> has two type parameters.</source>
          <target state="translated">Например, универсальный <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> имеет два параметра типа.</target>       </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph> might be represented as follows:</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> из <ph id="ph2">`MyType`</ph> с ключами типа <ph id="ph3">&lt;xref:System.String&gt;</ph> может быть представлен следующим образом:</target>       </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</source>
          <target state="translated">Для указания типа с указанием сборки в список аргументов типа, заключите тип сборки в квадратные скобки.</target>       </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</source>
          <target state="translated">Запятые, разделяющие части имени сборки, в противном случае интерпретируются как разделители дополнительных аргументов типа.</target>       </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> from MyAssembly.dll, with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph>, might be specified as follows:</source>
          <target state="translated">Например <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> из <ph id="ph2">`MyType`</ph> из MyAssembly.dll с ключами типа <ph id="ph3">&lt;xref:System.String&gt;</ph>, может быть указан следующим образом:</target>       </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</source>
          <target state="translated">Тип с указанием сборки можно заключать в скобки, только в том случае, когда он появится в списке параметров типа.</target>       </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</source>
          <target state="translated">Правила для поиска в сборках уточненных и неуточненных типы в списках параметров типа совпадают правилам для уточненных и неуточненных неуниверсальных типов.</target>       </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Nullable types are a special case of generic types.</source>
          <target state="translated">Типы, допускающие значения NULL являются особыми случаями универсальных типов.</target>       </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, a nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph> is represented by the string "System.Nullable`1[System.Int32]".</source>
          <target state="translated">Например, для типа <ph id="ph1">&lt;xref:System.Int32&gt;</ph> представленный строкой «System.Nullable'1[System.Int32]».</target>       </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In C#, C++, and Visual Basic you can also get nullable types using type operators.</source>
          <target state="translated">В C#, C++ и Visual Basic можно также получить с помощью операторов типов типы nullable.</target>       </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, the nullable <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> type is returned by <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> in C#, by <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++, and by <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.</source>
          <target state="translated">Например, типа <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> возвращаемый тип <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> в C#, <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> в C++ и по <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> в Visual Basic.</target>       </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The following table shows the syntax you use with <ph id="ph1">`GetType`</ph> for various types.</source>
          <target state="translated">В следующей таблице показаны синтаксис, можно использовать с <ph id="ph1">`GetType`</ph> для различных типов.</target>       </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To Get</source>
          <target state="translated">Для получения</target>       </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Use</source>
          <target state="translated">Использовать</target>       </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph></source>
          <target state="translated">Допускающие значения NULL <ph id="ph1">&lt;xref:System.Int32&gt;</ph></target>       </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</target>       </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An unmanaged pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Неуправляемый указатель <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An unmanaged pointer to a pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Неуправляемый указатель на указатель на <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A managed pointer or reference to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Управляемый указатель или ссылка на <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</target>       </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Note that unlike pointers, references are limited to one level.</source>
          <target state="translated">Обратите внимание, что ссылки, в отличие от указателей, ограничены одним уровнем.</target>       </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A parent class and a nested class</source>
          <target state="translated">Родительский класс и вложенного класса</target>       </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A one-dimensional array with a lower bound of 0</source>
          <target state="translated">Одномерный массив с нижней границей, равной 0</target>       </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A one-dimensional array with an unknown lower bound</source>
          <target state="translated">Одномерный массив с неизвестной нижней границей</target>       </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An n-dimensional array</source>
          <target state="translated">N мерный массив</target>       </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A comma (,) inside the brackets a total of n-1 times.</source>
          <target state="translated">Запятая (,) внутри квадратных скобок n-1 раз.</target>       </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, <ph id="ph1">`System.Object[,,]`</ph> represents a three-dimensional <ph id="ph2">`Object`</ph> array.</source>
          <target state="translated">Например <ph id="ph1">`System.Object[,,]`</ph> представляет трехмерный массив <ph id="ph2">`Object`</ph> массива.</target>       </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A two-dimensional array's array</source>
          <target state="translated">Двумерный массив массивов</target>       </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A rectangular two-dimensional array with unknown lower bounds</source>
          <target state="translated">Прямоугольный двухмерный массив с неизвестными нижними границами</target>       </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A generic type with one type argument</source>
          <target state="translated">Универсальный тип с одним аргументом типа</target>       </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")"</target>       </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A generic type with two type arguments</source>
          <target state="translated">Универсальный тип с двумя аргументами типа</target>       </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</target>       </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A generic type with two assembly-qualified type arguments</source>
          <target state="translated">Универсальный тип с двумя аргументами типа сборки</target>       </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</target>       </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An assembly-qualified generic type with an assembly-qualified type argument</source>
          <target state="translated">Сборки универсального типа с аргументом типа сборки</target>       </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</target>       </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A generic type whose type argument is a generic type with two type arguments</source>
          <target state="translated">Универсальный тип, имеющий аргумент типа является универсальным типом с двумя аргументами типа</target>       </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></target>       </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Инициализатор класса вызывается и создает исключение.</target>       </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и тип не найден.</target>       </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> содержит недопустимые знаки, например внедренные табуляции.</target>       </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> является пустой строкой.</target>       </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> представляет тип массива с недопустимым размером.</target>       </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет массив <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> содержит недопустимый синтаксис.</target>       </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, "MyType[,*,]".</source>
          <target state="translated">Например, "MyType[,*,]".</target>       </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет универсальный тип, имеющий тип указателя, тип <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> или <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> в качестве одного из его аргументов типа.</target>       </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет универсальный тип, который содержит неправильное количество аргументов типа.</target>       </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</target>       </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и не удалось найти сборку либо одну из ее зависимостей.</target>       </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">Сборка или одна из ее зависимостей найдена, но не может быть загружена.</target>       </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">Сборка или одна из ее зависимостей является недопустимой.</target>       </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</source>
          <target state="translated">В текущий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка была скомпилирована в более поздней версии.</target>       </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The name of the type to get.</source>
          <target state="translated">Имя получаемого типа.</target>       </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided, the type name can be any string that <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> is capable of resolving.</source>
          <target state="translated">Если задан параметр <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept>, имя типа может быть любой строкой, которую может разрешить <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided or if standard type resolution is used, <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> must be an assembly-qualified name (see <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">Если задан параметр <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> или используется стандартное разрешение типов, параметр <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> должен быть именем с указанием сборки (см. описание свойства <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>), кроме случаев, когда этот тип находится в текущей выполняемой сборке или в библиотеке Mscorlib.dll — тогда достаточно задать имя типа с указанием пространства имен.</target>       </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>A method that locates and returns the assembly that is specified in <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Метод, находящий и возвращающий сборку, заданную в параметре <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The assembly name is passed to <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> as an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object.</source>
          <target state="translated">Имя сборки передается методу <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> в виде объекта <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> does not contain the name of an assembly, <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> is not called.</source>
          <target state="translated">Если параметр <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> не содержит имя сборки, метод <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> не вызывается.</target>       </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> is not supplied, standard assembly resolution is performed.</source>
          <target state="translated">Если метод <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> не указан, выполняется стандартное разрешение сборки.</target>       </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей.</target>       </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Doing so could result in elevation of privilege for malicious code.</source>
          <target state="translated">В противном случае возможно повышение привилегий для вредоносного кода.</target>       </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Use only methods that you provide or that you are familiar with.</source>
          <target state="translated">Рекомендуется использовать только методы, предоставленные пользователями или знакомые им.</target>       </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>A method that locates and returns the type that is specified by <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> from the assembly that is returned by <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> or by standard assembly resolution.</source>
          <target state="translated">Метод, находящий и возвращающий тип, заданный в параметре <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>, из сборки, возвращенной методом <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> или стандартным методом разрешения сборки.</target>       </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If no assembly is provided, the <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> method can provide one.</source>
          <target state="translated">Если сборка не предоставлена, метод <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> может предоставить ее.</target>       </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The method also takes a parameter that specifies whether to perform a case-insensitive search; <ph id="ph1">&lt;see langword="false" /&gt;</ph> is passed to that parameter.</source>
          <target state="translated">Метод также принимает параметр, указывающий, следует ли выполнять поиск без учета регистра; этому параметру передается значение <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей.</target>       </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.</source>
          <target state="translated">Возвращает тип с указанным именем; дополнительно может предоставлять настраиваемые методы для разрешения сборки и типа.</target>       </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The type with the specified name, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the type is not found.</source>
          <target state="translated">Тип с указанным именем или значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>, если тип не найден.</target>       </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Usage scenarios for this method and details about the <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph> parameters can be found in the <ph id="ph3">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload.</source>
          <target state="translated">Сценарии использования для этого метода и сведения о <ph id="ph1">`assemblyResolver`</ph> и <ph id="ph2">`typeResolver`</ph> параметры можно найти в <ph id="ph3">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> перегрузки метода.</target>       </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If <ph id="ph1">`typeName`</ph> cannot be found, the call to the <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph> method returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Если <ph id="ph1">`typeName`</ph> не удается найти, вызов <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph> возвращает <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>It does not throw an exception.</source>
          <target state="translated">Он не вызывает исключение.</target>       </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>To control whether an exception is thrown, call an overload of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method that has a <ph id="ph2">`throwOnError`</ph> parameter.</source>
          <target state="translated">Для управления ли исключение, вызовите перегрузку <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> метода, имеющего <ph id="ph2">`throwOnError`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Calling this method overload is the same as calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id="ph2">`false`</ph> for the <ph id="ph3">`throwOnError`</ph> and <ph id="ph4">`ignoreCase`</ph> parameters.</source>
          <target state="translated">Вызов этой перегрузки метода является таким же, как вызов <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> перегруженный метод и указывая <ph id="ph2">`false`</ph> для <ph id="ph3">`throwOnError`</ph> и <ph id="ph4">`ignoreCase`</ph> параметров.</target>       </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Инициализатор класса вызывается и создает исключение.</target>       </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>An error occurs when <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</source>
          <target state="translated">Ошибка происходит при разборе <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> в имя типа и имя сборки (например, если простое имя типа содержит не преобразованный в escape-последовательность специальный знак).</target>       </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет универсальный тип, имеющий тип указателя, тип <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> или <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> в качестве одного из его аргументов типа.</target>       </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет универсальный тип, который содержит неправильное количество аргументов типа.</target>       </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</target>       </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет массив <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">Сборка или одна из ее зависимостей найдена, но не может быть загружена.</target>       </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> contains an invalid assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> содержит недопустимое имя сборки.</target>       </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is a valid assembly name without a type name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> является допустимым именем сборки без типа имени.</target>       </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">Сборка или одна из ее зависимостей является недопустимой.</target>       </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated">Сборка была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</target>       </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The name of the type to get.</source>
          <target state="translated">Имя получаемого типа.</target>       </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided, the type name can be any string that <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> is capable of resolving.</source>
          <target state="translated">Если задан параметр <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept>, имя типа может быть любой строкой, которую может разрешить <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided or if standard type resolution is used, <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> must be an assembly-qualified name (see <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">Если задан параметр <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> или используется стандартное разрешение типов, параметр <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> должен быть именем с указанием сборки (см. описание свойства <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>), кроме случаев, когда этот тип находится в текущей выполняемой сборке или в библиотеке Mscorlib.dll — тогда достаточно задать имя типа с указанием пространства имен.</target>       </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>A method that locates and returns the assembly that is specified in <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Метод, находящий и возвращающий сборку, заданную в параметре <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The assembly name is passed to <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> as an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object.</source>
          <target state="translated">Имя сборки передается методу <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> в виде объекта <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> does not contain the name of an assembly, <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> is not called.</source>
          <target state="translated">Если параметр <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> не содержит имя сборки, метод <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> не вызывается.</target>       </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> is not supplied, standard assembly resolution is performed.</source>
          <target state="translated">Если метод <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> не указан, выполняется стандартное разрешение сборки.</target>       </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей.</target>       </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Doing so could result in elevation of privilege for malicious code.</source>
          <target state="translated">В противном случае возможно повышение привилегий для вредоносного кода.</target>       </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Use only methods that you provide or that you are familiar with.</source>
          <target state="translated">Рекомендуется использовать только методы, предоставленные пользователями или знакомые им.</target>       </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>A method that locates and returns the type that is specified by <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> from the assembly that is returned by <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> or by standard assembly resolution.</source>
          <target state="translated">Метод, находящий и возвращающий тип, заданный в параметре <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>, из сборки, возвращенной методом <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> или стандартным методом разрешения сборки.</target>       </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If no assembly is provided, the method can provide one.</source>
          <target state="translated">Если сборка не предоставлена, этот метод может предоставить ее.</target>       </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The method also takes a parameter that specifies whether to perform a case-insensitive search; <ph id="ph1">&lt;see langword="false" /&gt;</ph> is passed to that parameter.</source>
          <target state="translated">Метод также принимает параметр, указывающий, следует ли выполнять поиск без учета регистра; этому параметру передается значение <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей.</target>       </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, чтобы создать исключение, если тип не удается найти; значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>, чтобы вернуть значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Specifying <ph id="ph1">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated">Кроме того, при указании значения <ph id="ph1">&lt;see langword="false" /&gt;</ph> подавляются некоторые другие условия возникновения исключений, но не все из них.</target>       </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">См. раздел "Исключения".</target>       </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</source>
          <target state="translated">Возвращает тип с заданным именем и указывает, следует ли создавать исключение в случае невозможности найти тип, а также может предоставлять настраиваемые методы для разрешения сборки и типа.</target>       </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The type with the specified name.</source>
          <target state="translated">Тип с указанным именем.</target>       </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">Если тип не найден, параметр <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> определяет дальнейшее действие — возврат значения <ph id="ph2">&lt;see langword="null" /&gt;</ph> или создание исключения.</target>       </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</source>
          <target state="translated">В некоторых случаях исключение создается независимо от значения параметра <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">См. раздел "Исключения".</target>       </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Usage scenarios for this method and details about the <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph> parameters can be found in the <ph id="ph3">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload.</source>
          <target state="translated">Сценарии использования для этого метода и сведения о <ph id="ph1">`assemblyResolver`</ph> и <ph id="ph2">`typeResolver`</ph> параметры можно найти в <ph id="ph3">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> перегрузки метода.</target>       </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Calling this method overload is the same as calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id="ph2">`false`</ph> for the <ph id="ph3">`ignoreCase`</ph> parameter.</source>
          <target state="translated">Вызов этой перегрузки метода является таким же, как вызов <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> перегруженный метод и указывая <ph id="ph2">`false`</ph> для <ph id="ph3">`ignoreCase`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Инициализатор класса вызывается и создает исключение.</target>       </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и тип не найден.</target>       </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> содержит недопустимые знаки, например внедренные табуляции.</target>       </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> является пустой строкой.</target>       </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> представляет тип массива с недопустимым размером.</target>       </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет массив <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>An error occurs when <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</source>
          <target state="translated">Ошибка происходит при разборе <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> в имя типа и имя сборки (например, если простое имя типа содержит не преобразованный в escape-последовательность специальный знак).</target>       </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax (for example, "MyType[,*,]").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> равно <ph id="ph2">&lt;see langword="true" /&gt;</ph>, а <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> содержит недопустимый синтаксис (например, «MyType[,*,]»).</target>       </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет универсальный тип, имеющий тип указателя, тип <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> или <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> в качестве одного из его аргументов типа.</target>       </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет универсальный тип, который содержит неправильное количество аргументов типа.</target>       </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</target>       </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и не удалось найти сборку либо одну из ее зависимостей.</target>       </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> contains an invalid assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> содержит недопустимое имя сборки.</target>       </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is a valid assembly name without a type name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> является допустимым именем сборки без типа имени.</target>       </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">Сборка или одна из ее зависимостей найдена, но не может быть загружена.</target>       </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">Сборка или одна из ее зависимостей является недопустимой.</target>       </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated">Сборка была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</target>       </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The name of the type to get.</source>
          <target state="translated">Имя получаемого типа.</target>       </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided, the type name can be any string that <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> is capable of resolving.</source>
          <target state="translated">Если задан параметр <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept>, имя типа может быть любой строкой, которую может разрешить <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided or if standard type resolution is used, <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> must be an assembly-qualified name (see <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">Если задан параметр <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> или используется стандартное разрешение типов, параметр <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> должен быть именем с указанием сборки (см. описание свойства <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>), кроме случаев, когда этот тип находится в текущей выполняемой сборке или в библиотеке Mscorlib.dll — тогда достаточно задать имя типа с указанием пространства имен.</target>       </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A method that locates and returns the assembly that is specified in <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Метод, находящий и возвращающий сборку, заданную в параметре <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly name is passed to <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> as an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object.</source>
          <target state="translated">Имя сборки передается методу <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> в виде объекта <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> does not contain the name of an assembly, <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> is not called.</source>
          <target state="translated">Если параметр <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> не содержит имя сборки, метод <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> не вызывается.</target>       </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> is not supplied, standard assembly resolution is performed.</source>
          <target state="translated">Если метод <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> не указан, выполняется стандартное разрешение сборки.</target>       </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей.</target>       </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Doing so could result in elevation of privilege for malicious code.</source>
          <target state="translated">В противном случае возможно повышение привилегий для вредоносного кода.</target>       </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Use only methods that you provide or that you are familiar with.</source>
          <target state="translated">Рекомендуется использовать только методы, предоставленные пользователями или знакомые им.</target>       </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A method that locates and returns the type that is specified by <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> from the assembly that is returned by <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> or by standard assembly resolution.</source>
          <target state="translated">Метод, находящий и возвращающий тип, заданный в параметре <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>, из сборки, возвращенной методом <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> или стандартным методом разрешения сборки.</target>       </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If no assembly is provided, the method can provide one.</source>
          <target state="translated">Если сборка не предоставлена, этот метод может предоставить ее.</target>       </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <bpt id="p1">&lt;c&gt;</bpt>ignoreCase<ept id="p1">&lt;/c&gt;</ept> is passed to that parameter.</source>
          <target state="translated">Метод также принимает параметр, указывающий, следует ли выполнять поиск без учета регистра; этому параметру передается значение <bpt id="p1">&lt;c&gt;</bpt>ignoreCase<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей.</target>       </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, чтобы создать исключение, если тип не удается найти; значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>, чтобы вернуть значение <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Specifying <ph id="ph1">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated">Кроме того, при указании значения <ph id="ph1">&lt;see langword="false" /&gt;</ph> подавляются некоторые другие условия возникновения исключений, но не все из них.</target>       </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">См. раздел "Исключения".</target>       </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a case-insensitive search for <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>, <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a case-sensitive search for <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, чтобы не учитывать регистр при поиске <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>; значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>, чтобы учитывать регистр при поиске <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</source>
          <target state="translated">Возвращает тип с заданным именем и указывает, следует ли выполнять поиск без учета регистра и следует ли создавать исключение в случае невозможности найти тип, а также может предоставлять настраиваемые методы для разрешения сборки и типа.</target>       </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The type with the specified name.</source>
          <target state="translated">Тип с указанным именем.</target>       </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">Если тип не найден, параметр <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> определяет дальнейшее действие — возврат значения <ph id="ph2">&lt;see langword="null" /&gt;</ph> или создание исключения.</target>       </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</source>
          <target state="translated">В некоторых случаях исключение создается независимо от значения параметра <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">См. раздел "Исключения".</target>       </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Use this method overload and its associated overloads (<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29&gt;</ph>) to replace the default implementation of the <ph id="ph3">&lt;xref:System.Type.GetType%2A&gt;</ph> method with more flexible implementations.</source>
          <target state="translated">Используйте перегрузку этого метода и связанные перегрузки (<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph> и <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29&gt;</ph>) для замены реализация по умолчанию <ph id="ph3">&lt;xref:System.Type.GetType%2A&gt;</ph> метод с более гибкой реализации.</target>       </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:</source>
          <target state="translated">Предоставляя свои собственные методы, которые разрешаются имена типов и сборок, содержащих их, можно сделать следующее:</target>       </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Control which version of an assembly a type is loaded from.</source>
          <target state="translated">Какие версия сборки тип загружается из элемента управления.</target>       </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Provide another place to look for a type name that does not include an assembly name.</source>
          <target state="translated">Укажите другое место для поиска имени типа, который не включает имя сборки.</target>       </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Load assemblies using partial assembly names.</source>
          <target state="translated">Загрузить сборки с помощью частичных имен сборок.</target>       </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Return subclasses of <ph id="ph1">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> that are not created by the common language runtime (CLR).</source>
          <target state="translated">Вернуть подклассы <ph id="ph1">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> , созданных без общеязыковой среды выполнения (CLR).</target>       </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>For example, in version-tolerant serialization this method enables you to search for a "best fit" assembly by using a partial name.</source>
          <target state="translated">Например в независимой от версий сериализации этот метод позволяет найти для сборки «оптимальных параметров» с использованием частичного имени.</target>       </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Other overloads of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method require an assembly-qualified type name, which includes the version number.</source>
          <target state="translated">Другие перегрузки <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> метода требуется имя типа с указанием сборки, которое включает номер версии.</target>       </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Alternate implementations of the type system may need to return subclasses of <ph id="ph1">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> that are not created by the CLR; all types that are returned by other overloads of the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> method are runtime types.</source>
          <target state="translated">Альтернативные реализации системы типов может потребоваться вернуть подклассы <ph id="ph1">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> , не созданы CLR; все типы, которые возвращаются другие перегрузки <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> метод являются типами среды выполнения.</target>       </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Usage Notes</source>
          <target state="translated">Примечания об использовании</target>       </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>This method overload and its associated overloads parse <ph id="ph1">`typeName`</ph> into the name of a type and the name of an assembly, and then resolve the names.</source>
          <target state="translated">Эта перегрузка метода и связанные перегрузки проанализировать <ph id="ph1">`typeName`</ph> в имя типа и имя сборки и затем разрешения имен.</target>       </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly.</source>
          <target state="translated">Разрешение имени сборки предшествует разрешению имени типа, так как имя типа должно быть разрешено в контексте сборки.</target>       </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If you are unfamiliar with the concept of assembly-qualified type names, see the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property.</source>
          <target state="translated">Если вы не знакомы с концепцией имен типов с указанием сборки, см. раздел <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> is not an assembly-qualified name, assembly resolution is skipped.</source>
          <target state="translated">Если <ph id="ph1">`typeName`</ph> не является именем с указанием сборки, разрешение сборки пропускается.</target>       </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the <ph id="ph1">`typeResolver`</ph> parameter.</source>
          <target state="translated">Неполные имена типов может быть разрешен в контексте Mscorlib.dll или текущей выполняемой сборке или при необходимости можно предоставить сборку в <ph id="ph1">`typeResolver`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the <bpt id="p1">[</bpt>Mixed Name Resolution<ept id="p1">](#mixed_name_resolution)</ept> section.</source>
          <target state="translated">Эффекты включая или исключая имя сборки для различных видов разрешение имен отображаются в виде таблицы <bpt id="p1">[</bpt>разрешение смешанных имен<ept id="p1">](#mixed_name_resolution)</ept> раздела.</target>       </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>General usage notes:</source>
          <target state="translated">Общие примечания по использованию:</target>       </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Do not pass methods to <ph id="ph1">`assemblyResolver`</ph> or <ph id="ph2">`typeResolver`</ph> if they come from unknown or untrusted callers.</source>
          <target state="translated">Не передавайте методы для <ph id="ph1">`assemblyResolver`</ph> или <ph id="ph2">`typeResolver`</ph> полученные из неизвестных или ненадежных вызывающих объектов.</target>       </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Use only methods that you provide or that you are familiar with.</source>
          <target state="translated">Рекомендуется использовать только методы, предоставленные пользователями или знакомые им.</target>       </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Using methods from unknown or untrusted callers could result in elevation of privilege for malicious code.</source>
          <target state="translated">С помощью методов из неизвестных или ненадежных вызывающих объектов может привести к повышение привилегий для вредоносного кода.</target>       </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If you omit the <ph id="ph1">`assemblyResolver`</ph> and/or <ph id="ph2">`typeResolver`</ph> parameters, the value of the <ph id="ph3">`throwOnError`</ph> parameter is passed to the methods that perform the default resolution.</source>
          <target state="translated">Если не указан <ph id="ph1">`assemblyResolver`</ph> и/или <ph id="ph2">`typeResolver`</ph> параметров, значение <ph id="ph3">`throwOnError`</ph> параметр передается методу, выполнять разрешение по умолчанию.</target>       </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`throwOnError`</ph> is <ph id="ph2">`true`</ph>, this method throws a <ph id="ph3">&lt;xref:System.TypeLoadException&gt;</ph> when <ph id="ph4">`typeResolver`</ph> returns <ph id="ph5">`null`</ph>, and a <ph id="ph6">&lt;xref:System.IO.FileNotFoundException&gt;</ph> when <ph id="ph7">`assemblyResolver`</ph> returns <ph id="ph8">`null`</ph>.</source>
          <target state="translated">Если <ph id="ph1">`throwOnError`</ph> — <ph id="ph2">`true`</ph>, этот метод создает исключение <ph id="ph3">&lt;xref:System.TypeLoadException&gt;</ph> при <ph id="ph4">`typeResolver`</ph> возвращает <ph id="ph5">`null`</ph>и <ph id="ph6">&lt;xref:System.IO.FileNotFoundException&gt;</ph> при <ph id="ph7">`assemblyResolver`</ph> возвращает <ph id="ph8">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>This method does not catch exceptions thrown by <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph>.</source>
          <target state="translated">Этот метод не перехватывает исключения, вызванные <ph id="ph1">`assemblyResolver`</ph> и <ph id="ph2">`typeResolver`</ph>.</target>       </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>You are responsible for any exceptions that are thrown by the resolver methods.</source>
          <target state="translated">Вы несете ответственность за любые исключения, вызванные методами распознавателя.</target>       </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Assemblies</source>
          <target state="translated">Разрешение сборок</target>       </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method receives an <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object, which is produced by parsing the string assembly name that is included in <ph id="ph3">`typeName`</ph>.</source>
          <target state="translated"><ph id="ph1">`assemblyResolver`</ph> Метод получает <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph> объекта, который создается путем синтаксического анализа строковое имя сборки, включенный в <ph id="ph3">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> does not contain an assembly name, <ph id="ph2">`assemblyResolver`</ph> is not called and <ph id="ph3">`null`</ph> is passed to <ph id="ph4">`typeResolver`</ph>.</source>
          <target state="translated">Если <ph id="ph1">`typeName`</ph> не содержит имени сборки <ph id="ph2">`assemblyResolver`</ph> не вызывается и <ph id="ph3">`null`</ph> передается <ph id="ph4">`typeResolver`</ph>.</target>       </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is not supplied, standard assembly probing is used to locate the assembly.</source>
          <target state="translated">Если <ph id="ph1">`assemblyResolver`</ph> не указан, стандартная сборкой проверка используется для обнаружения сборки.</target>       </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is provided, the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> method does not do standard probing; in that case you must ensure that your <ph id="ph3">`assemblyResolver`</ph> can handle all the assemblies you pass to it.</source>
          <target state="translated">Если <ph id="ph1">`assemblyResolver`</ph> предоставляется, <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> метод не выполняет стандартные проверки; в этом случае необходимо убедиться, что ваш <ph id="ph3">`assemblyResolver`</ph> может обрабатывать все сборки, передайте в него.</target>       </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method should return <ph id="ph2">`null`</ph> if the assembly cannot be resolved.</source>
          <target state="translated"><ph id="ph1">`assemblyResolver`</ph> Метод должен возвращать <ph id="ph2">`null`</ph> если сборку не удается разрешить.</target>       </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> returns <ph id="ph2">`null`</ph>, <ph id="ph3">`typeResolver`</ph> is not called and no further processing occurs; additionally, if <ph id="ph4">`throwOnError`</ph> is <ph id="ph5">`true`</ph>, a <ph id="ph6">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">Если <ph id="ph1">`assemblyResolver`</ph> возвращает <ph id="ph2">`null`</ph>, <ph id="ph3">`typeResolver`</ph> не вызывается и дальнейшая обработка происходит; Кроме того, если <ph id="ph4">`throwOnError`</ph> — <ph id="ph5">`true`</ph>, <ph id="ph6">&lt;xref:System.IO.FileNotFoundException&gt;</ph> возникает исключение.</target>       </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> that is passed to <ph id="ph2">`assemblyResolver`</ph> is a partial name, one or more of its parts are <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> , передаваемое в <ph id="ph2">`assemblyResolver`</ph> является частичным имя для одного или нескольких частей, <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>For example, if it has no version, the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph> property is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Например, если он не имеет версии <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph> свойство <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph> property, the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CultureInfo%2A&gt;</ph> property, and the <ph id="ph3">&lt;xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A&gt;</ph> method all return <ph id="ph4">`null`</ph>, then only the simple name of the assembly was supplied.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph> свойства <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CultureInfo%2A&gt;</ph> свойство и <ph id="ph3">&lt;xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A&gt;</ph> метод возвращают <ph id="ph4">`null`</ph>, то простое имя сборки был предоставлен.</target>       </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method can use or ignore all parts of the assembly name.</source>
          <target state="translated"><ph id="ph1">`assemblyResolver`</ph> Метод может использовать или игнорировать все части имени сборки.</target>       </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The effects of different assembly resolution options are displayed as a table in the <bpt id="p1">[</bpt>Mixed Name Resolution<ept id="p1">](#mixed_name_resolution)</ept> section, for simple and assembly-qualified type names.</source>
          <target state="translated">Эффекты различных параметров разрешения сборок, отображаются в виде таблицы <bpt id="p1">[</bpt>разрешение смешанных имен<ept id="p1">](#mixed_name_resolution)</ept> раздел для имен типов простых и сборки.</target>       </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Types</source>
          <target state="translated">Разрешение типов</target>       </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> does not specify an assembly name, <ph id="ph2">`typeResolver`</ph> is always called.</source>
          <target state="translated">Если <ph id="ph1">`typeName`</ph> не соответствует имени сборки <ph id="ph2">`typeResolver`</ph> всегда вызываются.</target>       </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> specifies an assembly name, <ph id="ph2">`typeResolver`</ph> is called only when the assembly name is successfully resolved.</source>
          <target state="translated">Если <ph id="ph1">`typeName`</ph> указывает имя сборки, <ph id="ph2">`typeResolver`</ph> вызывается только в том случае, когда имя сборки успешно разрешен.</target>       </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> or standard assembly probing returns <ph id="ph2">`null`</ph>, <ph id="ph3">`typeResolver`</ph> is not called.</source>
          <target state="translated">Если <ph id="ph1">`assemblyResolver`</ph> или проверка возвращает стандартные сборки <ph id="ph2">`null`</ph>, <ph id="ph3">`typeResolver`</ph> не вызывается.</target>       </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`typeResolver`</ph> method receives three arguments:</source>
          <target state="translated"><ph id="ph1">`typeResolver`</ph> Метод принимает три аргумента:</target>       </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly to search or <ph id="ph1">`null`</ph> if <ph id="ph2">`typeName`</ph> does not contain an assembly name.</source>
          <target state="translated">Сборка для поиска или <ph id="ph1">`null`</ph> Если <ph id="ph2">`typeName`</ph> не содержит имя сборки.</target>       </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The simple name of the type.</source>
          <target state="translated">Простое имя типа.</target>       </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>In the case of a nested type, this is the outermost containing type.</source>
          <target state="translated">В случае вложенный тип это внешнего содержащего типа.</target>       </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>In the case of a generic type, this is the simple name of the generic type.</source>
          <target state="translated">В случае универсального типа это простое имя универсального типа.</target>       </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A Boolean value that is <ph id="ph1">`true`</ph> if the case of type names is to be ignored.</source>
          <target state="translated">Логическое значение, которое является <ph id="ph1">`true`</ph> Если нужно игнорировать регистр имен типов.</target>       </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The implementation determines the way these arguments are used.</source>
          <target state="translated">Реализация определяет способ использования этих аргументов.</target>       </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`typeResolver`</ph> method should return <ph id="ph2">`null`</ph> if it cannot resolve the type.</source>
          <target state="translated"><ph id="ph1">`typeResolver`</ph> Метод должен возвращать <ph id="ph2">`null`</ph> при невозможности разрешить тип.</target>       </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeResolver`</ph> returns <ph id="ph2">`null`</ph> and <ph id="ph3">`throwOnError`</ph> is <ph id="ph4">`true`</ph>, this overload of <ph id="ph5">&lt;xref:System.Type.GetType%2A&gt;</ph> throws a <ph id="ph6">&lt;xref:System.TypeLoadException&gt;</ph>.</source>
          <target state="translated">Если <ph id="ph1">`typeResolver`</ph> возвращает <ph id="ph2">`null`</ph> и <ph id="ph3">`throwOnError`</ph> — <ph id="ph4">`true`</ph>, эта перегрузка <ph id="ph5">&lt;xref:System.Type.GetType%2A&gt;</ph> вызывает <ph id="ph6">&lt;xref:System.TypeLoadException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The effects of different type resolution options are displayed as a table in the <bpt id="p1">[</bpt>Mixed Name Resolution<ept id="p1">](#mixed_name_resolution)</ept> section, for simple and assembly-qualified type names.</source>
          <target state="translated">Эффекты различных параметров разрешения типов отображены в виде таблицы <bpt id="p1">[</bpt>разрешение смешанных имен<ept id="p1">](#mixed_name_resolution)</ept> раздел для имен типов простых и сборки.</target>       </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Nested Types</source>
          <target state="translated">Разрешение вложенных типов</target>       </trans-unit>
        <trans-unit id="2904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> is a nested type, only the name of the outermost containing type is passed to <ph id="ph2">`typeResolver`</ph>.</source>
          <target state="translated">Если <ph id="ph1">`typeName`</ph> является вложенным типом, только имя самой внешней содержащий тип передается <ph id="ph2">`typeResolver`</ph>.</target>       </trans-unit>
        <trans-unit id="2905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>When <ph id="ph1">`typeResolver`</ph> returns this type, the <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph> method is called recursively until the innermost nested type has been resolved.</source>
          <target state="translated">Когда <ph id="ph1">`typeResolver`</ph> возвращаемый тип, <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph> метод вызывается рекурсивно, пока не будет устранена внутренней вложенного типа.</target>       </trans-unit>
        <trans-unit id="2906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Generic Types</source>
          <target state="translated">Разрешение универсальных типов</target>       </trans-unit>
        <trans-unit id="2907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> Вызывается рекурсивно для разрешения универсальных типов: сначала разрешается сам универсальный тип, а затем его аргументов типа.</target>       </trans-unit>
        <trans-unit id="2908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If a type argument is generic, <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> is called recursively to resolve its type arguments, and so on.</source>
          <target state="translated">Если аргумент типа является универсальным, <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> вызывается рекурсивно для разрешения его аргументов типа и т. д.</target>       </trans-unit>
        <trans-unit id="2909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The combination of <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph> that you provide must be capable of resolving all levels of this recursion.</source>
          <target state="translated">Сочетание <ph id="ph1">`assemblyResolver`</ph> и <ph id="ph2">`typeResolver`</ph> предоставить должен быть может разрешить все уровни Косвенная рекурсия.</target>       </trans-unit>
        <trans-unit id="2910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>For example, suppose you supply an <ph id="ph1">`assemblyResolver`</ph> that controls the loading of <ph id="ph2">`MyAssembly`</ph>.</source>
          <target state="translated">Например, предположим, что указывается <ph id="ph1">`assemblyResolver`</ph> загрузки, который управляет <ph id="ph2">`MyAssembly`</ph>.</target>       </trans-unit>
        <trans-unit id="2911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Suppose you want to resolve the generic type <ph id="ph1">`Dictionary&lt;string, MyType&gt;`</ph> (<ph id="ph2">`Dictionary(Of String, MyType)`</ph> in Visual Basic).</source>
          <target state="translated">Предположим, что нужно определить общий тип <ph id="ph1">`Dictionary&lt;string, MyType&gt;`</ph> (<ph id="ph2">`Dictionary(Of String, MyType)`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="2912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>You might pass the following generic type name:</source>
          <target state="translated">Можно передать следующее имя универсального типа:</target>       </trans-unit>
        <trans-unit id="2913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Notice that <ph id="ph1">`MyType`</ph> is the only assembly-qualified type argument.</source>
          <target state="translated">Обратите внимание, что <ph id="ph1">`MyType`</ph> — это аргумент только типа сборки.</target>       </trans-unit>
        <trans-unit id="2914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The names of the <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> and <ph id="ph2">&lt;xref:System.String&gt;</ph> classes are not assembly-qualified.</source>
          <target state="translated">Имена <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> и <ph id="ph2">&lt;xref:System.String&gt;</ph> классы не являются сборки.</target>       </trans-unit>
        <trans-unit id="2915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Your <ph id="ph1">`typeResolver`</ph> must be able handle either an assembly or <ph id="ph2">`null`</ph>, because it will receive <ph id="ph3">`null`</ph> for <ph id="ph4">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> and <ph id="ph5">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">Ваш <ph id="ph1">`typeResolver`</ph> должны быть способны выполнять обработку либо сборки или <ph id="ph2">`null`</ph>, так как он будет получать <ph id="ph3">`null`</ph> для <ph id="ph4">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> и <ph id="ph5">&lt;xref:System.String&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>It can handle that case by calling an overload of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:</source>
          <target state="translated">Он может обрабатывать этот случай путем вызова перегрузки <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> метод, который принимает строку, так как оба неполные имена типов в библиотеке Mscorlib.dll:</target>       </trans-unit>
        <trans-unit id="2917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method is not called for the dictionary type and the string type, because those type names are not assembly-qualified.</source>
          <target state="translated"><ph id="ph1">`assemblyResolver`</ph> Метод не вызывается для типа словаря и строкового типа, так как эти имена типов не сборки.</target>       </trans-unit>
        <trans-unit id="2918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Now suppose that instead of <ph id="ph1">`System.String`</ph>, the first generic argument type is <ph id="ph2">`YourType`</ph>, from <ph id="ph3">`YourAssembly`</ph>:</source>
          <target state="translated">Теперь предположим, что вместо <ph id="ph1">`System.String`</ph>, первого аргумента универсального типа <ph id="ph2">`YourType`</ph>, из <ph id="ph3">`YourAssembly`</ph>:</target>       </trans-unit>
        <trans-unit id="2919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve <ph id="ph1">`YourType`</ph> without an assembly-qualified name.</source>
          <target state="translated">Так как эта сборка не Mscorlib.dll текущей выполняемой сборке, не удается разрешить <ph id="ph1">`YourType`</ph> без имени сборки.</target>       </trans-unit>
        <trans-unit id="2920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Because your <ph id="ph1">`assemblyResolve`</ph> will be called recursively, it must be able to handle this case.</source>
          <target state="translated">Так как ваш <ph id="ph1">`assemblyResolve`</ph> будет вызывается рекурсивно, он должен иметь возможность этот случай.</target>       </trans-unit>
        <trans-unit id="2921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Instead of returning <ph id="ph1">`null`</ph> for assemblies other than <ph id="ph2">`MyAssembly`</ph>, it now performs an assembly load using the supplied <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object.</source>
          <target state="translated">Вместо возвращения <ph id="ph1">`null`</ph> для сборок, отличных от <ph id="ph2">`MyAssembly`</ph>, она теперь выполняет загрузку сборки с помощью предоставленного <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="2922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Back to <bpt id="p1">[</bpt>Usage Notes<ept id="p1">](#usage_notes)</ept>.</source>
          <target state="translated">К <bpt id="p1">[</bpt>заметки по использованию<ept id="p1">](#usage_notes)</ept>.</target>       </trans-unit>
        <trans-unit id="2923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Type Names with Special Characters</source>
          <target state="translated">Разрешение имен типов, содержащий специальные символы</target>       </trans-unit>
        <trans-unit id="2924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Certain characters have special meanings in assembly-qualified names.</source>
          <target state="translated">Некоторые символы имеют специальное значение в именах с указанием сборки.</target>       </trans-unit>
        <trans-unit id="2925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name.</source>
          <target state="translated">Если имя простого типа содержит эти символы, они вызовут ошибки синтаксического анализа при простое имя является частью имени сборки.</target>       </trans-unit>
        <trans-unit id="2926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method.</source>
          <target state="translated">Во избежание ошибок синтаксического анализа, необходимо экранировать специальные символы, обратную косую черту, прежде чем можно передать имя с указанием сборки для <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>For example, if a type is named <ph id="ph1">`Strange]Type`</ph>, the escape character must be added ahead of the square bracket as follows: <ph id="ph2">`Strange\]Type`</ph>.</source>
          <target state="translated">Например, если тип имеет имя <ph id="ph1">`Strange]Type`</ph>, escape-символ должны добавляться раньше квадратная скобка следующим образом: <ph id="ph2">`Strange\]Type`</ph>.</target>       </trans-unit>
        <trans-unit id="2928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies.</source>
          <target state="translated">Имена с такими специальными символами нельзя создать в Visual Basic или C#, но можно создать с помощью промежуточного языка Майкрософт (MSIL) или путем создания динамических сборок.</target>       </trans-unit>
        <trans-unit id="2929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The following table shows the special characters for type names.</source>
          <target state="translated">В следующей таблице показаны специальные символы для имен типов.</target>       </trans-unit>
        <trans-unit id="2930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Character</source>
          <target state="translated">Знак</target>       </trans-unit>
        <trans-unit id="2931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Meaning</source>
          <target state="translated">Значение</target>       </trans-unit>
        <trans-unit id="2932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`,`</ph> (comma)</source>
          <target state="translated"><ph id="ph1">`,`</ph> (запятая)</target>       </trans-unit>
        <trans-unit id="2933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Delimiter for assembly-qualified names.</source>
          <target state="translated">Разделитель для имен сборки.</target>       </trans-unit>
        <trans-unit id="2934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`[]`</ph> (square brackets)</source>
          <target state="translated"><ph id="ph1">`[]`</ph> (квадратные скобки)</target>       </trans-unit>
        <trans-unit id="2935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.</source>
          <target state="translated">Как пара суффиксов указывает тип массива; как пара разделителей заключает списки универсальных аргументов и имена с указанием сборки.</target>       </trans-unit>
        <trans-unit id="2936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`&amp;`</ph> (ampersand)</source>
          <target state="translated"><ph id="ph1">`&amp;`</ph> (амперсанд)</target>       </trans-unit>
        <trans-unit id="2937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>As a suffix, indicates that a type is a reference type.</source>
          <target state="translated">Как суффикс указывает, что тип является ссылочным типом.</target>       </trans-unit>
        <trans-unit id="2938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`*`</ph> (asterisk)</source>
          <target state="translated"><ph id="ph1">`*`</ph> (звездочка)</target>       </trans-unit>
        <trans-unit id="2939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>As a suffix, indicates that a type is a pointer type.</source>
          <target state="translated">Как суффикс указывает, что тип является типом указателя.</target>       </trans-unit>
        <trans-unit id="2940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`+`</ph> (plus)</source>
          <target state="translated"><ph id="ph1">`+`</ph> (плюс)</target>       </trans-unit>
        <trans-unit id="2941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Delimiter for nested types.</source>
          <target state="translated">Разделитель для вложенных типов.</target>       </trans-unit>
        <trans-unit id="2942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`\`</ph> (backslash)</source>
          <target state="translated"><ph id="ph1">`\`</ph> (обратная косая черта)</target>       </trans-unit>
        <trans-unit id="2943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Escape character.</source>
          <target state="translated">Escape-символ.</target>       </trans-unit>
        <trans-unit id="2944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Properties such as <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> return correctly escaped strings.</source>
          <target state="translated">Такие свойства, как <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> возвращают правильно escape-строк.</target>       </trans-unit>
        <trans-unit id="2945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>You must pass correctly escaped strings to the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method.</source>
          <target state="translated">Необходимо передать правильно escape-строк для <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="2946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>In turn, the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method passes correctly escaped names to <ph id="ph2">`typeResolver`</ph> and to the default type resolution methods.</source>
          <target state="translated">В свою очередь <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> метод передает правильно дублирующие имена для <ph id="ph2">`typeResolver`</ph> и методы разрешения типа по умолчанию.</target>       </trans-unit>
        <trans-unit id="2947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If you need to compare a name to an unescaped name in <ph id="ph1">`typeResolver`</ph>, you must remove the escape characters.</source>
          <target state="translated">Если необходимо сравнить имя с escape-последовательность имя в <ph id="ph1">`typeResolver`</ph>, необходимо удалить escape-символы.</target>       </trans-unit>
        <trans-unit id="2948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Back to <bpt id="p1">[</bpt>Usage Notes<ept id="p1">](#usage_notes)</ept>.</source>
          <target state="translated">К <bpt id="p1">[</bpt>заметки по использованию<ept id="p1">](#usage_notes)</ept>.</target>       </trans-unit>
        <trans-unit id="2949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Mixed Name Resolution</source>
          <target state="translated">Разрешение смешанных имен</target>       </trans-unit>
        <trans-unit id="2950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The following table summarizes the interactions between <ph id="ph1">`assemblyResolver`</ph>, <ph id="ph2">`typeResolver`</ph>, and default name resolution, for all combinations of type name and assembly name in <ph id="ph3">`typeName`</ph>:</source>
          <target state="translated">В следующей таблице перечислены взаимодействия между <ph id="ph1">`assemblyResolver`</ph>, <ph id="ph2">`typeResolver`</ph>и разрешение имен по умолчанию, для всех сочетаний имени типа и имя сборки в <ph id="ph3">`typeName`</ph>:</target>       </trans-unit>
        <trans-unit id="2951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Contents of type name</source>
          <target state="translated">Имя типа содержимого</target>       </trans-unit>
        <trans-unit id="2952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Assembly resolver method</source>
          <target state="translated">Метод распознавателя сборок</target>       </trans-unit>
        <trans-unit id="2953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Type resolver method</source>
          <target state="translated">Метод сопоставления имен типа</target>       </trans-unit>
        <trans-unit id="2954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Result</source>
          <target state="translated">Результат</target>       </trans-unit>
        <trans-unit id="2955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type, assembly</source>
          <target state="translated">тип сборки</target>       </trans-unit>
        <trans-unit id="2956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">null</target>       </trans-unit>
        <trans-unit id="2957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">null</target>       </trans-unit>
        <trans-unit id="2958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Equivalent to calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Аналогичен вызову <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> перегрузки метода.</target>       </trans-unit>
        <trans-unit id="2959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type, assembly</source>
          <target state="translated">тип сборки</target>       </trans-unit>
        <trans-unit id="2960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">предоставленный</target>       </trans-unit>
        <trans-unit id="2961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">null</target>       </trans-unit>
        <trans-unit id="2962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`assemblyResolver`</ph> returns the assembly or returns <ph id="ph2">`null`</ph> if it cannot resolve the assembly.</source>
          <target state="translated"><ph id="ph1">`assemblyResolver`</ph> Возвращает сборку, или возвращает <ph id="ph2">`null`</ph> при невозможности разрешить сборку.</target>       </trans-unit>
        <trans-unit id="2963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the assembly is resolved, the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.</source>
          <target state="translated">Если сборка не будет разрешена, <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> должен быть загружен тип из сборки используется перегрузка метода; в противном случае — нет не пытается разрешить тип.</target>       </trans-unit>
        <trans-unit id="2964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type, assembly</source>
          <target state="translated">тип сборки</target>       </trans-unit>
        <trans-unit id="2965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">null</target>       </trans-unit>
        <trans-unit id="2966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">предоставленный</target>       </trans-unit>
        <trans-unit id="2967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Equivalent to converting the assembly name to an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and calling the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType&gt;</ph> method overload to get the assembly.</source>
          <target state="translated">Эквивалентен преобразованию имя сборки в <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> объекта и вызывая метод <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType&gt;</ph> перегрузка метода для получения сборки.</target>       </trans-unit>
        <trans-unit id="2968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the assembly is resolved, it is passed to <ph id="ph1">`typeResolver`</ph>; otherwise, <ph id="ph2">`typeResolver`</ph> is not called and there is no further attempt to resolve the type.</source>
          <target state="translated">Если сборка разрешается, оно передается <ph id="ph1">`typeResolver`</ph>; в противном случае <ph id="ph2">`typeResolver`</ph> не вызывается и дальнейшая попытка разрешить тип.</target>       </trans-unit>
        <trans-unit id="2969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type, assembly</source>
          <target state="translated">тип сборки</target>       </trans-unit>
        <trans-unit id="2970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">предоставленный</target>       </trans-unit>
        <trans-unit id="2971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">предоставленный</target>       </trans-unit>
        <trans-unit id="2972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`assemblyResolver`</ph> returns the assembly or returns <ph id="ph2">`null`</ph> if it cannot resolve the assembly.</source>
          <target state="translated"><ph id="ph1">`assemblyResolver`</ph> Возвращает сборку, или возвращает <ph id="ph2">`null`</ph> при невозможности разрешить сборку.</target>       </trans-unit>
        <trans-unit id="2973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the assembly is resolved, it is passed to <ph id="ph1">`typeResolver`</ph>; otherwise, <ph id="ph2">`typeResolver`</ph> is not called and there is no further attempt to resolve the type.</source>
          <target state="translated">Если сборка разрешается, оно передается <ph id="ph1">`typeResolver`</ph>; в противном случае <ph id="ph2">`typeResolver`</ph> не вызывается и дальнейшая попытка разрешить тип.</target>       </trans-unit>
        <trans-unit id="2974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type</source>
          <target state="translated">тип</target>       </trans-unit>
        <trans-unit id="2975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null, provided</source>
          <target state="translated">значение NULL, в который</target>       </trans-unit>
        <trans-unit id="2976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">null</target>       </trans-unit>
        <trans-unit id="2977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Equivalent to calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Аналогичен вызову <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> перегрузки метода.</target>       </trans-unit>
        <trans-unit id="2978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Because the assembly name is not provided, only Mscorlib.dll and the currently executing assembly are searched.</source>
          <target state="translated">Поскольку имя сборки не указан, поиск только библиотеки Mscorlib.dll и текущей выполняемой сборке.</target>       </trans-unit>
        <trans-unit id="2979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is provided, it is ignored.</source>
          <target state="translated">Если <ph id="ph1">`assemblyResolver`</ph> не предоставлен, он игнорируется.</target>       </trans-unit>
        <trans-unit id="2980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type</source>
          <target state="translated">type</target>       </trans-unit>
        <trans-unit id="2981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null, provided</source>
          <target state="translated">значение NULL, в который</target>       </trans-unit>
        <trans-unit id="2982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">предоставленный</target>       </trans-unit>
        <trans-unit id="2983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`typeResolver`</ph> is called, and <ph id="ph2">`null`</ph> is passed for the assembly.</source>
          <target state="translated"><ph id="ph1">`typeResolver`</ph> вызывается, и <ph id="ph2">`null`</ph> передается для сборки.</target>       </trans-unit>
        <trans-unit id="2984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`typeResolver`</ph> can provide a type from any assembly, including assemblies it loads for the purpose.</source>
          <target state="translated"><ph id="ph1">`typeResolver`</ph> можно предоставить тип из любой сборки, включая сборки, загружаемые для этой цели.</target>       </trans-unit>
        <trans-unit id="2985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is provided, it is ignored.</source>
          <target state="translated">Если <ph id="ph1">`assemblyResolver`</ph> не предоставлен, он игнорируется.</target>       </trans-unit>
        <trans-unit id="2986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>assembly</source>
          <target state="translated">сборка</target>       </trans-unit>
        <trans-unit id="2987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null, provided</source>
          <target state="translated">значение NULL, в который</target>       </trans-unit>
        <trans-unit id="2988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null, provided</source>
          <target state="translated">значение NULL, в который</target>       </trans-unit>
        <trans-unit id="2989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> создается исключение, так как имя сборки проанализировать, как если бы оно является именем типа с указанием сборки.</target>       </trans-unit>
        <trans-unit id="2990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>This results in an invalid assembly name.</source>
          <target state="translated">Это приводит к недопустимое имя сборки.</target>       </trans-unit>
        <trans-unit id="2991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Back to: <bpt id="p1">[</bpt>Usage Notes<ept id="p1">](#usage_notes)</ept>, <bpt id="p2">[</bpt>Resolving Assemblies<ept id="p2">](#resolving_assemblies)</ept>, <bpt id="p3">[</bpt>Resolving Types<ept id="p3">](#resolving_types)</ept>.</source>
          <target state="translated">Обратно: <bpt id="p1">[</bpt>заметки по использованию<ept id="p1">](#usage_notes)</ept>, <bpt id="p2">[</bpt>разрешении сборок<ept id="p2">](#resolving_assemblies)</ept>, <bpt id="p3">[</bpt>разрешения типов<ept id="p3">](#resolving_types)</ept>.</target>       </trans-unit>
        <trans-unit id="2992" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2993" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Инициализатор класса вызывается и создает исключение.</target>       </trans-unit>
        <trans-unit id="2994" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и тип не найден.</target>       </trans-unit>
        <trans-unit id="2995" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2996" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> содержит недопустимые знаки, например внедренные табуляции.</target>       </trans-unit>
        <trans-unit id="2997" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="2998" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> является пустой строкой.</target>       </trans-unit>
        <trans-unit id="2999" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3000" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> представляет тип массива с недопустимым размером.</target>       </trans-unit>
        <trans-unit id="3001" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3002" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет массив <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3003" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>An error occurs when <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</source>
          <target state="translated">Ошибка происходит при разборе <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> в имя типа и имя сборки (например, если простое имя типа содержит не преобразованный в escape-последовательность специальный знак).</target>       </trans-unit>
        <trans-unit id="3004" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3005" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax (for example, "MyType[,*,]").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> равно <ph id="ph2">&lt;see langword="true" /&gt;</ph>, а <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> содержит недопустимый синтаксис (например, «MyType[,*,]»).</target>       </trans-unit>
        <trans-unit id="3006" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3007" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет универсальный тип, имеющий тип указателя, тип <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> или <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> в качестве одного из его аргументов типа.</target>       </trans-unit>
        <trans-unit id="3008" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3009" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет универсальный тип, который содержит неправильное количество аргументов типа.</target>       </trans-unit>
        <trans-unit id="3010" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3011" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</target>       </trans-unit>
        <trans-unit id="3012" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и не удалось найти сборку либо одну из ее зависимостей.</target>       </trans-unit>
        <trans-unit id="3013" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">Сборка или одна из ее зависимостей найдена, но не может быть загружена.</target>       </trans-unit>
        <trans-unit id="3014" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3015" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> contains an invalid assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> содержит недопустимое имя сборки.</target>       </trans-unit>
        <trans-unit id="3016" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3017" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is a valid assembly name without a type name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> является допустимым именем сборки без типа имени.</target>       </trans-unit>
        <trans-unit id="3018" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">Сборка или одна из ее зависимостей является недопустимой.</target>       </trans-unit>
        <trans-unit id="3019" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3020" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated">Сборка была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</target>       </trans-unit>
        <trans-unit id="3021" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>An array of objects whose types to determine.</source>
          <target state="translated">Массив объектов, типы которых нужно определить.</target>       </trans-unit>
        <trans-unit id="3022" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>Gets the types of the objects in the specified array.</source>
          <target state="translated">Возвращает типы объектов в указанном массиве.</target>       </trans-unit>
        <trans-unit id="3023" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the types of the corresponding elements in <ph id="ph2">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющих типы соответствующих элементов в массиве <ph id="ph2">&lt;paramref name="args" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.Type.GetTypeArray%2A&gt;</ph> method to list the types of the elements of an array.</source>
          <target state="translated">В следующем примере кода демонстрируется использование <ph id="ph1">&lt;xref:System.Type.GetTypeArray%2A&gt;</ph> метод, чтобы вывести список элементов массива.</target>       </trans-unit>
        <trans-unit id="3025" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source><ph id="ph1">&lt;paramref name="args" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="args" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3026" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3027" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>One or more of the elements in <ph id="ph1">&lt;paramref name="args" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Один или несколько элементов в <ph id="ph1">&lt;paramref name="args" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3028" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>The class initializers are invoked and at least one throws an exception.</source>
          <target state="translated">Вызываются инициализаторы класса, и по крайней мере один из них создает исключение.</target>       </trans-unit>
        <trans-unit id="3029" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>The type whose underlying type code to get.</source>
          <target state="translated">Тип, код базового типа которого требуется получить.</target>       </trans-unit>
        <trans-unit id="3030" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>Gets the underlying type code of the specified <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает код базового типа указанного объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3031" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>The code of the underlying type, or <ph id="ph1">&lt;see cref="F:System.TypeCode.Empty" /&gt;</ph> if <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Код базового типа или <ph id="ph1">&lt;see cref="F:System.TypeCode.Empty" /&gt;</ph>, если <ph id="ph2">&lt;paramref name="type" /&gt;</ph> — <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>When you inherit from <ph id="ph1">&lt;xref:System.Type&gt;</ph>, you can change the behavior of this method by overriding the <ph id="ph2">&lt;xref:System.Type.GetTypeCodeImpl%2A&gt;</ph> method.</source>
          <target state="translated">При наследовании от <ph id="ph1">&lt;xref:System.Type&gt;</ph>, поведение этого метода можно изменить путем переопределения <ph id="ph2">&lt;xref:System.Type.GetTypeCodeImpl%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>The following code example demonstrates how the <ph id="ph1">&lt;xref:System.TypeCode&gt;</ph> enumeration can be used.</source>
          <target state="translated">В следующем примере кода показано, как <ph id="ph1">&lt;xref:System.TypeCode&gt;</ph> перечисления может использоваться.</target>       </trans-unit>
        <trans-unit id="3034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>In a decision block inside the <ph id="ph1">`WriteObjectInfo`</ph> method, the <ph id="ph2">&lt;xref:System.TypeCode&gt;</ph> of an <ph id="ph3">&lt;xref:System.Object&gt;</ph> parameter is examined, and an appropriate message is written to the console.</source>
          <target state="translated">В блоке принятия решений внутри <ph id="ph1">`WriteObjectInfo`</ph> метода <ph id="ph2">&lt;xref:System.TypeCode&gt;</ph> из <ph id="ph3">&lt;xref:System.Object&gt;</ph> параметр проверяется, и в соответствующее сообщение записывается в консоль.</target>       </trans-unit>
        <trans-unit id="3035" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCodeImpl">
          <source>Returns the underlying type code of this <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> instance.</source>
          <target state="translated">Возвращает код базового типа этого экземпляра <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3036" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCodeImpl">
          <source>The type code of the underlying type.</source>
          <target state="translated">Код типа базового типа.</target>       </trans-unit>
        <trans-unit id="3037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCodeImpl">
          <source>This method provides the implementation for the <ph id="ph1">`static`</ph> (in C#) or <ph id="ph2">`Shared`</ph> (in Visual Basic) <ph id="ph3">&lt;xref:System.Type.GetTypeCode%28System.Type%29&gt;</ph> method.</source>
          <target state="translated">Этот метод обеспечивает реализацию <ph id="ph1">`static`</ph> (в C#) или <ph id="ph2">`Shared`</ph> (в Visual Basic) <ph id="ph3">&lt;xref:System.Type.GetTypeCode%28System.Type%29&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCodeImpl">
          <source>When you inherit from <ph id="ph1">&lt;xref:System.Type&gt;</ph>, you can override this method to provide your own implementation of <ph id="ph2">&lt;xref:System.Type.GetTypeCode%2A&gt;</ph>.</source>
          <target state="translated">При наследовании от <ph id="ph1">&lt;xref:System.Type&gt;</ph>, можно переопределить этот метод, чтобы предоставить свою собственную реализацию <ph id="ph2">&lt;xref:System.Type.GetTypeCode%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3039" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the type associated with the specified class identifier (CLSID).</source>
          <target state="translated">Возвращает тип, связанный с заданным кодом CLSID.</target>       </trans-unit>
        <trans-unit id="3040" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The CLSID of the type to get.</source>
          <target state="translated">Код CLSID извлекаемого типа.</target>       </trans-unit>
        <trans-unit id="3041" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Gets the type associated with the specified class identifier (CLSID).</source>
          <target state="translated">Возвращает тип, связанный с заданным кодом CLSID.</target>       </trans-unit>
        <trans-unit id="3042" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> regardless of whether the CLSID is valid.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> вне зависимости от того, допустим ли код CLSID.</target>       </trans-unit>
        <trans-unit id="3043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> Метод поддерживает доступ с поздним связыванием неуправляемый COM-объекты из приложения .NET Framework, когда вы знаете идентификатор класса COM-объекта (CLSID).</target>       </trans-unit>
        <trans-unit id="3044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
          <target state="translated">Идентификатор класса для COM-классов, определяется в разделе реестра HKEY_CLASSES_ROOT\CLSID.</target>       </trans-unit>
        <trans-unit id="3045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
          <target state="translated">Можно извлечь значение <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> свойства, чтобы определить, является ли тип, возвращаемый этим методом COM-объекта.</target>       </trans-unit>
        <trans-unit id="3046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
          <target state="translated">Можно вызвать <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> метод для доступа с поздней привязкой для COM объектов которого программный идентификатор (ProgID) известно.</target>       </trans-unit>
        <trans-unit id="3047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
          <target state="translated">При создании экземпляра неуправляемый COM-объект, из идентификатора CLSID состоит из двух этапов:</target>       </trans-unit>
        <trans-unit id="3048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the<ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
          <target state="translated">Получить <ph id="ph1">&lt;xref:System.Type&gt;</ph> , представляющий<ph id="ph2">`__ComObject`</ph> , соответствующий идентификатор CLSID, вызвав <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> method to instantiate the COM object.</source>
          <target state="translated">Вызовите <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> метод для создания экземпляра COM-объекта.</target>       </trans-unit>
        <trans-unit id="3050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>See the example for an illustration.</source>
          <target state="translated">См. пример для иллюстрации.</target>       </trans-unit>
        <trans-unit id="3051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%28System.Guid%29&gt;</ph> overload ignores any exception that may occur when instantiating a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object based on the <ph id="ph3">`clsid`</ph> argument.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%28System.Guid%29&gt;</ph> Перегрузки не обрабатывает любое исключение, которое возникает при создании экземпляра <ph id="ph2">&lt;xref:System.Type&gt;</ph> объекта, основанного на <ph id="ph3">`clsid`</ph> аргумент.</target>       </trans-unit>
        <trans-unit id="3052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Note that no exception is thrown if <ph id="ph1">`clsid`</ph> is not found in the registry.</source>
          <target state="translated">Обратите внимание, что исключение не возникает, если <ph id="ph1">`clsid`</ph> не найден в реестре.</target>       </trans-unit>
        <trans-unit id="3053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The following example uses the CLSID of the Microsoft Word <bpt id="p1">[</bpt>Application object<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> to retrieve a COM type that represents the Microsoft Word application.</source>
          <target state="translated">В следующем примере используется код CLSID Microsoft Word <bpt id="p1">[</bpt>объект приложения<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> для получения модели COM тип, представляющий приложение Microsoft Word.</target>       </trans-unit>
        <trans-unit id="3054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>It then instantiates the type by calling the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and closes it by calling the <bpt id="p1">[</bpt>Application.Quit<ept id="p1">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> method.</source>
          <target state="translated">Тип создается путем вызова <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> метода и закрывает его, вызвав <bpt id="p1">[</bpt>Application.Quit<ept id="p1">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> метод.</target>       </trans-unit>
        <trans-unit id="3055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>This method is intended for use when working with COM objects, not with .NET Framework objects.</source>
          <target state="translated">Этот метод предназначен для использования при работе с COM-объектами, а не с объектами .NET Framework.</target>       </trans-unit>
        <trans-unit id="3056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>All managed objects, including those that are visible to COM (that is, their <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> attribute is <ph id="ph2">&lt;see langword="true" /&gt;</ph>) have a GUID that is returned by the <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> property.</source>
          <target state="translated">Все управляемые объекты, включая те, которые являются видимыми для COM (то есть их <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> атрибут <ph id="ph2">&lt;see langword="true" /&gt;</ph>) имеют идентификатор GUID, который возвращается методом <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="3057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Although the method returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that corresponds to the GUID for .NET Framework objects, you can't use that <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object to create a type instance by calling the  <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method, as the following example shows.</source>
          <target state="translated">Несмотря на то, что метод возвращает <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> объектов объекта, который соответствует идентификатору GUID для .NET Framework, нельзя использовать, <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> объекта создаваемого экземпляра типа путем вызова <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> метода, как показано в следующем примере.</target>       </trans-unit>
        <trans-unit id="3058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Instead, the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that is passed to the <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method must represent an unmanaged COM object.</source>
          <target state="translated">Вместо этого <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> следует использовать только для получения GUID неуправляемый COM-объект и итоговый <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> объект, передаваемый <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> метод должен представлять неуправляемый COM-объект.</target>       </trans-unit>
        <trans-unit id="3059" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>The CLSID of the type to get.</source>
          <target state="translated">Код CLSID извлекаемого типа.</target>       </trans-unit>
        <trans-unit id="3060" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw any exception that occurs.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph> для вызова любого возникшего исключения.</target>       </trans-unit>
        <trans-unit id="3061" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3062" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to ignore any exception that occurs.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="false" /&gt;</ph> для игнорирования всех происходящих исключений.</target>       </trans-unit>
        <trans-unit id="3063" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</source>
          <target state="translated">Возвращает тип, связанный с заданным кодом CLSID, позволяющий определить, будет ли выбрасываться исключение в случае происхождения ошибки при загрузке типа.</target>       </trans-unit>
        <trans-unit id="3064" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> regardless of whether the CLSID is valid.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> вне зависимости от того, допустим ли код CLSID.</target>       </trans-unit>
        <trans-unit id="3065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> Метод поддерживает доступ с поздним связыванием неуправляемый COM-объекты из приложения .NET Framework, когда вы знаете идентификатор класса COM-объекта (CLSID).</target>       </trans-unit>
        <trans-unit id="3066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
          <target state="translated">Идентификатор класса для COM-классов, определяется в разделе реестра HKEY_CLASSES_ROOT\CLSID.</target>       </trans-unit>
        <trans-unit id="3067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
          <target state="translated">Можно извлечь значение <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> свойства, чтобы определить, является ли тип, возвращаемый этим методом COM-объекта.</target>       </trans-unit>
        <trans-unit id="3068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
          <target state="translated">Можно вызвать <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> метод для доступа с поздней привязкой для COM объектов которого программный идентификатор (ProgID) известно.</target>       </trans-unit>
        <trans-unit id="3069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
          <target state="translated">При создании экземпляра неуправляемый COM-объект, из идентификатора CLSID состоит из двух этапов:</target>       </trans-unit>
        <trans-unit id="3070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
          <target state="translated">Получить <ph id="ph1">&lt;xref:System.Type&gt;</ph> , представляющий <ph id="ph2">`__ComObject`</ph> , соответствующий идентификатор CLSID, вызвав <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> method to instantiate the COM object.</source>
          <target state="translated">Вызовите <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> метод для создания экземпляра COM-объекта.</target>       </trans-unit>
        <trans-unit id="3072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>See the example for an illustration.</source>
          <target state="translated">См. пример для иллюстрации.</target>       </trans-unit>
        <trans-unit id="3073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Exceptions such as <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> will be thrown when specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnError`</ph>, but it will not fail for unregistered CLSIDs.</source>
          <target state="translated">Такие исключения, как <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> будет создано при указании <ph id="ph2">`true`</ph> для <ph id="ph3">`throwOnError`</ph>, но он не будет работать для незарегистрированных идентификаторов CLSID.</target>       </trans-unit>
        <trans-unit id="3074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>The following example uses the CLSID of the Microsoft Word <bpt id="p1">[</bpt>Application object<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> to retrieve a COM type that represents the Microsoft Word application.</source>
          <target state="translated">В следующем примере используется код CLSID Microsoft Word <bpt id="p1">[</bpt>объект приложения<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> для получения модели COM тип, представляющий приложение Microsoft Word.</target>       </trans-unit>
        <trans-unit id="3075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>It then instantiates the type by calling the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and closes it by calling the <bpt id="p1">[</bpt>Application.Quit<ept id="p1">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> method.</source>
          <target state="translated">Тип создается путем вызова <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> метода и закрывает его, вызвав <bpt id="p1">[</bpt>Application.Quit<ept id="p1">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> метод.</target>       </trans-unit>
        <trans-unit id="3076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>An exception is thrown if an error occurs while loading the type.</source>
          <target state="translated">Исключение при возникновении ошибки при загрузке типа.</target>       </trans-unit>
        <trans-unit id="3077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>This method is intended for use when working with COM objects, not with .NET Framework objects.</source>
          <target state="translated">Этот метод предназначен для использования при работе с COM-объектами, а не с объектами .NET Framework.</target>       </trans-unit>
        <trans-unit id="3078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>All managed objects, including those that are visible to COM (that is, their <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> attribute is <ph id="ph2">&lt;see langword="true" /&gt;</ph>) have a GUID that is returned by the <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> property.</source>
          <target state="translated">Все управляемые объекты, включая те, которые являются видимыми для COM (то есть их <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> атрибут <ph id="ph2">&lt;see langword="true" /&gt;</ph>) имеют идентификатор GUID, который возвращается методом <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="3079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Although the method returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that corresponds to the GUID for .NET Framework objects, you can't use that <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object to create a type instance by calling the  <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method, as the following example shows.</source>
          <target state="translated">Несмотря на то, что метод возвращает <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> объектов объекта, который соответствует идентификатору GUID для .NET Framework, нельзя использовать, <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> объекта создаваемого экземпляра типа путем вызова <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> метода, как показано в следующем примере.</target>       </trans-unit>
        <trans-unit id="3080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Instead, the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that is passed to the <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method must represent an unmanaged COM object.</source>
          <target state="translated">Вместо этого <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> следует использовать только для получения GUID неуправляемый COM-объект и итоговый <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> объект, передаваемый <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> метод должен представлять неуправляемый COM-объект.</target>       </trans-unit>
        <trans-unit id="3081" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The CLSID of the type to get.</source>
          <target state="translated">Код CLSID извлекаемого типа.</target>       </trans-unit>
        <trans-unit id="3082" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The server from which to load the type.</source>
          <target state="translated">Сервер, с которого должен быть загружен тип.</target>       </trans-unit>
        <trans-unit id="3083" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>If the server name is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this method automatically reverts to the local machine.</source>
          <target state="translated">Если в качестве имени сервера задано значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>, этот метод автоматически перейдет к поиску на локальном компьютере.</target>       </trans-unit>
        <trans-unit id="3084" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Gets the type associated with the specified class identifier (CLSID) from the specified server.</source>
          <target state="translated">Возвращает с указанного сервера тип, связанный с заданным кодом CLSID.</target>       </trans-unit>
        <trans-unit id="3085" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> regardless of whether the CLSID is valid.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> вне зависимости от того, допустим ли код CLSID.</target>       </trans-unit>
        <trans-unit id="3086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> Метод поддерживает доступ с поздним связыванием неуправляемый COM-объекты из приложения .NET Framework, когда вы знаете идентификатор класса COM-объекта (CLSID).</target>       </trans-unit>
        <trans-unit id="3087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
          <target state="translated">Идентификатор класса для COM-классов, определяется в разделе реестра HKEY_CLASSES_ROOT\CLSID.</target>       </trans-unit>
        <trans-unit id="3088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
          <target state="translated">Можно извлечь значение <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> свойства, чтобы определить, является ли тип, возвращаемый этим методом COM-объекта.</target>       </trans-unit>
        <trans-unit id="3089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
          <target state="translated">Можно вызвать <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> метод для доступа с поздней привязкой для COM объектов которого программный идентификатор (ProgID) известно.</target>       </trans-unit>
        <trans-unit id="3090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
          <target state="translated">При создании экземпляра неуправляемый COM-объект, из идентификатора CLSID состоит из двух этапов:</target>       </trans-unit>
        <trans-unit id="3091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
          <target state="translated">Получить <ph id="ph1">&lt;xref:System.Type&gt;</ph> , представляющий <ph id="ph2">`__ComObject`</ph> , соответствующий идентификатор CLSID, вызвав <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> method to instantiate the COM object.</source>
          <target state="translated">Вызовите <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> метод для создания экземпляра COM-объекта.</target>       </trans-unit>
        <trans-unit id="3093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The following example uses the CLSID of the Microsoft Word <bpt id="p1">[</bpt>Application object<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com. It then instantiates the type by calling the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and closes it by calling the <bpt id="p2">[</bpt>Application.Quit<ept id="p2">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> method.</source>
          <target state="translated">В следующем примере используется код CLSID Microsoft Word <bpt id="p1">[</bpt>объект приложения<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> для получения модели COM тип, представляющий приложение Microsoft Word на сервере с именем computer17.central.contoso.com. Тип создается путем вызова <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> метода и закрывает его, вызвав <bpt id="p2">[</bpt>Application.Quit<ept id="p2">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> метод.</target>       </trans-unit>
        <trans-unit id="3094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>This method is intended for use when working with COM objects, not with .NET Framework objects.</source>
          <target state="translated">Этот метод предназначен для использования при работе с COM-объектами, а не с объектами .NET Framework.</target>       </trans-unit>
        <trans-unit id="3095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>All managed objects, including those that are visible to COM (that is, their <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> attribute is <ph id="ph2">&lt;see langword="true" /&gt;</ph>) have a GUID that is returned by the <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> property.</source>
          <target state="translated">Все управляемые объекты, включая те, которые являются видимыми для COM (то есть их <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> атрибут <ph id="ph2">&lt;see langword="true" /&gt;</ph>) имеют идентификатор GUID, который возвращается методом <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="3096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Although the method returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that corresponds to the GUID for .NET Framework objects, you can't use that <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object to create a type instance by calling the  <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method, as the following example shows.</source>
          <target state="translated">Несмотря на то, что метод возвращает <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> объектов объекта, который соответствует идентификатору GUID для .NET Framework, нельзя использовать, <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> объекта создаваемого экземпляра типа путем вызова <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> метода, как показано в следующем примере.</target>       </trans-unit>
        <trans-unit id="3097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Instead, the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that is passed to the <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method must represent an unmanaged COM object.</source>
          <target state="translated">Вместо этого <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> следует использовать только для получения GUID неуправляемый COM-объект и итоговый <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> объект, передаваемый <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> метод должен представлять неуправляемый COM-объект.</target>       </trans-unit>
        <trans-unit id="3098" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The CLSID of the type to get.</source>
          <target state="translated">Код CLSID извлекаемого типа.</target>       </trans-unit>
        <trans-unit id="3099" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The server from which to load the type.</source>
          <target state="translated">Сервер, с которого должен быть загружен тип.</target>       </trans-unit>
        <trans-unit id="3100" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>If the server name is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this method automatically reverts to the local machine.</source>
          <target state="translated">Если в качестве имени сервера задано значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>, этот метод автоматически перейдет к поиску на локальном компьютере.</target>       </trans-unit>
        <trans-unit id="3101" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw any exception that occurs.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph> для вызова любого возникшего исключения.</target>       </trans-unit>
        <trans-unit id="3102" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3103" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to ignore any exception that occurs.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="false" /&gt;</ph> для игнорирования всех происходящих исключений.</target>       </trans-unit>
        <trans-unit id="3104" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</source>
          <target state="translated">Возвращает с указанного сервера тип, связанный с заданным кодом CLSID, позволяющий определить, будет ли выбрасываться исключение при происхождении ошибки во время загрузки типа.</target>       </trans-unit>
        <trans-unit id="3105" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> regardless of whether the CLSID is valid.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> вне зависимости от того, допустим ли код CLSID.</target>       </trans-unit>
        <trans-unit id="3106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> Метод поддерживает доступ с поздним связыванием неуправляемый COM-объекты из приложения .NET Framework, когда вы знаете идентификатор класса COM-объекта (CLSID).</target>       </trans-unit>
        <trans-unit id="3107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
          <target state="translated">Идентификатор класса для COM-классов, определяется в разделе реестра HKEY_CLASSES_ROOT\CLSID.</target>       </trans-unit>
        <trans-unit id="3108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
          <target state="translated">Можно извлечь значение <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> свойства, чтобы определить, является ли тип, возвращаемый этим методом COM-объекта.</target>       </trans-unit>
        <trans-unit id="3109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
          <target state="translated">Можно вызвать <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> метод для доступа с поздней привязкой для COM объектов которого программный идентификатор (ProgID) известно.</target>       </trans-unit>
        <trans-unit id="3110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
          <target state="translated">При создании экземпляра неуправляемый COM-объект, из идентификатора CLSID состоит из двух этапов:</target>       </trans-unit>
        <trans-unit id="3111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
          <target state="translated">Получить <ph id="ph1">&lt;xref:System.Type&gt;</ph> , представляющий <ph id="ph2">`__ComObject`</ph> , соответствующий идентификатор CLSID, вызвав <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> method to instantiate the COM object.</source>
          <target state="translated">Вызовите <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> метод для создания экземпляра COM-объекта.</target>       </trans-unit>
        <trans-unit id="3113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Exceptions such as <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> will be thrown when specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnError`</ph>, but it will not fail for unregistered CLSIDs.</source>
          <target state="translated">Такие исключения, как <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> будет создано при указании <ph id="ph2">`true`</ph> для <ph id="ph3">`throwOnError`</ph>, но он не будет работать для незарегистрированных идентификаторов CLSID.</target>       </trans-unit>
        <trans-unit id="3114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The following example uses the CLSID of the Microsoft Word <bpt id="p1">[</bpt>Application object<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com. It then instantiates the type by calling the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and closes it by calling the <bpt id="p2">[</bpt>Application.Quit<ept id="p2">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> method.</source>
          <target state="translated">В следующем примере используется код CLSID Microsoft Word <bpt id="p1">[</bpt>объект приложения<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> для получения модели COM тип, представляющий приложение Microsoft Word на сервере с именем computer17.central.contoso.com. Тип создается путем вызова <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> метода и закрывает его, вызвав <bpt id="p2">[</bpt>Application.Quit<ept id="p2">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> метод.</target>       </trans-unit>
        <trans-unit id="3115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>An exception is thrown if an error occurs while loading the type.</source>
          <target state="translated">Исключение при возникновении ошибки при загрузке типа.</target>       </trans-unit>
        <trans-unit id="3116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>This method is intended for use when working with COM objects, not with .NET Framework objects.</source>
          <target state="translated">Этот метод предназначен для использования при работе с COM-объектами, а не с объектами .NET Framework.</target>       </trans-unit>
        <trans-unit id="3117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>All managed objects, including those that are visible to COM (that is, their <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> attribute is <ph id="ph2">&lt;see langword="true" /&gt;</ph>) have a GUID that is returned by the <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> property.</source>
          <target state="translated">Все управляемые объекты, включая те, которые являются видимыми для COM (то есть их <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> атрибут <ph id="ph2">&lt;see langword="true" /&gt;</ph>) имеют идентификатор GUID, который возвращается методом <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="3118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Although the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> method returns a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that corresponds to the GUID for a particular managed object, you can't use that <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> object to create a type instance by calling the  <ph id="ph4">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method, as the following example shows.</source>
          <target state="translated">Несмотря на то что <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> возвращает <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> объекта, который соответствует идентификатору GUID для конкретного управляемого объекта, нельзя использовать <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> объекта создаваемого экземпляра типа путем вызова <ph id="ph4">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> метода, как в следующем примере Показывает.</target>       </trans-unit>
        <trans-unit id="3119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Instead, the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that is passed to the <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method must represent an unmanaged COM object.</source>
          <target state="translated">Вместо этого <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> следует использовать только для получения GUID неуправляемый COM-объект и итоговый <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> объект, передаваемый <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> метод должен представлять неуправляемый COM-объект.</target>       </trans-unit>
        <trans-unit id="3120" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>The object that refers to the type.</source>
          <target state="translated">Объект, который ссылается на тип.</target>       </trans-unit>
        <trans-unit id="3121" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>Gets the type referenced by the specified type handle.</source>
          <target state="translated">Возвращает тип, на который ссылается указанный дескриптор типа.</target>       </trans-unit>
        <trans-unit id="3122" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>The type referenced by the specified <ph id="ph1">&lt;see cref="T:System.RuntimeTypeHandle" /&gt;</ph>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the <ph id="ph3">&lt;see cref="P:System.RuntimeTypeHandle.Value" /&gt;</ph> property of <ph id="ph4">&lt;paramref name="handle" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Тип, на который ссылается заданный дескриптор <ph id="ph1">&lt;see cref="T:System.RuntimeTypeHandle" /&gt;</ph>, или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если значение свойства <ph id="ph3">&lt;see cref="P:System.RuntimeTypeHandle.Value" /&gt;</ph> параметра <ph id="ph4">&lt;paramref name="handle" /&gt;</ph> равно <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>The handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">Дескрипторы доступны только в домене приложения, в котором они были получены.</target>       </trans-unit>
        <trans-unit id="3124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Type.GetTypeFromHandle%2A&gt;</ph> method to get a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object from a <ph id="ph3">&lt;xref:System.RuntimeTypeHandle&gt;</ph> provided by the <ph id="ph4">&lt;xref:System.Type.GetTypeHandle%2A&gt;</ph> method.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.Type.GetTypeFromHandle%2A&gt;</ph> метод, чтобы получить <ph id="ph2">&lt;xref:System.Type&gt;</ph> объекта из <ph id="ph3">&lt;xref:System.RuntimeTypeHandle&gt;</ph> , предоставляемые <ph id="ph4">&lt;xref:System.Type.GetTypeHandle%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3125" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Инициализатор класса вызывается и создает исключение.</target>       </trans-unit>
        <trans-unit id="3126" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the type associated with the specified program identifier (ProgID).</source>
          <target state="translated">Возвращает тип, связанный с заданным идентификатором ProgID.</target>       </trans-unit>
        <trans-unit id="3127" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>The ProgID of the type to get.</source>
          <target state="translated">Идентификатор ProgID извлекаемого типа.</target>       </trans-unit>
        <trans-unit id="3128" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает тип, связанный с указанным идентификатором ProgID, и возвращает значение NULL, если при загрузке объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> возникла ошибка.</target>       </trans-unit>
        <trans-unit id="3129" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>The type associated with the specified ProgID, if <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Тип, связанный с указанным идентификатором ProgID, если идентификатор <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> является допустимой записью в реестре и с ним связан определенный тип; в противном случае — значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>This method is provided for COM support.</source>
          <target state="translated">Этот метод предназначен для поддержки модели COM.</target>       </trans-unit>
        <trans-unit id="3131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
          <target state="translated">Идентификаторы ProgID не используются в Microsoft .NET Framework, так как они были заменены концепции пространства имен.</target>       </trans-unit>
        <trans-unit id="3132" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="3134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="3135" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The ProgID of the type to get.</source>
          <target state="translated">Идентификатор ProgID извлекаемого типа.</target>       </trans-unit>
        <trans-unit id="3136" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw any exception that occurs.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph> для вызова любого возникшего исключения.</target>       </trans-unit>
        <trans-unit id="3137" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3138" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to ignore any exception that occurs.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="false" /&gt;</ph> для игнорирования всех происходящих исключений.</target>       </trans-unit>
        <trans-unit id="3139" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</source>
          <target state="translated">Возвращает тип, связанный с заданным идентификатором ProgID, позволяющим определить, будет ли выбрасываться исключение при происхождении ошибки во время загрузки типа.</target>       </trans-unit>
        <trans-unit id="3140" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The type associated with the specified program identifier (ProgID), if <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Тип, связанный с указанным идентификатором ProgID, если идентификатор <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> является допустимой записью в реестре и с ним связан определенный тип; в противном случае — значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>This method is provided for COM support.</source>
          <target state="translated">Этот метод предназначен для поддержки модели COM.</target>       </trans-unit>
        <trans-unit id="3142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
          <target state="translated">Идентификаторы не используются в Microsoft .NET Framework, так как они были заменены концепции пространства имен.</target>       </trans-unit>
        <trans-unit id="3143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The following example retrieves a type by passing a ProgID, specifying whether to throw an exception if the ProgID is invalid.</source>
          <target state="translated">В следующем примере извлекается тип путем передачи идентификатора ProgID, будет ли выбрасываться исключение при недопустимости идентификатор ProgID.</target>       </trans-unit>
        <trans-unit id="3144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The example then displays the ClassID related to the ProgID, along with any applicable exception message.</source>
          <target state="translated">Затем отображается идентификатор ClassID, связанный с ProgID, а также любые соответствующее сообщение об ошибке.</target>       </trans-unit>
        <trans-unit id="3145" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3146" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The specified ProgID is not registered.</source>
          <target state="translated">Указанный идентификатор ProgID не зарегистрирован.</target>       </trans-unit>
        <trans-unit id="3147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="3148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="3149" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The progID of the type to get.</source>
          <target state="translated">Идентификатор ProgID извлекаемого типа.</target>       </trans-unit>
        <trans-unit id="3150" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The server from which to load the type.</source>
          <target state="translated">Сервер, с которого должен быть загружен тип.</target>       </trans-unit>
        <trans-unit id="3151" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>If the server name is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this method automatically reverts to the local machine.</source>
          <target state="translated">Если в качестве имени сервера задано значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>, этот метод автоматически перейдет к поиску на локальном компьютере.</target>       </trans-unit>
        <trans-unit id="3152" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</source>
          <target state="translated">Возвращает с указанного сервера тип, связанный с заданным идентификатором ProgID, и возвращает значение NULL, если при загрузке типа произошла ошибка.</target>       </trans-unit>
        <trans-unit id="3153" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The type associated with the specified program identifier (progID), if <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Тип, связанный с заданным идентификатором ProgID, если идентификатор <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> является допустимой записью в реестре и с ним связан определенный тип; в противном случае — значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>This method is provided for COM support.</source>
          <target state="translated">Этот метод предназначен для поддержки модели COM.</target>       </trans-unit>
        <trans-unit id="3155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
          <target state="translated">Идентификаторы не используются в Microsoft .NET Framework, так как они были заменены концепции пространства имен.</target>       </trans-unit>
        <trans-unit id="3156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The following example retrieves a type by passing a ProgID and server name.</source>
          <target state="translated">В следующем примере извлекается тип путем передачи идентификатора ProgID и имени сервера.</target>       </trans-unit>
        <trans-unit id="3157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The example then displays the ClassID related to the ProgID, or throws an exception if the ProgID or the server name is invalid.</source>
          <target state="translated">В примере отображается идентификатор ClassID, связанный с ProgID или вызывает исключение, если идентификатор ProgID или имя сервера является недопустимым.</target>       </trans-unit>
        <trans-unit id="3158" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="prodID" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="prodID" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="3160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="3161" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The progID of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to get.</source>
          <target state="translated">Идентификатор ProgID извлекаемого типа <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3162" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The server from which to load the type.</source>
          <target state="translated">Сервер, с которого должен быть загружен тип.</target>       </trans-unit>
        <trans-unit id="3163" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>If the server name is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this method automatically reverts to the local machine.</source>
          <target state="translated">Если в качестве имени сервера задано значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>, этот метод автоматически перейдет к поиску на локальном компьютере.</target>       </trans-unit>
        <trans-unit id="3164" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw any exception that occurs.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph> для вызова любого возникшего исключения.</target>       </trans-unit>
        <trans-unit id="3165" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3166" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to ignore any exception that occurs.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="false" /&gt;</ph> для игнорирования всех происходящих исключений.</target>       </trans-unit>
        <trans-unit id="3167" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</source>
          <target state="translated">Возвращает с указанного сервера тип, связанный с заданным идентификатором progID, который позволяет определить, будет ли выбрасываться исключение при происхождении ошибки во время загрузки типа.</target>       </trans-unit>
        <trans-unit id="3168" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The type associated with the specified program identifier (progID), if <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Тип, связанный с заданным идентификатором ProgID, если идентификатор <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> является допустимой записью в реестре и с ним связан определенный тип; в противном случае — значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>This method is provided for COM support.</source>
          <target state="translated">Этот метод предназначен для поддержки модели COM.</target>       </trans-unit>
        <trans-unit id="3170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
          <target state="translated">Идентификаторы не используются в Microsoft .NET Framework, так как они были заменены концепции пространства имен.</target>       </trans-unit>
        <trans-unit id="3171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The following example retrieves a type by passing a ProgID and server name.</source>
          <target state="translated">В следующем примере извлекается тип путем передачи идентификатора ProgID и имени сервера.</target>       </trans-unit>
        <trans-unit id="3172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The example then displays the ClassID related to the ProgID, specifying whether to throw an exception if the ProgID or the server name is invalid.</source>
          <target state="translated">Затем отображается идентификатор ClassID, связанный с ProgID, будет ли выбрасываться исключение при недопустимости идентификатор ProgID или имя сервера.</target>       </trans-unit>
        <trans-unit id="3173" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3174" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The specified progID is not registered.</source>
          <target state="translated">Указанный идентификатор progID не зарегистрирован.</target>       </trans-unit>
        <trans-unit id="3175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">требуется полное доверие для непосредственно вызывающего метода.</target>       </trans-unit>
        <trans-unit id="3176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Этот член не может использоваться частично доверенным или прозрачным кодом.</target>       </trans-unit>
        <trans-unit id="3177" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>The object for which to get the type handle.</source>
          <target state="translated">Объект, для которого требуется получить дескриптор типа.</target>       </trans-unit>
        <trans-unit id="3178" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>Gets the handle for the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of a specified object.</source>
          <target state="translated">Возвращает дескриптор <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> для указанного объекта.</target>       </trans-unit>
        <trans-unit id="3179" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>The handle for the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">Дескриптор типа <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> для указанного объекта <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>The handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">Дескрипторы доступны только в домене приложения, в котором они были получены.</target>       </trans-unit>
        <trans-unit id="3181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>The following example defines the class <ph id="ph1">`MyClass1`</ph>, gets an instance of it, and retrieves the runtime handle of the object.</source>
          <target state="translated">В следующем примере определяется класс <ph id="ph1">`MyClass1`</ph>, возвращает его экземпляр и извлекается дескриптор среды выполнения объекта.</target>       </trans-unit>
        <trans-unit id="3182" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="o" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3183" translate="yes" xml:space="preserve" uid="P:System.Type.GUID">
          <source>Gets the GUID associated with the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает идентификатор GUID, связанный с объектом <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GUID">
          <source>The GUID associated with the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Идентификатор GUID, связанный с объектом <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GUID">
          <source>A GUID is associated with a type using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GuidAttribute&gt;</ph> attribute.</source>
          <target state="translated">Идентификатор GUID связан с типом с помощью <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GuidAttribute&gt;</ph> атрибута.</target>       </trans-unit>
        <trans-unit id="3186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GUID">
          <source>The following example creates the class <ph id="ph1">`MyClass1`</ph> with a public method, creates a <ph id="ph2">`Type`</ph> object corresponding to <ph id="ph3">`MyClass1`</ph>, and gets the <ph id="ph4">&lt;xref:System.Guid&gt;</ph> structure using the <ph id="ph5">`GUID`</ph> property of the <ph id="ph6">`Type`</ph> class.</source>
          <target state="translated">В следующем примере создается класс <ph id="ph1">`MyClass1`</ph> в открытый метод создает <ph id="ph2">`Type`</ph> объект, соответствующий <ph id="ph3">`MyClass1`</ph>и возвращает <ph id="ph4">&lt;xref:System.Guid&gt;</ph> структуры с помощью <ph id="ph5">`GUID`</ph> свойство <ph id="ph6">`Type`</ph> класса.</target>       </trans-unit>
        <trans-unit id="3187" translate="yes" xml:space="preserve" uid="P:System.Type.HasElementType">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> encompasses or refers to another type; that is, whether the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer, or is passed by reference.</source>
          <target state="translated">Возвращает значение, позволяющее определить, содержит ли текущий объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> в себе другой тип или ссылку на другой тип (иными словами, является ли текущий объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> массивом, указателем либо параметром или же он передается по ссылке).</target>       </trans-unit>
        <trans-unit id="3188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer, or is passed by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является массивом, указателем или параметром, переданным по ссылке; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source>For example, Type.GetType("Int32[]").HasElementType returns <ph id="ph1">`true`</ph>, but Type.GetType("Int32").HasElementType returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Например, Type.GetType("Int32[]"). Возвращает HasElementType <ph id="ph1">`true`</ph>, но Type.GetType("Int32"). Возвращает HasElementType <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source>HasElementType also returns <ph id="ph1">`true`</ph> for "Int32*" and "Int32&amp;".</source>
          <target state="translated">Также возвращает HasElementType <ph id="ph1">`true`</ph> для «Int32 *» и «Int32 &amp;».</target>       </trans-unit>
        <trans-unit id="3191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет универсальный тип или параметр типа в определении универсального типа или метода, это свойство всегда возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source>The following example returns <ph id="ph1">`true`</ph> or <ph id="ph2">`false`</ph> depending on whether or not the object is an array, a reference type, or a pointer.</source>
          <target state="translated">В следующем примере возвращается <ph id="ph1">`true`</ph> или <ph id="ph2">`false`</ph> в зависимости от того, является ли объект является массив, указатель или ссылочным типом.</target>       </trans-unit>
        <trans-unit id="3193" translate="yes" xml:space="preserve" uid="M:System.Type.HasElementTypeImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.HasElementType" /&gt;</ph> property and determines whether the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> encompasses or refers to another type; that is, whether the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer, or is passed by reference.</source>
          <target state="translated">При переопределении в производном классе реализует свойство <ph id="ph1">&lt;see cref="P:System.Type.HasElementType" /&gt;</ph> и определяет, что содержится в текущем объекте <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>: непосредственно другой тип или же указывающая на него ссылка (иными словами, является ли текущий объект <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> массивом, указателем или параметром или же он передается по ссылке).</target>       </trans-unit>
        <trans-unit id="3194" translate="yes" xml:space="preserve" uid="M:System.Type.HasElementTypeImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer, or is passed by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является массивом, указателем или параметром, переданным по ссылке; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.HasElementTypeImpl">
          <source>For example, Type.GetType("Int32[]").HasElementTypeImpl returns <ph id="ph1">`true`</ph>, but Type.GetType("Int32").HasElementTypeImpl returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Например, Type.GetType("Int32[]"). Возвращает HasElementTypeImpl <ph id="ph1">`true`</ph>, но Type.GetType("Int32"). Возвращает HasElementTypeImpl <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.HasElementTypeImpl">
          <source>HasElementTypeImpl also returns <ph id="ph1">`true`</ph> for "Int32*" and "Int32&amp;".</source>
          <target state="translated">Также возвращает HasElementTypeImpl <ph id="ph1">`true`</ph> для «Int32 *» и «Int32 &amp;».</target>       </trans-unit>
        <trans-unit id="3197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.HasElementTypeImpl">
          <source>The following example defines the class <ph id="ph1">`MyTypeDelegator`</ph>, which overrides the <ph id="ph2">`HasElementTypeImpl`</ph> method.</source>
          <target state="translated">В следующем примере определяется класс <ph id="ph1">`MyTypeDelegator`</ph>, перезаписав <ph id="ph2">`HasElementTypeImpl`</ph> метод.</target>       </trans-unit>
        <trans-unit id="3198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.HasElementTypeImpl">
          <source>The main class checks for the <ph id="ph1">`HasElementType`</ph> property and displays the element type.</source>
          <target state="translated">Главный класс проверяет <ph id="ph1">`HasElementType`</ph> свойства и отображает тип элемента.</target>       </trans-unit>
        <trans-unit id="3199" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Invokes a specific member of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Вызывает определенный член текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3200" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The string containing the name of the constructor, method, property, or field member to invoke.</source>
          <target state="translated">Строка, содержащая имя вызываемого элемента — конструктора, метода, свойства или поля.</target>       </trans-unit>
        <trans-unit id="3201" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3202" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>An empty string ("") to invoke the default member.</source>
          <target state="translated">Пустая строка ("") — в этом случае будет вызван член по умолчанию.</target>       </trans-unit>
        <trans-unit id="3203" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3204" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>For <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> members, a string representing the DispID, for example "[DispID=3]".</source>
          <target state="translated">Для членов <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> — строка, представляющая идентификатор DispID, например "[DispID=3]".</target>       </trans-unit>
        <trans-unit id="3205" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="3206" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The access can be one of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> such as <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph>, and so on.</source>
          <target state="translated">Тип доступа может быть обозначен одним из флагов <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>, например <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph> и т.д.</target>       </trans-unit>
        <trans-unit id="3207" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The type of lookup need not be specified.</source>
          <target state="translated">Тип поиска указывать необязательно.</target>       </trans-unit>
        <trans-unit id="3208" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>If the type of lookup is omitted, <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph> are used.</source>
          <target state="translated">Если тип поиска не указан, используются флаги <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3209" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.</target>       </trans-unit>
        <trans-unit id="3210" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3211" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Пустая ссылка (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> в Visual Basic) для использования свойства <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3212" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Note that explicitly defining a <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> object may be required for successfully invoking method overloads with variable arguments.</source>
          <target state="translated">Обратите внимание, что для успешного вызова перегруженных версий метода с переменными аргументами может потребоваться явное объявление объекта <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3213" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The object on which to invoke the specified member.</source>
          <target state="translated">Объект, для которого следует вызвать указанный член.</target>       </trans-unit>
        <trans-unit id="3214" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>An array containing the arguments to pass to the member to invoke.</source>
          <target state="translated">Массив с аргументами, передаваемыми вызываемому члену.</target>       </trans-unit>
        <trans-unit id="3215" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Invokes the specified member, using the specified binding constraints and matching the specified argument list.</source>
          <target state="translated">Вызывает указанный член, соответствующий заданным ограничениям привязки и указанному списку аргументов.</target>       </trans-unit>
        <trans-unit id="3216" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>An object representing the return value of the invoked member.</source>
          <target state="translated">Объект, представляющий возвращаемое значение вызываемого элемента.</target>       </trans-unit>
        <trans-unit id="3217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>You cannot use <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> to invoke a generic method.</source>
          <target state="translated">Нельзя использовать <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> в вызове универсального метода.</target>       </trans-unit>
        <trans-unit id="3218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги фильтра можно использовать для определения члены, которые нужно включить в поиск:</target>       </trans-unit>
        <trans-unit id="3219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Public`</ph> для включения в поиск открытых членов.</target>       </trans-unit>
        <trans-unit id="3220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private and protected members) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.NonPublic`</ph> для включения в поиск закрытым членам (то есть, закрытые и защищенные члены).</target>       </trans-unit>
        <trans-unit id="3221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include static members up the hierarchy.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> для включения статические члены вверх по иерархии.</target>       </trans-unit>
        <trans-unit id="3222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> модификатор флаги можно использовать для изменения условий поиска:</target>       </trans-unit>
        <trans-unit id="3223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> Чтобы игнорировать регистр <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="3224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> для поиска только члены, объявленные в <ph id="ph2">&lt;xref:System.Type&gt;</ph>, не унаследованные члены группы.</target>       </trans-unit>
        <trans-unit id="3225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> invocation flags can be used to denote what action to take with the member:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги вызова можно использовать для указания действия, выполняемого с членом:</target>       </trans-unit>
        <trans-unit id="3226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`CreateInstance`</ph> to invoke a constructor.</source>
          <target state="translated"><ph id="ph1">`CreateInstance`</ph> для вызова конструктора.</target>       </trans-unit>
        <trans-unit id="3227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`name`</ph> is ignored.</source>
          <target state="translated"><ph id="ph1">`name`</ph> учитывается.</target>       </trans-unit>
        <trans-unit id="3228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with other invocation flags.</source>
          <target state="translated">Не является допустимым с другими флагами вызова.</target>       </trans-unit>
        <trans-unit id="3229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`InvokeMethod`</ph> to invoke a method, but not a constructor or a type initializer.</source>
          <target state="translated"><ph id="ph1">`InvokeMethod`</ph> для вызова метода, но не конструктор или инициализатор типа.</target>       </trans-unit>
        <trans-unit id="3230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`SetField`</ph> or <ph id="ph2">`SetProperty`</ph>.</source>
          <target state="translated">Не является допустимым с <ph id="ph1">`SetField`</ph> или <ph id="ph2">`SetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>If <ph id="ph1">`InvokeMethod`</ph> is specified by itself, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, and <ph id="ph4">`BindingFlags.Static`</ph> are automatically included.</source>
          <target state="translated">Если <ph id="ph1">`InvokeMethod`</ph> указан сам по себе <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, и <ph id="ph4">`BindingFlags.Static`</ph> включаются автоматически.</target>       </trans-unit>
        <trans-unit id="3232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`GetField`</ph> to get the value of a field.</source>
          <target state="translated"><ph id="ph1">`GetField`</ph> Для получения значения поля.</target>       </trans-unit>
        <trans-unit id="3233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`SetField`</ph>.</source>
          <target state="translated">Не является допустимым с <ph id="ph1">`SetField`</ph>.</target>       </trans-unit>
        <trans-unit id="3234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`SetField`</ph> to set the value of a field.</source>
          <target state="translated"><ph id="ph1">`SetField`</ph> Чтобы задать значение поля.</target>       </trans-unit>
        <trans-unit id="3235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`GetField`</ph>.</source>
          <target state="translated">Не является допустимым с <ph id="ph1">`GetField`</ph>.</target>       </trans-unit>
        <trans-unit id="3236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`GetProperty`</ph> to get a property.</source>
          <target state="translated"><ph id="ph1">`GetProperty`</ph> Для получения свойства.</target>       </trans-unit>
        <trans-unit id="3237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`SetProperty`</ph>.</source>
          <target state="translated">Не является допустимым с <ph id="ph1">`SetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`SetProperty`</ph> to set a property.</source>
          <target state="translated"><ph id="ph1">`SetProperty`</ph> Чтобы задать свойство.</target>       </trans-unit>
        <trans-unit id="3239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`GetProperty`</ph>.</source>
          <target state="translated">Не является допустимым с <ph id="ph1">`GetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>A method will be invoked if both of the following conditions are true:</source>
          <target state="translated">Метод будет вызван, если выполняются оба следующих условия:</target>       </trans-unit>
        <trans-unit id="3242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The number of parameters in the method declaration equals the number of arguments in the <ph id="ph1">`args`</ph> array (unless default arguments are defined on the member and <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> is specified).</source>
          <target state="translated">Число параметров в объявлении метода равно количеству аргументов в <ph id="ph1">`args`</ph> массив (если для члена не определены аргументы по умолчанию и <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> указан).</target>       </trans-unit>
        <trans-unit id="3243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The type of each argument can be converted by the binder to the type of the parameter.</source>
          <target state="translated">Тип каждого аргумента может преобразовываться связывателем тип параметра.</target>       </trans-unit>
        <trans-unit id="3244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The binder will find all of the matching methods.</source>
          <target state="translated">Связыватель найдет все подходящие методы.</target>       </trans-unit>
        <trans-unit id="3245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>These methods are found based upon the type of binding requested (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> values <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>, and so on).</source>
          <target state="translated">Эти методы находятся в зависимости от типа связывания (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> значения <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>и так далее).</target>       </trans-unit>
        <trans-unit id="3246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
          <target state="translated">Набор методов фильтруется по имени, количество аргументов и набор модификаторов поиска, определенных в модуле привязки.</target>       </trans-unit>
        <trans-unit id="3247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>After the method is selected, it is invoked.</source>
          <target state="translated">После выбора метода он вызывается.</target>       </trans-unit>
        <trans-unit id="3248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Accessibility is checked at that point.</source>
          <target state="translated">На этом этапе проверяется доступность.</target>       </trans-unit>
        <trans-unit id="3249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
          <target state="translated">Средство поиска может управлять поиском определения набора методов на основе связанного с методом атрибута доступности.</target>       </trans-unit>
        <trans-unit id="3250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> class is responsible for selecting the method to be invoked.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> Метод <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> класс отвечает за выбор вызываемого метода.</target>       </trans-unit>
        <trans-unit id="3251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The default binder selects the most specific match.</source>
          <target state="translated">Связыватель по умолчанию выбирает наиболее точное соответствие.</target>       </trans-unit>
        <trans-unit id="3252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <ph id="ph1">&lt;xref:System.Reflection&gt;</ph> whenever the code is fully trusted.</source>
          <target state="translated">Ограничения доступа игнорируются для полностью доверенный код; то есть, закрытые конструкторы, методы, поля и свойства можно получить доступ к и вызывать с помощью <ph id="ph1">&lt;xref:System.Reflection&gt;</ph> каждый раз, когда код имеет полное доверие.</target>       </trans-unit>
        <trans-unit id="3253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>You can use <ph id="ph1">`Type.InvokeMember`</ph> to set a field to a particular value by specifying <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Можно использовать <ph id="ph1">`Type.InvokeMember`</ph> присвоено конкретное значение в поле, указав <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>For example, if you want to set a public instance field named F on class C, and F is a <ph id="ph1">`String`</ph>, you can use code such as:</source>
          <target state="translated">Например, если вы хотите задать полю открытого экземпляра F класса C, а F — <ph id="ph1">`String`</ph>, можно использовать код, например:</target>       </trans-unit>
        <trans-unit id="3255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>If F is a <ph id="ph1">`String[]`</ph>, you can use code such as:</source>
          <target state="translated">Если F- <ph id="ph1">`String[]`</ph>, можно использовать код, например:</target>       </trans-unit>
        <trans-unit id="3256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>which will initialize the field F to this new array.</source>
          <target state="translated">который будет инициализировать поля F новым массивом.</target>       </trans-unit>
        <trans-unit id="3257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>You can also use <ph id="ph1">`Type.InvokeMember`</ph> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</source>
          <target state="translated">Можно также использовать <ph id="ph1">`Type.InvokeMember`</ph> Чтобы установить позиции в массиве, указав его индекс значения, и затем следующего значения с помощью кода примерно следующего вида:</target>       </trans-unit>
        <trans-unit id="3258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>This will change string "z" in the array that F holds to string "b".</source>
          <target state="translated">Это приведет к изменению строка «z» в массиве F строку «b».</target>       </trans-unit>
        <trans-unit id="3259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>When you invoke an <ph id="ph1">`IDispatch`</ph> member, you can specify the DispID instead of the member name, using the string format "[DispID=##]".</source>
          <target state="translated">При вызове <ph id="ph1">`IDispatch`</ph> member, укажите идентификатор DispID, вместо имени элемента с помощью строки формата «[DispID = ##]».</target>       </trans-unit>
        <trans-unit id="3260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</source>
          <target state="translated">Например, если DispID MyComMethod равно 3, можно указать строку «[DispID = 3]» вместо «MyComMethod».</target>       </trans-unit>
        <trans-unit id="3261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Invoking a member by DispID is faster than looking up the member by name.</source>
          <target state="translated">Вызов члена по идентификатору DispID выполняется быстрее, чем поиск элемента по имени.</target>       </trans-unit>
        <trans-unit id="3262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</source>
          <target state="translated">В сложных сценариях агрегирования DispID иногда является единственным способом вызова необходимого члена.</target>       </trans-unit>
        <trans-unit id="3263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">Начиная с <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, этот метод можно использовать для доступа к закрытым членам, если вызывающему объекту предоставлены <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> и отметки Если набор прав, не являющиеся открытыми члены ограничена вызывающего набором разрешений или подмножество его.</target>       </trans-unit>
        <trans-unit id="3264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(См. <bpt id="p1">[</bpt>рекомендации по безопасности для отражения<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="3265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Для применения этих функциональных возможностей приложение должно использовать <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> или более поздние версии.</target>       </trans-unit>
        <trans-unit id="3266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The following example uses <ph id="ph1">`InvokeMember`</ph> to access members of a type.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">`InvokeMember`</ph> для доступа к членам типа.</target>       </trans-unit>
        <trans-unit id="3267" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> and <ph id="ph3">&lt;paramref name="name" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> не содержит <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph>, а <ph id="ph3">&lt;paramref name="name" /&gt;</ph> равно <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3268" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> attribute.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> не является допустимым атрибутом <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3269" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3270" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain one of the following binding flags: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> не содержит одного из следующих флагов привязки: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> или <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3271" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3272" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> содержит <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> в сочетании с <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> или <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3273" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3274" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> содержит как <ph id="ph2">&lt;see langword="GetField" /&gt;</ph>, так и <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3275" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3276" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> содержит как <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph>, так и <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3277" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3278" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> or <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> содержит <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> в сочетании с <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> или <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3279" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3280" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> and <ph id="ph3">&lt;paramref name="args" /&gt;</ph> has more than one element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> содержит <ph id="ph2">&lt;see langword="SetField" /&gt;</ph>, а <ph id="ph3">&lt;paramref name="args" /&gt;</ph> содержит более одного элемента.</target>       </trans-unit>
        <trans-unit id="3281" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3282" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>This method is called on a COM object and one of the following binding flags was not passed in: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph>, or <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</source>
          <target state="translated">Этот метод вызывается для объекта COM, и один из следующих флагов привязки не был передан: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph> или <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3283" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3284" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>One of the named parameter arrays contains a string that is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Один из массивов именованных параметров содержит строку, имеющую значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3285" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The specified member is a class initializer.</source>
          <target state="translated">Указанный член является инициализатором класса.</target>       </trans-unit>
        <trans-unit id="3286" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The field or property cannot be found.</source>
          <target state="translated">Невозможно найти поле или свойство.</target>       </trans-unit>
        <trans-unit id="3287" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>No method can be found that matches the arguments in <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">Невозможно найти метод, который соответствует аргументам в <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3288" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3289" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type that contains open type parameters, that is, <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Текущий объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> представляет тип, содержащий параметры открытого типа, то есть <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> возвращает <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3290" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The specified member cannot be invoked on <ph id="ph1">&lt;paramref name="target" /&gt;</ph>.</source>
          <target state="translated">Невозможно вызвать указанный член для <ph id="ph1">&lt;paramref name="target" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3291" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>More than one method matches the binding criteria.</source>
          <target state="translated">Несколько методов соответствуют критериям привязки.</target>       </trans-unit>
        <trans-unit id="3292" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The .NET Compact Framework does not currently support this method.</source>
          <target state="translated">Платформа .NET Compact Framework сейчас не поддерживает этот метод.</target>       </trans-unit>
        <trans-unit id="3293" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The method represented by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> has one or more unspecified generic type parameters.</source>
          <target state="translated">Метод, представленный <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, имеет один или несколько незаданных параметров универсального типа.</target>       </trans-unit>
        <trans-unit id="3294" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>That is, the method's <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">То есть свойство <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> метода возвращает <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>for accessing non-public members regardless of their grant set.</source>
          <target state="translated">для доступа к закрытым членам независимо от их разрешений набора.</target>       </trans-unit>
        <trans-unit id="3296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Связанное перечисление: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>to call unmanaged code.</source>
          <target state="translated">для вызова неуправляемого кода.</target>       </trans-unit>
        <trans-unit id="3298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Связанное перечисление: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3299" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The string containing the name of the constructor, method, property, or field member to invoke.</source>
          <target state="translated">Строка, содержащая имя вызываемого элемента — конструктора, метода, свойства или поля.</target>       </trans-unit>
        <trans-unit id="3300" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3301" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>An empty string ("") to invoke the default member.</source>
          <target state="translated">Пустая строка ("") — в этом случае будет вызван член по умолчанию.</target>       </trans-unit>
        <trans-unit id="3302" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3303" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>For <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> members, a string representing the DispID, for example "[DispID=3]".</source>
          <target state="translated">Для членов <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> — строка, представляющая идентификатор DispID, например "[DispID=3]".</target>       </trans-unit>
        <trans-unit id="3304" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="3305" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The access can be one of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> such as <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph>, and so on.</source>
          <target state="translated">Тип доступа может быть обозначен одним из флагов <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>, например <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph> и т.д.</target>       </trans-unit>
        <trans-unit id="3306" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The type of lookup need not be specified.</source>
          <target state="translated">Тип поиска указывать необязательно.</target>       </trans-unit>
        <trans-unit id="3307" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>If the type of lookup is omitted, <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph> are used.</source>
          <target state="translated">Если тип поиска не указан, используются флаги <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3308" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.</target>       </trans-unit>
        <trans-unit id="3309" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3310" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Пустая ссылка (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> в Visual Basic) для использования свойства <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3311" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Note that explicitly defining a <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> object may be required for successfully invoking method overloads with variable arguments.</source>
          <target state="translated">Обратите внимание, что для успешного вызова перегруженных версий метода с переменными аргументами может потребоваться явное объявление объекта <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3312" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The object on which to invoke the specified member.</source>
          <target state="translated">Объект, для которого следует вызвать указанный член.</target>       </trans-unit>
        <trans-unit id="3313" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>An array containing the arguments to pass to the member to invoke.</source>
          <target state="translated">Массив с аргументами, передаваемыми вызываемому члену.</target>       </trans-unit>
        <trans-unit id="3314" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph>.</source>
          <target state="translated">Объект, представляющий используемые языковые стандарты глобализации. Его задание может понадобиться для выполнения преобразований, зависящих от языкового стандарта, например преобразования числовой строки <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> к типу <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3315" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3316" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) to use the current thread's <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>.</source>
          <target state="translated">Пустая ссылка (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> в Visual Basic) для использования объекта <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> текущего потока.</target>       </trans-unit>
        <trans-unit id="3317" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</source>
          <target state="translated">Вызывает указанный член, соответствующий заданным ограничениям привязки, списку аргументов, а также языку и региональным параметрам.</target>       </trans-unit>
        <trans-unit id="3318" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>An object representing the return value of the invoked member.</source>
          <target state="translated">Объект, представляющий возвращаемое значение вызываемого элемента.</target>       </trans-unit>
        <trans-unit id="3319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> (the <ph id="ph2">`culture`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`culture`</ph>.</source>
          <target state="translated">Несмотря на то что связыватель по умолчанию не обрабатывает <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> ( <ph id="ph2">`culture`</ph> параметр), можно использовать абстрактный <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> класс, чтобы написать собственный связыватель, обрабатывающий <ph id="ph4">`culture`</ph>.</target>       </trans-unit>
        <trans-unit id="3320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>You cannot use <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> to invoke a generic method.</source>
          <target state="translated">Нельзя использовать <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> в вызове универсального метода.</target>       </trans-unit>
        <trans-unit id="3321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги фильтра можно использовать для определения члены, которые нужно включить в поиск:</target>       </trans-unit>
        <trans-unit id="3322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Public`</ph> для включения в поиск открытых членов.</target>       </trans-unit>
        <trans-unit id="3323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.NonPublic`</ph> для включения в поиск закрытым членам (то есть частных, внутренних и защищенные члены).</target>       </trans-unit>
        <trans-unit id="3324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include static members up the hierarchy.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> для включения статические члены вверх по иерархии.</target>       </trans-unit>
        <trans-unit id="3325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> модификатор флаги можно использовать для изменения условий поиска:</target>       </trans-unit>
        <trans-unit id="3326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> Чтобы игнорировать регистр <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="3327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> для поиска только члены, объявленные в <ph id="ph2">&lt;xref:System.Type&gt;</ph>, не унаследованные члены группы.</target>       </trans-unit>
        <trans-unit id="3328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> invocation flags can be used to denote what action to take with the member:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги вызова можно использовать для указания действия, выполняемого с членом:</target>       </trans-unit>
        <trans-unit id="3329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`CreateInstance`</ph> to invoke a constructor.</source>
          <target state="translated"><ph id="ph1">`CreateInstance`</ph> для вызова конструктора.</target>       </trans-unit>
        <trans-unit id="3330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`name`</ph> is ignored.</source>
          <target state="translated"><ph id="ph1">`name`</ph> учитывается.</target>       </trans-unit>
        <trans-unit id="3331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with other invocation flags.</source>
          <target state="translated">Не является допустимым с другими флагами вызова.</target>       </trans-unit>
        <trans-unit id="3332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`InvokeMethod`</ph> to invoke a method, but not a constructor or a type initializer.</source>
          <target state="translated"><ph id="ph1">`InvokeMethod`</ph> для вызова метода, но не конструктор или инициализатор типа.</target>       </trans-unit>
        <trans-unit id="3333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`SetField`</ph> or <ph id="ph2">`SetProperty`</ph>.</source>
          <target state="translated">Не является допустимым с <ph id="ph1">`SetField`</ph> или <ph id="ph2">`SetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>If <ph id="ph1">`InvokeMethod`</ph> is specified by itself, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, and <ph id="ph4">`BindingFlags.Static`</ph> are automatically included.</source>
          <target state="translated">Если <ph id="ph1">`InvokeMethod`</ph> указан сам по себе <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, и <ph id="ph4">`BindingFlags.Static`</ph> включаются автоматически.</target>       </trans-unit>
        <trans-unit id="3335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`GetField`</ph> to get the value of a field.</source>
          <target state="translated"><ph id="ph1">`GetField`</ph> Для получения значения поля.</target>       </trans-unit>
        <trans-unit id="3336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`SetField`</ph>.</source>
          <target state="translated">Не является допустимым с <ph id="ph1">`SetField`</ph>.</target>       </trans-unit>
        <trans-unit id="3337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`SetField`</ph> to set the value of a field.</source>
          <target state="translated"><ph id="ph1">`SetField`</ph> Чтобы задать значение поля.</target>       </trans-unit>
        <trans-unit id="3338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`GetField`</ph>.</source>
          <target state="translated">Не является допустимым с <ph id="ph1">`GetField`</ph>.</target>       </trans-unit>
        <trans-unit id="3339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`GetProperty`</ph> to get a property.</source>
          <target state="translated"><ph id="ph1">`GetProperty`</ph> Для получения свойства.</target>       </trans-unit>
        <trans-unit id="3340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`SetProperty`</ph>.</source>
          <target state="translated">Не является допустимым с <ph id="ph1">`SetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`SetProperty`</ph> to set a property.</source>
          <target state="translated"><ph id="ph1">`SetProperty`</ph> Чтобы задать свойство.</target>       </trans-unit>
        <trans-unit id="3342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`GetProperty`</ph>.</source>
          <target state="translated">Не является допустимым с <ph id="ph1">`GetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>A method will be invoked if both of the following conditions are true:</source>
          <target state="translated">Метод будет вызван, если выполняются оба следующих условия:</target>       </trans-unit>
        <trans-unit id="3345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The number of parameters in the method declaration equals the number of arguments in the <ph id="ph1">`args`</ph> array (unless default arguments are defined on the member and <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> is specified).</source>
          <target state="translated">Число параметров в объявлении метода равно количеству аргументов в <ph id="ph1">`args`</ph> массив (если для члена не определены аргументы по умолчанию и <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> указан).</target>       </trans-unit>
        <trans-unit id="3346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The type of each argument can be converted by the binder to the type of the parameter.</source>
          <target state="translated">Тип каждого аргумента может преобразовываться связывателем тип параметра.</target>       </trans-unit>
        <trans-unit id="3347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The binder will find all of the matching methods.</source>
          <target state="translated">Связыватель найдет все подходящие методы.</target>       </trans-unit>
        <trans-unit id="3348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>These methods are found based upon the type of binding requested (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> values <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>, and so on).</source>
          <target state="translated">Эти методы находятся в зависимости от типа связывания (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> значения <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>и так далее).</target>       </trans-unit>
        <trans-unit id="3349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
          <target state="translated">Набор методов фильтруется по имени, количество аргументов и набор модификаторов поиска, определенных в модуле привязки.</target>       </trans-unit>
        <trans-unit id="3350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>After the method is selected, it is invoked.</source>
          <target state="translated">После выбора метода он вызывается.</target>       </trans-unit>
        <trans-unit id="3351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Accessibility is checked at that point.</source>
          <target state="translated">На этом этапе проверяется доступность.</target>       </trans-unit>
        <trans-unit id="3352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
          <target state="translated">Средство поиска может управлять поиском определения набора методов на основе связанного с методом атрибута доступности.</target>       </trans-unit>
        <trans-unit id="3353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> class is responsible for selecting the method to be invoked.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> Метод <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> класс отвечает за выбор вызываемого метода.</target>       </trans-unit>
        <trans-unit id="3354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The default binder selects the most specific match.</source>
          <target state="translated">Связыватель по умолчанию выбирает наиболее точное соответствие.</target>       </trans-unit>
        <trans-unit id="3355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.</source>
          <target state="translated">Ограничения доступа игнорируются для полностью доверенный код; то есть закрытые конструкторы, методы, поля и свойства можно получить доступ к и вызываемыми средствами отражения, если полностью доверенный код.</target>       </trans-unit>
        <trans-unit id="3356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>You can use <ph id="ph1">`Type.InvokeMember`</ph> to set a field to a particular value by specifying <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Можно использовать <ph id="ph1">`Type.InvokeMember`</ph> присвоено конкретное значение в поле, указав <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, if you want to set a public instance field named F on class C, and F is a <ph id="ph1">`String`</ph> you can use code such as:</source>
          <target state="translated">Например, если вы хотите задать полю открытого экземпляра F класса C, а F — <ph id="ph1">`String`</ph> можно использовать код, например:</target>       </trans-unit>
        <trans-unit id="3358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>If F is a <ph id="ph1">`String[]`</ph>, you can use code such as:</source>
          <target state="translated">Если F- <ph id="ph1">`String[]`</ph>, можно использовать код, например:</target>       </trans-unit>
        <trans-unit id="3359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>which will initialize the field F to this new array.</source>
          <target state="translated">который будет инициализировать поля F новым массивом.</target>       </trans-unit>
        <trans-unit id="3360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>You can also use <ph id="ph1">`Type.InvokeMember`</ph> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</source>
          <target state="translated">Можно также использовать <ph id="ph1">`Type.InvokeMember`</ph> Чтобы установить позиции в массиве, указав его индекс значения, и затем следующего значения с помощью кода примерно следующего вида:</target>       </trans-unit>
        <trans-unit id="3361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>This will change string "z" in the array that F holds to string "b".</source>
          <target state="translated">Это приведет к изменению строка «z» в массиве F строку «b».</target>       </trans-unit>
        <trans-unit id="3362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>When you invoke an <ph id="ph1">`IDispatch`</ph> member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</source>
          <target state="translated">При вызове <ph id="ph1">`IDispatch`</ph> элемента, можно указать DispID вместо имени элемента с помощью строки формата «[DispID = ##]».</target>       </trans-unit>
        <trans-unit id="3363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</source>
          <target state="translated">Например, если DispID MyComMethod равно 3, можно указать строку «[DispID = 3]» вместо «MyComMethod».</target>       </trans-unit>
        <trans-unit id="3364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Invoking a member by DispID is faster than looking up the member by name.</source>
          <target state="translated">Вызов члена по идентификатору DispID выполняется быстрее, чем поиск элемента по имени.</target>       </trans-unit>
        <trans-unit id="3365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</source>
          <target state="translated">В сложных сценариях агрегирования DispID иногда является единственным способом вызова необходимого члена.</target>       </trans-unit>
        <trans-unit id="3366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">Начиная с <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, этот метод можно использовать для доступа к закрытым членам, если вызывающему объекту предоставлены <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> и отметки Если набор прав, не являющиеся открытыми члены ограничена вызывающего набором разрешений или подмножество его.</target>       </trans-unit>
        <trans-unit id="3367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(См. <bpt id="p1">[</bpt>рекомендации по безопасности для отражения<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="3368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Для применения этих функциональных возможностей приложение должно использовать <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> или более поздние версии.</target>       </trans-unit>
        <trans-unit id="3369" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> and <ph id="ph3">&lt;paramref name="name" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> не содержит <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph>, а <ph id="ph3">&lt;paramref name="name" /&gt;</ph> равно <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3370" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> attribute.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> не является допустимым атрибутом <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3371" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3372" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain one of the following binding flags: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> не содержит одного из следующих флагов привязки: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> или <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3373" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3374" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> содержит <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> в сочетании с <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> или <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3375" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3376" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> содержит как <ph id="ph2">&lt;see langword="GetField" /&gt;</ph>, так и <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3377" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3378" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> содержит как <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph>, так и <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3379" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3380" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> or <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> содержит <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> в сочетании с <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> или <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3381" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3382" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> and <ph id="ph3">&lt;paramref name="args" /&gt;</ph> has more than one element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> содержит <ph id="ph2">&lt;see langword="SetField" /&gt;</ph>, а <ph id="ph3">&lt;paramref name="args" /&gt;</ph> содержит более одного элемента.</target>       </trans-unit>
        <trans-unit id="3383" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3384" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>This method is called on a COM object and one of the following binding flags was not passed in: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph>, or <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</source>
          <target state="translated">Этот метод вызывается для объекта COM, и один из следующих флагов привязки не был передан: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph> или <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3385" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3386" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>One of the named parameter arrays contains a string that is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Один из массивов именованных параметров содержит строку, имеющую значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3387" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The specified member is a class initializer.</source>
          <target state="translated">Указанный член является инициализатором класса.</target>       </trans-unit>
        <trans-unit id="3388" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The field or property cannot be found.</source>
          <target state="translated">Невозможно найти поле или свойство.</target>       </trans-unit>
        <trans-unit id="3389" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>No method can be found that matches the arguments in <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">Невозможно найти метод, который соответствует аргументам в <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3390" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3391" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type that contains open type parameters, that is, <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Текущий объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> представляет тип, содержащий параметры открытого типа, то есть <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> возвращает <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3392" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The specified member cannot be invoked on <ph id="ph1">&lt;paramref name="target" /&gt;</ph>.</source>
          <target state="translated">Невозможно вызвать указанный член для <ph id="ph1">&lt;paramref name="target" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3393" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>More than one method matches the binding criteria.</source>
          <target state="translated">Несколько методов соответствуют критериям привязки.</target>       </trans-unit>
        <trans-unit id="3394" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The method represented by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> has one or more unspecified generic type parameters.</source>
          <target state="translated">Метод, представленный <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, имеет один или несколько незаданных параметров универсального типа.</target>       </trans-unit>
        <trans-unit id="3395" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>That is, the method's <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">То есть свойство <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> метода возвращает <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>for accessing non-public members regardless of their grant set.</source>
          <target state="translated">для доступа к закрытым членам независимо от их разрешений набора.</target>       </trans-unit>
        <trans-unit id="3397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Связанное перечисление: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>to call unmanaged code.</source>
          <target state="translated">для вызова неуправляемого кода.</target>       </trans-unit>
        <trans-unit id="3399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Связанное перечисление: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3400" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The string containing the name of the constructor, method, property, or field member to invoke.</source>
          <target state="translated">Строка, содержащая имя вызываемого элемента — конструктора, метода, свойства или поля.</target>       </trans-unit>
        <trans-unit id="3401" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3402" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An empty string ("") to invoke the default member.</source>
          <target state="translated">Пустая строка ("") — в этом случае будет вызван член по умолчанию.</target>       </trans-unit>
        <trans-unit id="3403" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3404" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> members, a string representing the DispID, for example "[DispID=3]".</source>
          <target state="translated">Для членов <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> — строка, представляющая идентификатор DispID, например "[DispID=3]".</target>       </trans-unit>
        <trans-unit id="3405" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Битовая маска, составленная из одного или нескольких объектов <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> и указывающая, как ведется поиск.</target>       </trans-unit>
        <trans-unit id="3406" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The access can be one of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> such as <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph>, and so on.</source>
          <target state="translated">Тип доступа может быть обозначен одним из флагов <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph>, например <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph> и т.д.</target>       </trans-unit>
        <trans-unit id="3407" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The type of lookup need not be specified.</source>
          <target state="translated">Тип поиска указывать необязательно.</target>       </trans-unit>
        <trans-unit id="3408" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If the type of lookup is omitted, <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph> are used.</source>
          <target state="translated">Если тип поиска не указан, используются флаги <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3409" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.</target>       </trans-unit>
        <trans-unit id="3410" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3411" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A null reference (Nothing in Visual Basic), to use the <ph id="ph1">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Пустая ссылка (Nothing в Visual Basic) для использования свойства <ph id="ph1">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3412" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Note that explicitly defining a <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> object may be required for successfully invoking method overloads with variable arguments.</source>
          <target state="translated">Обратите внимание, что для успешного вызова перегруженных версий метода с переменными аргументами может потребоваться явное объявление объекта <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3413" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The object on which to invoke the specified member.</source>
          <target state="translated">Объект, для которого следует вызвать указанный член.</target>       </trans-unit>
        <trans-unit id="3414" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array containing the arguments to pass to the member to invoke.</source>
          <target state="translated">Массив с аргументами, передаваемыми вызываемому члену.</target>       </trans-unit>
        <trans-unit id="3415" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Массив объектов <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph>, представляющих атрибуты, связанные с соответствующим элементом в массиве <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="3416" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A parameter's associated attributes are stored in the member's signature.</source>
          <target state="translated">Атрибуты, связанные с параметром, хранятся в сигнатуре члена.</target>       </trans-unit>
        <trans-unit id="3417" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The default binder processes this parameter only when calling a COM component.</source>
          <target state="translated">Связыватель по умолчанию обрабатывает этот параметр только при вызове COM-компонента.</target>       </trans-unit>
        <trans-unit id="3418" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>, представляющий используемый языковой стандарт глобализации. Он может понадобиться для выполнения преобразований, зависящих от языкового стандарта, например приведения числа в строковом формате к типу Double.</target>       </trans-unit>
        <trans-unit id="3419" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3420" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) to use the current thread's <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>.</source>
          <target state="translated">Пустая ссылка (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> в Visual Basic) для использования объекта <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> текущего потока.</target>       </trans-unit>
        <trans-unit id="3421" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array containing the names of the parameters to which the values in the <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> array are passed.</source>
          <target state="translated">Массив, содержащий имена параметров, в которые передаются значения элементов массива <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="3422" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</source>
          <target state="translated">При переопределении в производном классе вызывает указанный член, соответствующий заданным ограничениям привязки, списку аргументов, модификаторов, а также языку и региональным параметрам.</target>       </trans-unit>
        <trans-unit id="3423" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An object representing the return value of the invoked member.</source>
          <target state="translated">Объект, представляющий возвращаемое значение вызываемого элемента.</target>       </trans-unit>
        <trans-unit id="3424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`InvokeMember`</ph> calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.</source>
          <target state="translated"><ph id="ph1">`InvokeMember`</ph> вызывает член конструктор или метод, возвращает или устанавливает значение свойства, возвращает или задает элемент поля данных, или возвращает или задает элемент массива.</target>       </trans-unit>
        <trans-unit id="3425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>You cannot use <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> to invoke a generic method.</source>
          <target state="translated">Нельзя использовать <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> в вызове универсального метода.</target>       </trans-unit>
        <trans-unit id="3426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>When you invoke an <ph id="ph1">`IDispatch`</ph> member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</source>
          <target state="translated">При вызове <ph id="ph1">`IDispatch`</ph> элемента, можно указать DispID вместо имени элемента с помощью строки формата «[DispID = ##]».</target>       </trans-unit>
        <trans-unit id="3427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</source>
          <target state="translated">Например, если DispID MyComMethod равно 3, можно указать строку «[DispID = 3]» вместо «MyComMethod».</target>       </trans-unit>
        <trans-unit id="3428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Invoking a member by DispID is faster than looking up the member by name.</source>
          <target state="translated">Вызов члена по идентификатору DispID выполняется быстрее, чем поиск элемента по имени.</target>       </trans-unit>
        <trans-unit id="3429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</source>
          <target state="translated">В сложных сценариях агрегирования DispID иногда является единственным способом вызова необходимого члена.</target>       </trans-unit>
        <trans-unit id="3430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> or <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> (the <ph id="ph3">`modifiers`</ph> and <ph id="ph4">`culture`</ph> parameters), you can use the abstract <ph id="ph5">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph6">`modifiers`</ph> and <ph id="ph7">`culture`</ph>.</source>
          <target state="translated">Несмотря на то что связыватель по умолчанию не обрабатывает <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> или <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> ( <ph id="ph3">`modifiers`</ph> и <ph id="ph4">`culture`</ph> параметров), можно использовать абстрактный <ph id="ph5">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> класс, чтобы написать собственный связыватель, обрабатывающий <ph id="ph6">`modifiers`</ph> и <ph id="ph7">`culture`</ph>.</target>       </trans-unit>
        <trans-unit id="3431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.</target>       </trans-unit>
        <trans-unit id="3432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Each parameter in the <ph id="ph1">`namedParameters`</ph> array gets the value in the corresponding element in the <ph id="ph2">`args`</ph> array.</source>
          <target state="translated">Каждый параметр в массиве <ph id="ph1">`namedParameters`</ph> получает значение от соответствующего элемента массива <ph id="ph2">`args`</ph>.</target>       </trans-unit>
        <trans-unit id="3433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If the length of <ph id="ph1">`args`</ph> is greater than the length of <ph id="ph2">`namedParameters`</ph>, the remaining argument values are passed in order.</source>
          <target state="translated">Если длина <ph id="ph1">`args`</ph> больше, чем длина <ph id="ph2">`namedParameters`</ph>, оставшиеся значения аргументов передаются по порядку.</target>       </trans-unit>
        <trans-unit id="3434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">`namedParameters`</ph> array can be used to change the order of arguments in an input array.</source>
          <target state="translated"><ph id="ph1">`namedParameters`</ph> Массива можно использовать для изменения порядка аргументов в входного массива.</target>       </trans-unit>
        <trans-unit id="3435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, given the method <ph id="ph1">`M(string a, int b)`</ph> (<ph id="ph2">`M(ByVal a As String, ByVal b As Integer)`</ph> in Visual Basic) and the input array <ph id="ph3">`{ 42, "x" }`</ph>, the input array can be passed unchanged to <ph id="ph4">`args`</ph> if the array <ph id="ph5">`{ "b", "a" }`</ph> is supplied for <ph id="ph6">`namedParameters`</ph>.</source>
          <target state="translated">Например, если метод <ph id="ph1">`M(string a, int b)`</ph> (<ph id="ph2">`M(ByVal a As String, ByVal b As Integer)`</ph> в Visual Basic) и входного массива <ph id="ph3">`{ 42, "x" }`</ph>, входного массива могут передаваться в неизмененном виде <ph id="ph4">`args`</ph> Если массив <ph id="ph5">`{ "b", "a" }`</ph> предоставляется для <ph id="ph6">`namedParameters`</ph>.</target>       </trans-unit>
        <trans-unit id="3436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги фильтра можно использовать для определения члены, которые нужно включить в поиск:</target>       </trans-unit>
        <trans-unit id="3437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.Public`</ph> для включения в поиск открытых членов.</target>       </trans-unit>
        <trans-unit id="3438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.NonPublic`</ph> для включения в поиск закрытым членам (то есть частных, внутренних и защищенные члены).</target>       </trans-unit>
        <trans-unit id="3439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include static members up the hierarchy.</source>
          <target state="translated">Укажите <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> для включения статические члены вверх по иерархии.</target>       </trans-unit>
        <trans-unit id="3440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> модификатор флаги можно использовать для изменения условий поиска:</target>       </trans-unit>
        <trans-unit id="3441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> Чтобы игнорировать регистр <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="3442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> для поиска только члены, объявленные в <ph id="ph2">&lt;xref:System.Type&gt;</ph>, не унаследованные члены группы.</target>       </trans-unit>
        <trans-unit id="3443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> invocation flags can be used to denote what action to take with the member:</source>
          <target state="translated">Следующие <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> флаги вызова можно использовать для указания действия, выполняемого с членом:</target>       </trans-unit>
        <trans-unit id="3444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`CreateInstance`</ph> to invoke a constructor.</source>
          <target state="translated"><ph id="ph1">`CreateInstance`</ph> для вызова конструктора.</target>       </trans-unit>
        <trans-unit id="3445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`name`</ph> is ignored.</source>
          <target state="translated"><ph id="ph1">`name`</ph> учитывается.</target>       </trans-unit>
        <trans-unit id="3446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with other invocation flags.</source>
          <target state="translated">Не является допустимым с другими флагами вызова.</target>       </trans-unit>
        <trans-unit id="3447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`InvokeMethod`</ph> to invoke a method, but not a constructor or a type initializer.</source>
          <target state="translated"><ph id="ph1">`InvokeMethod`</ph> для вызова метода, но не конструктор или инициализатор типа.</target>       </trans-unit>
        <trans-unit id="3448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`SetField`</ph> or <ph id="ph2">`SetProperty`</ph>.</source>
          <target state="translated">Не является допустимым с <ph id="ph1">`SetField`</ph> или <ph id="ph2">`SetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If <ph id="ph1">`InvokeMethod`</ph> is specified by itself, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, and <ph id="ph4">`BindingFlags.Static`</ph> are automatically included.</source>
          <target state="translated">Если <ph id="ph1">`InvokeMethod`</ph> указан сам по себе <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, и <ph id="ph4">`BindingFlags.Static`</ph> включаются автоматически.</target>       </trans-unit>
        <trans-unit id="3450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`GetField`</ph> to get the value of a field.</source>
          <target state="translated"><ph id="ph1">`GetField`</ph> Для получения значения поля.</target>       </trans-unit>
        <trans-unit id="3451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`SetField`</ph>.</source>
          <target state="translated">Не является допустимым с <ph id="ph1">`SetField`</ph>.</target>       </trans-unit>
        <trans-unit id="3452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`SetField`</ph> to set the value of a field.</source>
          <target state="translated"><ph id="ph1">`SetField`</ph> Чтобы задать значение поля.</target>       </trans-unit>
        <trans-unit id="3453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`GetField`</ph>.</source>
          <target state="translated">Не является допустимым с <ph id="ph1">`GetField`</ph>.</target>       </trans-unit>
        <trans-unit id="3454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`GetProperty`</ph> to get a property.</source>
          <target state="translated"><ph id="ph1">`GetProperty`</ph> Для получения свойства.</target>       </trans-unit>
        <trans-unit id="3455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`SetProperty`</ph>.</source>
          <target state="translated">Не является допустимым с <ph id="ph1">`SetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`SetProperty`</ph> to set a property.</source>
          <target state="translated"><ph id="ph1">`SetProperty`</ph> Чтобы задать свойство.</target>       </trans-unit>
        <trans-unit id="3457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`GetProperty`</ph>.</source>
          <target state="translated">Не является допустимым с <ph id="ph1">`GetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A method will be invoked if both of the following conditions are true:</source>
          <target state="translated">Метод будет вызван, если выполняются оба следующих условия:</target>       </trans-unit>
        <trans-unit id="3460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The number of parameters in the method declaration equals the number of arguments in the <ph id="ph1">`args`</ph> array (unless default arguments are defined on the member and <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> is specified).</source>
          <target state="translated">Число параметров в объявлении метода равно количеству аргументов в <ph id="ph1">`args`</ph> массив (если для члена не определены аргументы по умолчанию и <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> указан).</target>       </trans-unit>
        <trans-unit id="3461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The type of each argument can be converted by the binder to the type of the parameter.</source>
          <target state="translated">Тип каждого аргумента может преобразовываться связывателем тип параметра.</target>       </trans-unit>
        <trans-unit id="3462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The binder will find all of the matching methods.</source>
          <target state="translated">Связыватель найдет все подходящие методы.</target>       </trans-unit>
        <trans-unit id="3463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>These methods are found based upon the type of binding requested (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> values <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>, and so on).</source>
          <target state="translated">Эти методы находятся в зависимости от типа связывания (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> значения <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>и так далее).</target>       </trans-unit>
        <trans-unit id="3464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
          <target state="translated">Набор методов фильтруется по имени, количество аргументов и набор модификаторов поиска, определенных в модуле привязки.</target>       </trans-unit>
        <trans-unit id="3465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>After the method is selected, it is invoked.</source>
          <target state="translated">После выбора метода он вызывается.</target>       </trans-unit>
        <trans-unit id="3466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Accessibility is checked at that point.</source>
          <target state="translated">На этом этапе проверяется доступность.</target>       </trans-unit>
        <trans-unit id="3467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
          <target state="translated">Средство поиска может управлять поиском определения набора методов на основе связанного с методом атрибута доступности.</target>       </trans-unit>
        <trans-unit id="3468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> class is responsible for selecting the method to be invoked.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> Метод <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> класс отвечает за выбор вызываемого метода.</target>       </trans-unit>
        <trans-unit id="3469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The default binder selects the most specific match.</source>
          <target state="translated">Связыватель по умолчанию выбирает наиболее точное соответствие.</target>       </trans-unit>
        <trans-unit id="3470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`InvokeMember`</ph> can be used to invoke methods with parameters that have default values.</source>
          <target state="translated"><ph id="ph1">`InvokeMember`</ph> можно использовать для вызова методов с параметрами, имеющими значения по умолчанию.</target>       </trans-unit>
        <trans-unit id="3471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>To bind to these methods, Reflection requires <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType&gt;</ph> to be specified.</source>
          <target state="translated">Чтобы связать эти методы, требуется отражения <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType&gt;</ph> должен быть задан.</target>       </trans-unit>
        <trans-unit id="3472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For a parameter that has a default value, you can either supply a different value, or supply <ph id="ph1">&lt;xref:System.Reflection.Missing.Value?displayProperty=nameWithType&gt;</ph> to use the default value.</source>
          <target state="translated">Для параметра, имеющего значение по умолчанию, можно указать другое значение, или указать <ph id="ph1">&lt;xref:System.Reflection.Missing.Value?displayProperty=nameWithType&gt;</ph> использовать значение по умолчанию.</target>       </trans-unit>
        <trans-unit id="3473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, consider a method such as MyMethod(int x, float y = 2.0).</source>
          <target state="translated">Например, рассмотрим метод, например MyMethod (int, x, float y = 2.0).</target>       </trans-unit>
        <trans-unit id="3474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and <ph id="ph1">`Missing.Value`</ph> for the second argument.</source>
          <target state="translated">Чтобы вызвать этот метод только с первым аргументом как MyMethod(4), передать один из упомянутых выше флагов привязки и два аргумента, а именно, 4 для первого аргумента и <ph id="ph1">`Missing.Value`</ph> второго аргумента.</target>       </trans-unit>
        <trans-unit id="3475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Unless you use <ph id="ph1">`Missing.Value`</ph>, you may not omit optional parameters with the <ph id="ph2">`Invoke`</ph> method.</source>
          <target state="translated">Если вы не используете <ph id="ph1">`Missing.Value`</ph>, не менее опускать необязательные параметры с <ph id="ph2">`Invoke`</ph> метод.</target>       </trans-unit>
        <trans-unit id="3476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If you must do so, use <ph id="ph1">`InvokeMember`</ph> instead.</source>
          <target state="translated">Если необходимо сделать это, используйте <ph id="ph1">`InvokeMember`</ph> вместо него.</target>       </trans-unit>
        <trans-unit id="3477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <ph id="ph1">&lt;xref:System.Reflection&gt;</ph> whenever the code is fully trusted.</source>
          <target state="translated">Ограничения доступа игнорируются для полностью доверенный код; то есть, закрытые конструкторы, методы, поля и свойства можно получить доступ к и вызывать с помощью <ph id="ph1">&lt;xref:System.Reflection&gt;</ph> каждый раз, когда код имеет полное доверие.</target>       </trans-unit>
        <trans-unit id="3478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>You can use <ph id="ph1">`Type.InvokeMember`</ph> to set a field to a particular value by specifying <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Можно использовать <ph id="ph1">`Type.InvokeMember`</ph> присвоено конкретное значение в поле, указав <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, if you want to set a public instance field named F on class C, and F is a <ph id="ph1">`String`</ph>, you can use code such as:</source>
          <target state="translated">Например, если вы хотите задать полю открытого экземпляра F класса C, а F — <ph id="ph1">`String`</ph>, можно использовать код, например:</target>       </trans-unit>
        <trans-unit id="3480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If F is a <ph id="ph1">`String[]`</ph>, you can use code such as:</source>
          <target state="translated">Если F- <ph id="ph1">`String[]`</ph>, можно использовать код, например:</target>       </trans-unit>
        <trans-unit id="3481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>which will initialize the field F to this new array.</source>
          <target state="translated">который будет инициализировать поля F новым массивом.</target>       </trans-unit>
        <trans-unit id="3482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>You can also use <ph id="ph1">`Type.InvokeMember`</ph> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</source>
          <target state="translated">Можно также использовать <ph id="ph1">`Type.InvokeMember`</ph> Чтобы установить позиции в массиве, указав его индекс значения, и затем следующего значения с помощью кода примерно следующего вида:</target>       </trans-unit>
        <trans-unit id="3483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This will change string "z" in the array that F holds to string "b".</source>
          <target state="translated">Это приведет к изменению строка «z» в массиве F строку «b».</target>       </trans-unit>
        <trans-unit id="3484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">Начиная с <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, этот метод можно использовать для доступа к закрытым членам, если вызывающему объекту предоставлены <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> с <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> и отметки Если набор прав, не являющиеся открытыми члены ограничена вызывающего набором разрешений или подмножество его.</target>       </trans-unit>
        <trans-unit id="3485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(См. <bpt id="p1">[</bpt>рекомендации по безопасности для отражения<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="3486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Для применения этих функциональных возможностей приложение должно использовать <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> или более поздние версии.</target>       </trans-unit>
        <trans-unit id="3487" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> and <ph id="ph3">&lt;paramref name="name" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> не содержит <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph>, а <ph id="ph3">&lt;paramref name="name" /&gt;</ph> равно <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3488" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="args" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="args" /&gt;</ph> и <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> имеют разную длину.</target>       </trans-unit>
        <trans-unit id="3489" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3490" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> attribute.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> не является допустимым атрибутом <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3491" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3492" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain one of the following binding flags: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> не содержит одного из следующих флагов привязки: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> или <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3493" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3494" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> содержит <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> в сочетании с <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> или <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3495" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3496" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> содержит как <ph id="ph2">&lt;see langword="GetField" /&gt;</ph>, так и <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3497" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3498" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> содержит как <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph>, так и <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3499" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3500" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> or <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> содержит <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> в сочетании с <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> или <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3501" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3502" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> and <ph id="ph3">&lt;paramref name="args" /&gt;</ph> has more than one element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> содержит <ph id="ph2">&lt;see langword="SetField" /&gt;</ph>, а <ph id="ph3">&lt;paramref name="args" /&gt;</ph> содержит более одного элемента.</target>       </trans-unit>
        <trans-unit id="3503" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3504" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The named parameter array is larger than the argument array.</source>
          <target state="translated">Массив именованных параметров больше, чем массив аргументов.</target>       </trans-unit>
        <trans-unit id="3505" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3506" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This method is called on a COM object and one of the following binding flags was not passed in: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph>, or <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</source>
          <target state="translated">Этот метод вызывается для объекта COM, и один из следующих флагов привязки не был передан: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph> или <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3507" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3508" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>One of the named parameter arrays contains a string that is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Один из массивов именованных параметров содержит строку, имеющую значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3509" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The specified member is a class initializer.</source>
          <target state="translated">Указанный член является инициализатором класса.</target>       </trans-unit>
        <trans-unit id="3510" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The field or property cannot be found.</source>
          <target state="translated">Невозможно найти поле или свойство.</target>       </trans-unit>
        <trans-unit id="3511" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>No method can be found that matches the arguments in <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">Невозможно найти метод, который соответствует аргументам в <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3512" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3513" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>No member can be found that has the argument names supplied in <ph id="ph1">&lt;paramref name="namedParameters" /&gt;</ph>.</source>
          <target state="translated">Невозможно найти члены с именами аргументов, указанными в <ph id="ph1">&lt;paramref name="namedParameters" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3514" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="3515" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type that contains open type parameters, that is, <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Текущий объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> представляет тип, содержащий параметры открытого типа, то есть <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> возвращает <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3516" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The specified member cannot be invoked on <ph id="ph1">&lt;paramref name="target" /&gt;</ph>.</source>
          <target state="translated">Невозможно вызвать указанный член для <ph id="ph1">&lt;paramref name="target" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3517" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>More than one method matches the binding criteria.</source>
          <target state="translated">Несколько методов соответствуют критериям привязки.</target>       </trans-unit>
        <trans-unit id="3518" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The method represented by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> has one or more unspecified generic type parameters.</source>
          <target state="translated">Метод, представленный <ph id="ph1">&lt;paramref name="name" /&gt;</ph>, имеет один или несколько незаданных параметров универсального типа.</target>       </trans-unit>
        <trans-unit id="3519" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>That is, the method's <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">То есть свойство <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> метода возвращает <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>for accessing non-public members regardless of their grant set.</source>
          <target state="translated">для доступа к закрытым членам независимо от их разрешений набора.</target>       </trans-unit>
        <trans-unit id="3521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Связанное перечисление: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>to call unmanaged code.</source>
          <target state="translated">для вызова неуправляемого кода.</target>       </trans-unit>
        <trans-unit id="3523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Связанное перечисление: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3524" translate="yes" xml:space="preserve" uid="P:System.Type.IsAbstract">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is abstract and must be overridden.</source>
          <target state="translated">Возвращает значение, показывающее, является ли данный объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> абстрактным объектом, который должен быть переопределен.</target>       </trans-unit>
        <trans-unit id="3525" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is abstract; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если класс <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является абстрактным; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3526" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsAbstract%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> in the following cases:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsAbstract%2A&gt;</ph> Возвращает <ph id="ph2">`true`</ph> в следующих случаях:</target>       </trans-unit>
        <trans-unit id="3527" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The current type is abstract; that is, it cannot be instantiated, but can only serve as the base class for derived classes.</source>
          <target state="translated">Текущий тип является абстрактным. то есть он не может быть создан, но только можно использовать в качестве базового класса для производных классов.</target>       </trans-unit>
        <trans-unit id="3528" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>In C#, abstract classes are marked with the <bpt id="p1">[</bpt>abstract<ept id="p1">](~/docs/csharp/language-reference/keywords/abstract.md)</ept> keyword; in Visual Basic, they are marked with the <bpt id="p2">[</bpt>MustInherit<ept id="p2">](~/docs/visual-basic/language-reference/modifiers/mustinherit.md)</ept> keyword.</source>
          <target state="translated">В C#, абстрактные классы отмечены <bpt id="p1">[</bpt>абстрактный<ept id="p1">](~/docs/csharp/language-reference/keywords/abstract.md)</ept> ключевого слова; в Visual Basic, они отмечены <bpt id="p2">[</bpt>MustInherit<ept id="p2">](~/docs/visual-basic/language-reference/modifiers/mustinherit.md)</ept> ключевое слово.</target>       </trans-unit>
        <trans-unit id="3529" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The current type is an interface.</source>
          <target state="translated">Текущий тип является интерфейсом.</target>       </trans-unit>
        <trans-unit id="3530" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3531" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The following example creates an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects that represent the following types:contains type returns <ph id="ph2">`true`</ph> if the specified object is <ph id="ph3">`abstract`</ph>; otherwise, it returns <ph id="ph4">`false`</ph>.</source>
          <target state="translated">В следующем примере создается массив <ph id="ph1">&lt;xref:System.Type&gt;</ph> объекты, представляющие следующие типы: содержит возвращаемые значения типа <ph id="ph2">`true`</ph> , если указанный объект <ph id="ph3">`abstract`</ph>; в противном случае он возвращает <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3532" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`AbstractClass`</ph>, an abstract class (a class marked as <ph id="ph2">`abstract`</ph> in C# and <ph id="ph3">`MustInherit`</ph> in Visual Basic).</source>
          <target state="translated"><ph id="ph1">`AbstractClass`</ph>, абстрактного класса (класс, помеченный как <ph id="ph2">`abstract`</ph> в C# и <ph id="ph3">`MustInherit`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="3533" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`DerivedClass`</ph>, a class that inherits from <ph id="ph2">`AbstractClass`</ph>.</source>
          <target state="translated"><ph id="ph1">`DerivedClass`</ph>, который наследует от класса <ph id="ph2">`AbstractClass`</ph>.</target>       </trans-unit>
        <trans-unit id="3534" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`SingleClass`</ph>, a non-inheritable class.</source>
          <target state="translated"><ph id="ph1">`SingleClass`</ph>, класс не наследуется.</target>       </trans-unit>
        <trans-unit id="3535" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>It is defined as <ph id="ph1">`sealed`</ph> in C# and <ph id="ph2">`NotInheritable`</ph> in Visual Basic.</source>
          <target state="translated">Он определяется как <ph id="ph1">`sealed`</ph> в C# и <ph id="ph2">`NotInheritable`</ph> в Visual Basic.</target>       </trans-unit>
        <trans-unit id="3536" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`ITypeInfo`</ph>, an interface.</source>
          <target state="translated"><ph id="ph1">`ITypeInfo`</ph>, интерфейс.</target>       </trans-unit>
        <trans-unit id="3537" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`ImplementingClass`</ph>, a class that implements the <ph id="ph2">`ITypeInfo`</ph> interface.</source>
          <target state="translated"><ph id="ph1">`ImplementingClass`</ph>, класс, реализующий <ph id="ph2">`ITypeInfo`</ph> интерфейса.</target>       </trans-unit>
        <trans-unit id="3538" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The method returns <ph id="ph1">`true`</ph> only for <ph id="ph2">`AbstractClass`</ph>, the abstract class, and <ph id="ph3">`ITypeInfo`</ph>, the interface.</source>
          <target state="translated">Метод возвращает <ph id="ph1">`true`</ph> только для <ph id="ph2">`AbstractClass`</ph>, абстрактного класса, и <ph id="ph3">`ITypeInfo`</ph>, интерфейс.</target>       </trans-unit>
        <trans-unit id="3539" translate="yes" xml:space="preserve" uid="P:System.Type.IsAnsiClass">
          <source>Gets a value indicating whether the string format attribute <ph id="ph1">&lt;see langword="AnsiClass" /&gt;</ph> is selected for the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает значение, позволяющее определить, выбран ли для объекта <ph id="ph1">&lt;see langword="AnsiClass" /&gt;</ph> атрибут формата строки <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3540" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the string format attribute <ph id="ph2">&lt;see langword="AnsiClass" /&gt;</ph> is selected for the <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если для данного объекта <ph id="ph2">&lt;see langword="AnsiClass" /&gt;</ph> выбран атрибут формата строки <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; в противном случае — значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3541" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> selects the string format attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> Выбирает атрибутов формата строки.</target>       </trans-unit>
        <trans-unit id="3542" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>The string format attributes enhance interoperability by defining how strings should be interpreted.</source>
          <target state="translated">Атрибуты формата строки расширяют возможности взаимодействия, определение того, как должны интерпретироваться строки.</target>       </trans-unit>
        <trans-unit id="3543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, this property pertains to the generic type definition from which the type was constructed.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет универсальный тип, это свойство относится к определению универсального типа, тип был создан.</target>       </trans-unit>
        <trans-unit id="3544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Например если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> в Visual Basic), значение этого свойства определяется <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3545" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа универсального типа, это свойство всегда возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3546" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>The following example gets the field information and checks for the <ph id="ph1">`AnsiClass`</ph> attribute.</source>
          <target state="translated">В следующем примере возвращаются сведения и проверяет наличие <ph id="ph1">`AnsiClass`</ph> атрибута.</target>       </trans-unit>
        <trans-unit id="3547" translate="yes" xml:space="preserve" uid="P:System.Type.IsArray">
          <source>Gets a value that indicates whether the type is an array.</source>
          <target state="translated">Возвращает значение, показывающее, является ли тип массивом.</target>       </trans-unit>
        <trans-unit id="3548" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is an array; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий тип является массивом; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3549" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsArray%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for the <ph id="ph3">&lt;xref:System.Array&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsArray%2A&gt;</ph> Возвращает <ph id="ph2">`false`</ph> для <ph id="ph3">&lt;xref:System.Array&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="3550" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>It also returns <ph id="ph1">`false`</ph> if the current instance is a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a collection type or an interface designed to work with collections, such as <ph id="ph3">&lt;xref:System.Collections.IEnumerable&gt;</ph> or <ph id="ph4">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.</source>
          <target state="translated">Он также возвращает <ph id="ph1">`false`</ph> , если текущий экземпляр является <ph id="ph2">&lt;xref:System.Type&gt;</ph> объект, представляющий тип коллекции или интерфейс предназначен для работы с коллекциями, таких как <ph id="ph3">&lt;xref:System.Collections.IEnumerable&gt;</ph> или <ph id="ph4">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3551" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>To check for an array, use code such as:</source>
          <target state="translated">Чтобы проверить наличие массив, можно используйте следующий код:</target>       </trans-unit>
        <trans-unit id="3552" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>If the current type represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Если текущий тип представляет универсальный тип или параметр типа в определении универсального типа или универсального метода, это свойство всегда возвращает <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3553" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>This property is read-only.</source>
          <target state="translated">Это свойство доступно только для чтения.</target>       </trans-unit>
        <trans-unit id="3554" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>The following example demonstrates using the <ph id="ph1">&lt;xref:System.Type.IsArray%2A&gt;</ph> property.</source>
          <target state="translated">В следующем примере показано использование <ph id="ph1">&lt;xref:System.Type.IsArray%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="3555" translate="yes" xml:space="preserve" uid="M:System.Type.IsArrayImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsArray" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array.</source>
          <target state="translated">При переопределении в производном классе реализует свойство <ph id="ph1">&lt;see cref="P:System.Type.IsArray" /&gt;</ph> и определяет, является ли данный объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> массивом.</target>       </trans-unit>
        <trans-unit id="3556" translate="yes" xml:space="preserve" uid="M:System.Type.IsArrayImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является массивом; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsArrayImpl">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class must return <ph id="ph2">`false`</ph> because it is an object, not an array.</source>
          <target state="translated">Экземпляр <ph id="ph1">&lt;xref:System.Array&gt;</ph> должны возвращать класс <ph id="ph2">`false`</ph> , так как он является объектом, не массив.</target>       </trans-unit>
        <trans-unit id="3558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsArrayImpl">
          <source>The following example overrides the <ph id="ph1">`IsArrayImpl`</ph> method in the <ph id="ph2">`MyTypeDelegator`</ph> class, checks if a variable is an array, and displays the result.</source>
          <target state="translated">В следующем примере переопределяется <ph id="ph1">`IsArrayImpl`</ph> метод <ph id="ph2">`MyTypeDelegator`</ph> класса, проверяется, если переменная является массивом и отображается результат.</target>       </trans-unit>
        <trans-unit id="3559" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The type to compare with the current type.</source>
          <target state="translated">Тип для сравнения с текущим типом.</target>       </trans-unit>
        <trans-unit id="3560" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>Determines whether an instance of a specified type can be assigned to an instance of the current type.</source>
          <target state="translated">Определяет, можно ли присвоить экземпляр указанного типа экземпляру текущего типа.</target>       </trans-unit>
        <trans-unit id="3561" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if any of the following conditions is true:</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если истинно любое из следующих условий:</target>       </trans-unit>
        <trans-unit id="3562" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> and the current instance represent the same type.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="c" /&gt;</ph> и текущий экземпляр принадлежат к одному типу.</target>       </trans-unit>
        <trans-unit id="3563" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is derived either directly or indirectly from the current instance.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="c" /&gt;</ph> унаследован прямо или косвенно от текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="3564" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is derived directly from the current instance if it inherits from the current instance; <ph id="ph2">&lt;paramref name="c" /&gt;</ph> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;paramref name="c" /&gt;</ph> является производным непосредственно от текущего экземпляра, если он наследуется от него. Параметр <ph id="ph2">&lt;paramref name="c" /&gt;</ph> является косвенно производным от текущего экземпляра, если он наследуется от последовательности одного или нескольких классов, наследуемых от текущего экземпляра.</target>       </trans-unit>
        <trans-unit id="3565" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The current instance is an interface that <ph id="ph1">&lt;paramref name="c" /&gt;</ph> implements.</source>
          <target state="translated">Текущий экземпляр является интерфейсом, который реализуется параметром <ph id="ph1">&lt;paramref name="c" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3566" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is a generic type parameter, and the current instance represents one of the constraints of <ph id="ph2">&lt;paramref name="c" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> является параметром универсального типа, а текущий экземпляр представляет одно из ограничений, наложенных на параметр <ph id="ph2">&lt;paramref name="c" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3567" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>In the following example, the current instance is a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> class.</source>
          <target state="translated">В приведенном ниже примере текущий экземпляр является объектом <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, который представляет класс <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3568" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><bpt id="p1">&lt;c&gt;</bpt>GenericWithConstraint<ept id="p1">&lt;/c&gt;</ept> is a generic type whose generic type parameter must be of type    <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>GenericWithConstraint<ept id="p1">&lt;/c&gt;</ept> — это универсальный тип, параметр универсального типа которого должен иметь тип <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3569" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>Passing its generic type parameter to the <ph id="ph1">&lt;see cref="M:System.Type.IsAssignableFrom(System.Type)" /&gt;</ph> indicates that  an instance of the generic type parameter can be assigned to an <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> object.</source>
          <target state="translated">Передача этого параметра универсального типа в <ph id="ph1">&lt;see cref="M:System.Type.IsAssignableFrom(System.Type)" /&gt;</ph> означает, что экземпляр параметра универсального типа можно присвоить объекту <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3570" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> represents a value type, and the current instance represents <bpt id="p1">&lt;c&gt;</bpt>Nullable<ph id="ph2">&amp;lt;</ph>c<ph id="ph3">&amp;gt;</ph><ept id="p1">&lt;/c&gt;</ept> (<bpt id="p2">&lt;c&gt;</bpt>Nullable(Of c)<ept id="p2">&lt;/c&gt;</ept> in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> представляет тип значения, а текущий экземпляр представляет <bpt id="p1">&lt;c&gt;</bpt>Nullable<ph id="ph2">&amp;lt;</ph>c<ph id="ph3">&amp;gt;</ph><ept id="p1">&lt;/c&gt;</ept> (<bpt id="p2">&lt;c&gt;</bpt>Nullable(Of c)<ept id="p2">&lt;/c&gt;</ept> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="3571" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if none of these conditions are true, or if <ph id="ph2">&lt;paramref name="c" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="false" /&gt;</ph>, если не выполняется ни одно из этих условий или значение параметра <ph id="ph2">&lt;paramref name="c" /&gt;</ph> равно <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph> method can be used to determine whether an instance of <ph id="ph2">`c`</ph> can be assigned to an instance of the current type, The method is most useful when you are handling objects whose types are not known at design time and allows for conditional assignment, as the following example shows.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph> Метод может использоваться, чтобы определить, является ли экземпляр <ph id="ph2">`c`</ph> можно назначить к экземпляру текущего типа, метод особенно полезен при работе с объектами, типы которых не известны во время разработки и обеспечивает условный Показывает назначений, в следующем примере.</target>       </trans-unit>
        <trans-unit id="3573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>This method thus ensures that a line of code like the following will execute at runtime without throwing an <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> exception or a similar exception:</source>
          <target state="translated">Этот метод таким образом гарантирует, что строка кода, как следующие будет выполняться во время выполнения, не вызывая <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> или аналогичные исключений:</target>       </trans-unit>
        <trans-unit id="3574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Этот метод может быть переопределен в производном классе.</target>       </trans-unit>
        <trans-unit id="3575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>A generic type definition is not assignable from a closed constructed type.</source>
          <target state="translated">Определение универсального типа не может быть назначен из закрытым сконструированным типом.</target>       </trans-unit>
        <trans-unit id="3576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>That is, you cannot assign the closed constructed type <ph id="ph1">`MyGenericList&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericList(Of Integer)`</ph> in Visual Basic) to a variable of type <ph id="ph3">`MyGenericList&lt;T&gt;`</ph>.</source>
          <target state="translated">То есть нельзя назначить закрытым сконструированным типом <ph id="ph1">`MyGenericList&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericList(Of Integer)`</ph> в Visual Basic) для переменной типа <ph id="ph3">`MyGenericList&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>If the <ph id="ph1">`c`</ph> parameter is of type <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>, the result is based on the type that is to be built.</source>
          <target state="translated">Если <ph id="ph1">`c`</ph> параметр имеет тип <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>, результат зависит от типа, который должен быть построен.</target>       </trans-unit>
        <trans-unit id="3578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The following code example demonstrates this using a built type named <ph id="ph1">`B`</ph>.</source>
          <target state="translated">В следующем примере кода это демонстрируется использование типа сборки с именем <ph id="ph1">`B`</ph>.</target>       </trans-unit>
        <trans-unit id="3579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The following example demonstrates the <ph id="ph1">`IsAssignableFrom`</ph> method using defined classes, integer arrays, and generics.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">`IsAssignableFrom`</ph> метода с помощью определенных классов, целое число со знаком массивы и универсальные шаблоны.</target>       </trans-unit>
        <trans-unit id="3580" translate="yes" xml:space="preserve" uid="P:System.Type.IsAutoClass">
          <source>Gets a value indicating whether the string format attribute <ph id="ph1">&lt;see langword="AutoClass" /&gt;</ph> is selected for the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает значение, позволяющее определить, выбран ли для объекта <ph id="ph1">&lt;see langword="AutoClass" /&gt;</ph> атрибут формата строки <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3581" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the string format attribute <ph id="ph2">&lt;see langword="AutoClass" /&gt;</ph> is selected for the <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если для данного объекта <ph id="ph2">&lt;see langword="AutoClass" /&gt;</ph> выбран атрибут формата строки <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; в противном случае — значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3582" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> selects the string format attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> Выбирает атрибутов формата строки.</target>       </trans-unit>
        <trans-unit id="3583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>The string format attributes enhance interoperability by defining how strings should be interpreted.</source>
          <target state="translated">Атрибуты формата строки расширяют возможности взаимодействия, определение того, как должны интерпретироваться строки.</target>       </trans-unit>
        <trans-unit id="3584" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, тип был создан.</target>       </trans-unit>
        <trans-unit id="3585" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Например если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> в Visual Basic), значение этого свойства определяется <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3586" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа универсального типа, это свойство всегда возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3587" translate="yes" xml:space="preserve" uid="P:System.Type.IsAutoLayout">
          <source>Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.</source>
          <target state="translated">Возвращает значение, указывающее, выкладываются ли поля текущего типа автоматически средой CLR.</target>       </trans-unit>
        <trans-unit id="3588" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> property of the current type includes <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.AutoLayout" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если свойство <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> текущего типа включает <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.AutoLayout" /&gt;</ph>; в противном случае — значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3589" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>This property is provided as a convenience.</source>
          <target state="translated">Это свойство предоставляется для удобства.</target>       </trans-unit>
        <trans-unit id="3590" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> enumeration value to select the type layout attributes, and then test whether <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> is set.</source>
          <target state="translated">Кроме того, можно использовать <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> значение перечисления, чтобы выбрать атрибуты макета типа и проверки ли <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> имеет значение.</target>       </trans-unit>
        <trans-unit id="3591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>,<ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> enumeration values indicate the way the fields of the type are laid out in memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>,<ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, И <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> значения перечисления указывают способ поля типа располагаются в памяти.</target>       </trans-unit>
        <trans-unit id="3592" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>For dynamic types, you can specify <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> when you create the type.</source>
          <target state="translated">Для динамических типов, можно указать <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> при создании типа.</target>       </trans-unit>
        <trans-unit id="3593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>In code, apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType&gt;</ph> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.</source>
          <target state="translated">В коде, применить <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> атрибутом <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType&gt;</ph> значение перечисления в тип, позволяющий определить подходящий способ размещения класса среды выполнения.</target>       </trans-unit>
        <trans-unit id="3594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>You cannot use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method to determine whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> has been applied to a type.</source>
          <target state="translated">Нельзя использовать <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> метод, чтобы определить, является ли <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> был применен к типу.</target>       </trans-unit>
        <trans-unit id="3595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, тип был создан.</target>       </trans-unit>
        <trans-unit id="3596" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;.`</ph></source>
          <target state="translated">Например если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> в Visual Basic), значение этого свойства определяется <ph id="ph4">`MyGenericType&lt;T&gt;.`</ph></target>       </trans-unit>
        <trans-unit id="3597" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3598" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>The following example creates an instance of the type and displays the <ph id="ph1">&lt;xref:System.Type.IsAutoLayout%2A&gt;</ph> property.</source>
          <target state="translated">В следующем примере создается экземпляр типа и отображает <ph id="ph1">&lt;xref:System.Type.IsAutoLayout%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="3599" translate="yes" xml:space="preserve" uid="P:System.Type.IsByRef">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference.</source>
          <target state="translated">Возвращает значение, указывающее, передан ли объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> по ссылке.</target>       </trans-unit>
        <trans-unit id="3600" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> передан по ссылке; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3601" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source>To get to the actual type, dereference the type that was passed by reference, and then call <ph id="ph1">&lt;xref:System.Type.GetElementType%2A&gt;</ph> on that type.</source>
          <target state="translated">Чтобы получить фактический тип, разыменования тип, который был передан по ссылке, а затем вызвать <ph id="ph1">&lt;xref:System.Type.GetElementType%2A&gt;</ph> этого типа.</target>       </trans-unit>
        <trans-unit id="3602" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source>The following example demonstrates a use of the <ph id="ph1">`IsByRef`</ph> property to check whether a specified type is passed by reference.</source>
          <target state="translated">В следующем примере показано использование <ph id="ph1">`IsByRef`</ph> свойство, чтобы проверить, передается ли указанный тип по ссылке.</target>       </trans-unit>
        <trans-unit id="3603" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source>The example defines the class <ph id="ph1">`MyTypeDelegator`</ph>, which overrides the <ph id="ph2">`HasElementTypeImpl`</ph> method.</source>
          <target state="translated">В примере определяется класс <ph id="ph1">`MyTypeDelegator`</ph>, перезаписав <ph id="ph2">`HasElementTypeImpl`</ph> метод.</target>       </trans-unit>
        <trans-unit id="3604" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source>The main class checks for the <ph id="ph1">`HasElementType`</ph> property and displays the element type.</source>
          <target state="translated">Главный класс проверяет <ph id="ph1">`HasElementType`</ph> свойства и отображает тип элемента.</target>       </trans-unit>
        <trans-unit id="3605" translate="yes" xml:space="preserve" uid="M:System.Type.IsByRefImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference.</source>
          <target state="translated">При переопределении в производном классе реализует свойство <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> и определяет, передается ли данный объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> по ссылке.</target>       </trans-unit>
        <trans-unit id="3606" translate="yes" xml:space="preserve" uid="M:System.Type.IsByRefImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> передан по ссылке; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3607" translate="yes" xml:space="preserve" uid="P:System.Type.IsClass">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a class or a delegate; that is, not a value type or interface.</source>
          <target state="translated">Получает значение, позволяющее определить, является объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> классом или делегатом (иными словами, не является типом значения или интерфейсом).</target>       </trans-unit>
        <trans-unit id="3608" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a class; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является классом; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3609" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>This property returns <ph id="ph1">`true`</ph> for classes as well as delegates.</source>
          <target state="translated">Это свойство возвращает <ph id="ph1">`true`</ph> для классов, а также делегаты.</target>       </trans-unit>
        <trans-unit id="3610" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>It returns <ph id="ph1">`false`</ph> for value types (for structures and enumerations) even if they are boxed.</source>
          <target state="translated">Он возвращает <ph id="ph1">`false`</ph> для типов значений (для структур и перечислений) даже в том случае, если упакованы.</target>       </trans-unit>
        <trans-unit id="3611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`true`</ph>.If the current <ph id="ph3">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns <ph id="ph4">`true`</ph> if the generic type definition is a class definition; that is, it does not define an interface or a value type.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает <ph id="ph2">`true`</ph>. Если текущий <ph id="ph3">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, это свойство возвращает <ph id="ph4">`true`</ph> Если определение универсального типа является определением класса; то есть, он не определяет интерфейсом или типом значения.</target>       </trans-unit>
        <trans-unit id="3612" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>This property returns <ph id="ph1">`true`</ph> for <ph id="ph2">`Type`</ph> instances that represent the <ph id="ph3">&lt;xref:System.Enum&gt;</ph> and <ph id="ph4">&lt;xref:System.ValueType&gt;</ph> classes.</source>
          <target state="translated">Это свойство возвращает <ph id="ph1">`true`</ph> для <ph id="ph2">`Type`</ph> экземпляров, представляющего <ph id="ph3">&lt;xref:System.Enum&gt;</ph> и <ph id="ph4">&lt;xref:System.ValueType&gt;</ph> классы.</target>       </trans-unit>
        <trans-unit id="3613" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves.</source>
          <target state="translated">Эти классы являются базовые типы перечисления и типы значений, соответственно, но они не являются перечисления или тип значения, сами.</target>       </trans-unit>
        <trans-unit id="3614" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Type.IsValueType%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.IsEnum%2A&gt;</ph> properties.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Type.IsValueType%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Type.IsEnum%2A&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="3615" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType&gt;</ph> enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType&gt;</ph> Значение перечисления, являющийся отличительным признаком объявление типа, как класс или интерфейс. Тем не менее, классов и типов значений, помечены <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType&gt;</ph> атрибута.</target>       </trans-unit>
        <trans-unit id="3616" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>If you retrieve the value of a type's Attributes property and use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType&gt;</ph> value to determine whether a type is a class instead of a value type, you must also call the <ph id="ph2">&lt;xref:System.Type.IsValueType%2A&gt;</ph> property.</source>
          <target state="translated">Если извлечь значение свойства атрибуты и использовать тип <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType&gt;</ph> значение, чтобы определить, является ли тип классом вместо типа значения, необходимо вызвать <ph id="ph2">&lt;xref:System.Type.IsValueType%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="3617" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>The example for the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration contains additional information as well as anexample.</source>
          <target state="translated">Пример для <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> перечисление содержит дополнительные сведения, а также anexample.</target>       </trans-unit>
        <trans-unit id="3618" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>This property is read-only.</source>
          <target state="translated">Это свойство доступно только для чтения.</target>       </trans-unit>
        <trans-unit id="3619" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>The following example creates an instance of a type and indicates whether the type is a class.</source>
          <target state="translated">Следующий пример создает экземпляр типа и указывает, является ли тип классом.</target>       </trans-unit>
        <trans-unit id="3620" translate="yes" xml:space="preserve" uid="P:System.Type.IsCOMObject">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object.</source>
          <target state="translated">Возвращает значение, указывающее, является ли объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> COM-объектом.</target>       </trans-unit>
        <trans-unit id="3621" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является COM-объектом, в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3622" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>This method returns <ph id="ph1">`false`</ph> for COM interfaces because they are not objects.</source>
          <target state="translated">Этот метод возвращает <ph id="ph1">`false`</ph> для интерфейсов COM, так как они не являются объектами.</target>       </trans-unit>
        <trans-unit id="3623" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>COM interfaces can be implemented by Microsoft .NET Framework objects.</source>
          <target state="translated">Интерфейсы COM, могут быть реализованы объектами Microsoft .NET Framework.</target>       </trans-unit>
        <trans-unit id="3624" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>You can also load a COM class and get a <ph id="ph1">`Type`</ph> object for that COM class by using the <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool.</source>
          <target state="translated">Можно также загрузить класс COM и получить <ph id="ph1">`Type`</ph> объект для этого класса COM с помощью <bpt id="p1">[</bpt>Tlbimp.exe (программа импорта библиотек типов)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> средства.</target>       </trans-unit>
        <trans-unit id="3625" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, тип был создан.</target>       </trans-unit>
        <trans-unit id="3626" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int`</ph>&gt; (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Например если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет <ph id="ph2">`MyGenericType&lt;int`</ph>&gt; (<ph id="ph3">`MyGenericType(Of Integer)`</ph> в Visual Basic), значение этого свойства определяется <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3627" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3628" translate="yes" xml:space="preserve" uid="M:System.Type.IsCOMObjectImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsCOMObject" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object.</source>
          <target state="translated">При переопределении в производном классе реализует свойство <ph id="ph1">&lt;see cref="P:System.Type.IsCOMObject" /&gt;</ph> и определяет, является ли объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> COM-объектом.</target>       </trans-unit>
        <trans-unit id="3629" translate="yes" xml:space="preserve" uid="M:System.Type.IsCOMObjectImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является COM-объектом, в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsCOMObjectImpl">
          <source>This method returns <ph id="ph1">`false`</ph> for COM interfaces because they are not objects.</source>
          <target state="translated">Этот метод возвращает <ph id="ph1">`false`</ph> для интерфейсов COM, так как они не являются объектами.</target>       </trans-unit>
        <trans-unit id="3631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsCOMObjectImpl">
          <source>COM interfaces can be implemented by Microsoft .NET Framework objects.</source>
          <target state="translated">Интерфейсы COM, могут быть реализованы объектами Microsoft .NET Framework.</target>       </trans-unit>
        <trans-unit id="3632" translate="yes" xml:space="preserve" uid="P:System.Type.IsConstructedGenericType">
          <source>Gets a value that indicates whether this object represents a constructed generic type.</source>
          <target state="translated">Возвращает значение, указывающее, представляет ли этот данный объект сконструированный универсальный тип.</target>       </trans-unit>
        <trans-unit id="3633" translate="yes" xml:space="preserve" uid="P:System.Type.IsConstructedGenericType">
          <source>You can create instances of a constructed generic type.</source>
          <target state="translated">Можно создать экземпляры сконструированного универсального типа.</target>       </trans-unit>
        <trans-unit id="3634" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsConstructedGenericType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this object represents a constructed generic type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если этот объект представляет сконструированный универсальный тип; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3635" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsConstructedGenericType">
          <source>A constructed generic type has had explicit types supplied for all of its generic type parameters.</source>
          <target state="translated">Сконструированный универсальный тип был явно типы, предоставленный для всех параметров универсального типа.</target>       </trans-unit>
        <trans-unit id="3636" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsConstructedGenericType">
          <source>It is also referred to as a closed generic type.</source>
          <target state="translated">Его также называют закрытого универсального типа.</target>       </trans-unit>
        <trans-unit id="3637" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsConstructedGenericType">
          <source>When this property is <ph id="ph1">`true`</ph>, you can create instances of the current type; when it is <ph id="ph2">`false`</ph>, you can't.</source>
          <target state="translated">Если этому свойству присвоено <ph id="ph1">`true`</ph>, когда это, можно создать экземпляры текущего типа <ph id="ph2">`false`</ph>, невозможно.</target>       </trans-unit>
        <trans-unit id="3638" translate="yes" xml:space="preserve" uid="P:System.Type.IsContextful">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> can be hosted in a context.</source>
          <target state="translated">Возвращает значение, позволяющее определить, можно ли поместить в контекст объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> can be hosted in a context; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> может быть помещен в контекст; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization.</source>
          <target state="translated">Контекст перехватывает вызовы к членам класса и принудительно применяет политики, применяемые к классу, например синхронизации.</target>       </trans-unit>
        <trans-unit id="3641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>For more detailed information on remoting contexts, see <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.Context&gt;</ph>.</source>
          <target state="translated">Более подробные сведения о контекстах удаленного взаимодействия см. в разделе <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.Context&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>The following example demonstrates the <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> properties of the <ph id="ph4">&lt;xref:System.Type&gt;</ph> class.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, и <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> свойства <ph id="ph4">&lt;xref:System.Type&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="3644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</source>
          <target state="translated">Проверяется ли данный тип может размещаться в контексте ли он может быть маршалирован по ссылке и является ли тип примитивный тип данных.</target>       </trans-unit>
        <trans-unit id="3645" translate="yes" xml:space="preserve" uid="M:System.Type.IsContextfulImpl">
          <source>Implements the <ph id="ph1">&lt;see cref="P:System.Type.IsContextful" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> can be hosted in a context.</source>
          <target state="translated">Реализует свойство <ph id="ph1">&lt;see cref="P:System.Type.IsContextful" /&gt;</ph> и определяет, можно ли поместить в контекст данный объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3646" translate="yes" xml:space="preserve" uid="M:System.Type.IsContextfulImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> can be hosted in a context; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> может быть помещен в контекст; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsContextfulImpl">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Этот метод может быть переопределен в производном классе.</target>       </trans-unit>
        <trans-unit id="3648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsContextfulImpl">
          <source>A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</source>
          <target state="translated">Контекст перехватывает вызовы к членам класса и применять политики, которые применяются к классу, например синхронизации.</target>       </trans-unit>
        <trans-unit id="3649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsContextfulImpl">
          <source>The following example demonstrates a use of the <ph id="ph1">`IsContextfulImpl`</ph> method.</source>
          <target state="translated">В следующем примере показано использование <ph id="ph1">`IsContextfulImpl`</ph> метода.</target>       </trans-unit>
        <trans-unit id="3650" translate="yes" xml:space="preserve" uid="P:System.Type.IsEnum">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents an enumeration.</source>
          <target state="translated">Возвращает значение, позволяющее определить, представляет ли текущий объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> перечисление.</target>       </trans-unit>
        <trans-unit id="3651" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> represents an enumeration; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> представляет перечисление; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>This property returns <ph id="ph1">`true`</ph> for an enumeration, but not for the <ph id="ph2">&lt;xref:System.Enum&gt;</ph> type itself.</source>
          <target state="translated">Это свойство возвращает <ph id="ph1">`true`</ph> для перечисления, но не для <ph id="ph2">&lt;xref:System.Enum&gt;</ph> сами типы.</target>       </trans-unit>
        <trans-unit id="3653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, тип был создан.</target>       </trans-unit>
        <trans-unit id="3654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Например если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> в Visual Basic), значение этого свойства определяется <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3655" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3656" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>This property is read-only.</source>
          <target state="translated">Это свойство доступно только для чтения.</target>       </trans-unit>
        <trans-unit id="3657" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>The following example demonstrates how to use the <ph id="ph1">`IsEnum`</ph> property.</source>
          <target state="translated">В следующем примере демонстрируется использование <ph id="ph1">`IsEnum`</ph> свойство.</target>       </trans-unit>
        <trans-unit id="3658" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source>The value to be tested.</source>
          <target state="translated">Проверяемое значение.</target>       </trans-unit>
        <trans-unit id="3659" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source>Returns a value that indicates whether the specified value exists in the current enumeration type.</source>
          <target state="translated">Возвращает значение, показывающее, имеется ли в текущем типе перечисления указанное значение.</target>       </trans-unit>
        <trans-unit id="3660" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified value is a member of the current enumeration type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если указанное значение является членом текущего типа перечисления; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3661" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source>The current type is not an enumeration.</source>
          <target state="translated">Текущий тип не является перечислением.</target>       </trans-unit>
        <trans-unit id="3662" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="value" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3663" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is of a type that cannot be the underlying type of an enumeration.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> не является типом и не может быть основным типом для перечисления.</target>       </trans-unit>
        <trans-unit id="3664" translate="yes" xml:space="preserve" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>The COM type that is tested for equivalence with the current type.</source>
          <target state="translated">Тип модели COM, который проверяется на эквивалентность текущему типу.</target>       </trans-unit>
        <trans-unit id="3665" translate="yes" xml:space="preserve" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Determines whether two COM types have the same identity and are eligible for type equivalence.</source>
          <target state="translated">Определяет, имеют ли два типа модели COM одинаковые удостоверения и могут ли они считаться эквивалентными.</target>       </trans-unit>
        <trans-unit id="3666" translate="yes" xml:space="preserve" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the COM types are equivalent; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если типы модели COM эквивалентны; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3667" translate="yes" xml:space="preserve" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>This method also returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.</source>
          <target state="translated">Этот метод также возвращает значение <ph id="ph1">&lt;see langword="false" /&gt;</ph>, если один тип находится в сборке, загружаемой для исполнения, а другой — в сборке, загружаемой в контекст, предназначенный только для отражения.</target>       </trans-unit>
        <trans-unit id="3668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies.</source>
          <target state="translated">Начиная с версии <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, общеязыковая среда выполнения поддерживает внедрение сведений о типах COM непосредственно в управляемые сборки, не требуя управляемые сборки для получения сведений о типах COM из взаимодействия сборки.</target>       </trans-unit>
        <trans-unit id="3669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type.</source>
          <target state="translated">Так как внедренные сведения о типах включают в себя только типы и члены, которые действительно используются в управляемой сборке, в двух управляемых сборках могут быть очень разные представления одного типа COM.</target>       </trans-unit>
        <trans-unit id="3670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Each managed assembly has a different <ph id="ph1">&lt;xref:System.Type&gt;</ph> object to represent its view of the COM type.</source>
          <target state="translated">Все управляемые сборки имеют разные объекты <ph id="ph1">&lt;xref:System.Type&gt;</ph> для обозначения представления типа COM.</target>       </trans-unit>
        <trans-unit id="3671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.</source>
          <target state="translated">Среда CLR поддерживает эквивалентность типов между этими разными представлениями для интерфейсов, структур, перечислений и делегатов.</target>       </trans-unit>
        <trans-unit id="3672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly.</source>
          <target state="translated">Эквивалентность типов означает, что COM-объект, передаваемый из одной управляемой сборки в другую, можно привести к соответствующему управляемому типу в принимающей сборке.</target>       </trans-unit>
        <trans-unit id="3673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsEquivalentTo%2A&gt;</ph> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsEquivalentTo%2A&gt;</ph> Метод включает сборку определить, что COM-объект, полученный из другой сборки имеет то же удостоверение COM, как один из типов взаимодействия первой сборки собственные внедренных и таким образом, может быть приведен к этому типу.</target>       </trans-unit>
        <trans-unit id="3674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>For more information, see <bpt id="p1">[</bpt>Type Equivalence and Embedded Interop Types<ept id="p1">](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>эквивалентности типов и внедренных типов взаимодействия<ept id="p1">](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3675" translate="yes" xml:space="preserve" uid="P:System.Type.IsExplicitLayout">
          <source>Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.</source>
          <target state="translated">Возвращает значение, указывающее, выкладываются ли поля текущего типа с явно заданными смещениями.</target>       </trans-unit>
        <trans-unit id="3676" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> property of the current type includes <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если свойство <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> текущего типа включает <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /&gt;</ph>; в противном случае — значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3677" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>This property is provided as a convenience.</source>
          <target state="translated">Это свойство предоставляется для удобства.</target>       </trans-unit>
        <trans-unit id="3678" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> enumeration value to select the type layout attributes, and then test whether <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> is set.</source>
          <target state="translated">Кроме того, можно использовать <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> значение перечисления, чтобы выбрать атрибуты макета типа и проверки ли <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> имеет значение.</target>       </trans-unit>
        <trans-unit id="3679" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> enumeration values indicate the way the fields of the type are laid out in memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, И <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> значения перечисления указывают способ поля типа располагаются в памяти.</target>       </trans-unit>
        <trans-unit id="3680" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>For dynamic types, you can specify <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> when you create the type.</source>
          <target state="translated">Для динамических типов, можно указать <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> при создании типа.</target>       </trans-unit>
        <trans-unit id="3681" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>In code, apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.</source>
          <target state="translated">В коде, применить <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> атрибутом <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> значение перечисления в тип, чтобы указать смещение, с которого начинается поля указаны явным образом.</target>       </trans-unit>
        <trans-unit id="3682" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>You cannot use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method to determine whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> has been applied to a type.</source>
          <target state="translated">Нельзя использовать <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> метод, чтобы определить, является ли <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> был применен к типу.</target>       </trans-unit>
        <trans-unit id="3683" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, тип был создан.</target>       </trans-unit>
        <trans-unit id="3684" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Например если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> в Visual Basic), значение этого свойства определяется <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3685" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3686" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>The following example creates an instance of a type and displays the value of its <ph id="ph1">&lt;xref:System.Type.IsExplicitLayout%2A&gt;</ph> property.</source>
          <target state="translated">В следующем примере создается экземпляр типа и выводится значение его <ph id="ph1">&lt;xref:System.Type.IsExplicitLayout%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="3687" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>It uses the <ph id="ph1">`MySystemTime`</ph> class, which is also in the code example for <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>.</source>
          <target state="translated">Она использует <ph id="ph1">`MySystemTime`</ph> класс, который также находится в примере кода для <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3688" translate="yes" xml:space="preserve" uid="P:System.Type.IsGenericParameter">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter in the definition of a generic type or method.</source>
          <target state="translated">Возвращает значение, позволяющее определить, представляет ли текущий объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> параметр типа в определении универсального типа или метода.</target>       </trans-unit>
        <trans-unit id="3689" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type parameter of a generic type definition or generic method definition; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> представляет параметр определения универсального типа; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3690" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source><ph id="ph1">&lt;xref:System.Type&gt;</ph> objects that represent generic type parameters can be obtained by calling the <ph id="ph2">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method of a <ph id="ph3">&lt;xref:System.Type&gt;</ph> object that represents a generic type definition, or the <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A&gt;</ph> method of a <ph id="ph5">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a generic method definition.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type&gt;</ph> объекты, представляющие параметры универсального типа можно получить, вызвав <ph id="ph2">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> метод <ph id="ph3">&lt;xref:System.Type&gt;</ph> , представляющий определение универсального типа или <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A&gt;</ph> метод <ph id="ph5">&lt;xref:System.Reflection.MethodInfo&gt;</ph> объекта, который представляет универсальный метод Определение.</target>       </trans-unit>
        <trans-unit id="3691" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>For a generic type or method definition, the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> for every element of the resulting array.</source>
          <target state="translated">Для универсального типа или определение метода <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> возвращает <ph id="ph2">`true`</ph> для каждого элемента результирующего массива.</target>       </trans-unit>
        <trans-unit id="3692" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>For a closed constructed type or method, the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for every element of the array returned by the <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method.</source>
          <target state="translated">Для закрытого универсального типа или метода <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> возвращает <ph id="ph2">`false`</ph> для каждого элемента массива, возвращаемого <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3693" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>For an open constructed type or method, some elements of the array might be specific types and others might be type parameters.</source>
          <target state="translated">Для открытого сконструированного типа или метода некоторые элементы массива могут принадлежать к определенным типам, а другие могут быть параметрами типа.</target>       </trans-unit>
        <trans-unit id="3694" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> returns <ph id="ph2">`false`</ph> for the types and <ph id="ph3">`true`</ph> for the type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> Возвращает <ph id="ph2">`false`</ph> для типов и <ph id="ph3">`true`</ph> для параметров типа.</target>       </trans-unit>
        <trans-unit id="3695" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>The code example for the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property demonstrates a generic class with a mixture of types and type parameters.</source>
          <target state="translated">В примере кода для <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> свойства демонстрирует универсального класса со сочетание типов и их параметров.</target>       </trans-unit>
        <trans-unit id="3696" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3697" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to test for generic type parameters in a generic type.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> свойство для проверки параметров универсального типа в универсальном типе.</target>       </trans-unit>
        <trans-unit id="3698" translate="yes" xml:space="preserve" uid="P:System.Type.IsGenericType">
          <source>Gets a value indicating whether the current type is a generic type.</source>
          <target state="translated">Возвращает значение, указывающее, является ли текущий тип универсальным.</target>       </trans-unit>
        <trans-unit id="3699" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is a generic type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Если текущий тип является универсальным типом; в противном случае <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3700" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property to determine whether a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object represents a generic type.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> свойство, чтобы определить, является ли <ph id="ph2">&lt;xref:System.Type&gt;</ph> объект представляет универсальный тип.</target>       </trans-unit>
        <trans-unit id="3701" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property to determine whether a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object represents an open constructed type or a closed constructed type.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> свойства, чтобы определить ли <ph id="ph2">&lt;xref:System.Type&gt;</ph> представляет открытого сконструированного типа или закрытым сконструированным типом.</target>       </trans-unit>
        <trans-unit id="3702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> if the immediate type is not generic.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> Возвращает <ph id="ph2">`false`</ph> при интерпретации тип не является универсальным.</target>       </trans-unit>
        <trans-unit id="3703" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For example, an array whose elements are of type <ph id="ph1">`A&lt;int&gt;`</ph> (<ph id="ph2">`A(Of Integer)`</ph> in Visual Basic) is not itself a generic type.</source>
          <target state="translated">Например, массив, элементы которого имеют тип <ph id="ph1">`A&lt;int&gt;`</ph> (<ph id="ph2">`A(Of Integer)`</ph> в Visual Basic) является сам по себе не является универсальным типом.</target>       </trans-unit>
        <trans-unit id="3704" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The following table summarizes the invariant conditions for common terms used in generic reflection.</source>
          <target state="translated">В следующей таблице перечислены неизменяемых условий для общих терминов, используемых в универсальном отражении.</target>       </trans-unit>
        <trans-unit id="3705" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Term</source>
          <target state="translated">Термин</target>       </trans-unit>
        <trans-unit id="3706" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Invariant</source>
          <target state="translated">Инвариант</target>       </trans-unit>
        <trans-unit id="3707" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>generic type definition</source>
          <target state="translated">определение универсального типа</target>       </trans-unit>
        <trans-unit id="3708" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Значение свойства <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> — <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3709" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Defines a generic type.</source>
          <target state="translated">Определяет универсальный тип.</target>       </trans-unit>
        <trans-unit id="3710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>A constructed type is created by calling the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a generic type definition and specifying an array of type arguments.</source>
          <target state="translated">Сконструированный тип создается путем вызова <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> метод <ph id="ph2">&lt;xref:System.Type&gt;</ph> объект, представляющий определение универсального типа и указав массив аргументов типа.</target>       </trans-unit>
        <trans-unit id="3711" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> can be called only on generic type definitions.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> может вызываться только для определений универсального типа.</target>       </trans-unit>
        <trans-unit id="3712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Any generic type definition is a generic type (the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property is <ph id="ph2">`true`</ph>), but the converse is not true.</source>
          <target state="translated">Любое определение универсального типа является универсальным типом ( <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> свойство <ph id="ph2">`true`</ph>), но не верно обратное.</target>       </trans-unit>
        <trans-unit id="3713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>generic type</source>
          <target state="translated">универсальный тип</target>       </trans-unit>
        <trans-unit id="3714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Значение свойства <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> — <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3715" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Can be a generic type definition, an open constructed type, or a closed constructed type.</source>
          <target state="translated">Может быть определением универсального типа, открытого сконструированного типа или закрытым сконструированным типом.</target>       </trans-unit>
        <trans-unit id="3716" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Note that an array type whose element type is generic is not itself a generic type.</source>
          <target state="translated">Обратите внимание, что тип массива, тип элементов которого является универсальным сам по себе не является универсальным типом.</target>       </trans-unit>
        <trans-unit id="3717" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The same is true of a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing a pointer to a generic type.</source>
          <target state="translated">То же самое справедливо для <ph id="ph1">&lt;xref:System.Type&gt;</ph> объект, представляющий указатель на универсальный тип.</target>       </trans-unit>
        <trans-unit id="3718" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>open constructed type</source>
          <target state="translated">открытый сконструированный тип</target>       </trans-unit>
        <trans-unit id="3719" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Значение свойства <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> — <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3720" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Примеры: универсальный тип, который неназначенные параметры типа, тип, вложенный в определении универсального типа или в виде открытого сконструированного типа или универсального типа с аргументом типа, для которого <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> свойство <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3721" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>It is not possible to create an instance of an open constructed type.</source>
          <target state="translated">Создайте экземпляр открытого сконструированного типа невозможна.</target>       </trans-unit>
        <trans-unit id="3722" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Note that not all open constructed types are generic.</source>
          <target state="translated">Обратите внимание, что не все открытые сконструированные типы являются универсальными.</target>       </trans-unit>
        <trans-unit id="3723" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.</source>
          <target state="translated">Например массива, тип элементов которого является определением универсального типа, не является универсальным, и указатель на открытый сконструированный тип не является универсальным.</target>       </trans-unit>
        <trans-unit id="3724" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>closed constructed type</source>
          <target state="translated">закрытым сконструированным типом</target>       </trans-unit>
        <trans-unit id="3725" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Значение свойства <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> — <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3726" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>When examined recursively, the type has no unassigned generic parameters.</source>
          <target state="translated">При рекурсивном тип не имеет неназначенные универсальных параметров.</target>       </trans-unit>
        <trans-unit id="3727" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>generic type parameter</source>
          <target state="translated">параметр универсального типа</target>       </trans-unit>
        <trans-unit id="3728" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Значение свойства <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> — <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3729" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Значение свойства <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> — <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3730" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>In a generic type definition, a placeholder for a type that will be assigned later.</source>
          <target state="translated">В определении универсального типа это заполнитель для типа, который будет назначен позже.</target>       </trans-unit>
        <trans-unit id="3731" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>generic type argument</source>
          <target state="translated">аргумент универсального типа</target>       </trans-unit>
        <trans-unit id="3732" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Can be any type, including a generic type parameter.</source>
          <target state="translated">Может быть любого типа, включая параметр универсального типа.</target>       </trans-unit>
        <trans-unit id="3733" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Type arguments are specified as an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects passed to the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method when creating a constructed generic type.</source>
          <target state="translated">Аргументы типа задаются как массив <ph id="ph1">&lt;xref:System.Type&gt;</ph> объекты передавать <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> метод при создании сконструированного универсального типа.</target>       </trans-unit>
        <trans-unit id="3734" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>If instances of the resulting type are to be created, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property must be <ph id="ph2">`false`</ph> for all the type arguments.</source>
          <target state="translated">Если экземпляры результирующего типа создаваемой <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> свойство должно быть <ph id="ph2">`false`</ph> для всех аргументов типа.</target>       </trans-unit>
        <trans-unit id="3735" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The following code example and table illustrate some of these terms and invariants.</source>
          <target state="translated">Следующий пример кода и таблица иллюстрируют некоторые из этих условий и инварианты.</target>       </trans-unit>
        <trans-unit id="3736" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">`Derived`</ph> class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.</source>
          <target state="translated"><ph id="ph1">`Derived`</ph> Класс является особенно интересны, так как его базовый тип является сконструированный тип, который содержит как типы и параметры типа в списке аргументов.</target>       </trans-unit>
        <trans-unit id="3737" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The following table shows examples that use and build on the classes <ph id="ph1">`Base`</ph>, <ph id="ph2">`Derived`</ph>, and <ph id="ph3">`G`</ph>.</source>
          <target state="translated">В следующей таблице показаны примеры, использовать и построить его в классах <ph id="ph1">`Base`</ph>, <ph id="ph2">`Derived`</ph>, и <ph id="ph3">`G`</ph>.</target>       </trans-unit>
        <trans-unit id="3738" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>When the C++ and C# code is the same, only one entry is shown.</source>
          <target state="translated">Когда код C++ и C# зависит от того, отображается только одна запись.</target>       </trans-unit>
        <trans-unit id="3739" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Example</source>
          <target state="translated">Пример</target>       </trans-unit>
        <trans-unit id="3740" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Invariants</source>
          <target state="translated">Инварианты</target>       </trans-unit>
        <trans-unit id="3741" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For this type:</source>
          <target state="translated">Для этого типа:</target>       </trans-unit>
        <trans-unit id="3742" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> имеет значение <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3743" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> имеет значение <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3744" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> имеет значение <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3745" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For this type:</source>
          <target state="translated">Для этого типа:</target>       </trans-unit>
        <trans-unit id="3746" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> имеет значение <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3747" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> имеет значение <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3748" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> имеет значение <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3749" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For the type of variable <ph id="ph1">`d`</ph>:</source>
          <target state="translated">Для типа переменной <ph id="ph1">`d`</ph>:</target>       </trans-unit>
        <trans-unit id="3750" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`false`</ph> because <ph id="ph3">`d`</ph> is an array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> — <ph id="ph2">`false`</ph> поскольку <ph id="ph3">`d`</ph> является массивом.</target>       </trans-unit>
        <trans-unit id="3751" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> имеет значение <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3752" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> имеет значение <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3753" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">`T`</ph>, <ph id="ph2">`U`</ph>, and <ph id="ph3">`V`</ph> (everywhere they appear)</source>
          <target state="translated"><ph id="ph1">`T`</ph>, <ph id="ph2">`U`</ph>, и <ph id="ph3">`V`</ph> (где они перечислены)</target>       </trans-unit>
        <trans-unit id="3754" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> имеет значение <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3755" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`false`</ph> because there is no way to constrain a type parameter to generic types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> — <ph id="ph2">`false`</ph> , так как нет возможности ограничить параметр типа для универсальных типов.</target>       </trans-unit>
        <trans-unit id="3756" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> имеет значение <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3757" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph> because <ph id="ph3">`T`</ph>, <ph id="ph4">`U`</ph>, and <ph id="ph5">`V`</ph> are themselves generic type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> — <ph id="ph2">`true`</ph> из-за <ph id="ph3">`T`</ph>, <ph id="ph4">`U`</ph>, и <ph id="ph5">`V`</ph> сами являются параметрами универсального типа.</target>       </trans-unit>
        <trans-unit id="3758" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>This does not imply anything about type arguments that are assigned to them later.</source>
          <target state="translated">Это не означает, что-либо аргументы, которые им назначены более поздней версии.</target>       </trans-unit>
        <trans-unit id="3759" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The type of field <ph id="ph1">`F`</ph></source>
          <target state="translated">Тип поля <ph id="ph1">`F`</ph></target>       </trans-unit>
        <trans-unit id="3760" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> имеет значение <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3761" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph> because a type has been assigned to the type parameter of <ph id="ph3">`G`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> — <ph id="ph2">`false`</ph> , так как параметр типа был назначен тип <ph id="ph3">`G`</ph>.</target>       </trans-unit>
        <trans-unit id="3762" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Note that this is equivalent to having called the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method.</source>
          <target state="translated">Обратите внимание, что это эквивалентно вызову <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="3763" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph> because the type of field <ph id="ph3">`F`</ph> has a type argument that is an open constructed type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> — <ph id="ph2">`true`</ph> так как тип поля <ph id="ph3">`F`</ph> имеет аргумент типа, который является открытым сконструированным типом.</target>       </trans-unit>
        <trans-unit id="3764" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The constructed type is open because its type argument (that is, <ph id="ph1">`Base`</ph>) is a generic type definition.</source>
          <target state="translated">Сконструированный тип открыт из-за аргумента типа (то есть <ph id="ph1">`Base`</ph>) является определением универсального типа.</target>       </trans-unit>
        <trans-unit id="3765" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>This illustrates the recursive nature of the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property.</source>
          <target state="translated">Это иллюстрирует характер рекурсивные <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="3766" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The nested class <ph id="ph1">`Nested`</ph></source>
          <target state="translated">Вложенный класс <ph id="ph1">`Nested`</ph></target>       </trans-unit>
        <trans-unit id="3767" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>, even though the <ph id="ph3">`Nested`</ph> class has no generic type parameters of its own, because it is nested in a generic type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> — <ph id="ph2">`true`</ph>, даже если <ph id="ph3">`Nested`</ph> класса не имеет универсальный тип параметров свои собственные, так как оно является вложенным в универсальный тип.</target>       </trans-unit>
        <trans-unit id="3768" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> имеет значение <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3769" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>That is, you can call the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method and supply the type parameter of the enclosing type, <ph id="ph2">`Derived`</ph>.</source>
          <target state="translated">То есть, можно вызвать <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> метод и задать параметр типа включающего типа <ph id="ph2">`Derived`</ph>.</target>       </trans-unit>
        <trans-unit id="3770" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph> because the enclosing type, <ph id="ph3">`Derived`</ph>, has generic type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> — <ph id="ph2">`true`</ph> так как включающий тип, <ph id="ph3">`Derived`</ph>, имеет параметры универсального типа.</target>       </trans-unit>
        <trans-unit id="3771" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>This illustrates the recursive nature of the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property.</source>
          <target state="translated">Это иллюстрирует характер рекурсивные <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="3772" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The following code example displays the value of the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> properties for the types described in the Remarks section.</source>
          <target state="translated">В следующем примере кода отображает значение <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>, и <ph id="ph4">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> свойства для типов, описанных в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="3773" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For explanations of the property values, see the accompanying table in Remarks.</source>
          <target state="translated">Объяснение значений свойств см в разделе Примечания.</target>       </trans-unit>
        <trans-unit id="3774" translate="yes" xml:space="preserve" uid="P:System.Type.IsGenericTypeDefinition">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a generic type definition, from which other generic types can be constructed.</source>
          <target state="translated">Возвращает значение, позволяющее определить, представляет ли текущий объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> определение универсального типа, на основе которого можно сконструировать другие универсальные типы.</target>       </trans-unit>
        <trans-unit id="3775" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object represents a generic type definition; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если этот объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> представляет определение универсального типа; в противном случае — <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3776" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>A generic type definition is a template from which other types can be constructed.</source>
          <target state="translated">Определение универсального типа — это шаблон, из которого можно сконструировать другие типы.</target>       </trans-unit>
        <trans-unit id="3777" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>For example, from the generic type definition <ph id="ph1">`G&lt;T&gt;`</ph> (expressed in C# syntax; <ph id="ph2">`G(Of T)`</ph> in Visual Basic or <ph id="ph3">`generic &lt;typename T&gt; ref class G`</ph> in C++) you can construct and instantiate the type <ph id="ph4">`G&lt;int&gt;`</ph> (<ph id="ph5">`G(Of Integer)`</ph> in Visual Basic), by calling the <ph id="ph6">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with a generic argument list containing the <ph id="ph7">&lt;xref:System.Int32&gt;</ph> type.</source>
          <target state="translated">Например, в определении универсального типа <ph id="ph1">`G&lt;T&gt;`</ph> (выраженная в синтаксис C#; <ph id="ph2">`G(Of T)`</ph> в Visual Basic или <ph id="ph3">`generic &lt;typename T&gt; ref class G`</ph> в C++) можно создать и создать экземпляр типа <ph id="ph4">`G&lt;int&gt;`</ph> (<ph id="ph5">`G(Of Integer)`</ph> в Visual Basic), путем вызова <ph id="ph6">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> метод с универсальным аргументом список, содержащий <ph id="ph7">&lt;xref:System.Int32&gt;</ph> типа.</target>       </trans-unit>
        <trans-unit id="3778" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>Given a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing this constructed type, the <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method gets the generic type definition back again.</source>
          <target state="translated">Получает <ph id="ph1">&lt;xref:System.Type&gt;</ph> объект, представляющий это сконструированный тип, <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> метод возвращает определение универсального типа и обратно еще раз.</target>       </trans-unit>
        <trans-unit id="3779" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property to determine whether you can create new types from the current type.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> свойство, чтобы определить, можно ли создавать новые типы из текущего типа.</target>       </trans-unit>
        <trans-unit id="3780" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>If the <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>, you can call the <ph id="ph3">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method to create new generic types.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> возвращает <ph id="ph2">`true`</ph>, можно вызвать <ph id="ph3">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> метод, чтобы создать новые универсальные типы.</target>       </trans-unit>
        <trans-unit id="3781" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3782" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>The following example displays information about a type, including whether or not it is a generic type definition.</source>
          <target state="translated">Следующий пример отображает сведения о типе, включая ли это определение универсального типа.</target>       </trans-unit>
        <trans-unit id="3783" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>Information is displayed for a constructed type, for its generic type definition, and for an ordinary type.</source>
          <target state="translated">Сведения отображаются для сконструированного типа, его определения универсального типа и обычный тип.</target>       </trans-unit>
        <trans-unit id="3784" translate="yes" xml:space="preserve" uid="P:System.Type.IsImport">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> has a <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph> attribute applied, indicating that it was imported from a COM type library.</source>
          <target state="translated">Возвращает значение, позволяющее определить, есть ли у объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> атрибут <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph>, свидетельствующий о том, что объект был импортирован из библиотеки COM-типов.</target>       </trans-unit>
        <trans-unit id="3785" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsImport">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> has a <ph id="ph3">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если у <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> есть атрибут <ph id="ph3">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph>; в противном случае — значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3786" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsImport">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, тип был создан.</target>       </trans-unit>
        <trans-unit id="3787" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsImport">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;.`</ph></source>
          <target state="translated">Например если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> в Visual Basic), значение этого свойства определяется <ph id="ph4">`MyGenericType&lt;T&gt;.`</ph></target>       </trans-unit>
        <trans-unit id="3788" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsImport">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3789" translate="yes" xml:space="preserve" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>The object to compare with the current type.</source>
          <target state="translated">Объект, который требуется сравнить с текущим типом.</target>       </trans-unit>
        <trans-unit id="3790" translate="yes" xml:space="preserve" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>Determines whether the specified object is an instance of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Определяет, является ли указанный объект экземпляром текущего типа <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3791" translate="yes" xml:space="preserve" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see langword="Type" /&gt;</ph> is in the inheritance hierarchy of the object represented by <ph id="ph3">&lt;paramref name="o" /&gt;</ph>, or if the current <ph id="ph4">&lt;see langword="Type" /&gt;</ph> is an interface that <ph id="ph5">&lt;paramref name="o" /&gt;</ph> implements.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий объект <ph id="ph2">&lt;see langword="Type" /&gt;</ph> входит в иерархию наследования объекта, представленного параметром <ph id="ph3">&lt;paramref name="o" /&gt;</ph> или если текущий объект <ph id="ph4">&lt;see langword="Type" /&gt;</ph> является интерфейсом, реализуемым параметром <ph id="ph5">&lt;paramref name="o" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3792" translate="yes" xml:space="preserve" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if neither of these conditions is the case, if <ph id="ph2">&lt;paramref name="o" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, or if the current <ph id="ph4">&lt;see langword="Type" /&gt;</ph> is an open generic type (that is, <ph id="ph5">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> returns <ph id="ph6">&lt;see langword="true" /&gt;</ph>).</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="false" /&gt;</ph>, если не выполняется ни одно из перечисленных условий, параметр <ph id="ph2">&lt;paramref name="o" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="null" /&gt;</ph> или текущий объект <ph id="ph4">&lt;see langword="Type" /&gt;</ph> является открытым универсальным типом (то есть свойство <ph id="ph5">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> возвращает значение <ph id="ph6">&lt;see langword="true" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="3793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Этот метод может быть переопределен в производном классе.</target>       </trans-unit>
        <trans-unit id="3794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>A constructed type is not an instance of its generic type definition.</source>
          <target state="translated">Сконструированный тип не является экземпляром определения универсального типа.</target>       </trans-unit>
        <trans-unit id="3795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>That is, <ph id="ph1">`MyGenericList&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericList(Of Integer)`</ph> in Visual Basic) is not an instance of <ph id="ph3">`MyGenericList&lt;T&gt;`</ph> (<ph id="ph4">`MyGenericList(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">То есть <ph id="ph1">`MyGenericList&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericList(Of Integer)`</ph> в Visual Basic) не является экземпляром <ph id="ph3">`MyGenericList&lt;T&gt;`</ph> (<ph id="ph4">`MyGenericList(Of T)`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="3796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>The following example demonstrates the use of the <ph id="ph1">`IsInstanceOfType`</ph> method.</source>
          <target state="translated">В следующем примере иллюстрируется использование метода <ph id="ph1">`IsInstanceOfType`</ph>.</target>       </trans-unit>
        <trans-unit id="3797" translate="yes" xml:space="preserve" uid="P:System.Type.IsInterface">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is an interface; that is, not a class or a value type.</source>
          <target state="translated">Возвращает значение, позволяющее определить, является ли объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> интерфейсом (иными словами, не является классом или типом значения).</target>       </trans-unit>
        <trans-unit id="3798" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an interface; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является интерфейсом; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3799" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask&gt;</ph> distinguishes a type declaration as class, interface or value type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask&gt;</ph> Отличает объявление типа как класса, интерфейса или типа значения.</target>       </trans-unit>
        <trans-unit id="3800" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3801" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source>This property is read-only.</source>
          <target state="translated">Это свойство доступно только для чтения.</target>       </trans-unit>
        <trans-unit id="3802" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source>The following example creates an interface, checks for the interface type, and indicates whether a class has the <ph id="ph1">`IsInterface`</ph> property set.</source>
          <target state="translated">Следующий пример создает интерфейс, проверяет тип интерфейса и указывает, имеет ли класс <ph id="ph1">`IsInterface`</ph> набор свойств.</target>       </trans-unit>
        <trans-unit id="3803" translate="yes" xml:space="preserve" uid="P:System.Type.IsLayoutSequential">
          <source>Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.</source>
          <target state="translated">Возвращает значение, указывающее, выкладываются ли поля текущего типа последовательно, в том порядке, в котором они были определены, или выдаются в метаданные.</target>       </trans-unit>
        <trans-unit id="3804" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> property of the current type includes <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если свойство <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> текущего типа включает <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /&gt;</ph>; в противном случае — значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3805" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>This property is provided as a convenience.</source>
          <target state="translated">Это свойство предоставляется для удобства.</target>       </trans-unit>
        <trans-unit id="3806" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> enumeration value to select the type layout attributes, and then test whether <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> is set.</source>
          <target state="translated">Кроме того, можно использовать <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> значение перечисления, чтобы выбрать атрибуты макета типа и проверки ли <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> имеет значение.</target>       </trans-unit>
        <trans-unit id="3807" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> enumeration values indicate the way the fields of the type are laid out in memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, И <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> значения перечисления указывают способ поля типа располагаются в памяти.</target>       </trans-unit>
        <trans-unit id="3808" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>For dynamic types, you can specify <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> when you create the type.</source>
          <target state="translated">Для динамических типов, можно указать <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> при создании типа.</target>       </trans-unit>
        <trans-unit id="3809" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>In code, apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> enumeration value to the type, to specify that layout is sequential.</source>
          <target state="translated">В коде, применить <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> атрибутом <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> значение перечисления в тип, для указания макета выполняются последовательно.</target>       </trans-unit>
        <trans-unit id="3810" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>You cannot use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method to determine whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> has been applied to a type.</source>
          <target state="translated">Нельзя использовать <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> метод, чтобы определить, является ли <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> был применен к типу.</target>       </trans-unit>
        <trans-unit id="3811" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Дополнительные сведения см. раздел 9.1.2 спецификации Common Language Infrastructure (CLI) документацию по «Раздел II: определение метаданных и семантика».</target>       </trans-unit>
        <trans-unit id="3812" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">Документация доступна в Интернете; см. страницы <bpt id="p1">[</bpt>ECMAC# и стандарты Common Language Infrastructure<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> на сайте MSDN и <bpt id="p2">[</bpt>Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> на международном веб-сайте организации ECMA.</target>       </trans-unit>
        <trans-unit id="3813" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, тип был создан.</target>       </trans-unit>
        <trans-unit id="3814" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Например если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> в Visual Basic), значение этого свойства определяется <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3815" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3816" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>The following example creates an instance of a class for which the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> enumeration value in the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> class has been set, checks for the <ph id="ph3">&lt;xref:System.Type.IsLayoutSequential%2A&gt;</ph> property, and displays the result.</source>
          <target state="translated">В следующем примере создается экземпляр класса, для которого <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> значения перечисления в <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> класса было установлено, проверьте наличие <ph id="ph3">&lt;xref:System.Type.IsLayoutSequential%2A&gt;</ph> свойства и отображается результат.</target>       </trans-unit>
        <trans-unit id="3817" translate="yes" xml:space="preserve" uid="P:System.Type.IsMarshalByRef">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is marshaled by reference.</source>
          <target state="translated">Возвращает значение, указывающее, маршалирован ли объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> по ссылке.</target>       </trans-unit>
        <trans-unit id="3818" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsMarshalByRef">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is marshaled by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> маршалируется по ссылке; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3819" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsMarshalByRef">
          <source>The following example demonstrates the <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> properties of the <ph id="ph4">&lt;xref:System.Type&gt;</ph> class.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, и <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> свойства <ph id="ph4">&lt;xref:System.Type&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="3820" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsMarshalByRef">
          <source>It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</source>
          <target state="translated">Проверяется ли данный тип может размещаться в контексте ли он может быть маршалирован по ссылке и является ли тип примитивный тип данных.</target>       </trans-unit>
        <trans-unit id="3821" translate="yes" xml:space="preserve" uid="M:System.Type.IsMarshalByRefImpl">
          <source>Implements the <ph id="ph1">&lt;see cref="P:System.Type.IsMarshalByRef" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is marshaled by reference.</source>
          <target state="translated">Реализует свойство <ph id="ph1">&lt;see cref="P:System.Type.IsMarshalByRef" /&gt;</ph> и определяет, маршалируется ли объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> по ссылке.</target>       </trans-unit>
        <trans-unit id="3822" translate="yes" xml:space="preserve" uid="M:System.Type.IsMarshalByRefImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is marshaled by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> маршалируется по ссылке; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsMarshalByRefImpl">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Этот метод может быть переопределен в производном классе.</target>       </trans-unit>
        <trans-unit id="3824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsMarshalByRefImpl">
          <source>The following example determines whether the given type is marshaled by reference and displays the result.</source>
          <target state="translated">В следующем примере определяется, является ли данный тип маршалируется по ссылке и отображает результат.</target>       </trans-unit>
        <trans-unit id="3825" translate="yes" xml:space="preserve" uid="P:System.Type.IsNested">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type whose definition is nested inside the definition of another type.</source>
          <target state="translated">Возвращает значение, позволяющее определить, представляет ли текущий объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> тип, определение которого вложено в определение другого типа.</target>       </trans-unit>
        <trans-unit id="3826" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested inside another type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> вложен в другой тип; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3827" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsNested%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> for all nested types, regardless of visibility.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsNested%2A&gt;</ph> Возвращает <ph id="ph2">`true`</ph> для всех вложенных типов, независимо от видимости.</target>       </trans-unit>
        <trans-unit id="3828" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>To test for nesting and visibility at the same time, use the related properties <ph id="ph1">&lt;xref:System.Type.IsNestedAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsNestedFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.IsNestedFamANDAssem%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Type.IsNestedPrivate%2A&gt;</ph>, or <ph id="ph6">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph>.</source>
          <target state="translated">Чтобы проверить вложение и видимость в то же время, используйте связанные свойства <ph id="ph1">&lt;xref:System.Type.IsNestedAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsNestedFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.IsNestedFamANDAssem%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Type.IsNestedPrivate%2A&gt;</ph>, или <ph id="ph6">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3829" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask&gt;</ph> enumeration member selects the visibility attributes for a type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask&gt;</ph> Член перечисления выбирает атрибуты видимости типа.</target>       </trans-unit>
        <trans-unit id="3830" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">В следующем примере создается внешнего класса с количеством вложенных классов, имеющих различные виды видимость.</target>       </trans-unit>
        <trans-unit id="3831" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">Затем извлекается значение из нескольких связанных с видимостью <ph id="ph1">&lt;xref:System.Type&gt;</ph> свойства для родительского типа и каждый из вложенных типов.</target>       </trans-unit>
        <trans-unit id="3832" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedAssembly">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only within its own assembly.</source>
          <target state="translated">Возвращает значение, позволяющее определить, является ли объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> вложенным и видимым только в своей сборке.</target>       </trans-unit>
        <trans-unit id="3833" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only within its own assembly; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является вложенным и видимым только в своей сборке; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3834" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа универсального типа, это свойство всегда возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3835" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> выбирает атрибуты видимости.</target>       </trans-unit>
        <trans-unit id="3836" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">В следующем примере создается внешнего класса с количеством вложенных классов, имеющих различные виды видимость.</target>       </trans-unit>
        <trans-unit id="3837" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">Затем извлекается значение из нескольких связанных с видимостью <ph id="ph1">&lt;xref:System.Type&gt;</ph> свойства для родительского типа и каждый из вложенных типов.</target>       </trans-unit>
        <trans-unit id="3838" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedFamANDAssem">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only to classes that belong to both its own family and its own assembly.</source>
          <target state="translated">Возвращает значение, позволяющее определить, является ли объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> вложенным и видимым только для классов, принадлежащих одновременно к семейству и сборке этого объекта.</target>       </trans-unit>
        <trans-unit id="3839" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является вложенным и видимым только классам, принадлежащим одновременно к семейству и сборке этого объекта; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3840" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа универсального типа, это свойство всегда возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3841" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> выбирает атрибуты видимости.</target>       </trans-unit>
        <trans-unit id="3842" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly.</source>
          <target state="translated">В языках C# и Visual Basic, не включайте семантику, позволяют определить вложенный тип, который является видимым только для защищенные типы в сборке.</target>       </trans-unit>
        <trans-unit id="3843" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source><ph id="ph1">`protected internal`</ph> visibility in C# and <ph id="ph2">`Protected Friend`</ph> visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.</source>
          <target state="translated"><ph id="ph1">`protected internal`</ph> видимость в C# и <ph id="ph2">`Protected Friend`</ph> видимости в Visual Basic определить вложенный тип, который является видимым для защищенные типы и типы в той же сборке.</target>       </trans-unit>
        <trans-unit id="3844" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object's family is defined as all objects of the same <ph id="ph2">&lt;xref:System.Type&gt;</ph> and of its subtypes.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Type&gt;</ph> семейство объекта определяется как все объекты в одной и той же <ph id="ph2">&lt;xref:System.Type&gt;</ph> и из его подтипов.</target>       </trans-unit>
        <trans-unit id="3845" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">В следующем примере создается внешнего класса с количеством вложенных классов, имеющих различные виды видимость.</target>       </trans-unit>
        <trans-unit id="3846" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">Затем извлекается значение из нескольких связанных с видимостью <ph id="ph1">&lt;xref:System.Type&gt;</ph> свойства для родительского типа и каждый из вложенных типов.</target>       </trans-unit>
        <trans-unit id="3847" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedFamily">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only within its own family.</source>
          <target state="translated">Возвращает значение, позволяющее определить, является ли объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> вложенным и видимым только в своем семействе.</target>       </trans-unit>
        <trans-unit id="3848" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only within its own family; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является вложенным и видимым только внутри собственного семейства; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3849" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа универсального типа, это свойство всегда возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3850" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> выбирает атрибуты видимости.</target>       </trans-unit>
        <trans-unit id="3851" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object's family is defined as all objects of the exact same <ph id="ph2">&lt;xref:System.Type&gt;</ph> and of its subtypes.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Type&gt;</ph> семейство объекта — это все объекты типа, представленного данным же <ph id="ph2">&lt;xref:System.Type&gt;</ph> и из его подтипов.</target>       </trans-unit>
        <trans-unit id="3852" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">В следующем примере создается внешнего класса с количеством вложенных классов, имеющих различные виды видимость.</target>       </trans-unit>
        <trans-unit id="3853" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">Затем извлекается значение из нескольких связанных с видимостью <ph id="ph1">&lt;xref:System.Type&gt;</ph> свойства для родительского типа и каждый из вложенных типов.</target>       </trans-unit>
        <trans-unit id="3854" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedFamORAssem">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only to classes that belong to either its own family or to its own assembly.</source>
          <target state="translated">Возвращает значение, позволяющее определить, является ли данный объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> вложенным и видимым только для классов, принадлежащих либо к его семейству, либо к его сборке.</target>       </trans-unit>
        <trans-unit id="3855" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является вложенным и видимым только классам, принадлежащим его семейству или его сборке; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3856" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>If the visibility of a type is <ph id="ph1">`protected internal`</ph> in C# or <ph id="ph2">`Protected Friend`</ph> in Visual Basic, the <ph id="ph3">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph> property returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Если видимость типа <ph id="ph1">`protected internal`</ph> в C# или <ph id="ph2">`Protected Friend`</ph> в Visual Basic <ph id="ph3">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph> возвращает <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3857" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа универсального типа, это свойство всегда возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3858" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> выбирает атрибуты видимости.</target>       </trans-unit>
        <trans-unit id="3859" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object's family is defined as all objects of the exact same <ph id="ph2">&lt;xref:System.Type&gt;</ph> and of its subtypes.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Type&gt;</ph> семейство объекта — это все объекты типа, представленного данным же <ph id="ph2">&lt;xref:System.Type&gt;</ph> и из его подтипов.</target>       </trans-unit>
        <trans-unit id="3860" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">В следующем примере создается внешнего класса с количеством вложенных классов, имеющих различные виды видимость.</target>       </trans-unit>
        <trans-unit id="3861" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">Затем извлекается значение из нескольких связанных с видимостью <ph id="ph1">&lt;xref:System.Type&gt;</ph> свойства для родительского типа и каждый из вложенных типов.</target>       </trans-unit>
        <trans-unit id="3862" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedPrivate">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and declared private.</source>
          <target state="translated">Возвращает значение, позволяющее определить, является ли объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> вложенным и объявленным как закрытый.</target>       </trans-unit>
        <trans-unit id="3863" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and declared private; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является вложенным и объявленным как закрытый; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3864" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа универсального типа, это свойство всегда возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3865" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> выбирает атрибуты видимости.</target>       </trans-unit>
        <trans-unit id="3866" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">В следующем примере создается внешнего класса с количеством вложенных классов, имеющих различные виды видимость.</target>       </trans-unit>
        <trans-unit id="3867" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">Затем извлекается значение из нескольких связанных с видимостью <ph id="ph1">&lt;xref:System.Type&gt;</ph> свойства для родительского типа и каждый из вложенных типов.</target>       </trans-unit>
        <trans-unit id="3868" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedPublic">
          <source>Gets a value indicating whether a class is nested and declared public.</source>
          <target state="translated">Возвращает значение, позволяющее определить, является ли класс вложенным и объявленным как открытый.</target>       </trans-unit>
        <trans-unit id="3869" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the class is nested and declared public; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если данный класс является вложенным и объявленным как открытый; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3870" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа универсального типа, это свойство всегда возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3871" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> выбирает атрибуты видимости.</target>       </trans-unit>
        <trans-unit id="3872" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">В следующем примере создается внешнего класса с количеством вложенных классов, имеющих различные виды видимость.</target>       </trans-unit>
        <trans-unit id="3873" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">Затем извлекается значение из нескольких связанных с видимостью <ph id="ph1">&lt;xref:System.Type&gt;</ph> свойства для родительского типа и каждый из вложенных типов.</target>       </trans-unit>
        <trans-unit id="3874" translate="yes" xml:space="preserve" uid="P:System.Type.IsNotPublic">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is not declared public.</source>
          <target state="translated">Возвращает значение, позволяющее определить, не был ли объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> объявлен как открытый.</target>       </trans-unit>
        <trans-unit id="3875" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is not declared public and is not a nested type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> не объявлен как открытый и не является вложенным типом; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3876" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>Do not use this property with nested types; use the <ph id="ph1">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> property instead.</source>
          <target state="translated">Не используйте это свойство для вложенных типов. Используйте <ph id="ph1">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> свойство вместо него.</target>       </trans-unit>
        <trans-unit id="3877" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа универсального типа, это свойство возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3878" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>This example usesthe <ph id="ph1">`IsNotPublic`</ph> property to get the visibility of the type.</source>
          <target state="translated">Этот пример usesthe <ph id="ph1">`IsNotPublic`</ph> свойство видимости типа.</target>       </trans-unit>
        <trans-unit id="3879" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>The following code example demonstrates why you cannot use <ph id="ph1">`IsPublic`</ph> and <ph id="ph2">`IsNotPublic`</ph> for nested classes.</source>
          <target state="translated">В следующем примере кода показано, почему не удается использовать <ph id="ph1">`IsPublic`</ph> и <ph id="ph2">`IsNotPublic`</ph> для вложенных классов.</target>       </trans-unit>
        <trans-unit id="3880" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>For nested classes, ignore the results of <ph id="ph1">`IsPublic`</ph> and <ph id="ph2">`IsNotPublic`</ph> and pay attention only to the results of <ph id="ph3">`IsNestedPublic`</ph> and <ph id="ph4">`IsNestedPrivate`</ph>.</source>
          <target state="translated">Для вложенных классов игнорировать результаты <ph id="ph1">`IsPublic`</ph> и <ph id="ph2">`IsNotPublic`</ph> и уделить внимание только результаты <ph id="ph3">`IsNestedPublic`</ph> и <ph id="ph4">`IsNestedPrivate`</ph>.</target>       </trans-unit>
        <trans-unit id="3881" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>The reflection output for this code fragment would be as follows:</source>
          <target state="translated">Выходные данные отражения для этот фрагмент кода будет выглядеть следующим образом:</target>       </trans-unit>
        <trans-unit id="3882" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>Class</source>
          <target state="translated">Класс</target>       </trans-unit>
        <trans-unit id="3883" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>IsNotPublic</source>
          <target state="translated">IsNotPublic</target>       </trans-unit>
        <trans-unit id="3884" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>IsPublic</source>
          <target state="translated">IsPublic</target>       </trans-unit>
        <trans-unit id="3885" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>IsNestedPublic</source>
          <target state="translated">IsNestedPublic</target>       </trans-unit>
        <trans-unit id="3886" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>IsNestedPrivate</source>
          <target state="translated">IsNestedPrivate</target>       </trans-unit>
        <trans-unit id="3887" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>A</source>
          <target state="translated">А</target>       </trans-unit>
        <trans-unit id="3888" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3889" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>TRUE</source>
          <target state="translated">true</target>       </trans-unit>
        <trans-unit id="3890" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3891" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3892" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>B</source>
          <target state="translated">С</target>       </trans-unit>
        <trans-unit id="3893" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3894" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3895" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>TRUE</source>
          <target state="translated">true</target>       </trans-unit>
        <trans-unit id="3896" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3897" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>C</source>
          <target state="translated">C</target>       </trans-unit>
        <trans-unit id="3898" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3899" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3900" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3901" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>TRUE</source>
          <target state="translated">true</target>       </trans-unit>
        <trans-unit id="3902" translate="yes" xml:space="preserve" uid="P:System.Type.IsPointer">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer.</source>
          <target state="translated">Возвращает значение, указывающее, является ли объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> указателем.</target>       </trans-unit>
        <trans-unit id="3903" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPointer">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является указателем; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3904" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPointer">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет универсальный тип или параметр типа в определении универсального типа или метода, это свойство всегда возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3905" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPointer">
          <source>This property is read-only.</source>
          <target state="translated">Это свойство доступно только для чтения.</target>       </trans-unit>
        <trans-unit id="3906" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPointer">
          <source>The following example shows a use of the <ph id="ph1">`IsPointer`</ph> property.</source>
          <target state="translated">В следующем примере показано использование <ph id="ph1">`IsPointer`</ph> свойство.</target>       </trans-unit>
        <trans-unit id="3907" translate="yes" xml:space="preserve" uid="M:System.Type.IsPointerImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsPointer" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer.</source>
          <target state="translated">При переопределении в производном классе реализует свойство <ph id="ph1">&lt;see cref="P:System.Type.IsPointer" /&gt;</ph> и определяет, является ли объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> указателем.</target>       </trans-unit>
        <trans-unit id="3908" translate="yes" xml:space="preserve" uid="M:System.Type.IsPointerImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является указателем; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3909" translate="yes" xml:space="preserve" uid="P:System.Type.IsPrimitive">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types.</source>
          <target state="translated">Возвращает значение, указывающее, является ли <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> одним из типов-примитивов.</target>       </trans-unit>
        <trans-unit id="3910" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является одним из типов-примитивов; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3911" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source>The primitive types are <ph id="ph1">&lt;xref:System.Boolean&gt;</ph>, <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.SByte&gt;</ph>, <ph id="ph4">&lt;xref:System.Int16&gt;</ph>, <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, <ph id="ph7">&lt;xref:System.UInt32&gt;</ph>, <ph id="ph8">&lt;xref:System.Int64&gt;</ph>, <ph id="ph9">&lt;xref:System.UInt64&gt;</ph>, <ph id="ph10">&lt;xref:System.IntPtr&gt;</ph>, <ph id="ph11">&lt;xref:System.UIntPtr&gt;</ph>, <ph id="ph12">&lt;xref:System.Char&gt;</ph>, <ph id="ph13">&lt;xref:System.Double&gt;</ph>, and <ph id="ph14">&lt;xref:System.Single&gt;</ph>.</source>
          <target state="translated">Примитивные типы являются <ph id="ph1">&lt;xref:System.Boolean&gt;</ph>, <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.SByte&gt;</ph>, <ph id="ph4">&lt;xref:System.Int16&gt;</ph>, <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, <ph id="ph7">&lt;xref:System.UInt32&gt;</ph>, <ph id="ph8">&lt;xref:System.Int64&gt;</ph>, <ph id="ph9">&lt;xref:System.UInt64&gt;</ph>, <ph id="ph10">&lt;xref:System.IntPtr&gt;</ph>, <ph id="ph11">&lt;xref:System.UIntPtr&gt;</ph>, <ph id="ph12">&lt;xref:System.Char&gt;</ph>, <ph id="ph13">&lt;xref:System.Double&gt;</ph>, и <ph id="ph14">&lt;xref:System.Single&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3912" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет универсальный тип или параметр типа в определении универсального типа или метода, это свойство всегда возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3913" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source>The following example demonstrates the <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> properties of the <ph id="ph4">&lt;xref:System.Type&gt;</ph> class.</source>
          <target state="translated">В следующем примере демонстрируется <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, и <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> свойства <ph id="ph4">&lt;xref:System.Type&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="3914" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source>It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</source>
          <target state="translated">Проверяется ли данный тип может размещаться в контексте ли он может быть маршалирован по ссылке и является ли тип примитивный тип данных.</target>       </trans-unit>
        <trans-unit id="3915" translate="yes" xml:space="preserve" uid="M:System.Type.IsPrimitiveImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsPrimitive" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types.</source>
          <target state="translated">При переопределении в производном классе реализует свойство <ph id="ph1">&lt;see cref="P:System.Type.IsPrimitive" /&gt;</ph> и определяет, является ли объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> одним из типов-примитивов.</target>       </trans-unit>
        <trans-unit id="3916" translate="yes" xml:space="preserve" uid="M:System.Type.IsPrimitiveImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является одним из типов-примитивов; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsPrimitiveImpl">
          <source>The primitive types are <ph id="ph1">&lt;xref:System.Boolean&gt;</ph>, <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.SByte&gt;</ph>, <ph id="ph4">&lt;xref:System.Int16&gt;</ph>, <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, <ph id="ph7">&lt;xref:System.UInt32&gt;</ph>, <ph id="ph8">&lt;xref:System.Int64&gt;</ph>, <ph id="ph9">&lt;xref:System.UInt64&gt;</ph>, <ph id="ph10">&lt;xref:System.Char&gt;</ph>, <ph id="ph11">&lt;xref:System.Double&gt;</ph>, and <ph id="ph12">&lt;xref:System.Single&gt;</ph>.</source>
          <target state="translated">Примитивные типы являются <ph id="ph1">&lt;xref:System.Boolean&gt;</ph>, <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.SByte&gt;</ph>, <ph id="ph4">&lt;xref:System.Int16&gt;</ph>, <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, <ph id="ph7">&lt;xref:System.UInt32&gt;</ph>, <ph id="ph8">&lt;xref:System.Int64&gt;</ph>, <ph id="ph9">&lt;xref:System.UInt64&gt;</ph>, <ph id="ph10">&lt;xref:System.Char&gt;</ph>, <ph id="ph11">&lt;xref:System.Double&gt;</ph>, и <ph id="ph12">&lt;xref:System.Single&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsPrimitiveImpl">
          <source>The following example determines whether the given type is a primitive type and displays the result.</source>
          <target state="translated">В следующем примере определяется, является ли данный тип типом-примитивом и отображается результат.</target>       </trans-unit>
        <trans-unit id="3919" translate="yes" xml:space="preserve" uid="P:System.Type.IsPublic">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is declared public.</source>
          <target state="translated">Возвращает значение, позволяющее определить, был ли объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> объявлен как открытый.</target>       </trans-unit>
        <trans-unit id="3920" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is declared public and is not a nested type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> объявлен как открытый и не является вложенным типом; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3921" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source>Do not use with nested types; use <ph id="ph1">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> instead.</source>
          <target state="translated">Не используйте для вложенных типов. Используйте <ph id="ph1">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> вместо него.</target>       </trans-unit>
        <trans-unit id="3922" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа универсального типа, это свойство возвращает <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3923" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> выбирает атрибуты видимости.</target>       </trans-unit>
        <trans-unit id="3924" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source>The following example creates an instance of <ph id="ph1">`MyTestClass`</ph>, checks for the <ph id="ph2">`IsPublic`</ph> property, and displays the result.</source>
          <target state="translated">В следующем примере создается экземпляр <ph id="ph1">`MyTestClass`</ph>, проверяет наличие <ph id="ph2">`IsPublic`</ph> свойства и отображается результат.</target>       </trans-unit>
        <trans-unit id="3925" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source>For nested classes, ignore the results of <ph id="ph1">`IsPublic`</ph> and <ph id="ph2">`IsNotPublic`</ph> and pay attention only to the results of <ph id="ph3">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Type.IsNestedPrivate%2A&gt;</ph>.</source>
          <target state="translated">Для вложенных классов игнорировать результаты <ph id="ph1">`IsPublic`</ph> и <ph id="ph2">`IsNotPublic`</ph> и уделить внимание только результаты <ph id="ph3">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> и <ph id="ph4">&lt;xref:System.Type.IsNestedPrivate%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3926" translate="yes" xml:space="preserve" uid="P:System.Type.IsSealed">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is declared sealed.</source>
          <target state="translated">Возвращает значение, позволяющее определить, был ли объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> объявлен как запечатанный.</target>       </trans-unit>
        <trans-unit id="3927" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSealed">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is declared sealed; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> объявлен как запечатанный; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3928" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSealed">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа универсального типа, это свойство всегда возвращает <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3929" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSealed">
          <source>The following example creates an instance of a <ph id="ph1">`sealed`</ph> class, checks for the <ph id="ph2">`IsSealed`</ph> property, and displays the result.</source>
          <target state="translated">В следующем примере создается экземпляр <ph id="ph1">`sealed`</ph> класса, проверяется <ph id="ph2">`IsSealed`</ph> свойство и отображается результат.</target>       </trans-unit>
        <trans-unit id="3930" translate="yes" xml:space="preserve" uid="P:System.Type.IsSecurityCritical">
          <source>Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</source>
          <target state="translated">Возвращает значение, которое указывает, является ли текущий тип критически важным для безопасности или защищенным критически важным для безопасности на данном уровне доверия и, следовательно, может ли он выполнять критические операции.</target>       </trans-unit>
        <trans-unit id="3931" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is security-critical or security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is transparent.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий тип является критически важным для безопасности или защищенным критически важным для безопасности на текущем уровне доверия; значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>, если он является прозрачным.</target>       </trans-unit>
        <trans-unit id="3932" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, И <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> свойства отчетов уровень прозрачности типа в его текущем уровне доверия, что определяется общеязыковой среды выполнения (CLR).</target>       </trans-unit>
        <trans-unit id="3933" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">В следующей таблице показаны сочетания этих свойств.</target>       </trans-unit>
        <trans-unit id="3934" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Security level</source>
          <target state="translated">Уровень безопасности</target>       </trans-unit>
        <trans-unit id="3935" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="3936" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="3937" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="3938" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">Critical</target>       </trans-unit>
        <trans-unit id="3939" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Safe critical</source>
          <target state="translated">Надежным с точки зрения</target>       </trans-unit>
        <trans-unit id="3940" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">Прозрачный</target>       </trans-unit>
        <trans-unit id="3941" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.</target>       </trans-unit>
        <trans-unit id="3942" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">Для сборок с частичным доверием значение этого свойства зависит от текущего уровня доверия сборки.</target>       </trans-unit>
        <trans-unit id="3943" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Если сборка загружается в домен приложения с частичным доверием (например, в изолированном домене приложения), среда выполнения игнорирует примечания безопасности сборки.</target>       </trans-unit>
        <trans-unit id="3944" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">Сборка и все типы считаются прозрачными.</target>       </trans-unit>
        <trans-unit id="3945" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">Среда выполнения уделяет внимание заметки безопасности сборки с частичным доверием, только в том случае, если эта сборка загружается в домен приложения с полным доверием (например, в домене приложения по умолчанию для настольного приложения).</target>       </trans-unit>
        <trans-unit id="3946" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">В отличие от этого доверенной сборке (то есть сборки строгим именем, установленной в глобальном кэше сборок) всегда является загружена с полным доверием независимо от уровня доверия домена приложения, поэтому ее текущий уровень доверия всегда является полностью доверенным.</target>       </trans-unit>
        <trans-unit id="3947" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">Можно определить текущие уровни доверия сборок и доменов приложений с помощью <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="3948" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о отражение и прозрачность см. в разделе <bpt id="p1">[</bpt>рекомендации по безопасности для отражения<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3949" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Сведения о прозрачности см. в разделе <bpt id="p1">[</bpt>изменения системы безопасности<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3950" translate="yes" xml:space="preserve" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</source>
          <target state="translated">Возвращает значение, которое указывает, является ли текущий тип защищенным критически важным для безопасности на текущем уровне доверия и, следовательно, может ли он выполнять критические операции и предоставлять доступ прозрачному коду.</target>       </trans-unit>
        <trans-unit id="3951" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is security-critical or transparent.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий тип является защищенным критически важным для безопасности на текущем уровне доверия; значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>, если он является критически важным для безопасности или прозрачным.</target>       </trans-unit>
        <trans-unit id="3952" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, И <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> свойства отчетов уровень прозрачности типа в его текущем уровне доверия, что определяется общеязыковой среды выполнения (CLR).</target>       </trans-unit>
        <trans-unit id="3953" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">В следующей таблице показаны сочетания этих свойств.</target>       </trans-unit>
        <trans-unit id="3954" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Security level</source>
          <target state="translated">Уровень безопасности</target>       </trans-unit>
        <trans-unit id="3955" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="3956" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="3957" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="3958" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">Critical</target>       </trans-unit>
        <trans-unit id="3959" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Safe critical</source>
          <target state="translated">Надежным с точки зрения</target>       </trans-unit>
        <trans-unit id="3960" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">Прозрачный</target>       </trans-unit>
        <trans-unit id="3961" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.</target>       </trans-unit>
        <trans-unit id="3962" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">Для сборок с частичным доверием значение этого свойства зависит от текущего уровня доверия сборки.</target>       </trans-unit>
        <trans-unit id="3963" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Если сборка загружается в домен приложения с частичным доверием (например, в изолированном домене приложения), среда выполнения игнорирует примечания безопасности сборки.</target>       </trans-unit>
        <trans-unit id="3964" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">Сборка и все типы считаются прозрачными.</target>       </trans-unit>
        <trans-unit id="3965" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">Среда выполнения уделяет внимание заметки безопасности сборки с частичным доверием, только в том случае, если эта сборка загружается в домен приложения с полным доверием (например, в домене приложения по умолчанию для настольного приложения).</target>       </trans-unit>
        <trans-unit id="3966" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">В отличие от этого доверенной сборке (то есть сборки строгим именем, установленной в глобальном кэше сборок) всегда является загружена с полным доверием независимо от уровня доверия домена приложения, поэтому ее текущий уровень доверия всегда является полностью доверенным.</target>       </trans-unit>
        <trans-unit id="3967" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">Можно определить текущие уровни доверия сборок и доменов приложений с помощью <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="3968" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о отражение и прозрачность см. в разделе <bpt id="p1">[</bpt>рекомендации по безопасности для отражения<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3969" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Сведения о прозрачности см. в разделе <bpt id="p1">[</bpt>изменения системы безопасности<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3970" translate="yes" xml:space="preserve" uid="P:System.Type.IsSecurityTransparent">
          <source>Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.</source>
          <target state="translated">Возвращает значение, которое указывает, является ли текущий тип прозрачным на текущем уровне доверия и, следовательно, не может выполнять критические операции.</target>       </trans-unit>
        <trans-unit id="3971" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type is security-transparent at the current trust level; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий тип является прозрачным на текущем уровне доверия; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3972" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>If this property returns <ph id="ph1">`true`</ph>, the <ph id="ph2">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph> properties return <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Если это свойство возвращает <ph id="ph1">`true`</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph> и <ph id="ph3">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph> возвращаемого свойства <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3973" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, И <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> свойства отчетов уровень прозрачности типа в его текущем уровне доверия, что определяется общеязыковой среды выполнения (CLR).</target>       </trans-unit>
        <trans-unit id="3974" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.</target>       </trans-unit>
        <trans-unit id="3975" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">Для сборок с частичным доверием значение этого свойства зависит от текущего уровня доверия сборки.</target>       </trans-unit>
        <trans-unit id="3976" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Если сборка загружается в домен приложения с частичным доверием (например, в изолированном домене приложения), среда выполнения игнорирует примечания безопасности сборки.</target>       </trans-unit>
        <trans-unit id="3977" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">Сборка и все типы считаются прозрачными.</target>       </trans-unit>
        <trans-unit id="3978" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">Среда выполнения уделяет внимание заметки безопасности сборки с частичным доверием, только в том случае, если эта сборка загружается в домен приложения с полным доверием (например, в домене приложения по умолчанию для настольного приложения).</target>       </trans-unit>
        <trans-unit id="3979" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">В отличие от этого доверенной сборке (то есть сборки строгим именем, установленной в глобальном кэше сборок) всегда является загружена с полным доверием независимо от уровня доверия домена приложения, поэтому ее текущий уровень доверия всегда является полностью доверенным.</target>       </trans-unit>
        <trans-unit id="3980" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">Можно определить текущие уровни доверия сборок и доменов приложений с помощью <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="3981" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о отражение и прозрачность см. в разделе <bpt id="p1">[</bpt>рекомендации по безопасности для отражения<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3982" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Сведения о прозрачности см. в разделе <bpt id="p1">[</bpt>изменения системы безопасности<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3983" translate="yes" xml:space="preserve" uid="P:System.Type.IsSerializable">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is serializable.</source>
          <target state="translated">Возвращает значение, позволяющее определить, сериализуем ли объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3984" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is serializable; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является сериализуемым; в противным случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3985" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>Types that are defined in the .NET Standard are not marked with <ph id="ph1">&lt;xref:System.SerializableAttribute&gt;</ph>.</source>
          <target state="translated">Типы, которые определены в .NET Standard не отмечены ни <ph id="ph1">&lt;xref:System.SerializableAttribute&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3986" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>Instead, each .NET implementation determines whether a type is serializable.</source>
          <target state="translated">Вместо этого каждая реализация .NET определяет, является ли сериализуемый тип.</target>       </trans-unit>
        <trans-unit id="3987" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>At run time, you can use the <ph id="ph1">&lt;xref:System.Type.IsSerializable%2A&gt;</ph> property to determine whether that implementation supports serialization of an instance of the type.</source>
          <target state="translated">Во время выполнения, можно использовать <ph id="ph1">&lt;xref:System.Type.IsSerializable%2A&gt;</ph> свойства, чтобы определить, поддерживает ли эта реализация сериализации экземпляра типа.</target>       </trans-unit>
        <trans-unit id="3988" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>For more information and an example, see <bpt id="p1">[</bpt>How to determine if a .NET Standard object is serializable<ept id="p1">](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md)</ept>.</source>
          <target state="translated">Дополнительные сведения и пример см. в разделе <bpt id="p1">[</bpt>как определить, является ли сериализуемый объект .NET Standard<ept id="p1">](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3989" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, тип был создан.</target>       </trans-unit>
        <trans-unit id="3990" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Например если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> в Visual Basic), значение этого свойства определяется <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3991" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3992" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>The following example creates an instance of <ph id="ph1">`MyTestClass`</ph> class, sets the [Serializable] attribute, and checks the <ph id="ph2">`IsSerializable`</ph> property for <ph id="ph3">`true`</ph> or <ph id="ph4">`false`</ph>.</source>
          <target state="translated">В следующем примере создается экземпляр <ph id="ph1">`MyTestClass`</ph> классе, задает атрибут [Serializable] и проверяет <ph id="ph2">`IsSerializable`</ph> свойство <ph id="ph3">`true`</ph> или <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3993" translate="yes" xml:space="preserve" uid="P:System.Type.IsSpecialName">
          <source>Gets a value indicating whether the type has a name that requires special handling.</source>
          <target state="translated">Возвращает значение, позволяющее определить, требует ли имя данного объекта специальной обработки.</target>       </trans-unit>
        <trans-unit id="3994" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type has a name that requires special handling; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если имя типа требует специальной обработки; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3995" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source>Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.</source>
          <target state="translated">Имена, которые начинаются с или содержать знак подчеркивания (_), к свойствам и методы перегрузки операторов являются примерами типов, которые могут потребовать специальной обработки в некоторых компиляторах.</target>       </trans-unit>
        <trans-unit id="3996" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, тип был создан.</target>       </trans-unit>
        <trans-unit id="3997" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Например если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> в Visual Basic), значение этого свойства определяется <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3998" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3999" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>The type to compare with the current type.</source>
          <target state="translated">Тип для сравнения с текущим типом.</target>       </trans-unit>
        <trans-unit id="4000" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Determines whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> derives from the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Определяет, является ли текущий <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> производным от указанного <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4001" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see langword="Type" /&gt;</ph> derives from <ph id="ph3">&lt;paramref name="c" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий объект <ph id="ph2">&lt;see langword="Type" /&gt;</ph> является производным от <ph id="ph3">&lt;paramref name="c" /&gt;</ph>; в противном случае — <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4002" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>This method also returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if <ph id="ph2">&lt;paramref name="c" /&gt;</ph> and the current <ph id="ph3">&lt;see langword="Type" /&gt;</ph> are equal.</source>
          <target state="translated">Этот метод также возвращает значение <ph id="ph1">&lt;see langword="false" /&gt;</ph>, если параметр <ph id="ph2">&lt;paramref name="c" /&gt;</ph> и текущий объект <ph id="ph3">&lt;see langword="Type" /&gt;</ph> равны.</target>       </trans-unit>
        <trans-unit id="4003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> method to determine any of the following:</source>
          <target state="translated">Можно вызвать <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> метод, чтобы определить следующее:</target>       </trans-unit>
        <trans-unit id="4004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Whether one class derives from another.</source>
          <target state="translated">Является ли один класс является производным от другого.</target>       </trans-unit>
        <trans-unit id="4005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Whether a type derives from <ph id="ph1">&lt;xref:System.ValueType&gt;</ph>.</source>
          <target state="translated">Является ли тип наследуется от <ph id="ph1">&lt;xref:System.ValueType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>However, the <ph id="ph1">&lt;xref:System.Type.IsValueType%2A&gt;</ph> is a more efficient way to determine whether a type is a value type.</source>
          <target state="translated">Тем не менее <ph id="ph1">&lt;xref:System.Type.IsValueType%2A&gt;</ph> — более эффективный способ определить, является ли тип типом значения.</target>       </trans-unit>
        <trans-unit id="4007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Whether a type derives from <ph id="ph1">&lt;xref:System.Enum&gt;</ph>.</source>
          <target state="translated">Является ли тип наследуется от <ph id="ph1">&lt;xref:System.Enum&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>However, the <ph id="ph1">&lt;xref:System.Type.IsEnum%2A&gt;</ph> method is a more efficient way to determine whether a type is an enumeration.</source>
          <target state="translated">Однако <ph id="ph1">&lt;xref:System.Type.IsEnum%2A&gt;</ph> метода является более эффективный способ определить, является ли тип перечислением.</target>       </trans-unit>
        <trans-unit id="4009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Whether a type is a delegate, that is, whether it derives from either <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> or <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph>.</source>
          <target state="translated">Является ли тип является делегатом, т. е ли он является производным от либо <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> или <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> Метод не может использоваться для определения, является ли интерфейс производным от другого интерфейса или ли класс реализует интерфейс.</target>       </trans-unit>
        <trans-unit id="4011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph> method for that purpose, as the following example shows.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph> метод для этой цели, как показано в следующем примере.</target>       </trans-unit>
        <trans-unit id="4012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> if it has no class constraint.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, он является производным от ограничения своего класса или из <ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> , если он не имеет ограничения класса.</target>       </trans-unit>
        <trans-unit id="4013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Except when used with interfaces, <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> is the converse of <ph id="ph2">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph>.</source>
          <target state="translated">За исключением случаев использования с интерфейсами, <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> имеет противоположное <ph id="ph2">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>That is, if <ph id="ph1">`t1.IsSubclassOf(t2)`</ph> is <ph id="ph2">`true`</ph>, then <ph id="ph3">`t2.IsAssignableFrom(t1)`</ph> is also <ph id="ph4">`true`</ph>.</source>
          <target state="translated">То есть если <ph id="ph1">`t1.IsSubclassOf(t2)`</ph> — <ph id="ph2">`true`</ph>, затем <ph id="ph3">`t2.IsAssignableFrom(t1)`</ph> также <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="4015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Этот метод может быть переопределен в производном классе.</target>       </trans-unit>
        <trans-unit id="4016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>The following example creates a class named <ph id="ph1">`Class1`</ph> and a derived class named <ph id="ph2">`DerivedC1`</ph>.</source>
          <target state="translated">В следующем примере создается класс с именем <ph id="ph1">`Class1`</ph> и производный класс с именем <ph id="ph2">`DerivedC1`</ph>.</target>       </trans-unit>
        <trans-unit id="4017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>It calls the <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> method to show that <ph id="ph2">`DerivedC1`</ph> is a subclass of <ph id="ph3">`Class1`</ph>.</source>
          <target state="translated">Он вызывает <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> метод, чтобы показать, что <ph id="ph2">`DerivedC1`</ph> является подклассом <ph id="ph3">`Class1`</ph>.</target>       </trans-unit>
        <trans-unit id="4018" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="c" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4019" translate="yes" xml:space="preserve" uid="P:System.Type.IsUnicodeClass">
          <source>Gets a value indicating whether the string format attribute <ph id="ph1">&lt;see langword="UnicodeClass" /&gt;</ph> is selected for the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает значение, позволяющее определить, выбран ли для объекта <ph id="ph1">&lt;see langword="UnicodeClass" /&gt;</ph> атрибут формата строки <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4020" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the string format attribute <ph id="ph2">&lt;see langword="UnicodeClass" /&gt;</ph> is selected for the <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если для данного объекта <ph id="ph2">&lt;see langword="UnicodeClass" /&gt;</ph> выбран атрибут формата строки <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; в противном случае — значение <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4021" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> is used to select the string format attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> Используется для выбора атрибутов формата строки.</target>       </trans-unit>
        <trans-unit id="4022" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>The string format attributes enhance interoperability by defining how strings should be interpreted.</source>
          <target state="translated">Атрибуты формата строки расширяют возможности взаимодействия, определение того, как должны интерпретироваться строки.</target>       </trans-unit>
        <trans-unit id="4023" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, тип был создан.</target>       </trans-unit>
        <trans-unit id="4024" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Например если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> в Visual Basic), значение этого свойства определяется <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="4025" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="4026" translate="yes" xml:space="preserve" uid="P:System.Type.IsValueType">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a value type.</source>
          <target state="translated">Возвращает значение, позволяющее определить, является ли объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> типом значения.</target>       </trans-unit>
        <trans-unit id="4027" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a value type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если тип <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является типом значения; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4028" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>Value types are types that are represented as sequences of bits; value types are not classes or interfaces.</source>
          <target state="translated">Типы значений — это типы, которые представлены в виде последовательности битов; типы значений не являются классами или интерфейсами.</target>       </trans-unit>
        <trans-unit id="4029" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>Value types are referred to as "structs" in some programming languages.</source>
          <target state="translated">Типы значений, называются «структуры» в некоторых языках программирования.</target>       </trans-unit>
        <trans-unit id="4030" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>Enums are a special case of value types.</source>
          <target state="translated">Перечисления являются особым случаем типов значений.</target>       </trans-unit>
        <trans-unit id="4031" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>This property returns <ph id="ph1">`false`</ph> for the <ph id="ph2">&lt;xref:System.ValueType&gt;</ph> class, because <ph id="ph3">&lt;xref:System.ValueType&gt;</ph> is not a value type itself.</source>
          <target state="translated">Это свойство возвращает <ph id="ph1">`false`</ph> для <ph id="ph2">&lt;xref:System.ValueType&gt;</ph> класса, так как <ph id="ph3">&lt;xref:System.ValueType&gt;</ph> не является типом значения, сам.</target>       </trans-unit>
        <trans-unit id="4032" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>It is the base class for all value types, and therefore any value type can be assigned to it.</source>
          <target state="translated">Это базовый класс для всех типов значений, и поэтому к нему можно присвоить значения любого типа.</target>       </trans-unit>
        <trans-unit id="4033" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>This would not be possible if <ph id="ph1">&lt;xref:System.ValueType&gt;</ph> itself was a value type.</source>
          <target state="translated">Это нельзя сделать Если <ph id="ph1">&lt;xref:System.ValueType&gt;</ph> сам был типом значения.</target>       </trans-unit>
        <trans-unit id="4034" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>Value types are boxed when they are assigned to a field of type <ph id="ph1">&lt;xref:System.ValueType&gt;</ph>.</source>
          <target state="translated">Типы значений, упаковываются при назначении поле типа <ph id="ph1">&lt;xref:System.ValueType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4035" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>This property returns <ph id="ph1">`true`</ph> for enumerations, but not for the <ph id="ph2">&lt;xref:System.Enum&gt;</ph> type itself.</source>
          <target state="translated">Это свойство возвращает <ph id="ph1">`true`</ph> для перечислений, но не для <ph id="ph2">&lt;xref:System.Enum&gt;</ph> сами типы.</target>       </trans-unit>
        <trans-unit id="4036" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>For an example that demonstrates this behavior, see <ph id="ph1">&lt;xref:System.Type.IsEnum%2A&gt;</ph>.</source>
          <target state="translated">Пример, демонстрирующий это см. в разделе <ph id="ph1">&lt;xref:System.Type.IsEnum%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4037" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>This property is read-only.</source>
          <target state="translated">Это свойство доступно только для чтения.</target>       </trans-unit>
        <trans-unit id="4038" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>The following example creates a variable of type <ph id="ph1">`MyEnum`</ph>, checks for the <ph id="ph2">`IsValueType`</ph> property, and displays the result.</source>
          <target state="translated">В следующем примере создается переменная типа <ph id="ph1">`MyEnum`</ph>, проверяет наличие <ph id="ph2">`IsValueType`</ph> свойства и отображается результат.</target>       </trans-unit>
        <trans-unit id="4039" translate="yes" xml:space="preserve" uid="M:System.Type.IsValueTypeImpl">
          <source>Implements the <ph id="ph1">&lt;see cref="P:System.Type.IsValueType" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a value type; that is, not a class or an interface.</source>
          <target state="translated">Реализует свойство <ph id="ph1">&lt;see cref="P:System.Type.IsValueType" /&gt;</ph> и определяет, является ли объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> типом значения (иными словами, не является классом или интерфейсом).</target>       </trans-unit>
        <trans-unit id="4040" translate="yes" xml:space="preserve" uid="M:System.Type.IsValueTypeImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a value type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если тип <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является типом значения; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsValueTypeImpl">
          <source>This method is provided to enable the implementation of alternate type systems.</source>
          <target state="translated">Этот метод предоставляется для обеспечения реализации систем альтернативный тип.</target>       </trans-unit>
        <trans-unit id="4042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsValueTypeImpl">
          <source>It is not generally used in application code.</source>
          <target state="translated">Обычно оно не используется в коде приложения.</target>       </trans-unit>
        <trans-unit id="4043" translate="yes" xml:space="preserve" uid="P:System.Type.IsVisible">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> can be accessed by code outside the assembly.</source>
          <target state="translated">Возвращает значение, позволяющее определить, можно ли получить доступ к объекту <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> из кода за пределами сборки.</target>       </trans-unit>
        <trans-unit id="4044" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsVisible">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a public type or a public nested type such that all the enclosing types are public; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> является открытым типом или открытым вложенным типом, все включающие типы которого также являются открытыми; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4045" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsVisible">
          <source>Use this property to determine whether a type is part of the public interface of a component assembly.</source>
          <target state="translated">Используйте это свойство, чтобы определить, является ли тип частью открытого интерфейса сборки компонентов.</target>       </trans-unit>
        <trans-unit id="4046" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsVisible">
          <source>The following code example tests two classes, only one of which is visible outside the assembly.</source>
          <target state="translated">В следующем примере кода проверяются два класса, только один из которых отображается за пределами сборки.</target>       </trans-unit>
        <trans-unit id="4047" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents an array of the current type.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, который представляет массив текущего типа.</target>       </trans-unit>
        <trans-unit id="4048" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a one-dimensional array of the current type, with a lower bound of zero.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий одномерный массив текущего типа с нижней границей, равной нулю.</target>       </trans-unit>
        <trans-unit id="4049" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a one-dimensional array of the current type, with a lower bound of zero.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий одномерный массив текущего типа с нижней границей, равной нулю.</target>       </trans-unit>
        <trans-unit id="4050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> method provides a way to generate array types whose element types are computed at run time.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> Метод предоставляет способ создания типов массивов, типы элементов которых вычисляются во время выполнения.</target>       </trans-unit>
        <trans-unit id="4051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</source>
          <target state="translated"><bpt id="p1">**</bpt>Примечание<ept id="p1">**</ept> общеязыковая среда выполнения различает векторов (то есть одномерные массивы, всегда отсчитываемый от нуля) и многомерных массивов.</target>       </trans-unit>
        <trans-unit id="4052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</source>
          <target state="translated">Вектор, который всегда имеет только одно измерение, не совпадает с многомерного массива, которая имеет только одно измерение.</target>       </trans-unit>
        <trans-unit id="4053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>This method overload can only be used to create vector types, and it is the only way to create a vector type.</source>
          <target state="translated">Эта перегрузка метода может использоваться только для создания векторных типов, и это единственный способ создания векторных типов.</target>       </trans-unit>
        <trans-unit id="4054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.MakeArrayType%28System.Int32%29&gt;</ph> method overload to create multidimensional array types.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Type.MakeArrayType%28System.Int32%29&gt;</ph> перегрузка метода для создания многомерных массивов.</target>       </trans-unit>
        <trans-unit id="4055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>The following code example creates array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), and pointer types for the <ph id="ph3">`Test`</ph> class.</source>
          <target state="translated">В следующем примере кода создается массив, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> в Visual Basic) и типы указателей для <ph id="ph3">`Test`</ph> класса.</target>       </trans-unit>
        <trans-unit id="4056" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">Вызванный метод не поддерживается в базовом классе.</target>       </trans-unit>
        <trans-unit id="4057" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">Реализацию должны обеспечивать производные классы.</target>       </trans-unit>
        <trans-unit id="4058" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>The current type is <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated">Текущий тип — <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4059" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="4060" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>The current type is a <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated">Текущий тип — <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4061" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">То есть <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> возвращает <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4062" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The number of dimensions for the array.</source>
          <target state="translated">Размерность массива.</target>       </trans-unit>
        <trans-unit id="4063" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>This number must be less than or equal to 32.</source>
          <target state="translated">Это число должно быть меньше либо равно 32.</target>       </trans-unit>
        <trans-unit id="4064" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing an array of the current type, with the specified number of dimensions.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий массив текущего типа указанной размерности.</target>       </trans-unit>
        <trans-unit id="4065" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>An object representing an array of the current type, with the specified number of dimensions.</source>
          <target state="translated">Объект, представляющий массив текущего типа указанной размерности.</target>       </trans-unit>
        <trans-unit id="4066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> method provides a way to generate array types whose element types are computed at run time.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> Метод предоставляет способ создания типов массивов, типы элементов которых вычисляются во время выполнения.</target>       </trans-unit>
        <trans-unit id="4067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</source>
          <target state="translated">Общеязыковая среда выполнения различает векторов (то есть одномерные массивы, всегда отсчитываемый от нуля) и многомерных массивов.</target>       </trans-unit>
        <trans-unit id="4068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</source>
          <target state="translated">Вектор, который всегда имеет только одно измерение, не совпадает с многомерного массива, которая имеет только одно измерение.</target>       </trans-unit>
        <trans-unit id="4069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>You cannot use this method overload to create a vector type; if <ph id="ph1">`rank`</ph> is 1, this method overload returns a multidimensional array type that happens to have one dimension.</source>
          <target state="translated">Эта перегрузка метода нельзя использовать для создания векторного типа; Если <ph id="ph1">`rank`</ph> имеет значение 1, эта перегрузка метода возвращает тип многомерного массива, который имеет одно измерение.</target>       </trans-unit>
        <trans-unit id="4070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.MakeArrayType&gt;</ph> method overload to create vector types.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Type.MakeArrayType&gt;</ph> перегрузка метода для создания векторных типов.</target>       </trans-unit>
        <trans-unit id="4071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The following code example creates array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), and pointer types for the <ph id="ph3">`Test`</ph> class.</source>
          <target state="translated">В следующем примере кода создается массив, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> в Visual Basic) и типы указателей для <ph id="ph3">`Test`</ph> класса.</target>       </trans-unit>
        <trans-unit id="4072" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> недопустим.</target>       </trans-unit>
        <trans-unit id="4073" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>For example, 0 or negative.</source>
          <target state="translated">Например, 0 или отрицательное число.</target>       </trans-unit>
        <trans-unit id="4074" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">Вызванный метод не поддерживается в базовом классе.</target>       </trans-unit>
        <trans-unit id="4075" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The current type is <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated">Текущий тип — <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4076" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="4077" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The current type is a <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated">Текущий тип — <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4078" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">То есть <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> возвращает <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4079" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="4080" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> is greater than 32.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="rank" /&gt;</ph> больше 32.</target>       </trans-unit>
        <trans-unit id="4081" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the current type when passed as a <ph id="ph2">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> parameter in Visual Basic).</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, который представляет текущий тип при передаче в качестве параметра <ph id="ph2">&lt;see langword="ref" /&gt;</ph> (параметра <ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="4082" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the current type when passed as a <ph id="ph2">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> parameter in Visual Basic).</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, который представляет текущий тип при передаче в качестве параметра <ph id="ph2">&lt;see langword="ref" /&gt;</ph> (параметра <ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="4083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeByRefType">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph> method provides a way to generate <ph id="ph2">`ref`</ph> types (<ph id="ph3">`ByRef`</ph> in Visual Basic) for parameter lists.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph> Метод предоставляет способ создания <ph id="ph2">`ref`</ph> типов (<ph id="ph3">`ByRef`</ph> в Visual Basic) для параметра перечислены.</target>       </trans-unit>
        <trans-unit id="4084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeByRefType">
          <source>Using the syntax of Microsoft intermediate language (MSIL), if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, this method returns a <ph id="ph3">&lt;xref:System.Type&gt;</ph> object representing <ph id="ph4">`Int32&amp;`</ph>.</source>
          <target state="translated">С помощью синтаксиса кода промежуточного языка Майкрософт (MSIL), если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, этот метод возвращает <ph id="ph3">&lt;xref:System.Type&gt;</ph> , представляющий <ph id="ph4">`Int32&amp;`</ph>.</target>       </trans-unit>
        <trans-unit id="4085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeByRefType">
          <source>The following code example creates array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), and pointer types for the <ph id="ph3">`Test`</ph> class.</source>
          <target state="translated">В следующем примере кода создается массив, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> в Visual Basic) и типы указателей для <ph id="ph3">`Test`</ph> класса.</target>       </trans-unit>
        <trans-unit id="4086" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">Вызванный метод не поддерживается в базовом классе.</target>       </trans-unit>
        <trans-unit id="4087" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>The current type is <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated">Текущий тип — <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4088" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="4089" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>The current type is a <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated">Текущий тип — <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4090" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">То есть <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> возвращает <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4091" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>An array of types to be substituted for the type parameters of the current generic type.</source>
          <target state="translated">Массив типов, который должен быть замещен параметрами типа текущего универсального типа.</target>       </trans-unit>
        <trans-unit id="4092" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the resulting constructed type.</source>
          <target state="translated">Замещает элементы массива типов для параметров определения текущего универсального типа и возвращает объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, представляющий сконструированный результирующий тип.</target>       </trans-unit>
        <trans-unit id="4093" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the constructed type formed by substituting the elements of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> for the type parameters of the current generic type.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> представляет сконструированный тип, сформированный путем замещения элементов объекта <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> параметрами текущего универсального типа.</target>       </trans-unit>
        <trans-unit id="4094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a particular constructed type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> Метод позволяет написать код, который назначает определенные типы параметров типа определения универсального типа, тем самым создавая <ph id="ph2">&lt;xref:System.Type&gt;</ph> , представляющий определенный сконструированный тип.</target>       </trans-unit>
        <trans-unit id="4095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>You can use this <ph id="ph1">&lt;xref:System.Type&gt;</ph> object to create run-time instances of the constructed type.</source>
          <target state="translated">Эту функцию можно использовать <ph id="ph1">&lt;xref:System.Type&gt;</ph> для создания экземпляров во время выполнения сконструированного типа.</target>       </trans-unit>
        <trans-unit id="4096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Types constructed with <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types.</source>
          <target state="translated">Созданы типы с <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> может быть открыт, то есть некоторые их аргументы могут быть параметры типа заключающих универсальных методов или типов.</target>       </trans-unit>
        <trans-unit id="4097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>You might use such open constructed types when you emit dynamic assemblies.</source>
          <target state="translated">Такие открытые сконструированные типы можно использовать, когда порождение динамических сборок.</target>       </trans-unit>
        <trans-unit id="4098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>For example, consider the classes <ph id="ph1">`Base`</ph> and <ph id="ph2">`Derived`</ph> in the following code.</source>
          <target state="translated">Например, рассмотрим классы <ph id="ph1">`Base`</ph> и <ph id="ph2">`Derived`</ph> в следующем коде.</target>       </trans-unit>
        <trans-unit id="4099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To generate <ph id="ph1">`Derived`</ph> in a dynamic assembly, it is necessary to construct its base type.</source>
          <target state="translated">Для создания <ph id="ph1">`Derived`</ph> в динамической сборке, необходимо построить его базовый тип.</target>       </trans-unit>
        <trans-unit id="4100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To do this, call the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object representing the class <ph id="ph3">`Base`</ph>, using the generic type arguments <ph id="ph4">&lt;xref:System.Int32&gt;</ph> and the type parameter <ph id="ph5">`V`</ph> from <ph id="ph6">`Derived`</ph>.</source>
          <target state="translated">Чтобы сделать это, вызовите <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> метод <ph id="ph2">&lt;xref:System.Type&gt;</ph> объект, представляющий класс <ph id="ph3">`Base`</ph>, с помощью аргументов универсального типа <ph id="ph4">&lt;xref:System.Int32&gt;</ph> и параметр типа <ph id="ph5">`V`</ph> из <ph id="ph6">`Derived`</ph>.</target>       </trans-unit>
        <trans-unit id="4101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Because types and generic type parameters are both represented by <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects, an array containing both can be passed to the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method.</source>
          <target state="translated">Поскольку типы и параметры универсального типа представлены по <ph id="ph1">&lt;xref:System.Type&gt;</ph> объектов, можно передать массив, содержащий оба <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="4102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>A constructed type such as <ph id="ph1">`Base&lt;int, V&gt;`</ph> is useful when emitting code, but you cannot call the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method on this type because it is not a generic type definition.</source>
          <target state="translated">Сконструированный тип, такой как <ph id="ph1">`Base&lt;int, V&gt;`</ph> удобно при выпуске кода, но не может вызывать <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> метода для данного типа, так как он не является определением универсального типа.</target>       </trans-unit>
        <trans-unit id="4103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To create a closed constructed type that can be instantiated, first call the <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method to get a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object representing the generic type definition and then call <ph id="ph3">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> with the desired type arguments.</source>
          <target state="translated">Чтобы создать закрытым сконструированным типом может быть создан, сначала вызовите <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> метод, чтобы получить <ph id="ph2">&lt;xref:System.Type&gt;</ph> объект, представляющий определение универсального типа, а затем вызвать <ph id="ph3">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> с аргументами нужного типа.</target>       </trans-unit>
        <trans-unit id="4104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Type&gt;</ph> object returned by <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> is the same as the <ph id="ph3">&lt;xref:System.Type&gt;</ph> obtained by calling the <ph id="ph4">&lt;xref:System.Object.GetType%2A&gt;</ph> method of the resulting constructed type, or the <ph id="ph5">&lt;xref:System.Object.GetType%2A&gt;</ph> method of any constructed type that was created from the same generic type definition using the same type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type&gt;</ph> Объект, возвращаемый <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> совпадает со значением <ph id="ph3">&lt;xref:System.Type&gt;</ph> получается вызовом <ph id="ph4">&lt;xref:System.Object.GetType%2A&gt;</ph> метод итоговый сконструированный тип, или <ph id="ph5">&lt;xref:System.Object.GetType%2A&gt;</ph> метод любого сконструированный тип, который был создан из того же универсального Определение типа, используя те же аргументы типа.</target>       </trans-unit>
        <trans-unit id="4105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>An array of generic types is not itself a generic type.</source>
          <target state="translated">Массив универсальных типов сам по себе не является универсальным типом.</target>       </trans-unit>
        <trans-unit id="4106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>You cannot call <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> on an array type such as <ph id="ph2">`C&lt;T&gt;[]`</ph> (<ph id="ph3">`Dim ac() As C(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">Не удается вызвать <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> на массив типов, такие как <ph id="ph2">`C&lt;T&gt;[]`</ph> (<ph id="ph3">`Dim ac() As C(Of T)`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="4107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To construct a closed generic type from <ph id="ph1">`C&lt;T&gt;[]`</ph>, call <ph id="ph2">&lt;xref:System.Type.GetElementType%2A&gt;</ph> to obtain the generic type definition <ph id="ph3">`C&lt;T&gt;`</ph>; call <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> on the generic type definition to create the constructed type; and finally call the <ph id="ph5">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> method on the constructed type to create the array type.</source>
          <target state="translated">Для создания закрытого универсального типа из <ph id="ph1">`C&lt;T&gt;[]`</ph>, вызовите <ph id="ph2">&lt;xref:System.Type.GetElementType%2A&gt;</ph> для получения определения универсального типа <ph id="ph3">`C&lt;T&gt;`</ph>; вызвать <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> в определении универсального типа для создания сконструированного типа; Наконец вызовите <ph id="ph5">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> метод сконструированный тип, чтобы создать тип массива.</target>       </trans-unit>
        <trans-unit id="4108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The same is true of pointer types and <ph id="ph1">`ref`</ph> types (<ph id="ph2">`ByRef`</ph> in Visual Basic).</source>
          <target state="translated">То же самое справедливо для типов указателей и <ph id="ph1">`ref`</ph> типов (<ph id="ph2">`ByRef`</ph> в Visual Basic).</target>       </trans-unit>
        <trans-unit id="4109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Nested Types</source>
          <target state="translated">Вложенные типы</target>       </trans-unit>
        <trans-unit id="4111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic.</source>
          <target state="translated">Если универсальный тип определен с помощью C#, C++ или Visual Basic, его вложенные типы являются универсальными.</target>       </trans-unit>
        <trans-unit id="4112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types.</source>
          <target state="translated">Это верно, даже если вложенные типы не имеют тип параметров своих собственных, так как все три языка включать параметры типа заключающих типов в список параметров вложенных типов.</target>       </trans-unit>
        <trans-unit id="4113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Consider the following classes:</source>
          <target state="translated">Рассмотрим следующие классы:</target>       </trans-unit>
        <trans-unit id="4114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The type parameter list of the nested class <ph id="ph1">`Inner`</ph> has two type parameters, <ph id="ph2">`T`</ph> and <ph id="ph3">`U`</ph>, the first of which is the type parameter of its enclosing class.</source>
          <target state="translated">Список параметров типа вложенного класса <ph id="ph1">`Inner`</ph> имеет два параметра типа, <ph id="ph2">`T`</ph> и <ph id="ph3">`U`</ph>, первый из которых представляет собой параметр типа включающего класса.</target>       </trans-unit>
        <trans-unit id="4115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Similarly, the type parameter list of the nested class <ph id="ph1">`Innermost1`</ph> has three type parameters, <ph id="ph2">`T`</ph>, <ph id="ph3">`U`</ph>, and <ph id="ph4">`V`</ph>, with <ph id="ph5">`T`</ph> and <ph id="ph6">`U`</ph> coming from its enclosing classes.</source>
          <target state="translated">Аналогичным образом, список параметров типа вложенного класса <ph id="ph1">`Innermost1`</ph> имеет три параметра типа <ph id="ph2">`T`</ph>, <ph id="ph3">`U`</ph>, и <ph id="ph4">`V`</ph>, с <ph id="ph5">`T`</ph> и <ph id="ph6">`U`</ph> поступающих классами.</target>       </trans-unit>
        <trans-unit id="4116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The nested class <ph id="ph1">`Innermost2`</ph> has two type parameters, <ph id="ph2">`T`</ph> and <ph id="ph3">`U`</ph>, which come from its enclosing classes.</source>
          <target state="translated">Вложенный класс <ph id="ph1">`Innermost2`</ph> имеет два параметра типа, <ph id="ph2">`T`</ph> и <ph id="ph3">`U`</ph>, которой принадлежат классами.</target>       </trans-unit>
        <trans-unit id="4117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.</source>
          <target state="translated">Если список параметров типа включающего более одного параметра типа, все параметры типа в порядке включаются в списке параметров типа вложенного типа.</target>       </trans-unit>
        <trans-unit id="4118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To construct a generic type from the generic type definition for a nested type, call the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own.</source>
          <target state="translated">Для создания универсального типа в определении универсального типа для вложенного типа, вызовите <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> метод с массивом, сформированном путем объединения массивов аргументов всех заключающих типов, начиная с внешней универсального типа, и заканчивая Массив аргументов типа вложенного типа, если он имеет свои собственные параметры типов.</target>       </trans-unit>
        <trans-unit id="4119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To create an instance of <ph id="ph1">`Innermost1`</ph>, call the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with an array containing three types, to be assigned to T, U, and V. To create an instance of <ph id="ph3">`Innermost2`</ph>, call the <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with an array containing two types, to be assigned to T and U.</source>
          <target state="translated">Чтобы создать экземпляр <ph id="ph1">`Innermost1`</ph>, вызовите <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> метод с массив, содержащий три типа, присваиваемое T, U и V. Чтобы создать экземпляр <ph id="ph3">`Innermost2`</ph>, вызовите <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> метод с массив, содержащий два типа, присваиваемое T и U.</target>       </trans-unit>
        <trans-unit id="4120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types.</source>
          <target state="translated">Языки программирования распространяют параметры типа заключающих типов таким образом, чтобы можно было использовать для определения полей вложенных типов, параметры типа вмещающего типа.</target>       </trans-unit>
        <trans-unit id="4121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Otherwise, the type parameters would not be in scope within the bodies of the nested types.</source>
          <target state="translated">В противном случае параметров типа не будут находиться в области внутри тела вложенных типов.</target>       </trans-unit>
        <trans-unit id="4122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">Можно определить без распространения параметров включающего типа, с помощью выпуска кода в динамических сборках или с помощью вложенных типов <bpt id="p1">[</bpt>Ilasm.exe (ассемблер IL)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="4123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Consider the following code for the MSIL assembler:</source>
          <target state="translated">Рассмотрим следующий код для обработки ассемблером MSIL.</target>       </trans-unit>
        <trans-unit id="4124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>In this example, it is not possible to define a field of type <ph id="ph1">`T`</ph> or <ph id="ph2">`U`</ph> in class <ph id="ph3">`Innermost`</ph>, because those type parameters are not in scope.</source>
          <target state="translated">В этом примере не удается определить тип поля <ph id="ph1">`T`</ph> или <ph id="ph2">`U`</ph> в классе <ph id="ph3">`Innermost`</ph>, так как эти параметры типов находятся вне области.</target>       </trans-unit>
        <trans-unit id="4125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:</source>
          <target state="translated">В следующем примере кода ассемблера определяет вложенные классы, которые ведут себя так, определенных в C++, Visual Basic и C#:</target>       </trans-unit>
        <trans-unit id="4126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine nested classes defined in the high-level languages and observe this naming scheme.</source>
          <target state="translated">Можно использовать <bpt id="p1">[</bpt>Ildasm.exe (дизассемблер IL)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> для Изучите вложенные классы, определенные в высокоуровневых языках и посмотрите, такая схема именования.</target>       </trans-unit>
        <trans-unit id="4127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method to create a constructed type from the generic type definition for the <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> type.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> метод для создания сконструированного типа определения универсального типа для <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> типа.</target>       </trans-unit>
        <trans-unit id="4128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The constructed type represents a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`Test`</ph> objects with string keys.</source>
          <target state="translated">Представляет сконструированный тип <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> из <ph id="ph2">`Test`</ph> объектов, содержащих строковые ключи.</target>       </trans-unit>
        <trans-unit id="4129" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The current type does not represent a generic type definition.</source>
          <target state="translated">Текущий тип не представляет определение универсального типа.</target>       </trans-unit>
        <trans-unit id="4130" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsGenericTypeDefinition" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">То есть <ph id="ph1">&lt;see cref="P:System.Type.IsGenericTypeDefinition" /&gt;</ph> возвращает <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4131" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4132" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="4133" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Any element of <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Любой элемент <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4134" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The number of elements in <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is not the same as the number of type parameters in the current generic type definition.</source>
          <target state="translated">Число элементов объекта <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> не совпадает с числом параметров типа в текущем определении универсального типа.</target>       </trans-unit>
        <trans-unit id="4135" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="4136" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Any element of <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> does not satisfy the constraints specified for the corresponding type parameter of the current generic type.</source>
          <target state="translated">Ни в одном из элементов объекта <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> не соблюдаются ограничения, заданные для соответствующего параметра текущего универсального типа.</target>       </trans-unit>
        <trans-unit id="4137" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="4138" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> contains an element that is a pointer type (<ph id="ph2">&lt;see cref="P:System.Type.IsPointer" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>), a by-ref type (<ph id="ph4">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph5">&lt;see langword="true" /&gt;</ph>), or <ph id="ph6">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> содержит элемент, представляющий собой тип указателя (<ph id="ph2">&lt;see cref="P:System.Type.IsPointer" /&gt;</ph> возвращает <ph id="ph3">&lt;see langword="true" /&gt;</ph>), тип ByRef (<ph id="ph4">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> возвращает <ph id="ph5">&lt;see langword="true" /&gt;</ph>) или <ph id="ph6">&lt;see cref="T:System.Void" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4139" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">Вызванный метод не поддерживается в базовом классе.</target>       </trans-unit>
        <trans-unit id="4140" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">Реализацию должны обеспечивать производные классы.</target>       </trans-unit>
        <trans-unit id="4141" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a pointer to the current type.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, который представляет указатель на текущий тип.</target>       </trans-unit>
        <trans-unit id="4142" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a pointer to the current type.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, который представляет указатель на текущий тип.</target>       </trans-unit>
        <trans-unit id="4143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakePointerType">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakePointerType%2A&gt;</ph> method provides a way to generate pointer types for parameter lists.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakePointerType%2A&gt;</ph> Метод предоставляет способ создания типов указателей для списки параметров.</target>       </trans-unit>
        <trans-unit id="4144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakePointerType">
          <source>Using the syntax of Microsoft intermediate language (MSIL), if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, this method returns a <ph id="ph3">&lt;xref:System.Type&gt;</ph> object representing <ph id="ph4">`Int32*`</ph>.</source>
          <target state="translated">С помощью синтаксиса кода промежуточного языка Майкрософт (MSIL), если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, этот метод возвращает <ph id="ph3">&lt;xref:System.Type&gt;</ph> , представляющий <ph id="ph4">`Int32*`</ph>.</target>       </trans-unit>
        <trans-unit id="4145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakePointerType">
          <source>The following code example creates array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), and pointer types for the <ph id="ph3">`Test`</ph> class.</source>
          <target state="translated">В следующем примере кода создается массив, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> в Visual Basic) и типы указателей для <ph id="ph3">`Test`</ph> класса.</target>       </trans-unit>
        <trans-unit id="4146" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">Вызванный метод не поддерживается в базовом классе.</target>       </trans-unit>
        <trans-unit id="4147" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>The current type is <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated">Текущий тип — <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4148" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="4149" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>The current type is a <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated">Текущий тип — <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4150" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">То есть <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> возвращает <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4151" translate="yes" xml:space="preserve" uid="P:System.Type.MemberType">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> value indicating that this member is a type or a nested type.</source>
          <target state="translated">Возвращает значение <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph>, позволяющее определить, каким типом является этот член: обычным или вложенным.</target>       </trans-unit>
        <trans-unit id="4152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> value indicating that this member is a type or a nested type.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph>, позволяющее определить, каким типом является этот член: обычным или вложенным.</target>       </trans-unit>
        <trans-unit id="4153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>This property overrides <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Это свойство переопределяет <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4154" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>Therefore, when you examine a set of <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects—for example, the array returned by <ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph>—the <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph> property returns <ph id="ph4">&lt;xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType&gt;</ph> when a given member is a nested type.</source>
          <target state="translated">Таким образом, при рассмотрении набор <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> объектов — например, массив, возвращаемый методом <ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph>— <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph> возвращает <ph id="ph4">&lt;xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType&gt;</ph> Если данный элемент является вложенным типом.</target>       </trans-unit>
        <trans-unit id="4155" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, тип был создан.</target>       </trans-unit>
        <trans-unit id="4156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Например если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> в Visual Basic), значение этого свойства определяется <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="4157" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">&lt;xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает <ph id="ph2">&lt;xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>The following code example shows the <ph id="ph1">`MemberType`</ph> field as a parameter to the <ph id="ph2">`GetMember`</ph> method:</source>
          <target state="translated">В следующем примере кода показан <ph id="ph1">`MemberType`</ph> поля в качестве параметра <ph id="ph2">`GetMember`</ph> метод:</target>       </trans-unit>
        <trans-unit id="4159" translate="yes" xml:space="preserve" uid="F:System.Type.Missing">
          <source>Represents a missing value in the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> information.</source>
          <target state="translated">Представляет отсутствующее значение в данных объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4160" translate="yes" xml:space="preserve" uid="F:System.Type.Missing">
          <source>This field is read-only.</source>
          <target state="translated">Это поле доступно только для чтения.</target>       </trans-unit>
        <trans-unit id="4161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>Use the <ph id="ph1">`Missing`</ph> field for invocation through reflection to obtain the default value of a parameter.</source>
          <target state="translated">Используйте <ph id="ph1">`Missing`</ph> для вызова через отражение для получения значения параметра по умолчанию.</target>       </trans-unit>
        <trans-unit id="4162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>If the <ph id="ph1">`Missing`</ph> field is passed in for a parameter value and there is no default value for that parameter, an <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> is thrown.</source>
          <target state="translated">Если <ph id="ph1">`Missing`</ph> передается в качестве значения параметра, и нет значения по умолчанию для этого параметра <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> возникает исключение.</target>       </trans-unit>
        <trans-unit id="4163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>The following code example shows the use of the <ph id="ph1">`Missing`</ph> field to invoke a method with its default arguments.</source>
          <target state="translated">В следующем примере кода показано использование <ph id="ph1">`Missing`</ph> поля для вызова метода с аргументами по умолчанию.</target>       </trans-unit>
        <trans-unit id="4164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>This code produces the following output:</source>
          <target state="translated">Этот код выводит следующие результаты:</target>       </trans-unit>
        <trans-unit id="4165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>a = 10 b = 55.3 c = 12</source>
          <target state="translated">= 10, b = 55.3 c = 12</target>       </trans-unit>
        <trans-unit id="4166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>a = 10 b = 1.3 c = 1</source>
          <target state="translated">= 10, b = 1.3 c = 1</target>       </trans-unit>
        <trans-unit id="4167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>a = 10 b = 1.2 c = 1</source>
          <target state="translated">= 10, b = 1.2 c = 1</target>       </trans-unit>
        <trans-unit id="4168" translate="yes" xml:space="preserve" uid="P:System.Type.Module">
          <source>Gets the module (the DLL) in which the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is defined.</source>
          <target state="translated">Возвращает модуль (DLL), в котором определен текущий объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>The module in which the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is defined.</source>
          <target state="translated">Модуль, в котором определен текущий объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4170" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns the module in which the generic type definition was defined.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, это свойство возвращает модуль, в котором определен определение универсального типа.</target>       </trans-unit>
        <trans-unit id="4171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>For example, if you create an instance of <ph id="ph1">`MyGenericStack&lt;int&gt;`</ph>, the <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> property for the constructed type returns the module in which <ph id="ph3">`MyGenericStack&lt;T&gt;`</ph> is defined.</source>
          <target state="translated">Например, если создать экземпляр <ph id="ph1">`MyGenericStack&lt;int&gt;`</ph>, <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> свойство для сконструированного типа возвращает модуль, в котором <ph id="ph3">`MyGenericStack&lt;T&gt;`</ph> определен.</target>       </trans-unit>
        <trans-unit id="4172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>Similarly, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic parameter <ph id="ph2">`T`</ph>, this property returns the assembly that contains the generic type that defines <ph id="ph3">`T`</ph>.</source>
          <target state="translated">Аналогично Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет универсальный параметр <ph id="ph2">`T`</ph>, это свойство возвращает сборку, которая содержит универсальный тип, определяющий <ph id="ph3">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="4173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>This following example demonstrates a use of the <ph id="ph1">&lt;xref:System.Type.Namespace%2A&gt;</ph> and <ph id="ph2">`Module`</ph> properties and the <ph id="ph3">&lt;xref:System.Type.ToString%2A&gt;</ph> method of <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">В следующем примере показано использование <ph id="ph1">&lt;xref:System.Type.Namespace%2A&gt;</ph> и <ph id="ph2">`Module`</ph> свойства и <ph id="ph3">&lt;xref:System.Type.ToString%2A&gt;</ph> метод <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4174" translate="yes" xml:space="preserve" uid="P:System.Type.Namespace">
          <source>Gets the namespace of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает пространство имен объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>The namespace of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>; <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the current instance has no namespace or represents a generic parameter.</source>
          <target state="translated">Пространство имен <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> или значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>, если текущий экземпляр не имеет пространства имен или представляет универсальный параметр.</target>       </trans-unit>
        <trans-unit id="4176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure.</source>
          <target state="translated">Пространство имен — логические разработки именования удобства используются главным образом для определения области в приложении и организовать классов и других типов в одну иерархическую структуру.</target>       </trans-unit>
        <trans-unit id="4177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>From the viewpoint of the runtime, there are no namespaces.</source>
          <target state="translated">С точки зрения среды выполнения отсутствуют пространства имен.</target>       </trans-unit>
        <trans-unit id="4178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns the namespace that contains the generic type definition.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет сконструированный универсальный тип, это свойство возвращает пространство имен, содержащее определение универсального типа.</target>       </trans-unit>
        <trans-unit id="4179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>Similarly, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic parameter <ph id="ph2">`T`</ph>, this property returns the namespace that contains the generic type definition that defines <ph id="ph3">`T`</ph>.</source>
          <target state="translated">Аналогично Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет универсальный параметр <ph id="ph2">`T`</ph>, это свойство возвращает пространство имен, содержащее определение универсального типа, который определяет <ph id="ph3">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="4180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a generic parameter, this property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> объект представляет универсальный параметр, это свойство возвращает <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="4181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>This following example demonstrates a use of the <ph id="ph1">`Namespace`</ph> and <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> properties and the <ph id="ph3">&lt;xref:System.Type.ToString%2A&gt;</ph> method of <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">В следующем примере показано использование <ph id="ph1">`Namespace`</ph> и <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> свойства и <ph id="ph3">&lt;xref:System.Type.ToString%2A&gt;</ph> метод <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4182" translate="yes" xml:space="preserve" uid="M:System.Type.op_Equality(System.Type,System.Type)">
          <source>The first object to compare.</source>
          <target state="translated">Первый из сравниваемых объектов.</target>       </trans-unit>
        <trans-unit id="4183" translate="yes" xml:space="preserve" uid="M:System.Type.op_Equality(System.Type,System.Type)">
          <source>The second object to compare.</source>
          <target state="translated">Второй из сравниваемых объектов.</target>       </trans-unit>
        <trans-unit id="4184" translate="yes" xml:space="preserve" uid="M:System.Type.op_Equality(System.Type,System.Type)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects are equal.</source>
          <target state="translated">Определение равенства двух объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4185" translate="yes" xml:space="preserve" uid="M:System.Type.op_Equality(System.Type,System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значения параметров <ph id="ph2">&lt;paramref name="left" /&gt;</ph> и <ph id="ph3">&lt;paramref name="right" /&gt;</ph> равны; в противном случае — <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4186" translate="yes" xml:space="preserve" uid="M:System.Type.op_Inequality(System.Type,System.Type)">
          <source>The first object to compare.</source>
          <target state="translated">Первый из сравниваемых объектов.</target>       </trans-unit>
        <trans-unit id="4187" translate="yes" xml:space="preserve" uid="M:System.Type.op_Inequality(System.Type,System.Type)">
          <source>The second object to compare.</source>
          <target state="translated">Второй из сравниваемых объектов.</target>       </trans-unit>
        <trans-unit id="4188" translate="yes" xml:space="preserve" uid="M:System.Type.op_Inequality(System.Type,System.Type)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects are not equal.</source>
          <target state="translated">Определяет неравенство двух объектов <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4189" translate="yes" xml:space="preserve" uid="M:System.Type.op_Inequality(System.Type,System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значения <ph id="ph2">&lt;paramref name="left" /&gt;</ph> и <ph id="ph3">&lt;paramref name="right" /&gt;</ph> не равны; в противном случае — <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4190" translate="yes" xml:space="preserve" uid="P:System.Type.ReflectedType">
          <source>Gets the class object that was used to obtain this member.</source>
          <target state="translated">Возвращает объект класса, который использовался для получения этого члена.</target>       </trans-unit>
        <trans-unit id="4191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ReflectedType">
          <source>The <ph id="ph1">&lt;see langword="Type" /&gt;</ph> object through which this <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object was obtained.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see langword="Type" /&gt;</ph>, с помощью которого был получен данный объект <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ReflectedType">
          <source>For <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects, the value of this property is always the same as the value of the <ph id="ph2">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property.</source>
          <target state="translated">Для <ph id="ph1">&lt;xref:System.Type&gt;</ph> объекты, значение этого свойства всегда является таким же, как значение <ph id="ph2">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="4193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ReflectedType">
          <source>This example displays the reflected type of a nested class.</source>
          <target state="translated">Этот пример отображает отраженный тип вложенного класса.</target>       </trans-unit>
        <trans-unit id="4194" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly-qualified name of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to get.</source>
          <target state="translated">Имя искомого типа <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> с указанием сборки.</target>       </trans-unit>
        <trans-unit id="4195" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw a <ph id="ph2">&lt;see cref="T:System.TypeLoadException" /&gt;</ph> if the type cannot be found; <ph id="ph3">&lt;see langword="false" /&gt;</ph> to return <ph id="ph4">&lt;see langword="null" /&gt;</ph> if the type cannot be found.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, чтобы в случае невозможности найти тип создавалось исключение <ph id="ph2">&lt;see cref="T:System.TypeLoadException" /&gt;</ph>; значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>, чтобы при невозможности найти тип возвращалось значение <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4196" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>Specifying <ph id="ph1">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated">Кроме того, при указании значения <ph id="ph1">&lt;see langword="false" /&gt;</ph> подавляются некоторые другие условия возникновения исключений, но не все из них.</target>       </trans-unit>
        <trans-unit id="4197" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">См. раздел "Исключения".</target>       </trans-unit>
        <trans-unit id="4198" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a case-insensitive search for <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a case-sensitive search for <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, чтобы не учитывать регистр при поиске <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>; значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>, чтобы учитывать регистр при поиске <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="4199" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found.</source>
          <target state="translated">Возвращает объект <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> с заданным именем, позволяющий определить, будет ли учитываться регистр при поиске, и будет ли создаваться исключение в случае невозможности найти тип.</target>       </trans-unit>
        <trans-unit id="4200" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The type is loaded for reflection only, not for execution.</source>
          <target state="translated">Тип загружается не для выполнения, а только для отражения.</target>       </trans-unit>
        <trans-unit id="4201" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The type with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Тип с указанным именем, если он существует; в противном случае — значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4202" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">Если тип не найден, параметр <ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> определяет дальнейшее действие — возврат значения <ph id="ph2">&lt;see langword="null" /&gt;</ph> или создание исключения.</target>       </trans-unit>
        <trans-unit id="4203" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph>.</source>
          <target state="translated">В некоторых случаях исключение создается независимо от значения параметра <ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4204" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">См. раздел "Исключения".</target>       </trans-unit>
        <trans-unit id="4205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>If the assembly containing the type is not already loaded into the reflection-only context, using the <ph id="ph1">&lt;xref:System.Type.ReflectionOnlyGetType%2A&gt;</ph> method is equivalent to first loading the assembly for reflection only, using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> method, and then loading the type by calling the assembly's <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Если сборка, содержащая тип еще не загружена в контекст только для отражения, с помощью <ph id="ph1">&lt;xref:System.Type.ReflectionOnlyGetType%2A&gt;</ph> метод является эквивалентно первой загрузки сборки, а только для отражения с помощью <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> метода и затем загружать тип путем вызова сборки <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="4206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>For information about assembly-qualified names, see the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Сведения об именах с указанием сборки см. в разделе <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="4207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>For additional details on specifying type names, see the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload.</source>
          <target state="translated">Дополнительные сведения об указании имен типа <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> перегрузки метода.</target>       </trans-unit>
        <trans-unit id="4208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.</source>
          <target state="translated">Если сборка уже загружена для выполнения, другая копия загружается в контекст только для отражения.</target>       </trans-unit>
        <trans-unit id="4209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwIfNotFound`</ph> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</source>
          <target state="translated"><ph id="ph1">`throwIfNotFound`</ph> Параметр указывает, что произойдет, если тип не найден, а также подавляются некоторые другие условия возникновения исключений, как описано в раздел "исключения".</target>       </trans-unit>
        <trans-unit id="4210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>Some exceptions are thrown regardless of the value of <ph id="ph1">`throwIfNotFound`</ph>.</source>
          <target state="translated">Некоторые исключения выдаются независимо от значения <ph id="ph1">`throwIfNotFound`</ph>.</target>       </trans-unit>
        <trans-unit id="4211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, if the assembly is not valid, a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph> is thrown even if <ph id="ph2">`throwIfNotFound`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Например, если сборка не является допустимым <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph> возникает, даже если <ph id="ph2">`throwIfNotFound`</ph> — <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="4212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>For more information about using the reflection-only context, see <bpt id="p1">[</bpt>How to: Load Assemblies into the Reflection-Only Context<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об использовании в контексте только для отражения см. в разделе <bpt id="p1">[</bpt>как: загрузка сборки контекста, предназначенного<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)</ept>.</target>       </trans-unit>
        <trans-unit id="4213" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4214" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Инициализатор класса вызывается и создает исключение.</target>       </trans-unit>
        <trans-unit id="4215" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и тип не найден.</target>       </trans-unit>
        <trans-unit id="4216" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="4217" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> содержит недопустимые знаки, например внедренные табуляции.</target>       </trans-unit>
        <trans-unit id="4218" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="4219" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> является пустой строкой.</target>       </trans-unit>
        <trans-unit id="4220" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="4221" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> представляет тип массива с недопустимым размером.</target>       </trans-unit>
        <trans-unit id="4222" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="4223" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет массив объектов <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4224" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> does not include the assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> не включает имя сборки.</target>       </trans-unit>
        <trans-unit id="4225" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="4226" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax; for example, "MyType[,*,]".</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> содержит недопустимый синтаксис (например, "MyType[,*,]").</target>       </trans-unit>
        <trans-unit id="4227" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="4228" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет универсальный тип, имеющий тип указателя, тип <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> или <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> в качестве одного из его аргументов типа.</target>       </trans-unit>
        <trans-unit id="4229" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="4230" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет универсальный тип, который содержит неправильное количество аргументов типа.</target>       </trans-unit>
        <trans-unit id="4231" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="4232" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</target>       </trans-unit>
        <trans-unit id="4233" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>, и не удалось найти сборку либо одну из ее зависимостей.</target>       </trans-unit>
        <trans-unit id="4234" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">Сборка или одна из ее зависимостей найдена, но не может быть загружена.</target>       </trans-unit>
        <trans-unit id="4235" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">Сборка или одна из ее зависимостей является недопустимой.</target>       </trans-unit>
        <trans-unit id="4236" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="4237" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated">Сборка была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</target>       </trans-unit>
        <trans-unit id="4238" translate="yes" xml:space="preserve" uid="P:System.Type.StructLayoutAttribute">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> that describes the layout of the current type.</source>
          <target state="translated">Возвращает атрибут <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph>, описывающий структуру текущего типа.</target>       </trans-unit>
        <trans-unit id="4239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> that describes the gross layout features of the current type.</source>
          <target state="translated">Возвращает атрибут <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph>, описывающий общие особенности структуры текущего типа.</target>       </trans-unit>
        <trans-unit id="4240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> is not returned by the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> не возвращается <ph id="ph2">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="4241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source>Instead, use this property to get it.</source>
          <target state="translated">Используйте это свойство для получения его.</target>       </trans-unit>
        <trans-unit id="4242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source>The following code example first defines a class, a structure, and a structure with special layout attributes (the structures are nested within the class).</source>
          <target state="translated">В следующем примере сначала определяется класс, структура и структура с особыми атрибутами размещения (структуры вложены в пределах класса).</target>       </trans-unit>
        <trans-unit id="4243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source>The example then uses the <ph id="ph1">&lt;xref:System.Type.StructLayoutAttribute%2A&gt;</ph> property to obtain a <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> for each type, and displays the properties of the attributes.</source>
          <target state="translated">Затем в примере используется <ph id="ph1">&lt;xref:System.Type.StructLayoutAttribute%2A&gt;</ph> , чтобы получить <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> для каждого типа и отображает свойства атрибутов.</target>       </trans-unit>
        <trans-unit id="4244" translate="yes" xml:space="preserve" uid="P:System.Type.StructLayoutAttribute">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">Вызванный метод не поддерживается в базовом классе.</target>       </trans-unit>
        <trans-unit id="4245" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Зарезервировано для будущего использования.</target>       </trans-unit>
        <trans-unit id="4246" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Должно быть равным IID_NULL.</target>       </trans-unit>
        <trans-unit id="4247" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Переданный массив имен, которые необходимо сопоставить.</target>       </trans-unit>
        <trans-unit id="4248" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Количество сопоставляемых имен.</target>       </trans-unit>
        <trans-unit id="4249" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Контекст языкового стандарта для интерпретации имен.</target>       </trans-unit>
        <trans-unit id="4250" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Массив, зарезервированный вызывающим объектом, куда помещаются идентификаторы, соответствующие именам.</target>       </trans-unit>
        <trans-unit id="4251" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Сопоставляет набор имен соответствующему набору идентификаторов диспетчеризации.</target>       </trans-unit>
        <trans-unit id="4252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="4253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="4254" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
        <trans-unit id="4255" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Возвращаемые сведения о типе.</target>       </trans-unit>
        <trans-unit id="4256" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Идентификатор языкового стандарта для сведений о типе.</target>       </trans-unit>
        <trans-unit id="4257" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>A pointer to the requested type information object.</source>
          <target state="translated">Указатель на объект с запрошенными сведениями о типе.</target>       </trans-unit>
        <trans-unit id="4258" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Возвращает сведения о типе объекта, которые затем могут использоваться для получения сведений о типе интерфейса.</target>       </trans-unit>
        <trans-unit id="4259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="4260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="4261" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
        <trans-unit id="4262" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Указатель, по которому записывается число предоставляемых объектом интерфейсов, предназначенных для получения сведений о типе.</target>       </trans-unit>
        <trans-unit id="4263" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Возвращает количество предоставляемых объектом интерфейсов для доступа к сведениям о типе (0 или 1).</target>       </trans-unit>
        <trans-unit id="4264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="4265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="4266" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
        <trans-unit id="4267" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Идентифицирует член.</target>       </trans-unit>
        <trans-unit id="4268" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Зарезервировано для будущего использования.</target>       </trans-unit>
        <trans-unit id="4269" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Должно быть равным IID_NULL.</target>       </trans-unit>
        <trans-unit id="4270" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Контекст языкового стандарта, в котором следует интерпретировать аргументы.</target>       </trans-unit>
        <trans-unit id="4271" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Флаги, описывающие контекст вызова.</target>       </trans-unit>
        <trans-unit id="4272" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Указатель на структуру, содержащую массив аргументов, массив DISPID для именованных аргументов, а также счетчики количества элементов в массивах.</target>       </trans-unit>
        <trans-unit id="4273" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Указатель, по которому будет сохранен результат.</target>       </trans-unit>
        <trans-unit id="4274" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Указатель на структуру, содержащую сведения об исключении.</target>       </trans-unit>
        <trans-unit id="4275" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Индекс первого аргумента, вызвавшего ошибку.</target>       </trans-unit>
        <trans-unit id="4276" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Предоставляет доступ к открытым свойствам и методам объекта.</target>       </trans-unit>
        <trans-unit id="4277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода.</target>       </trans-unit>
        <trans-unit id="4278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">`IDispatch::Invoke`</ph>, см. в библиотеке MSDN.</target>       </trans-unit>
        <trans-unit id="4279" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Доступ с поздним связыванием с помощью COM-интерфейса <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> не поддерживается.</target>       </trans-unit>
        <trans-unit id="4280" translate="yes" xml:space="preserve" uid="M:System.Type.ToString">
          <source>Returns a <ph id="ph1">&lt;see langword="String" /&gt;</ph> representing the name of the current <ph id="ph2">&lt;see langword="Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает объект типа <ph id="ph1">&lt;see langword="String" /&gt;</ph>, представляющий имя текущего объекта <ph id="ph2">&lt;see langword="Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4281" translate="yes" xml:space="preserve" uid="M:System.Type.ToString">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> representing the name of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Объект типа <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, представляющий имя текущего объекта <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>This method returns the fully qualified common language runtime namespace and name for all primitive types.</source>
          <target state="translated">Этот метод возвращает полное имен среды CLR и имя для всех типов-примитивов.</target>       </trans-unit>
        <trans-unit id="4283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>For example, the C# instruction, <ph id="ph1">`(long)0.Type().ToString()`</ph> returns "System.Int64" instead of merely "Int64".</source>
          <target state="translated">Например, C# инструкция <ph id="ph1">`(long)0.Type().ToString()`</ph> возвращает «System.Int64», а не просто «Int64».</target>       </trans-unit>
        <trans-unit id="4284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет универсальный тип, тип и его аргументов типа квалифицируются пространством имен и вложенных типов, но не в сборке.</target>       </trans-unit>
        <trans-unit id="4285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или универсального метода, этот метод возвращает неполное имя параметра типа.</target>       </trans-unit>
        <trans-unit id="4286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>This following example demonstrates a use of the <ph id="ph1">&lt;xref:System.Type.Namespace%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> properties and the <ph id="ph3">`ToString`</ph> method of <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">В следующем примере показано использование <ph id="ph1">&lt;xref:System.Type.Namespace%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> свойства и <ph id="ph3">`ToString`</ph> метод <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>The following example compares the strings returned by the <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> method and the <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> properties.</source>
          <target state="translated">В следующем примере сравниваются строки, возвращаемые <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> метод и <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, и <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> свойства.</target>       </trans-unit>
        <trans-unit id="4288" translate="yes" xml:space="preserve" uid="P:System.Type.TypeHandle">
          <source>Gets the handle for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Возвращает дескриптор текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source>The handle for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Дескриптор текущего объекта <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source><ph id="ph1">`TypeHandle`</ph> encapsulates a pointer to an internal data structure that represents the type.</source>
          <target state="translated"><ph id="ph1">`TypeHandle`</ph> Инкапсулирует указатель на внутреннюю структуру данных, представляющий тип.</target>       </trans-unit>
        <trans-unit id="4291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source>This handle is unique during the process lifetime.</source>
          <target state="translated">Этот дескриптор является уникальным во время существования процесса.</target>       </trans-unit>
        <trans-unit id="4292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source>The handle is valid only in the application domain in which it was obtained.</source>
          <target state="translated">Дескриптор действителен только в домене приложения, в котором они были получены.</target>       </trans-unit>
        <trans-unit id="4293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source>The following example returns the handle of the corresponding type and passes the handle to a method that gets the type from the handle and displays it.</source>
          <target state="translated">Следующий пример возвращает дескриптор соответствующего типа и передает дескриптор метода, который возвращает тип из дескриптора и отображает его.</target>       </trans-unit>
        <trans-unit id="4294" translate="yes" xml:space="preserve" uid="P:System.Type.TypeHandle">
          <source>The .NET Compact Framework does not currently support this property.</source>
          <target state="translated">Платформа .NET Compact Framework в настоящее время не поддерживает это свойство.</target>       </trans-unit>
        <trans-unit id="4295" translate="yes" xml:space="preserve" uid="P:System.Type.TypeInitializer">
          <source>Gets the initializer for the type.</source>
          <target state="translated">Возвращает инициализатор типа.</target>       </trans-unit>
        <trans-unit id="4296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeInitializer">
          <source>An object that contains the name of the class constructor for the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Объект, содержащий имя конструктора класса <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeInitializer">
          <source>Class initializers are also available through the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method, or through overloads of the <ph id="ph2">&lt;xref:System.Type.GetMember%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> methods that take <ph id="ph6">&lt;xref:System.Reflection.BindingFlags&gt;</ph> as a parameter.</source>
          <target state="translated">Инициализаторы класса, также доступны через <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> метод, или с помощью перегрузки <ph id="ph2">&lt;xref:System.Type.GetMember%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>, и <ph id="ph5">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> методов, которые принимают <ph id="ph6">&lt;xref:System.Reflection.BindingFlags&gt;</ph> как параметр.</target>       </trans-unit>
        <trans-unit id="4298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeInitializer">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Если текущий <ph id="ph1">&lt;xref:System.Type&gt;</ph> представляет параметр типа в определении универсального типа или метода, это свойство возвращает <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="4299" translate="yes" xml:space="preserve" uid="P:System.Type.UnderlyingSystemType">
          <source>Indicates the type provided by the common language runtime that represents this type.</source>
          <target state="translated">Указывает на тип, предоставляемый средой CLR, представляющей этот тип.</target>       </trans-unit>
        <trans-unit id="4300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.UnderlyingSystemType">
          <source>The underlying system type for the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Базовый системный тип текущего типа <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>