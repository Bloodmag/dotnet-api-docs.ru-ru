<Type Name="Type" FullName="System.Type">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a40925048dd06746d1e1cda2a76aa4ecaae1b916" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30731518" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет объявления типов для классов, интерфейсов, массивов, значений, перечислений параметров, определений универсальных типов и открытых или закрытых сконструированных универсальных типов.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Type` является корневым элементом <xref:System.Reflection> функциональные возможности и является основным способом доступа к метаданным. Использовать члены <xref:System.Type> для получения сведений о объявление типа, об элементах типа (например, конструкторы, методы, поля, свойства и события класса), модуля и сборки, в которой развернут данный класс.  
  
 Разрешения не требуются для кода использовать отражение для получения сведений о типы и члены, независимо от их уровни доступа. Разрешения не требуются для кода использовать отражение для доступа к открытым членам или другим членам, уровни доступа которых сделали бы их видимыми во время обычной компиляции. Тем не менее, использовать отражение для доступа к членам, которые обычно становятся недоступны, например к закрытым или внутренним методам или защищенным полям типа коду не наследует класс, код должен иметь <xref:System.Security.Permissions.ReflectionPermission>. В разделе [рекомендации по безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).  
  
 `Type` Представляет абстрактный базовый класс, который может быть создано несколько реализаций. Система всегда выбирает производного класса `RuntimeType`. В отражении все классы, начинающихся со слова среды выполнения каждого объекта в системе и поддерживают операции сравнения создаются только один раз.  
  
> [!NOTE]
>  В сценариях многопоточность, не блокируют <xref:System.Type> объекты для синхронизации доступа к `static` данных. Другой код, в течение которого у вас нет контроля, также может заблокировать тип класса. Это может привести к взаимоблокировке. Вместо этого следует синхронизировать доступ к статическим данным, заблокировав закрытый `static` объекта.  
  
> [!NOTE]
>  Производный класс может получить доступ к защищенные члены базовых классов вызывающего кода. Кроме того разрешен доступ к членам сборки вызывающего кода. Как правило если доступ разрешен в коде с ранним связыванием, то разрешены и в коде с поздним связыванием.  
  
> [!NOTE]
>  Интерфейсы, расширяющие другие интерфейсы, не наследуют методы, определенные в расширенные интерфейсы.  
  
 Содержание  
  
 [Какие типы представляют тип объекта?](#WhatTypes)   
 [Получение тип объекта](#Retrieve)   
 [Сравнение типов объектов на равенство](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>Какие типы представляют тип объекта?  
 Этот класс является потокобезопасным; несколько потоков могут одновременно считывать из экземпляра данного типа. Экземпляр <xref:System.Type> класс может представлять любой из следующих типов:  
  
-   Классы  
  
-   Типы значений  
  
-   Массивы  
  
-   интерфейсов,  
  
-   Перечисления  
  
-   Делегаты  
  
-   Сконструированных универсальных типов и определений универсальных типов  
  
-   Аргументы типа и типа параметров сконструированных универсальных типов, определений универсальных типов и определений универсальных методов  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>Получение тип объекта  
 <xref:System.Type> Объекта, связанного с определенным типом можно получить следующими способами:  
  
-   Экземпляр <xref:System.Object.GetType%2A?displayProperty=nameWithType> возвращает <xref:System.Type> , представляющий тип экземпляра. Так как все управляемые типы являются производными от <xref:System.Object>, <xref:System.Object.GetType%2A> метод может быть вызван на экземпляре любого типа.  
  
     В следующем примере вызывается <xref:System.Object.GetType%2A?displayProperty=nameWithType> метод, чтобы определить тип каждого объекта в массив объектов среды выполнения.  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   Статический <xref:System.Type.GetType%2A?displayProperty=nameWithType> методы возвращают <xref:System.Type> , представляющий тип, заданный полным именем.  
  
-   <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, И <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> методы возвращают `Type` объекты, представляющие типы, определенные в модуле. Первый метод может быть использован для получения массив <xref:System.Type> объектов для всех открытых и закрытых типов, определенных в модуле. (Можно получить экземпляр `Module` через <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> или <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> метода, либо с помощью <xref:System.Type.Module%2A?displayProperty=nameWithType> свойство.)  
  
-   <xref:System.Reflection.Assembly?displayProperty=nameWithType> Объект содержит несколько методов для извлечения классы, определенные в сборке, в том числе <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, и <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.  
  
-   <xref:System.Type.FindInterfaces%2A> Метод возвращает отфильтрованный список типов интерфейсов, поддерживаемых типом.  
  
-   <xref:System.Type.GetElementType%2A> Возвращает `Type` объект, представляющий элемент.  
  
-   <xref:System.Type.GetInterfaces%2A> И <xref:System.Type.GetInterface%2A> методы возвращают <xref:System.Type> объекты, представляющие типы интерфейсов, поддерживаемых типом.  
  
-   <xref:System.Type.GetTypeArray%2A> Метод возвращает массив <xref:System.Type> объекты, представляющие типы, определенные системой произвольный набор объектов. Объекты, указанные с помощью массива типа <xref:System.Object>.  
  
-   <xref:System.Type.GetTypeFromProgID%2A> И <xref:System.Type.GetTypeFromCLSID%2A> предоставляются методы для COM-взаимодействия. Они возвращают <xref:System.Type> , представляющий тип, заданный параметром `ProgID` или `CLSID`.  
  
-   <xref:System.Type.GetTypeFromHandle%2A> Метод предоставляется для обеспечения взаимодействия. Он возвращает `Type` , представляющий тип, указанный с помощью дескриптора класса.  
  
-   C# `typeof` оператор C++ `typeid` оператор и Visual Basic `GetType` оператор получения `Type` объекта для типа.  
  
-   <xref:System.Type.MakeGenericType%2A> Возвращает <xref:System.Type> объект, представляющий сконструированный универсальный тип, являющийся открытым сконструированным типом, если его <xref:System.Type.ContainsGenericParameters%2A> возвращает `true`, и закрытый сконструированный тип в противном случае. Универсальный тип может быть создан только в том случае, если он закрыт.  
  
-   <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, И <xref:System.Type.MakeByRefType%2A> методы возвращают <xref:System.Type> объектов, которые представляют, соответственно, массив указанного типа, указатель заданного типа и типа ссылочного параметра (`ref` в C# `ByRef`в Visual Basic).  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>Сравнение типов объектов на равенство  
 Объект <xref:System.Type> объект, представляющий тип уникален, то есть два <xref:System.Type> объектные ссылки на тот же объект только в том случае, если они принадлежат к одному типу. Это позволяет сравнивать <xref:System.Type> объекты с помощью равенство ссылок. В следующем примере сравниваются <xref:System.Type> объекты, представляющие количество целочисленных значений, чтобы определить, являются ли они того же типа.  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 В следующем примере показано несколько типичных функций класса <xref:System.Type>. C# `typeof` оператор (`GetType` оператор на языке Visual Basic `typeid` оператор в Visual C++) используется для получения <xref:System.Type> , представляющий <xref:System.String>. Из этого <xref:System.Type> объекта, <xref:System.Type.GetMethod%2A> метод используется для получения <xref:System.Reflection.MethodInfo> представляющий <xref:System.String.Substring%2A> перегрузка, которая принимает начальное расположение и длиной.  
  
 Для идентификации сигнатуры перегрузки, в примере кода создается временный массив, содержащий два <xref:System.Type> объектов представляющий `int` (`Integer` в Visual Basic).  
  
> [!NOTE]
>  Точнее, массив содержит две ссылки на экземпляр <xref:System.Type> , представляющий `int` в текущем домене приложения. Для любого типа имеется только один экземпляр <xref:System.Type> домена приложения.  
  
 В примере кода используется <xref:System.Reflection.MethodInfo> для вызова <xref:System.String.Substring%2A> метод в строке «Hello, World!» и отображает результат.  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
    <block subset="none" type="overrides">
      <para>При наследовании от <see langword="Type" />, необходимо переопределить следующие члены:  
  
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /> ,  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para>
    </block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Type" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор вызывается производными классами во время создания типа объектов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Reflection.Assembly" />, в котором объявлен тип. Для универсальных типов возвращает объект сборки <see cref="T:System.Reflection.Assembly" />, в которой определен универсальный тип.</summary>
        <value>Экземпляр <see cref="T:System.Reflection.Assembly" />, описывающий сборку, которая содержит текущий тип. Для универсальных типов экземпляр описывает сборку, содержащую определение универсального типа, а не сборку, которая создала и использует определенный сконструированный тип.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий <xref:System.Type> объект представляет сконструированный универсальный тип, это свойство возвращает сборку, содержащую определение универсального типа. Например, предположим, создается сборка с именем MyGenerics.dll, содержащую определение универсального типа `MyGenericStack<T>` (`MyGenericStack(Of T)` в Visual Basic `generic<T> ref class MyGenericStack` в C++). При создании экземпляра `MyGenericStack<int>` (`MyGenericStack(Of Integer)` в Visual Basic) в другой сборке, <xref:System.Type.Assembly%2A> свойство для сконструированного типа возвращает <xref:System.Reflection.Assembly> , представляющий MyGenerics.dll.  
  
 Аналогично Если текущий <xref:System.Type> представляет неприсвоенный универсальный параметр `T`, это свойство возвращает сборку, которая содержит универсальный тип, определяющий `T`.  
  
 Если <xref:System.Type.Assembly%2A?displayProperty=nameWithType> свойство недоступно в конкретной реализации .NET, такие как .NET Core или универсальной платформы Windows, используйте <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> свойство вместо него.      
  
 Это свойство доступно только для чтения.  
  
   
  
## Examples  
 Следующий пример отображает имя сборки, связанный с классом и полное имя типа.  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает имя типа с указанием сборки, включающее имя сборки, из которой был загружен объект <see cref="T:System.Type" />.</summary>
        <value>Имя объекта <see cref="T:System.Type" /> с указанием сборки, включающее имя сборки, из которой был загружен объект <see cref="T:System.Type" />, или значение <see langword="null" />, если текущий экземпляр представляет параметр универсального типа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Имя сборки типа состоит из имени типа, включая пространство имен, используя запятую, следуют отображаемое имя сборки. Отображаемое имя сборки, можно получить <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> свойство.  
  
> [!NOTE]
>  В .NET Framework версии 2.0 архитектура процессора добавляется удостоверение сборки и может быть указан как часть строки имени сборки. Например «ProcessorArchitecture = msil». Однако он не включен в строку, возвращаемую <xref:System.Type.AssemblyQualifiedName%2A> свойства для обеспечения совместимости. См. раздел <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
 Все компиляторы, поддерживающие среду порождают простое имя вложенного класса, а отражение создает искаженное имя, если запрос, в соответствии со следующими соглашениями.  
  
|разделитель|Значение|  
|---------------|-------------|  
|Обратная косая черта (\\)|Escape-символ.|  
|Запятая ()|Предшествует имени сборки.|  
|Знак плюс (+)|Перед вложенным классом.|  
|Точка (.)|Определяет идентификаторы пространства имен.|  
|квадратные скобки ([])|После имени типа обозначают массив этого типа.<br /><br /> - или -<br /><br /> Для универсального типа содержащего список аргументов универсального типа.<br /><br /> - или -<br /><br /> В список аргументов типа содержащего типа с указанием сборки.|  
  
 Например имя сборки для класса может выглядеть следующим образом:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 Если пространство имен содержится знак плюс, например TopNamespace.Sub+Namespace, а затем знак плюс (+) будет предшествовать escape-символ (\\), чтобы он не будет интерпретироваться как разделитель вложения. Эта строка будет порождение отражения следующим образом:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 Объект «++» становится «\\+\\+» и»\\«становится»\\\\».  
  
 Это полное имя можно сохранить и впоследствии использовано для загрузки <xref:System.Type>. Чтобы найти и загрузить <xref:System.Type>, используйте <xref:System.Type.GetType%2A> либо с типом имени, либо только имя типа с указанием сборки. <xref:System.Type.GetType%2A> с типом имя только будет искать <xref:System.Type> в сборке вызывающего, а затем в системе сборки. <xref:System.Type.GetType%2A> в сборке будет искать имя типа с указанием <xref:System.Type> в любой сборке.  
  
 Имена типов могут включать конечные символы, определяющие дополнительные сведения о типе, например, является ли тип ссылочным типом, типом указателя или тип массива. Чтобы получить имя типа без этих конечных символов, используйте `t.GetElementType().ToString()`, где `t` тип.  
  
 Пробелы учитываются во всех компонентах имени типа, за исключением имени сборки. В имени сборки пробелы перед разделителем ',' учитываются, но пробелы после разделителя «,» игнорируются.  
  
 Универсальные аргументы универсальных типов сами указываются с именем сборки. Например, в имя типа с указанием сборки для `MyGenericClass<int>` (`MyGenericClass(Of Integer)` в Visual Basic), `int` расширяется, чтобы имя типа с указанием сборки для <xref:System.Int32>.  
  
 Если текущий <xref:System.Type> объект представляет универсальный параметр, это свойство возвращает `null`.  
  
   
  
## Examples  
 Следующий пример отображает имя сборки, связанный с классом и полное имя типа.  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 В следующем примере сравниваются строки, возвращаемые <xref:System.Type.ToString%2A> метод и `Name`, <xref:System.Type.FullName%2A>, и <xref:System.Type.AssemblyQualifiedName%2A> свойства.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает атрибуты, связанные с объектом <see cref="T:System.Type" />.</summary>
        <value>Объект <see cref="T:System.Reflection.TypeAttributes" />, представляющий набор атрибутов типа <see cref="T:System.Type" />, если <see cref="T:System.Type" /> не представляет параметр универсального типа. В противном случае это значение не определено.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые члены <xref:System.Reflection.TypeAttributes> перечисления являются маски, представляющие группы значений. Каждая группа содержит один элемент, чье базовое значение равно нулю. Например, базовое значение <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> члена в <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> группы равен нулю, поскольку <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> члена в <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> группы. Таким образом необходимо использовать маску перед проверкой на эти значения. Иллюстрация приведена в примере.  
  
> [!TIP]
>  В большинстве случаев свойства, такие как <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, и <xref:System.Type.IsSpecialName%2A> проще в использовании, чем атрибуты типа.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство возвращает атрибуты определения универсального типа. Например, атрибуты, возвращаемые для `MyGenericClass<int>` (`MyGenericClass(Of Integer)` в Visual Basic) являются атрибутами `MyGenericClass<T>` (`MyGenericClass(Of T)` в Visual Basic).  
  
 Если текущий <xref:System.Type> представляет параметр универсального типа — то есть если <xref:System.Type.IsGenericParameter%2A> возвращает `true` — <xref:System.Reflection.TypeAttributes> значение, возвращаемое этим свойством не определено.  
  
   
  
## Examples  
 Следующий пример usesthe <xref:System.Type.Attributes%2A> свойство.  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает тип, для которого текущий объект <see cref="T:System.Type" /> является непосредственным наследником.</summary>
        <value>Объект <see cref="T:System.Type" />, прямым наследником которого является текущий объект <see cref="T:System.Type" />, или <see langword="null" />, если текущий объект <see langword="Type" /> представляет класс <see cref="T:System.Object" /> или интерфейс.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовый тип является типом, от которого непосредственно наследуется текущий тип. <xref:System.Object> представляет собой единственный тип, у которого нет базового типа, поэтому `null` возвращается как базовый тип <xref:System.Object>.  
  
 Наследование интерфейсов из нуля или более базовых интерфейсов. Таким образом, это свойство возвращает `null` Если `Type` объект представляет интерфейс. Базовые интерфейсы можно определить с помощью <xref:System.Type.GetInterfaces%2A> или <xref:System.Type.FindInterfaces%2A>.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, базовый тип отражает универсальные аргументы. В качестве примера рассмотрим следующие объявления:  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 Для типа, созданного `C<int>` (`C(Of Integer)` в Visual Basic), <xref:System.Type.BaseType%2A> возвращает `B<int>`.  
  
 Если текущий <xref:System.Type> представляет параметр определения универсального типа, <xref:System.Type.BaseType%2A> возвращает ограничение для класса, то есть параметр типа должен наследовать класс. При наличии без ограничения класса <xref:System.Type.BaseType%2A> возвращает <xref:System.Object?displayProperty=nameWithType>.  
  
 Это свойство доступно только для чтения.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Type.BaseType%2A> свойство.  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 Следующий пример использует рекурсию для списка полная иерархия наследования для каждого класса в сборке. В примере определяется класс с именем `C` , производный от класса с именем `B`, который, в свою очередь, является производным от класса с именем `A`.  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, имеются ли у текущего объекта <see cref="T:System.Type" /> параметры типа, которые не были замещены указанными типами.</summary>
        <value>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> сам является параметром универсального типа или если для его параметров типа не предоставлены определенные типы; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы создать экземпляр типа, должен быть не определения универсального типа или открытые сконструированные типы в аргументах типа самого типа, в любой включающих его универсальных типов или во всех элементах типа. — Другими словами, при рекурсивном, тип должен содержать никаких параметров универсального типа.  
  
 Поскольку типов может быть произвольным и довольно сложным, это сложно. Для удобства и уменьшить вероятность ошибок <xref:System.Type.ContainsGenericParameters%2A> свойство предоставляет стандартный способ различения закрытые сконструированные типы, которые могут быть созданы, и откройте созданных типов, которые нельзя. Если <xref:System.Type.ContainsGenericParameters%2A> возвращает `true`, тип не может быть создан.  
  
 <xref:System.Type.ContainsGenericParameters%2A> Свойство выполняет рекурсивно для параметров типа. Например, он возвращает `true` для массива, элементы которого имеют тип `A<T>` (`A(Of T)` в Visual Basic), даже если массив не является универсальным. Сравните это с поведением <xref:System.Type.IsGenericType%2A> свойство, которое возвращает `false` для массивов.  
  
 Для нескольких примеров классов и таблица, показывающая значения <xref:System.Type.ContainsGenericParameters%2A> свойство, в разделе <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 В следующем примере определяется универсальный класс с двумя параметрами типа и затем определяет второй универсальный класс, производный от первого класса. Базовый класс для производного класса имеет два аргумента типа: первый — <xref:System.Int32> , а второй — параметр типа производного типа. В примере отображаются сведения об этих универсальных классов, включая позициях сообщили <xref:System.Type.GenericParameterPosition%2A> свойство.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает метод <see cref="T:System.Reflection.MethodBase" />, который представляет объявляемый метод, если текущий <see cref="T:System.Type" /> представляет параметр типа универсального метода.</summary>
        <value>Если текущий объект <see cref="T:System.Type" /> представляет параметр типа универсального метода, класс <see cref="T:System.Reflection.MethodBase" />, представляющий объявляемый метод; в противном случае — значение <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объявляемый метод является определением универсального метода. То есть если <xref:System.Type.DeclaringMethod%2A> не возвращает `null`, затем `DeclaringMethod.IsGenericMethodDefinition` возвращает `true`.  
  
 <xref:System.Type.DeclaringType%2A> И <xref:System.Type.DeclaringMethod%2A> свойства идентификации определения универсального типа или определение универсального метода, в котором изначально был определен параметр универсального типа:  
  
-   Если <xref:System.Type.DeclaringMethod%2A> возвращает <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.MethodInfo> представляет определение универсального метода и текущий <xref:System.Type> представляет параметр типа определения универсального метода.  
  
-   Если <xref:System.Type.DeclaringMethod%2A> возвращает `null`, то <xref:System.Type.DeclaringType%2A> свойство всегда возвращает <xref:System.Type> объект, представляющий определение универсального типа и текущий <xref:System.Type> представляет параметр типа этого универсального типа Определение.  
  
-   Получение <xref:System.Type.DeclaringMethod%2A> свойству типа которого <xref:System.Type.IsGenericParameter%2A> свойство `false` вызывает <xref:System.InvalidOperationException>.  
  
 <xref:System.Reflection.MethodBase> , Возвращаемый <xref:System.Type.DeclaringMethod%2A> равно либо <xref:System.Reflection.MethodInfo> в случае универсальному методу, или <xref:System.Reflection.ConstructorInfo> в случае универсальный конструктор.  
  
> [!NOTE]
>  Универсальные конструкторы в платформе .NET Framework версии 2.0 не поддерживаются.  
  
 Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 В следующем примере кода определяет класс, который содержит универсальный метод, присваивается аргумент типа для метода и вызывает итоговый сконструированный универсальный метод. Он также отображаются сведения об определении универсального метода и сконструированный метод. При отображении сведений о параметрах типа определения универсального метода, в `DisplayGenericMethodInfo` метода, в примере кода показано значение <xref:System.Type.DeclaringMethod%2A> свойства для параметра универсального типа метода.  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает тип, объявивший текущий вложенный тип или параметр универсального типа.</summary>
        <value>Объект <see cref="T:System.Type" />, представляющий включающий тип, если текущий тип является вложенным, или определение универсального типа, если текущий тип является параметром универсального типа, или тип, объявивший этот универсальный метод, если текущий тип является параметром типа универсального метода; в противном случае — значение <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство возвращает определение универсального типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа универсального метода, это свойство возвращает тип, который содержит определение универсального метода. Если тип универсален, возвращается определение универсального типа. То есть, следующий код возвращает определение универсального типа <xref:System.Collections.Generic.List%601> универсальный класс, который содержит <xref:System.Collections.Generic.List%601.ConvertAll%2A> универсальный метод:  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода <xref:System.Type.DeclaringType%2A> и <xref:System.Type.DeclaringMethod%2A> свойства идентификации определения универсального типа или определение универсального метода, где параметр универсального типа был определен изначально:  
  
-   Если <xref:System.Type.DeclaringMethod%2A> возвращает <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.MethodInfo> представляет определение универсального метода и текущий <xref:System.Type> представляет параметр типа определения универсального метода.  
  
-   Если <xref:System.Type.DeclaringMethod%2A> возвращает `null`, то <xref:System.Type.DeclaringType%2A> свойство всегда возвращает <xref:System.Type> объект, представляющий определение универсального типа и текущий <xref:System.Type> представляет параметр типа этого универсального типа Определение.  
  
-   Получение <xref:System.Type.DeclaringType%2A> свойству типа которого <xref:System.Type.IsGenericParameter%2A> свойство `false` вызывает <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 Этот пример отображает объявляющий тип метода в производном классе.  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает ссылку на связыватель по умолчанию, который реализует внутренние правила выбора соответствующих членов, вызываемых методом <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</summary>
        <value>Ссылка на связыватель, используемый в системе по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Связыватель по умолчанию, предоставляемый общеязыковой применима во всех но очень специфических ситуаций. Если нужен связыватель, следующим правила, которые отличаются от методов связывателя по умолчанию, определяющие тип, производный от <xref:System.Reflection.Binder> и передайте экземпляр этого типа с помощью `binder` параметр одного из <xref:System.Type.InvokeMember%2A> перегрузки.  
  
 Отражение моделирует правила доступности для системы общих типов. Например если вызывающий объект находится в той же сборке, вызывающий объект не нужны специальные разрешения для внутренних членов. В противном случае вызывающая сторона должна <xref:System.Security.Permissions.ReflectionPermission>. Это при поиске членов, которые защищены, закрытого и т. д.  
  
 Представляет общий принцип, <xref:System.Reflection.Binder.ChangeType%2A> должен выполнять только расширяющие преобразования, которые никогда не потерять данные. Примером расширяющего преобразования является преобразование значение, которое является 32-разрядное целое число со знаком в значение, которое является 64-разрядное целое число со знаком. Этим оно отличается от сужающего преобразования, может произойти потеря данных. Примером сужающего преобразования является преобразование 64-разрядное целое число со знаком в 32-разрядное целое число со знаком.  
  
 В следующей таблице перечислены преобразования, поддерживаемые связыватель по умолчанию.  
  
|Тип источника|Тип целевого объекта|  
|-----------------|-----------------|  
|Любой тип|Базовый тип.|  
|Любой тип|Интерфейс, который его реализует.|  
|Char|Unt16, UInt32, Int32, UInt64, Int64, Single, Double|  
|Byte|Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double|  
|SByte|Int16, Int32, Int64, Single, Double|  
|UInt16|UInt32, Int32, UInt64, Int64, Single, Double|  
|Int16|Int32, Int64, Single, Double|  
|UInt32|UInt64, Int64, Single, Double|  
|Int32|Int64, Single, Double|  
|UInt64|Single, Double|  
|Int64|Single, Double|  
|Single|Double|  
|Не ссылка|По ссылке.|  
  
   
  
## Examples  
 В следующем примере возвращается связыватель по умолчанию из `DefaultBinder` свойство и вызывает член класса MyClass путем передачи `DefaultBinder` значение в качестве параметра <xref:System.Type.InvokeMember%2A>.  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Разделяет имена в пространстве имен класса <see cref="T:System.Type" />. Это поле доступно только для чтения.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет пустой массив типа <see cref="T:System.Type" />. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показан `EmptyTypes` поле, используемое в одном из `GetConstructor` методы для получения конструктора, не принимающего параметры.  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет, совпадает ли базовый системный тип текущего объекта <see cref="T:System.Type" /> с базовым системным типом указанного объекта <see cref="T:System.Object" /> или <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Объект, базовый системный тип которого сравнивается с базовым системным типом текущего типа <see cref="T:System.Type" />. Для успешного сравнения необходимо, чтобы параметр <c>o</c> можно было привести к объекту типа <see cref="T:System.Type" /> или преобразовать в объект такого типа.</param>
        <summary>Определяет, совпадает ли базовый системный тип текущего объекта <see cref="T:System.Type" /> с базовым системным типом указанного объекта <see cref="T:System.Object" />.</summary>
        <returns>
          Значение <see langword="true" />, если базовый системный тип параметра <paramref name="o" /> совпадает с базовым системным типом текущего объекта <see cref="T:System.Type" />; в противном случае — значение <see langword="false" />. Этот метод также возвращает <see langword="false" /> в следующих случаях:  
  
-   Свойство <paramref name="o" /> имеет значение <see langword="null" />.  
  
-   Параметр <paramref name="o" /> невозможно привести к объекту <see cref="T:System.Type" /> или преобразовать в такой объект.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Он приводит `o` для объекта типа <xref:System.Type> и вызывает <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Type.Equals%28System.Object%29> для сравнения различных <xref:System.Type> объекта экземпляров с различными <xref:System.Object> экземпляров.  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 Особенно необходимо отметить в примере приведены две вещи.  
  
-   Сравнение <xref:System.Type> объект, который представляет собой целое число с <xref:System.Reflection.TypeInfo> объект, который представляет возвращаемое целое `true` из-за <xref:System.Reflection.TypeInfo> является производным от <xref:System.Type>.  
  
-   Сравнение <xref:System.Type> , представляющий <xref:System.Collections.Generic.IList%601> объекта (открытый универсальный тип) с `List(Of String)` возвращает объект (закрытого универсального типа) `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">Объект, базовый системный тип которого сравнивается с базовым системным типом текущего типа <see cref="T:System.Type" />.</param>
        <summary>Позволяет определить, совпадает ли базовый системный тип текущего объекта <see cref="T:System.Type" /> с базовым системным типом указанного объекта <see cref="T:System.Type" />.</summary>
        <returns>
          Значение <see langword="true" />, если базовый системный тип параметра <paramref name="o" /> совпадает с базовым системным типом текущего объекта <see cref="T:System.Type" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере используется `Equals` для сравнения двух типов.  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Предоставляет фильтр членов, используемый для атрибутов. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это поле содержит ссылку на делегат, используемый <xref:System.Type.FindMembers%2A> метод. Метод, инкапсулированный этим делегатом принимает два параметра: первый — <xref:System.Reflection.MemberInfo> объекта, а второй — `Object`. Этот метод определяет, является ли `MemberInfo` соответствует критериям, заданным в объект `Object`. `Object` Может быть присвоено значение любого из полей в классах <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, или <xref:System.Reflection.MethodImplAttributes>.  
  
 Например `Object` может быть присвоено значение поля из `FieldAttributes` такие как Public. В этом случае, когда `FilterAttribute` вызове делегата, он вернет `true` только в том случае, если метод, представленный `MemberInfo` объекта помечено атрибутом открытого поля в метаданных.  
  
   
  
## Examples  
 В следующем примере извлекается `FilterAttribute` делегата, он передается в качестве параметра <xref:System.Type.FindMembers%2A> метода и отображает заданные элементы и их атрибуты.  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет фильтр членов с учетом регистра, применяемый к именам. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это поле содержит ссылку на делегат, используемый <xref:System.Type.FindMembers%2A> метод. Метод, инкапсулированный этим делегатом принимает два параметра: первый — <xref:System.Reflection.MemberInfo> объекта, а второй — `Object`. Этот метод определяет, является ли `MemberInfo` соответствует критериям, заданным в объект `Object`. `Object` Присваивается строковое значение, которое может содержать символ «*» подстановочный знак. Поддерживается только конец строки использование подстановочных знаков.  
  
 Например `Object` может быть присвоено значение «Byte *». В этом случае, когда `FilterName` вызове делегата, он вернет `true` только в том случае, если метод, представленный `MemberInfo` объект имеет имя, которое начинается с «Байт».  
  
   
  
## Examples  
 В следующем примере возвращаются методы, связанные с определяемой пользователем `Application` типа.  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет фильтр членов без учета регистра, применяемый к именам. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это поле содержит ссылку на делегат, используемый <xref:System.Type.FindMembers%2A> метод. Метод, инкапсулированный этим делегатом принимает два параметра: первый — <xref:System.Reflection.MemberInfo> объекта, а второй — `Object`. Этот метод определяет, является ли `MemberInfo` соответствует критериям, заданным в объект `Object`. `Object` Присваивается строковое значение, которое может содержать символ «*» подстановочный знак. Поддерживается только конец строки использование подстановочных знаков.  
  
 Например `Object` может быть присвоено значение «ByTe *». В этом случае, когда `FilterName` делегат, вызываемый, возвратит значение true, только если метод, представленный `MemberInfo` объект имеет имя, которое начинается с «byte», без учета регистра.  
  
   
  
## Examples  
 В следующем примере извлекается `MemberFilter` делегата, он передается в качестве параметра <xref:System.Type.FindMembers%2A> метода и отображает методы и их атрибуты `String` класс, начинающихся с буквы «c», не учитывается регистр.  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">Делегат, сравнивающий интерфейсы с параметром <c>filterCriteria</c>.</param>
        <param name="filterCriteria">Критерий поиска, определяющий, должен ли тот или иной интерфейс включаться в возвращаемый массив.</param>
        <summary>Возвращает массив объектов <see cref="T:System.Type" />, представляющий отфильтрованный список интерфейсов, реализованных или наследуемых текущим объектом <see cref="T:System.Type" />.</summary>
        <returns>Массив объектов <see cref="T:System.Type" />, представляющий отфильтрованный список интерфейсов, которые реализует или наследует текущий объект <see cref="T:System.Type" />, или пустой массив типа <see cref="T:System.Type" />, если после применения фильтра для текущего объекта <see cref="T:System.Type" /> не удалось найти соответствующие интерфейсы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен в производном классе.  
  
 <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> И <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> предоставленных делегатов <xref:System.Reflection.Module?displayProperty=nameWithType> класс может также использоваться, вместо <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> делегата.  
  
 Все интерфейсы, реализованные этим классом, считаются во время поиска, где они были объявлены в базовом классе или в самом классе.  
  
 Этот метод выполняет поиск иерархии базового класса, возвращая сопоставления интерфейсами каждый класс реализует, а также все сопоставления каждый из этих интерфейсов реализует интерфейсы (то есть возвращается транзитивное замыкание сопоставления интерфейсов). Каждый интерфейс возвращается.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода <xref:System.Type.FindInterfaces%2A> поиск всех интерфейсов, объявленных в ограничения, накладываемые на параметр типа и все интерфейсы наследуется через интерфейсы объявлено в соответствии с ограничениями. Если текущий <xref:System.Type> представляет аргумент типа универсального типа, <xref:System.Type.FindInterfaces%2A> ищет все интерфейсы, реализованные этим типом ли они соответствуют ограничениям.  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A> может возвращать универсальных интерфейсов, даже для типов, которые не являются универсальными. Например, может реализовать неуниверсальный тип `IEnumerable<int>` (`IEnumerable(Of Integer)` в Visual Basic).  
  
   
  
## Examples  
 В следующем примере вычисляется указанный интерфейс реализован или унаследованные указанным типом, а затем отображает имена интерфейсов.  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="filter" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Статический инициализатор вызывается и создает исключение.</exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">Объект, указывающий тип члена, который нужно найти.</param>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Нуль, чтобы было возвращено значение <see langword="null" />.</param>
        <param name="filter">Делегат, выполняющий сравнение и возвращающий <see langword="true" />, если проверяемый член соответствует условиям, заданным в параметре <c>filterCriteria</c>, и <see langword="false" /> в противном случае. Можно использовать делегаты <see langword="FilterAttribute" />, <see langword="FilterName" /> и <see langword="FilterNameIgnoreCase" />, предоставляемые этим классом. Первый делегат в качестве условий поиска использует поля классов <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> и <see langword="MethodImplAttributes" />, а два других делегата — объекты <see langword="String" />.</param>
        <param name="filterCriteria">Условие поиска, определяющее, будет ли член включен в возвращаемый массив объектов <see langword="MemberInfo" />.  
  
 Поля классов <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> и <see langword="MethodImplAttributes" /> могут использоваться вместе с делегатом <see langword="FilterAttribute" />, предоставляемым этим классом.</param>
        <summary>Возвращает отфильтрованный массив объектов <see cref="T:System.Reflection.MemberInfo" />, тип которого совпадает с указанным типом члена.</summary>
        <returns>Отфильтрованный массив объектов <see cref="T:System.Reflection.MemberInfo" />, имеющих тип указанного члена.  
  
 - или -  
  
 Пустой массив объектов типа <see cref="T:System.Reflection.MemberInfo" />, если у текущего типа <see cref="T:System.Type" /> нет членов типа <paramref name="memberType" />, удовлетворяющих условиям фильтра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен в производном классе.  
  
 Элементы включают свойства, методы, поля, события и т. д.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения члены, которые нужно включить в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` для получения возврата.  
  
-   Укажите `BindingFlags.Instance` для включения при поиске членов экземпляра.  
  
-   Укажите `BindingFlags.Static` для включения в поиск статические члены.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых членов.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск закрытым членам (то есть частных, внутренних и защищенные члены).  
  
 Следующие <xref:System.Reflection.BindingFlags> модификатор флаги можно использовать для изменения условий поиска:  
  
-   `BindingFlags.DeclaredOnly` для поиска только члены, объявленные в <xref:System.Type>, не унаследованные члены группы.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Допустимые значения для <xref:System.Type.MemberType%2A> определены в <xref:System.Reflection.MemberInfo>. Если такие члены не найдены, возвращается пустой массив.  
  
 Чтобы получить инициализатора класса (CCTOR), с помощью этого метода, необходимо указать <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic). Можно также получить с помощью инициализатора класса <xref:System.Type.TypeInitializer%2A> свойство.  
  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа или универсального метода <xref:System.Type.FindMembers%2A> обрабатывает все члены, объявленные ограничения класса и ограничений интерфейса параметра типа.  
  
   
  
## Examples  
 В следующем примере осуществляется поиск всех членов класса, соответствующих указанным условиям поиска, а затем отображает сопоставленные элементы.  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="filter" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает полное имя типа, включая пространство имен, но не сборку.</summary>
        <value>Полное имя типа, включая пространство имен, но не сборку; или значение <see langword="null" />, если текущий экземпляр представляет параметр универсального типа, тип массива, тип указателя, тип <see langword="byref" /> на основе параметра типа либо универсальный тип, который, хотя и не является определением универсального типа, содержит неразрешенные параметры типа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Например, полное имя <xref:System.String> тип — `System.String`. Сравните это с имя сборки, возвращаемое функцией <xref:System.Type.AssemblyQualifiedName%2A> свойство, которое состоит из полного имени и полного имени сборки.  
  
 Если текущий тип представляет закрытого универсального типа, аргументы типа в строке, возвращаемый методом <xref:System.Type.FullName%2A> свойства определяются их полное имя сборки, несмотря на то, что строковое представление универсального типа не квалифицируется его full имя сборки. В следующем примере показано различие в свойстве полное имя для типа, представляющий определение универсального типа и один из них представляет закрытого универсального типа.  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 Это свойство возвращает `null` если:  
  
-   Текущий <xref:System.Type> представляет параметр типа универсального типа.  
  
     В следующем примере извлекается параметру типа <xref:System.Nullable%601> тип и пытается отобразить его <xref:System.Type.FullName%2A> свойство.  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   Текущий <xref:System.Type> объект представляет тип массива, тип указателя или `byref` тип, основанный на параметр универсального типа.  
  
     В следующем примере определяется универсальный тип, `Generictype1<T>`, три метода: `Display(T[])`, который передается в массив типа T; `HandleT(T)`, который передается объект; и `ChangeValue(ref T)`, передаваемый по ссылке объект. C# и Visual Basic не допускает нам определить как указатель в T `HandleT` метода нужно вызвать <xref:System.Type.MakePointerType%2A> метод <xref:System.Type> , представляющий тип параметра метода для создания указателя на универсальный тип. Выходные данные примера показано, что во всех трех случаях <xref:System.Type.FullName%2A> свойство `null`.  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   Текущий тип содержит параметры универсального типа, которые не были заменены определенных типов (т. е <xref:System.Type.ContainsGenericParameters%2A> возвращает `true`), но тип не является определением универсального типа (т. е <xref:System.Type.IsGenericTypeDefinition%2A> возвращает свойство `false`  
  
     В следующем примере `Derived<T>` наследует от `Base<T>`. <xref:System.Type.BaseType%2A> Свойство получает <xref:System.Type> , представляющий базовый тип `Derived<T>`и его <xref:System.Type.FullName%2A> возвращает `null`.  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     Для получения <xref:System.Type.FullName%2A> , не `null`, можно использовать <xref:System.Type.GetGenericTypeDefinition%2A> метод для получения определения универсального типа, как показано в примере.  
  
 Это свойство доступно только для чтения.  
  
   
  
## Examples  
 Следующий пример отображает полное имя указанного типа.  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 В следующем примере сравниваются строки, возвращаемые <xref:System.Type.ToString%2A> метод и `Name`, <xref:System.Type.FullName%2A>, и <xref:System.Type.AssemblyQualifiedName%2A> свойства.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает сочетание флагов <see cref="T:System.Reflection.GenericParameterAttributes" />, описывающих ковариацию и особые ограничения текущего параметра универсального типа.</summary>
        <value>Побитовое сочетание значений <see cref="T:System.Reflection.GenericParameterAttributes" />, которое описывает ковариацию и особые ограничения текущего параметра универсального типа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этого свойства содержит флаги, описывающие, является ли текущий параметр универсального типа является ковариантным и флаги, описывающие особые ограничения. Используйте <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> выберите флаги ковариации и использовать <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> значения для выбора флагов ограничений.  
  
 Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 В следующем примере кода определяется универсальный тип `Test` с двумя параметрами типов, которые имеют различные ограничения. При выполнении программы ограничения проверяются с помощью <xref:System.Type.GenericParameterAttributes%2A> свойство и <xref:System.Type.GetGenericParameterConstraints%2A> метод.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Текущий объект <see cref="T:System.Type" /> не является параметром универсального типа. То есть свойство <see cref="P:System.Type.IsGenericParameter" /> возвращает значение <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Вызванный метод не поддерживается в базовом классе.</exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает позицию параметра типа в списке параметров универсального типа или метода, который объявил параметр, если объект <see cref="T:System.Type" /> представляет параметр универсального типа или метода.</summary>
        <value>Позиция параметра типа в списке параметров типа универсального типа или метода, которые задали этот параметр. Нумерация позиций начинается с 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GenericParameterPosition%2A> Свойство возвращает позицию параметра типа в списке параметров определения универсального типа или определение универсального метода где параметр типа был определен изначально. <xref:System.Type.DeclaringType%2A> И <xref:System.Type.DeclaringMethod%2A> свойства указывают на определении универсального типа или метода:  
  
-   Если <xref:System.Type.DeclaringMethod%2A> возвращает <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.MethodInfo> представляет определение универсального метода и текущий <xref:System.Type> представляет параметр типа определения универсального метода.  
  
-   Если <xref:System.Type.DeclaringMethod%2A> возвращает `null`, то <xref:System.Type.DeclaringType%2A> свойство всегда возвращает <xref:System.Type> объект, представляющий определение универсального типа и текущий <xref:System.Type> представляет параметр типа этого универсального типа Определение.  
  
 Чтобы обеспечить правильный контекст для значения <xref:System.Type.GenericParameterPosition%2A> свойства, это необходимо для определения универсального типа или метода, параметр типа относится к. Например, рассмотрим возвращаемое значение метода `GetSomething` в следующем коде:  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 Тип, возвращаемый `GetSomething` зависит от аргументов типа, предоставленный для класса `A` и `GetSomething` сам. Вы можете получить <xref:System.Reflection.MethodInfo> для `GetSomething`, и в, вы можете получить тип возвращаемого значения. При проверке параметров типа, возвращаемого типа <xref:System.Type.GenericParameterPosition%2A> возвращает 0 для обоих. Положение `V` равно 0, поскольку `V` является первым параметром типа в списке параметров типа для класса `A`. Положение `X` равно 0, поскольку `X` является первым параметром типа в списке параметров типа для `GetSomething`.  
  
> [!NOTE]
>  Вызов <xref:System.Type.GenericParameterPosition%2A> свойство вызывает исключение, если текущий <xref:System.Type> не представляет параметр типа. При проверке аргументами типа в открытом сконструированном типе использовать <xref:System.Type.IsGenericParameter%2A> свойства, о которой являются параметрами типа и которые являются типами. <xref:System.Type.IsGenericParameter%2A> Возвращает `true` для параметра типа; затем можно использовать <xref:System.Type.GenericParameterPosition%2A> метод для получения его положение и использования <xref:System.Type.DeclaringMethod%2A> и <xref:System.Type.DeclaringType%2A> свойства определения универсального метода, либо тип, определяющий его определения .  
  
   
  
## Examples  
 В следующем примере определяется универсальный класс с двумя параметрами типа и определяет второй универсальный класс, производный от первого класса. Базовый класс для производного класса имеет два аргумента типа: первый — <xref:System.Int32>, и второй является параметром типа производного типа. В примере отображаются сведения об этих универсальных классов, включая позициях сообщили <xref:System.Type.GenericParameterPosition%2A> свойство.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Текущий тип не представляет параметр типа. То есть <see cref="P:System.Type.IsGenericParameter" /> возвращает <see langword="false" />.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает массив аргументов универсального типа для этого типа.</summary>
        <value>Массив аргументов универсального типа для этого типа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает только аргументы универсального типа; то есть типы, которые были указаны для параметров универсального типа для текущего типа. Если текущий тип является определением универсального типа, это свойство возвращает пустой массив.  
  
> [!NOTE]
>  При использовании универсального типа другого универсального типа или универсального метода, некоторые из его аргументов универсального типа могут быть параметров универсального типа для включающего метода или типа.  
  
 Для получения параметров универсального типа для типа, представляющий определение универсального типа, используйте <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> свойство. Для получения <xref:System.Reflection.TypeInfo> для текущего <xref:System.Type> , используйте <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> метода расширения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает размерность массива.</summary>
        <returns>Целое число, указывающее на количество измерений текущего типа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример отображает число измерений в массиве.  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Функциональность этого метода не поддерживается в базовом классе и должна быть реализована в производном классе.</exception>
        <exception cref="T:System.ArgumentException">Текущий тип не является массивом.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе реализует свойство <see cref="P:System.Type.Attributes" /> и возвращает битовую маску, позволяющую определить атрибуты, связанные с объектом <see cref="T:System.Type" />.</summary>
        <returns>Объект <see cref="T:System.Reflection.TypeAttributes" />, представляющий набор атрибутов объекта <see cref="T:System.Type" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает определенный конструктор текущего объекта <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющих число, порядок и тип параметров нужного конструктора.  
  
 - или -  
  
 Пустой массив объектов <see cref="T:System.Type" /> для получения конструктора, не имеющего параметров. Подобный пустой массив предоставляется полем <see langword="static" /> с описателем <see cref="F:System.Type.EmptyTypes" />.</param>
        <summary>Выполняет поиск открытого конструктора экземпляра, параметры которого соответствуют типам, содержащимся в указанном массиве.</summary>
        <returns>Объект, представляющий открытый конструктор экземпляра, параметры которого соответствуют типам, указанным в массиве типов параметров, если такой конструктор найден; в противном случае — <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка метода выполняет поиск открытых конструкторов экземпляра и не может использоваться для получения инициализатора класса (.cctor). Чтобы получить инициализатор класса, используйте перегрузку, которая использует <xref:System.Reflection.BindingFlags>и укажите <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic). Можно также получить с помощью инициализатора класса <xref:System.Type.TypeInitializer%2A> свойство.  
  
 Если запрашиваемый конструктор не является открытым, этот метод возвращает `null`.  
  
> [!NOTE]
>  Необходимо указывать все параметры при поиске конструкторов и методов. Параметры можно опустить только в том случае, при вызове метода.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.ConstructorInfo> с параметрами типа, заменены соответствующими аргументами типа. Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод всегда возвращает `null`.  
  
   
  
## Examples  
 В следующем примере извлекается тип `MyClass`, возвращает <xref:System.Reflection.ConstructorInfo> объекта и отображается подпись конструктора.  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="types" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Массив <paramref name="types" /> является многомерным.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Нуль, чтобы было возвращено значение <see langword="null" />.</param>
        <param name="binder">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.  
  
 - или -  
  
 Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров, извлекаемых конструктором.  
  
 - или -  
  
 Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить конструктор, который не имеет параметров.  
  
 - или -  
  
 <see cref="F:System.Type.EmptyTypes" />.</param>
        <param name="modifiers">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве типов параметра. Связыватель по умолчанию не обрабатывает этот параметр.</param>
        <summary>Выполняет поиск конструктора, параметры которого соответствуют указанным типам аргументов и модификаторам, используя заданные ограничения привязки.</summary>
        <returns>Если поиск выполнен удачно, возвращается объект <see cref="T:System.Reflection.ConstructorInfo" />, представляющий конструктор, который соответствует указанным требованиям; в противном случае возвращается значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если точное соответствие не существует, `binder` попытается преобразовать типы параметров, указанные в `types` массива, чтобы найти совпадение. Если `binder` не удалось найти подходящий конструктор, затем `null` возвращается.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения конструкторов, включаемых в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` для получения возврата.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых конструкторов.  
  
-   Укажите `BindingFlags.NonPublic` необходимо включить в поиск закрытые конструкторы (то есть закрытые, внутренние и защищенные).  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Чтобы получить инициализатора класса (CCTOR), с помощью этой перегрузки метода, необходимо указать <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic). Можно также получить с помощью инициализатора класса <xref:System.Type.TypeInitializer%2A> свойство.  
  
> [!NOTE]
>  Необходимо указывать все параметры при поиске конструкторов и методов. Параметры можно опустить только в том случае, при вызове метода.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.ConstructorInfo> с параметрами типа, заменены соответствующими аргументами типа. Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод всегда возвращает `null`.  
  
   
  
## Examples  
 В следующем коде определяется тип `MyClass1` класса возвращает <xref:System.Reflection.ConstructorInfo> объекта, соответствующих указанным флагам привязки и отображается подпись конструктора.  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="types" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Массив <paramref name="types" /> является многомерным.  
  
 - или -  
  
 Массив <paramref name="modifiers" /> является многомерным.  
  
 - или -  
  
 <paramref name="types" /> и <paramref name="modifiers" /> имеют разную длину.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Нуль, чтобы было возвращено значение <see langword="null" />.</param>
        <param name="binder">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.  
  
 - или -  
  
 Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Объект, определяющий набор применяемых правил, касающихся порядка и расположения аргументов, способа передачи возвращаемого значения, регистров, используемых для аргументов, и очистки стека.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров, извлекаемых конструктором.  
  
 - или -  
  
 Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить конструктор, который не имеет параметров.</param>
        <param name="modifiers">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <c>types</c>. Связыватель по умолчанию не обрабатывает этот параметр.</param>
        <summary>Выполняет поиск конструктора с параметрами, соответствующими указанным модификаторам и типам аргументов, с учетом заданных ограничений по привязке и соглашений о вызовах.</summary>
        <returns>Если поиск выполнен удачно, возвращается объект, представляющий конструктор, который соответствует указанным требованиям; в противном случае возвращается значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то что связыватель по умолчанию не обрабатывает <xref:System.Reflection.ParameterModifier> ( `modifiers` параметр), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс, чтобы написать собственный связыватель, обрабатывающий `modifiers`. `ParameterModifier` используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.  
  
 Если точное соответствие не существует, `binder` попытается преобразовать типы параметров, указанные в `types` массива, чтобы найти совпадение. Если `binder` не удалось найти подходящий конструктор, затем `null` возвращается.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения конструкторов, включаемых в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` для получения возврата.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых конструкторов.  
  
-   Укажите `BindingFlags.NonPublic` необходимо включить в поиск закрытые конструкторы (то есть закрытые, внутренние и защищенные).  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Чтобы получить инициализатора класса (CCTOR), с помощью этого метода, необходимо указать <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic). Можно также получить с помощью инициализатора класса <xref:System.Type.TypeInitializer%2A> свойство.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методов при отражении в типе.  
  
|Тип члена|Static|Нестатический|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события, которые по имени и подписи. Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.  
  
3.  Пользовательские атрибуты не являются частью системы общих типов.  
  
> [!NOTE]
>  Необходимо указывать все параметры при поиске конструкторов и методов. Параметры можно опустить только в том случае, при вызове метода.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.ConstructorInfo> с параметрами типа, заменены соответствующими аргументами типа. Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод всегда возвращает `null`.  
  
   
  
## Examples  
 В следующем примере извлекается тип `MyClass1`, возвращает <xref:System.Reflection.ConstructorInfo> объекта, который соответствует указанным флагам привязки и отображается подпись конструктора.  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="types" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Массив <paramref name="types" /> является многомерным.  
  
 - или -  
  
 Массив <paramref name="modifiers" /> является многомерным.  
  
 - или -  
  
 <paramref name="types" /> и <paramref name="modifiers" /> имеют разную длину.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Нуль, чтобы было возвращено значение <see langword="null" />.</param>
        <param name="binder">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.  
  
 - или -  
  
 Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Объект, определяющий набор применяемых правил, касающихся порядка и расположения аргументов, способа передачи возвращаемого значения, регистров, используемых для аргументов, и очистки стека.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров, извлекаемых конструктором.  
  
 - или -  
  
 Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить конструктор, который не имеет параметров.</param>
        <param name="modifiers">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <c>types</c>. Связыватель по умолчанию не обрабатывает этот параметр.</param>
        <summary>При переопределении в производном классе ищет конструктор, параметры которого соответствуют указанным типам аргументов и модификаторам, используя для этого заданные ограничения привязки и соглашение о вызовах.</summary>
        <returns>Если поиск выполнен удачно, возвращается объект <see cref="T:System.Reflection.ConstructorInfo" />, представляющий конструктор, который соответствует указанным требованиям; в противном случае возвращается значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то что связыватель по умолчанию не обрабатывает <xref:System.Reflection.ParameterModifier> ( `modifiers` параметр), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс, чтобы написать собственный связыватель, обрабатывающий `modifiers`. `ParameterModifier` используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.  
  
 Если точное соответствие не существует, `binder` попытается преобразовать типы параметров, указанные в `types` массива, чтобы найти совпадение. Если `binder` не удалось найти подходящий конструктор, затем `null` возвращается.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения конструкторов, включаемых в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` для получения возврата.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых конструкторов.  
  
-   Укажите `BindingFlags.NonPublic` необходимо включить в поиск закрытые конструкторы (то есть закрытые, внутренние и защищенные).  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Этот метод реализует <xref:System.Type.GetConstructor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="types" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Массив <paramref name="types" /> является многомерным.  
  
 - или -  
  
 Массив <paramref name="modifiers" /> является многомерным.  
  
 - или -  
  
 <paramref name="types" /> и <paramref name="modifiers" /> имеют разную длину.</exception>
        <exception cref="T:System.NotSupportedException">Текущий тип является объектом <see cref="T:System.Reflection.Emit.TypeBuilder" /> или <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает конструкторы текущего объекта <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает все открытые конструкторы, определенные для текущего объекта <see cref="T:System.Type" />.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.ConstructorInfo" />, представляющий все открытые конструкторы экземпляров, определенные для текущего типа <see cref="T:System.Type" />, за исключением инициализатора типа (статический конструктор). Если для текущего объекта <see cref="T:System.Type" /> открытые конструкторы экземпляров не определены или если текущий объект <see cref="T:System.Type" /> представляет параметр типа в определении универсального типа или метода, возвращается пустой массив типа <see cref="T:System.Reflection.ConstructorInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A> Метод не возвращает конструкторы в определенном порядке, например порядке объявления. Код не должен зависеть от порядка, в котором возвращаются конструкторы, так как этот порядок меняется.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методов при отражении в типе.  
  
|Тип члена|Static|Нестатический|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события, которые по имени и подписи. Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.  
  
3.  Пользовательские атрибуты не являются частью системы общих типов.  
  
 Эта перегрузка метода вызывает <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> перегрузка метода с <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> в Visual Basic). Его не удастся найти инициализаторы класса (.cctor). Чтобы найти инициализаторы класса, используйте перегрузку, которая использует <xref:System.Reflection.BindingFlags>и укажите <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic). Можно также получить с помощью инициализатора класса <xref:System.Type.TypeInitializer%2A> свойство.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.ConstructorInfo> объекты с параметрами типа, заменены соответствующими аргументами типа. Например если класс `C<T>` имеет конструктор `C(T t1)` (`Sub New(ByVal t1 As T)` в Visual Basic), вызов <xref:System.Type.GetConstructors%2A> на `C<int>` возвращает <xref:System.Reflection.ConstructorInfo> , представляющий `C(int t1)` в C# (`Sub New(ByVal t1 As Integer)` в Visual Basic).  
  
 Если текущий <xref:System.Type> представляет параметр универсального типа, <xref:System.Type.GetConstructors%2A> метод возвращает пустой массив.  
  
   
  
## Examples  
 В этом примере показан результат выполнения <xref:System.Type.GetConstructors%2A> перегрузки из класса, который имеет два конструктора экземпляра и один статический конструктор.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 Результат выполнения этого кода является:  
  
 2  
  
 False  
  
 False  
  
 Поскольку <xref:System.Type.GetConstructors> перегрузка использует только <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, статический конструктор не подсчитывается `for` выражения и не вычисляется `IsStatic`.  
  
 Чтобы найти статические конструкторы, используйте <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> перегружать и передать сочетания (логические `OR`) из <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, как показано в следующем примере кода:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 Теперь выводится следующий результат:  
  
 3  
  
 False  
  
 Да  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Нуль, чтобы было возвращено значение <see langword="null" />.</param>
        <summary>При переопределении в производном классе ищет конструкторы, определенные для текущего объекта <see cref="T:System.Type" />, с использованием указанного объекта <see langword="BindingFlags" />.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.ConstructorInfo" />, представляющий все конструкторы, определенные для текущего объекта <see cref="T:System.Type" /> и удовлетворяющие указанным ограничениям привязки, в том числе и инициализатор типа, если он определен. Возвращает пустой массив типа <see cref="T:System.Reflection.ConstructorInfo" />, если для текущего типа <see cref="T:System.Type" /> не определены конструкторы, если ни один из определенных конструкторов не соответствует ограничениям привязки или если текущий тип <see cref="T:System.Type" /> представляет параметр типа в определении универсального типа или метода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A> Метод не возвращает конструкторы в определенном порядке, например порядке объявления. Код не должен зависеть от порядка, в котором возвращаются конструкторы, так как этот порядок меняется.  
  
 `bindingAttr` можно использовать для указания, нужно ли возвращать только открытые конструкторы или открытые и закрытые конструкторы.  
  
 Если точное соответствие не существует, `binder` попытается преобразовать типы параметров, указанные в `types` массива, чтобы найти совпадение. Если `binder` не удалось найти подходящий конструктор, затем `null` возвращается.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения конструкторов, включаемых в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` для получения возврата.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых конструкторов.  
  
-   Укажите `BindingFlags.NonPublic` необходимо включить в поиск закрытые конструкторы (то есть закрытые, внутренние и защищенные). Конструкторы базовых классов не возвращаются.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Чтобы получить инициализатора класса (CCTOR), с помощью этой перегрузки метода, необходимо указать <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic). Можно также получить с помощью инициализатора класса <xref:System.Type.TypeInitializer%2A> свойство.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.ConstructorInfo> объекты с параметрами типа, заменены соответствующими аргументами типа. Например если класс `C<T>` имеет конструктор `C(T t1)` (`Sub New(ByVal t1 As T)` в Visual Basic), вызов <xref:System.Type.GetConstructors%2A> на `C<int>` возвращает <xref:System.Reflection.ConstructorInfo> , представляющий `C(int t1)` в C# (`Sub New(ByVal t1 As Integer)` в Visual Basic).  
  
 Если текущий <xref:System.Type> представляет параметр универсального типа, <xref:System.Type.GetConstructors%2A> метод возвращает пустой массив.  
  
   
  
## Examples  
 В этом примере показан результат выполнения <xref:System.Type.GetConstructors> перегрузки из класса, который имеет два конструктора экземпляра и один статический конструктор.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 Результат выполнения этого кода является:  
  
 2  
  
 False  
  
 False  
  
 Поскольку <xref:System.Type.GetConstructors%2A> перегрузка использует только <xref:System.Reflection.BindingFlags.Public> и <xref:System.Reflection.BindingFlags.Instance>, статический конструктор не подсчитывается `for` выражения и не вычисляется `IsStatic`.  
  
 Чтобы найти статические конструкторы, используйте <xref:System.Type.GetConstructors%2A> перегружать и передать его сочетание (логическое или) <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, как показано в следующем примере кода:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 Теперь выводится следующий результат:  
  
 3  
  
 False  
  
 Да  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выполняет поиск членов, определенных для текущего объекта <see cref="T:System.Type" />, для которого задан атрибут <see cref="T:System.Reflection.DefaultMemberAttribute" />.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющий все члены по умолчанию текущего объекта <see cref="T:System.Type" />.  
  
 - или -  
  
 Пустой массив типа <see cref="T:System.Reflection.MemberInfo" />, если у текущего типа <see cref="T:System.Type" /> нет членов по умолчанию.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetDefaultMembers%2A> Метод не возвращает элементы в определенном порядке, например алфавитном или в порядке объявления. Код не должен зависеть от порядка, в котором возвращаются члены, так как этот порядок меняется.  
  
 Этот метод может быть переопределен в производном классе.  
  
 Элементы включают свойства, методы, поля, события и т. д.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методов при отражении в типе.  
  
|Тип члена|Static|Нестатический|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события, которые по имени и подписи. Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.  
  
3.  Пользовательские атрибуты не являются частью системы общих типов.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MemberInfo> объекты с параметрами типа, заменены соответствующими аргументами типа. Например если класс `C<T>` имеет свойство `P` , возвращающий `T`, вызов <xref:System.Type.GetDefaultMembers%2A> на `C<int>` возвращает `int P` в C# (`Property P As Integer` в Visual Basic).  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или члены <xref:System.Object> при наличии без ограничения класса.  
  
   
  
## Examples  
 В следующем примере извлекается информация об элементе по умолчанию из `MyClass` и отображает элементы по умолчанию.  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе возвращает тип <see cref="T:System.Type" /> объекта, на который ссылается данный массив, указатель или ссылка или который инкапсулирован в этих объектах.</summary>
        <returns>Тип объекта <see cref="T:System.Type" />, на который ссылается данный массив, указатель или ссылка или который инкапсулирован в этих объектах, или значение <see langword="null" />, если текущий объект <see cref="T:System.Type" /> не является массивом или указателем, не передается по ссылке либо представляет универсальный тип или параметр типа в определении универсального типа или метода.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает `null` для <xref:System.Array> класса.  
  
   
  
## Examples  
 В следующем примере показано использование `GetElementType` метода.  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Значение, имя которой требуется извлечь.</param>
        <summary>Возвращает имя константы с заданным значением для текущего типа перечисления.</summary>
        <returns>Имя члена текущего типа перечисления, имеющего указанное значение, или <see langword="null" />, если такая константа не найдена.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Текущий тип не является перечислением.  
  
 - или -  
  
 <paramref name="value" /> не принадлежит к текущему типу и не имеет тот же базовый тип, что и текущий тип.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает имена членов текущего типа перечисления.</summary>
        <returns>Массив, который содержит имена членов перечисления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы массива, возвращаемого значения сортируются по двоичным значениям (то есть значениям без знака) констант перечисления. Если массив содержит перечислимые константы с тем же значением, порядок соответствующих им имен не определен.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий тип не является перечислением.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает базовый тип текущего типа перечисления.</summary>
        <returns>Базовый тип текущего перечисления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию является базовым типом перечисления в C# и Visual Basic <xref:System.Int32>. Можно указать другие целочисленные типы.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий тип не является перечислением.  
  
 - или -  
  
 Тип перечисления не является допустимым, так как содержит более одного поля экземпляра.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает массив значений констант в текущем типе перечисления.</summary>
        <returns>Массив, содержащий значения. Элементы массива сортируются по двоичным значениям (то есть значениям без знака) констант перечисления.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Текущий тип не является перечислением.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает определенное событие, которое объявлено или унаследовано в текущем объекте <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя события, которое объявлено или унаследовано текущим типом <see cref="T:System.Type" />.</param>
        <summary>Возвращает объект <see cref="T:System.Reflection.EventInfo" />, представляющий указанное открытое событие.</summary>
        <returns>Объект, представляющий указанное открытое событие, которое объявлено или унаследовано в текущем объекте <see cref="T:System.Type" />, если такое событие найдено; в противном случае — <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Событие считается открытым для отражения, если у него есть хотя бы один метод или метод доступа, который является общим. В противном случае считается закрытым события, и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединять значения с использованием `Or`) для его получения.  
  
 Поиск `name` учитывается регистр. Поиск включает в себя открытый статический и открытый экземпляр события.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методов при отражении в типе.  
  
|Тип члена|Static|Нестатический|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события, которые по имени и подписи. Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.  
  
3.  Пользовательские атрибуты не являются частью системы общих типов.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.EventInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет события ограничения класса.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Reflection.EventInfo> объекта и возвращает событие класса button для указанного события.  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя события, которое объявлено или унаследовано текущим типом <see cref="T:System.Type" />.</param>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Нуль, чтобы было возвращено значение <see langword="null" />.</param>
        <summary>При переопределении в производном классе возвращает объект <see cref="T:System.Reflection.EventInfo" />, представляющий указанное событие, используя для этого указанные ограничения привязки.</summary>
        <returns>Объект, представляющий указанное событие, которое объявлено или унаследовано текущим типом <see cref="T:System.Type" />, если такое событие найдено; <see langword="null" /> в противном случае.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения, какие события необходимо включить в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` для получения возврата.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытые события.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск события не являющиеся открытыми (то есть, закрытые, внутренние и защищенные события).  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверх по иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> модификатор флаги можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только события, объявленные на <xref:System.Type>, не события унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Событие считается открытым для отражения, если у него есть хотя бы один метод или метод доступа, который является общим. В противном случае считается закрытым события, и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединять значения с использованием `Or`) для его получения.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.EventInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет события ограничения класса.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> метод для поиска типа открытый или неоткрытый события с именем «Щелкните», не `static` (`Shared` в Visual Basic).  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает события, которые объявлены или унаследованы текущим объектом <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает все открытые события, которые объявлены или унаследованы текущим объектом <see cref="T:System.Type" />.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.EventInfo" />, представляющий все открытые события, которые объявлены или унаследованы текущим объектом <see cref="T:System.Type" />.  
  
 - или -  
  
 Пустой массив типа <see cref="T:System.Reflection.EventInfo" />, если в текущем объекте <see cref="T:System.Type" /> нет открытых событий.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Событие считается открытым для отражения, если у него есть хотя бы один метод или метод доступа, который является общим. В противном случае считается закрытым события, и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединять значения с использованием `Or`) для его получения.  
  
 <xref:System.Type.GetEvents%2A> Метод не возвращает события в определенном порядке, например алфавитном или в порядке объявления. Код не должен зависеть от порядка, в котором возвращаются события, так как этот порядок меняется.  
  
 Этот метод может быть переопределен в производном классе.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методов при отражении в типе.  
  
|Тип члена|Static|Нестатический|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события, которые по имени и подписи. Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.  
  
3.  Пользовательские атрибуты не являются частью системы общих типов.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.EventInfo> объекты с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет события ограничения класса.  
  
   
  
## Examples  
 В следующем примере извлекается массив <xref:System.Reflection.EventInfo> объектов, возвращает все события для `Button` класса и отображаются имена событий. Чтобы скомпилировать этот пример Visual Basic, используйте следующую командную строку:  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Нуль, чтобы было возвращено значение <see langword="null" />.</param>
        <summary>При переопределении в производном классе ищет события, которые объявлены или унаследованы текущим объектом <see cref="T:System.Type" />, используя указанные ограничения привязки.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.EventInfo" />, представляющий все события, которые объявлены или унаследованы данным объектом <see cref="T:System.Type" /> и удовлетворяют указанным ограничениям привязки.  
  
 - или -  
  
 Пустой массив типа <see cref="T:System.Reflection.EventInfo" />, если у текущего типа <see cref="T:System.Type" /> нет событий или ни одно событие не удовлетворяет ограничениям привязки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetEvents%2A> Метод не возвращает события в определенном порядке, например алфавитном или в порядке объявления. Код не должен зависеть от порядка, в котором возвращаются события, так как этот порядок меняется.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения, какие события необходимо включить в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` для получения возврата.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытые события.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск события не являющиеся открытыми (то есть, закрытые, внутренние и защищенные события). Только защищенные и внутренние события базовых классов, возвращаются; Закрытые события базовых классов не возвращаются.  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверх по иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> модификатор флаги можно использовать для изменения условий поиска:  
  
-   `BindingFlags.DeclaredOnly` для поиска только события, объявленные на <xref:System.Type>, не события унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Событие считается открытым для отражения, если у него есть хотя бы один метод или метод доступа, который является общим. В противном случае считается закрытым события, и необходимо использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединять значения с использованием `Or`) для его получения.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.EventInfo> объекты с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет события ограничения класса.  
  
   
  
## Examples  
 В следующем примере извлекается массив <xref:System.Reflection.EventInfo> объектов, соответствующих указанным флагам привязки, возвращаются все события `Button` класса и отображаются имена событий. Чтобы скомпилировать этот пример Visual Basic, используйте следующую командную строку:  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает указанное поле текущего объекта <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого поля данных.</param>
        <summary>Выполняет поиск открытого поля с заданным именем.</summary>
        <returns>Объект, представляющий открытое поле с указанным именем, если такое свойство есть, или <see langword="null" />, если такого свойства нет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск `name` учитывается регистр. При поиске учитываются открытые статические и открытые поля экземпляра.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.FieldInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет поля ограничения класса.  
  
   
  
## Examples  
 В следующем примере извлекается `Type` объекта для заданного класса, получает <xref:System.Reflection.FieldInfo> объекта в поле и выводится значение поля.  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Этот объект <see cref="T:System.Type" /> является объектом <see cref="T:System.Reflection.Emit.TypeBuilder" />, чей метод <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> еще не вызывался.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого поля данных.</param>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Нуль, чтобы было возвращено значение <see langword="null" />.</param>
        <summary>Выполняет поиск указанного поля, используя заданные ограничения привязки.</summary>
        <returns>Объект, предоставляющий поле, которое соответствует указанным требованиям, если такое свойство найдено; в противном случае возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методов при отражении в типе.  
  
|Тип члена|Static|Нестатический|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события, которые по имени и подписи. Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.  
  
3.  Пользовательские атрибуты не являются частью системы общих типов.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения полей, включаемых в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` для получения возврата.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытые поля.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск неоткрытые поля (то есть, закрытые, внутренние и защищенные).  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверх по иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> модификатор флаги можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только поля, объявленные в <xref:System.Type>, не поля унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.FieldInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет поля ограничения класса.  
  
   
  
## Examples  
 В следующем примере извлекается `Type` объекта для заданного класса, получает <xref:System.Reflection.FieldInfo> объекта для поля, которое соответствует указанным флагам привязки и отображает значение поля.  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает поля текущего объекта <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает все открытые поля текущего объекта <see cref="T:System.Type" />.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.FieldInfo" />, представляющий все открытые поля, определенные для текущего объекта <see cref="T:System.Type" />.  
  
 - или -  
  
 Пустой массив типа <see cref="T:System.Reflection.FieldInfo" />, если для текущего типа <see cref="T:System.Type" /> открытые поля не определены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A> Метод не возвращает поля в определенном порядке, например алфавитном или в порядке объявления. Код не должен зависеть от порядка, в котором возвращаются поля, так как этот порядок меняется.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методов при отражении в типе.  
  
|Тип члена|Static|Нестатический|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события, которые по имени и подписи. Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.  
  
3.  Пользовательские атрибуты не являются частью системы общих типов.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.FieldInfo> объекты с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод выполняет поиск открытого поля ограничения класса.  
  
   
  
## Examples  
 В следующем примере показано использование `GetFields()` метода.  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Нуль, чтобы было возвращено значение <see langword="null" />.</param>
        <summary>При переопределении в производном классе ищет поля, определенные для текущего объекта <see cref="T:System.Type" />, используя указанные ограничения привязки.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.FieldInfo" />, представляющий все поля, определенные для текущего типа <see cref="T:System.Type" /> и удовлетворяющие указанным ограничениям привязки.  
  
 - или -  
  
 Пустой массив типа <see cref="T:System.Reflection.FieldInfo" />, если для текущего объекта <see cref="T:System.Type" /> не определены поля или ни одно из определенных полей не удовлетворяет ограничениям привязки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A> Метод не возвращает поля в определенном порядке, например алфавитном или в порядке объявления. Код не должен зависеть от порядка, в котором возвращаются поля, так как этот порядок меняется.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения полей, включаемых в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` для получения возврата.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытые поля.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск неоткрытые поля (то есть, закрытые, внутренние и защищенные). Только защищенные и внутренние поля базовых классов, возвращаются; закрытые поля базовых классов не возвращаются.  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверх по иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> модификатор флаги можно использовать для изменения условий поиска:  
  
-   `BindingFlags.DeclaredOnly` для поиска только поля, объявленные в <xref:System.Type>, не поля унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.FieldInfo> объекты с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод выполняет поиск открытого поля ограничения класса.  
  
   
  
## Examples  
 В следующем примере показано использование `GetFields(BindingFlags)` метода.  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает массив объектов <see cref="T:System.Type" />, которые представляют аргументы закрытого универсального типа или параметры определения универсального типа.</summary>
        <returns>Массив объектов <see cref="T:System.Type" />, которые представляют аргументы универсального типа. Возвращает пустой массив, если текущий тип не является универсальным.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы массива возвращаются в порядке, в котором они отображаются в списке аргументов типа для универсального типа.  
  
-   Если текущий тип является закрытым сконструированным типом (то есть <xref:System.Type.ContainsGenericParameters%2A> возвращает `false`), массив, возвращаемый методом <xref:System.Type.GetGenericArguments%2A> метод содержит типы, которые были назначены параметры универсального типа в определении универсального типа .  
  
-   Если текущий тип является определением универсального типа, массив содержит параметры типа.  
  
-   Если текущий тип является открытым сконструированным типом (то есть <xref:System.Type.ContainsGenericParameters%2A> возвращает `true`) в определенные типы не были назначены все параметры типа и параметров типа включающего универсального типа или метода, содержит массив типы и параметры типа. Используйте <xref:System.Type.IsGenericParameter%2A> свойство, чтобы отличить друг от друга. Для демонстрации этого сценария, см. пример кода для <xref:System.Type.ContainsGenericParameters%2A> свойства.  
  
 Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Type.GetGenericArguments%2A> метод для отображения аргументов типа сконструированного типа и параметров типа определения универсального типа.  
  
 Данный пример кода является частью большего примера, приведенного для <xref:System.Type.IsGenericTypeDefinition%2A> свойства. Далее приведен пример большего пример выходных данных.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Вызванный метод не поддерживается в базовом классе. Реализацию должны обеспечивать производные классы.</exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает массив объектов <see cref="T:System.Type" />, которые представляют ограничения, накладываемые на параметр текущего универсального типа.</summary>
        <returns>Массив объектов <see cref="T:System.Type" />, которые представляют ограничения, накладываемые на параметр текущего универсального типа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждое ограничение на параметр универсального типа выражается как <xref:System.Type> объект. Используйте <xref:System.Type.IsClass%2A> свойства, чтобы определить, является ли ограничение ограничению базового класса; Если свойство возвращает `false`, это ограничение является ограничением интерфейса. Если параметр типа без ограничения класса и интерфейса, возвращается пустой массив.  
  
 Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 В следующем примере кода определяется универсальный тип `Test` с двумя параметрами типов, которые имеют различные ограничения. При выполнении программы ограничения проверяются с помощью <xref:System.Type.GenericParameterAttributes%2A> свойство и <xref:System.Type.GetGenericParameterConstraints%2A> метод.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Текущий объект <see cref="T:System.Type" /> не является параметром универсального типа. То есть свойство <see cref="P:System.Type.IsGenericParameter" /> возвращает значение <see langword="false" />.</exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Type" />, представляющий определение универсального типа, на основе которого можно сконструировать текущий универсальный тип.</summary>
        <returns>Объект <see cref="T:System.Type" />, представляющий универсальный тип, на основе которого можно сконструировать текущий тип.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Определение универсального типа — это шаблон, из которого можно сконструировать другие типы. Например, в определении универсального типа `G<T>` (выраженная в синтаксис C#; `G(Of T)` в Visual Basic или `generic <typename T> ref class G` в C++) можно создать и создать экземпляр типа `G<int>` (`G(Of Integer)` в Visual Basic). Получает <xref:System.Type> объект, представляющий это сконструированный тип, <xref:System.Type.GetGenericTypeDefinition%2A> метод возвращает определение универсального типа.  
  
 Если два сконструированные типы создаются из одного определения универсального типа, используя те же аргументы типа <xref:System.Type.GetGenericTypeDefinition%2A> метод возвращает тот же <xref:System.Type> объекта для обоих типов.  
  
 При вызове метода <xref:System.Type.GetGenericTypeDefinition%2A> метод <xref:System.Type> объект, который уже представляет определение универсального типа, возвращается текущий <xref:System.Type>.  
  
> [!IMPORTANT]
>  Массив универсальных типов не сам является универсальным. В коде C# `A<int>[] v;` или Visual Basic `Dim v() As A(Of Integer)`, тип переменной `v` не является универсальным. Используйте <xref:System.Type.IsGenericType%2A> для определения, является ли тип универсальным перед вызовом <xref:System.Type.GetGenericTypeDefinition%2A>.  
  
 Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 В следующем примере кода создается экземпляр сконструированного типа с помощью обычного создания экземпляра, а затем использует <xref:System.Type.GetType%2A> и <xref:System.Type.GetGenericTypeDefinition%2A> методы для получения сконструированного типа и определения универсального типа. В этом примере используется универсальный <xref:System.Collections.Generic.Dictionary%602> тип, представляющий сконструированный тип <xref:System.Collections.Generic.Dictionary%602> из `Test` объектов, содержащих строковые ключи.  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Текущий тип не является универсальным.  То есть <see cref="P:System.Type.IsGenericType" /> возвращает <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">Вызванный метод не поддерживается в базовом классе. Реализацию должны обеспечивать производные классы.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код данного экземпляра.</summary>
        <returns>Хэш-код данного экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере отображается хэш-код `System.Windows.Forms.Button` класса.  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает определенный интерфейс, реализуемый или наследуемый текущим объектом <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого интерфейса. Для универсальных интерфейсов это искаженное имя.</param>
        <summary>Выполняет поиск интерфейса с заданным именем.</summary>
        <returns>Объект, представляющий интерфейс с заданным именем, который реализуется или наследуется текущим объектом <see cref="T:System.Type" />, если такой интерфейс существует; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск `name` учитывается регистр.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Type> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет ограничения интерфейса, а также все интерфейсы, унаследованные от класса или интерфейса ограничений.  
  
> [!NOTE]
>  Для универсальных интерфейсов `name` параметр является искаженное имя, заканчивающееся грависом (\`) и число параметров типа. Это верно для определений универсального интерфейса и сконструированных универсальных интерфейсов. Например, чтобы найти `IExample<T>` (`IExample(Of T)` в Visual Basic) или `IExample<string>` (`IExample(Of String)` в Visual Basic), поиск ``"IExample`1"``.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Type.GetInterface%28System.String%29> метод для поиска <xref:System.Collections.Hashtable> класса для <xref:System.Runtime.Serialization.IDeserializationCallback> интерфейс и списки методов интерфейса.  
  
 В примере также показано <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> перегрузка метода и <xref:System.Type.GetInterfaceMap%2A> метод.  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Текущий объект <see cref="T:System.Type" /> представляет тип, реализующий тот же универсальный интерфейс, но с другими аргументами типа.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого интерфейса. Для универсальных интерфейсов это искаженное имя.</param>
        <param name="ignoreCase">
          Значение <see langword="true" />, чтобы игнорировать регистр той части параметра <c>name</c>, в которой задается простое имя интерфейса (регистр в части, соответствующей пространству имен, должен соблюдаться).  
  
 - или -  
  
 Значение <see langword="false" /> для поиска с учетом регистра всех частей параметра <c>name</c>.</param>
        <summary>При переопределении в производном классе ищет интерфейс с заданным именем, позволяющий определить, нужно ли выполнять поиск без учета регистра.</summary>
        <returns>Объект, представляющий интерфейс с заданным именем, который реализуется или наследуется текущим объектом <see cref="T:System.Type" />, если такой интерфейс существует; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ignoreCase` Параметр применяется только к простое имя интерфейса, не к пространству имен. Часть `name` , задающий пространства имен должны иметь правильный регистр или интерфейс не будет найден. Например, строка «System.icomparable» находит <xref:System.IComparable> не поддерживает интерфейс, но строка «system.icomparable».  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Type> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет ограничения интерфейса, а также все интерфейсы, унаследованные от класса или интерфейса ограничений.  
  
> [!NOTE]
>  Для универсальных интерфейсов `name` параметр является искаженное имя, заканчивающееся грависом (\`) и число параметров типа. Это верно для определений универсального интерфейса и сконструированных универсальных интерфейсов. Например, чтобы найти `IExample<T>` (`IExample(Of T)` в Visual Basic) или `IExample<string>` (`IExample(Of String)` в Visual Basic), поиск `"IExample`1"".  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> способ выполнения поиска без учета регистра из <xref:System.Collections.Hashtable> класса для <xref:System.Collections.IEnumerable> интерфейса.  
  
 В примере также показано <xref:System.Type.GetInterface%28System.String%29> перегрузка метода и <xref:System.Type.GetInterfaceMap%2A> метод.  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Текущий объект <see cref="T:System.Type" /> представляет тип, реализующий тот же универсальный интерфейс, но с другими аргументами типа.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">Тип интерфейса, для которого требуется извлечь сопоставление.</param>
        <summary>Возвращает сопоставление для интерфейса заданного типа.</summary>
        <returns>Объект, представляющий сопоставление интерфейса для <paramref name="interfaceType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Карта интерфейса указывает сопоставление интерфейса в фактических члены класса, реализующего этот интерфейс.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, параметры заменяются соответствующими аргументами типа в элементах <xref:System.Reflection.InterfaceMapping> возвращаемый этим методом.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Type.GetInterfaceMap%2A> метод, чтобы определить, как <xref:System.IFormatProvider> сопоставляется интерфейс <xref:System.Globalization.CultureInfo> методов и как <xref:System.IAppDomainSetup> сопоставляется интерфейс <xref:System.AppDomainSetup> свойства. Обратите внимание, что, поскольку <xref:System.IAppDomainSetup> интерфейс определяет набор свойств, возвращенном <xref:System.Reflection.InterfaceMapping> объект включает в себя отдельные <xref:System.Reflection.MethodInfo> объектов для get свойства и методы доступа set.  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="interfaceType" /> не реализуется текущим типом.  
  
 - или -  
  
 Параметр <paramref name="interfaceType" /> не ссылается на интерфейс.  
  
 - или -  
  
 <paramref name="interfaceType" /> является универсальным интерфейсом, а текущий тип является типом массива.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="interfaceType" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Текущий объект <see cref="T:System.Type" /> представляет параметр универсального типа. Это означает, что значение параметра <see cref="P:System.Type.IsGenericParameter" /> равно <see langword="true" />.</exception>
        <exception cref="T:System.NotSupportedException">Вызванный метод не поддерживается в базовом классе. Реализацию должны обеспечивать производные классы.</exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе возвращает все интерфейсы, реализуемые или наследуемые текущим объектом <see cref="T:System.Type" />.</summary>
        <returns>Массив объектов <see cref="T:System.Type" />, представляющий все интерфейсы, реализуемые или наследуемые текущим типом <see cref="T:System.Type" />.  
  
 - или -  
  
 Пустой массив типа <see cref="T:System.Type" /> в случае отсутствия интерфейсов, реализуемых или наследуемых текущим типом <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetInterfaces%2A> Метод не возвращает интерфейсы в определенном порядке, например алфавитном или в порядке объявления. Код не должен зависеть от порядка, в котором возвращаются интерфейсы, так как этот порядок меняется.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Type> объекты с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет ограничения интерфейса, а также все интерфейсы, унаследованные от класса или интерфейса ограничений.  
  
   
  
## Examples  
 Следующий пример возвращает тип указанного класса и отображает все интерфейсы, которые тип реализует или наследует. Чтобы скомпилировать этот пример Visual Basic, используйте следующие команды компилятора:  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Статический инициализатор вызывается и создает исключение.</exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает указанные члены текущего объекта <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомых открытых членов.</param>
        <summary>Выполняет поиск открытого члена с заданным именем.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющий открытые члены с заданным именем, если такие члены есть, и пустой массив, если таких членов нет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск `name` учитывается регистр. Поиск включает элементы открытый статический и открытый экземпляр.  
  
 Элементы включают свойства, методы, поля, события и т. д.  
  
 <xref:System.Type.GetMember%2A> Метод не возвращает элементы в определенном порядке, например алфавитном или в порядке объявления. Код не должен зависеть от порядка, в котором возвращаются члены, так как этот порядок меняется.  
  
 Эта перегрузка метода не найдет инициализаторы класса (CCTOR). Чтобы найти инициализаторы класса, используйте перегрузку, которая использует <xref:System.Reflection.BindingFlags>и укажите <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic). Можно также получить с помощью инициализатора класса <xref:System.Type.TypeInitializer%2A> свойство.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методов при отражении в типе.  
  
|Тип члена|Static|Нестатический|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события, которые по имени и подписи. Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.  
  
3.  Пользовательские атрибуты не являются частью системы общих типов.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MemberInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или члены <xref:System.Object> при наличии без ограничения класса.  
  
> [!NOTE]
>  Универсальные методы не включать аргументы типа в `name`. Например, код C# `GetMember("MyMethod<int>")` ищет элемент с именем текст «`MyMethod<int>`», а не для метода с именем `MyMethod` , имеет один аргумент универсального типа `int`.  
  
   
  
## Examples  
 В следующем примере отображаются все члены `String` которых начинаются с буквы C.  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя для поиска элементов.</param>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Ноль для возвращения пустого массива.</param>
        <summary>Выполняет поиск указанных членов, используя заданные ограничения привязки.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющий открытые члены с заданным именем, если такие члены есть, и пустой массив, если таких членов нет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен в производном классе.  
  
 Элементы включают свойства, методы, поля, события и т. д.  
  
 <xref:System.Type.GetMember%2A> Метод не возвращает элементы в определенном порядке, например алфавитном или в порядке объявления. Код не должен зависеть от порядка, в котором возвращаются члены, так как этот порядок меняется.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения члены, которые нужно включить в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` для получения возврата.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых членов.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск закрытым членам (то есть частных, внутренних и защищенные члены).  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверх по иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> модификатор флаги можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только члены, объявленные в <xref:System.Type>, не унаследованные члены группы.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Чтобы получить инициализатора класса (CCTOR), с помощью этой перегрузки метода, необходимо указать «.cctor» для `name`, и <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic) для `bindingAttr`. Можно также получить с помощью инициализатора класса <xref:System.Type.TypeInitializer%2A> свойство.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MemberInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или члены <xref:System.Object> при наличии без ограничения класса.  
  
> [!NOTE]
>  Универсальные методы не включать аргументы типа в `name`. Например, код C# `GetMember("MyMethod<int>")` ищет элемент с именем текст «`MyMethod<int>`», а не для метода с именем `MyMethod` , имеет один аргумент универсального типа `int`.  
  
   
  
## Examples  
 Следующий пример отображает все открытые статические члены `myString` которых начинаются с буквы C.  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя для поиска элементов.</param>
        <param name="type">Значение, которое нужно найти.</param>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Ноль для возвращения пустого массива.</param>
        <summary>Ищет указанные члены заданного типа, используя установленные ограничения привязки.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющий открытые члены с заданным именем, если такие члены есть, и пустой массив, если таких членов нет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы включают свойства, методы, поля, события и т. д.  
  
 <xref:System.Type.GetMember%2A> Метод не возвращает элементы в определенном порядке, например алфавитном или в порядке объявления. Код не должен зависеть от порядка, в котором возвращаются члены, так как этот порядок меняется.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения члены, которые нужно включить в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` для получения возврата.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых членов.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск закрытым членам (то есть частных, внутренних и защищенные члены).  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверх по иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> модификатор флаги можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только члены, объявленные в <xref:System.Type>, не унаследованные члены группы.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Чтобы получить инициализатора класса (CCTOR), с помощью этой перегрузки метода, необходимо указать «.cctor» для `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> для `type`, и <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic) для `bindingAttr`. Можно также получить с помощью инициализатора класса <xref:System.Type.TypeInitializer%2A> свойство.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MemberInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или члены <xref:System.Object> при наличии без ограничения класса.  
  
> [!NOTE]
>  Универсальные методы не включать аргументы типа в `name`. Например, код C# `GetMember("MyMethod<int>")` ищет элемент с именем текст «`MyMethod<int>`», а не для метода с именем `MyMethod` , имеет один аргумент универсального типа `int`.  
  
   
  
## Examples  
 В следующем примере отображаются все методы `myString` которых начинаются с буквы C.  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Реализацию должен обеспечивать производный класс.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает члены (свойства, методы, поля, события и т. д.) текущего объекта <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает все открытые члены текущего объекта <see cref="T:System.Type" />.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющий все открытые члены текущего типа <see cref="T:System.Type" />.  
  
 - или -  
  
 Пустой массив типа <see cref="T:System.Reflection.MemberInfo" />, если у текущего типа <see cref="T:System.Type" /> нет открытых членов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы включают свойства, методы, поля, события и т. д.  
  
 <xref:System.Type.GetMembers%2A> Метод не возвращает элементы в определенном порядке, например алфавитном или в порядке объявления. Код не должен зависеть от порядка, в котором возвращаются члены, так как этот порядок меняется.  
  
 Эта перегрузка метода вызывает <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> перегрузка метода с <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> в Visual Basic). Его не удастся найти инициализаторы класса (.cctor). Чтобы найти инициализаторы класса, используйте перегрузку, которая использует <xref:System.Reflection.BindingFlags>и укажите <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic). Можно также получить с помощью инициализатора класса <xref:System.Type.TypeInitializer%2A> свойство.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методов при отражении в типе.  
  
|Тип члена|Static|Нестатический|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события, которые по имени и подписи. Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.  
  
3.  Пользовательские атрибуты не являются частью системы общих типов.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MemberInfo> объекты с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или члены <xref:System.Object> при наличии без ограничения класса.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Type.GetMembers> перегрузка метода для сбора сведений о все открытые члены указанного класса.  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Ноль (<see cref="F:System.Reflection.BindingFlags.Default" />) для возвращения пустого массива.</param>
        <summary>При переопределении в производном классе ищет члены, определенные для текущего объекта <see cref="T:System.Type" />, используя указанные ограничения привязки.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.MemberInfo" />, представляющий все члены, определенные для текущего типа <see cref="T:System.Type" /> и удовлетворяющие указанным ограничениям привязки.  
  
 - или -  
  
 Пустой массив типа <see cref="T:System.Reflection.MemberInfo" />, если для текущего объекта <see cref="T:System.Type" /> не определены члены или ни один из определенных членов не удовлетворяет ограничениям привязки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы включают свойства, методы, поля, события и т. д.  
  
 <xref:System.Type.GetMembers%2A> Метод не возвращает элементы в определенном порядке, например алфавитном или в порядке объявления. Код не должен зависеть от порядка, в котором возвращаются члены, так как этот порядок меняется.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения члены, которые нужно включить в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` для получения возврата.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых членов.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск закрытым членам (то есть частных, внутренних и защищенные члены). Только защищенные внутренние члены базовых классов возвращаются и; закрытые члены базовых классов не возвращаются.  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверх по иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> модификатор флаги можно использовать для изменения условий поиска:  
  
-   `BindingFlags.DeclaredOnly` для поиска только члены, объявленные в <xref:System.Type>, не унаследованные члены группы.  
  
 Вызов этого метода только с `Public` флаг или только `NonPublic` флаг Возвращает указанные члены и дополнительные флаги не требуются.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Чтобы получить инициализатора класса (CCTOR), с помощью этой перегрузки метода, необходимо указать <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> в Visual Basic). Можно также получить с помощью инициализатора класса <xref:System.Type.TypeInitializer%2A> свойство.  
  
 Если текущий объект T:System.Type представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MemberInfo> объекты с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет члены ограничения класса или члены <xref:System.Object> при наличии без ограничения класса.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> перегрузка метода для сбора сведений обо всех членах открытого экземпляра указанного класса.  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает заданный метод текущего класса <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого открытого метода.</param>
        <summary>Выполняет поиск открытого метода с заданным именем.</summary>
        <returns>Объект, представляющий открытый метод с заданным именем, если такой метод есть, и <see langword="null" />, если такого метода нет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск `name` учитывается регистр. При поиске учитываются открытые статические и открытые методы экземпляра.  
  
 Если метод перегружен и имеет несколько открытых методов, <xref:System.Type.GetMethod%28System.String%29> вызывает исключение <xref:System.Reflection.AmbiguousMatchException> исключение. В следующем примере создается исключение, так как присутствует более одного открытого перегрузка <xref:System.Int32.ToString%2A?displayProperty=nameWithType> метод.  С другой стороны так как `Person.ToString` переопределения методов <xref:System.Object.ToString%2A?displayProperty=nameWithType> и поэтому не перегружен, <xref:System.Type.GetMethod%28System.String%29> метод способен получить <xref:System.Reflection.MethodInfo> объекта.  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 Необходимо выполнить одно из следующих действий, чтобы получить определенный метод:  
  
-   Вызовите <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> метод и укажите `bindingAttr` аргумент, который однозначно определяет метод. Например, если вызывается исключение, поскольку тип имеет статический и экземпляр перегрузку, можно указать `bindingAttr` аргумент <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.  
  
-   Вызовите перегрузку <xref:System.Type.GetMethod%2A> метод, который включает в себя `types` параметр, который определяет типы параметров метода.  
  
-   Вызовите <xref:System.Type.GetMethods> метод, чтобы получить массив, содержащий все открытые методы, принадлежащие типу. Затем можно последовательно его для идентификации повторяющихся методов, с именем `name`.  
  
 Если текущий объект T:System.Type представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MethodInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object> при наличии без ограничения класса.  
  
> [!NOTE]
>  Универсальные методы не включать аргументы типа в `name`. Например, код C# `GetMember("MyMethod<int>")` ищет элемент с именем текст «`MyMethod<int>`», а не для метода с именем `MyMethod` , имеет один аргумент универсального типа `int`.  
  
   
  
## Examples  
 В следующем примере извлекается метод с именем `MethodA`.  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько методов с указанным именем.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого метода.</param>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Нуль, чтобы было возвращено значение <see langword="null" />.</param>
        <summary>Выполняет поиск указанного метода, используя заданные ограничения привязки.</summary>
        <returns>Если поиск выполнен удачно, возвращается объект, предоставляющий метод, который соответствует указанным требованиям; в противном случае возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения методов, включаемых в поиск:  
  
-   Необходимо указать либо <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> или <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> для получения возврата.  
  
-   Укажите <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> для включения в поиск открытых методов.  
  
-   Укажите <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> для включения в поиск неоткрытые методы (то есть, закрытые, внутренние и защищенные методы).  
  
-   Укажите <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> для включения `public` и `protected` статические члены вверх по иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> модификатор флаги можно использовать для изменения условий поиска:  
  
-   <xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> Чтобы игнорировать регистр `name`.  
  
-   <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> для поиска только методы, объявленные на <xref:System.Type>, не методы, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Если метод перегружен, более одного перегруженного метода соответствует ограничениям, указанным по `bindingAttr` аргумент, метод создает <xref:System.Reflection.AmbiguousMatchException> исключение. В следующем примере создается исключение из-за:  
  
-   `TestClass` Тип имеет две перегрузки открытого экземпляра `DisplayValue` метода `DisplayValue(String)` и `DisplayValue(String, Object[])`.  
  
-   `TestClass` Тип имеет две перегрузки открытого экземпляра `Equals` метода, один из которых наследуется от <xref:System.Object>: `Equals(TestClass)` и `Equals(Object)`.  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 Необходимо выполнить одно из следующих действий, чтобы получить определенный метод:  
  
-   Измените ограничения привязки. В предыдущем примере предпринимается попытка извлечь открытый экземпляр `Equals` возвращает метод, объявленный тип и не унаследован успешно `Equals(TestClass)`.  
  
-   Вызовите перегрузку <xref:System.Type.GetMethod%2A> метод, который включает в себя `types` параметр, который определяет типы параметров метода.  
  
-   Вызовите <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> метод, чтобы получить массив, содержащий все методы, принадлежащие типу с атрибутами указанную привязку. Затем можно последовательно его для идентификации повторяющихся методов, с именем `name`. Этот подход показан в предыдущем примере обработчик <xref:System.Reflection.AmbiguousMatchException> исключение.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MethodInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object> при наличии без ограничения класса.  
  
> [!NOTE]
>  Универсальные методы не включать аргументы типа в `name`. Например, код C# `GetMember("MyMethod<int>")` ищет элемент с именем текст «`MyMethod<int>`», а не для метода с именем `MyMethod` , имеет один аргумент универсального типа `int`.  
  
   
  
## Examples  
 Следующий пример возвращает метод, который соответствует указанным флагам привязки.  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько методов с указанным именем и соответствующих указанным ограничениям привязки.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого открытого метода.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого метода.  
  
 - или -  
  
 Пустой массив объектов <see cref="T:System.Type" /> (в соответствии со значением поля <see cref="F:System.Type.EmptyTypes" />) для получения метода, не принимающего параметры.</param>
        <summary>Ищет указанный открытый метод, параметры которого соответствуют заданным типам аргументов.</summary>
        <returns>Объект, представляющий открытый метод, параметры которого соответствуют указанным типам аргументов, если они существуют, и <see langword="null" />, если их нет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск `name` учитывается регистр. При поиске учитываются открытые статические и открытые методы экземпляра.  
  
> [!NOTE]
>  Необходимо указывать все параметры при поиске конструкторов и методов. Параметры можно опустить только в том случае, при вызове метода.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MethodInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object> при наличии без ограничения класса.  
  
> [!NOTE]
>  `name` Параметра не может содержать аргументов типа. Например, код C# `GetMethod("MyGenericMethod<int>")` ищет метод с именем текст «`MyGenericMethod<int>`», а не для метода с именем `MyGenericMethod` , имеет один аргумент универсального типа `int`. Вместо этого используйте `GetMethod("MyGenericMethod")` с помощью соответствующего параметра в `types` массива.  
  
   
  
## Examples  
 В следующем примере вычисляется заданной перегрузки метода `MethodA`, указание различных типов аргументов.  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Примера требуется `/unsafe` параметр компилятора.  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 В следующем примере извлекается <xref:System.Reflection.MethodInfo> объекты, представляющие `Add` методы, не являющегося универсальным типа ( <xref:System.Collections.ArrayList> класса), открытым универсальным типом ( <xref:System.Collections.Generic.List%601> класса) и закрытый универсальный тип ( `List(Of String)` типа.  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 В примере определяется `GetAddMethod` метод, который получает соответствующий <xref:System.Reflection.MethodInfo> объекта. Для обеспечения `types` аргумент открытый универсальный тип, он вызывает <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> метод. Для обеспечения `types` аргумент для закрытого универсального типа, он возвращает значение <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> свойства.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько методов с указанным именем и заданными параметрами.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="types" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Массив <paramref name="types" /> является многомерным.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого открытого метода.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого метода.  
  
 - или -  
  
 Пустой массив объектов <see cref="T:System.Type" /> (в соответствии со значением поля <see cref="F:System.Type.EmptyTypes" />) для получения метода, не принимающего параметры.</param>
        <param name="modifiers">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <c>types</c>. Используется только при вызове посредством COM-взаимодействия. При этом обрабатываются только параметры, переданные по ссылке. Связыватель по умолчанию не обрабатывает этот параметр.</param>
        <summary>Выполняет поиск указанного открытого метода, параметры которого соответствуют указанным типам аргументов и модификаторам.</summary>
        <returns>Если поиск выполнен успешно, возвращается объект, представляющий открытый метод, который соответствует указанным требованиям; в противном случае возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то что связыватель по умолчанию не обрабатывает <xref:System.Reflection.ParameterModifier> ( `modifiers` параметр), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс, чтобы написать собственный связыватель, обрабатывающий `modifiers`. `ParameterModifier` используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.  
  
 Поиск `name` учитывается регистр. При поиске учитываются открытые статические и открытые методы экземпляра.  
  
> [!NOTE]
>  Необходимо указывать все параметры при поиске конструкторов и методов. Параметры можно опустить только в том случае, при вызове метода.  
  
 Если текущий объект T:System.Type представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MethodInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object> при наличии без ограничения класса.  
  
> [!NOTE]
>  Универсальные методы не включать аргументы типа в `name`. Например, код C# `GetMethod("MyMethod<int>")` ищет элемент с именем текст «`MyMethod<int>`», а не для метода с именем `MyMethod` , имеет один аргумент универсального типа `int`. Вместо этого используйте `GetMethod("MyMethod")` с помощью соответствующего параметра в `types` массива.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько методов с указанным именем и заданными параметрами.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="types" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Массив <paramref name="types" /> является многомерным.  
  
 - или -  
  
 Массив <paramref name="modifiers" /> является многомерным.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого метода.</param>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Нуль, чтобы было возвращено значение <see langword="null" />.</param>
        <param name="binder">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.  
  
 - или -  
  
 Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого метода.  
  
 - или -  
  
 Пустой массив объектов <see cref="T:System.Type" /> (в соответствии со значением поля <see cref="F:System.Type.EmptyTypes" />) для получения метода, не принимающего параметры.</param>
        <param name="modifiers">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <c>types</c>. Используется только при вызове посредством COM-взаимодействия. При этом обрабатываются только параметры, переданные по ссылке. Связыватель по умолчанию не обрабатывает этот параметр.</param>
        <summary>Ищет заданный метод, параметры которого соответствуют указанным типам аргументов и модификаторам, используя установленные ограничения привязки.</summary>
        <returns>Если поиск выполнен удачно, возвращается объект, предоставляющий метод, который соответствует указанным требованиям; в противном случае возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то что связыватель по умолчанию не обрабатывает <xref:System.Reflection.ParameterModifier> ( `modifiers` параметр), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс, чтобы написать собственный связыватель, обрабатывающий `modifiers`. `ParameterModifier` используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения методов, включаемых в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` для получения возврата.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых методов.  
  
-   Укажите `BindingFlags.NonPublic` для включения закрытых методов (то есть, закрытые, внутренние и защищенные методы) в поиск.  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверх по иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> модификатор флаги можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только методы, объявленные на <xref:System.Type>, не методы, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Необходимо указывать все параметры при поиске конструкторов и методов. Параметры можно опустить только в том случае, при вызове метода.  
  
 Если текущий объект T:System.Type представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MethodInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object> при наличии без ограничения класса.  
  
> [!NOTE]
>  Универсальные методы не включать аргументы типа в `name`. Например, код C# `GetMember("MyMethod<int>")` ищет элемент с именем текст «`MyMethod<int>`», а не для метода с именем `MyMethod` , имеет один аргумент универсального типа `int`.  
  
   
  
## Examples  
 В следующем примере вычисляется заданной перегрузки метода `MethodA`, указав ограничений привязки и различных типов аргументов.  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Примера требуется `/unsafe` параметр компилятора.  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько методов с указанным именем и соответствующих указанным ограничениям привязки.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="types" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Массив <paramref name="types" /> является многомерным.  
  
 - или -  
  
 Массив <paramref name="modifiers" /> является многомерным.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого метода.</param>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Нуль, чтобы было возвращено значение <see langword="null" />.</param>
        <param name="binder">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.  
  
 - или -  
  
 Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Объект, определяющий набор применяемых правил, касающихся порядка и расположения аргументов, способа передачи возвращаемого значения, регистров, используемых для аргументов, и способа очистки стека.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого метода.  
  
 - или -  
  
 Пустой массив объектов <see cref="T:System.Type" /> (в соответствии со значением поля <see cref="F:System.Type.EmptyTypes" />) для получения метода, не принимающего параметры.</param>
        <param name="modifiers">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <c>types</c>. Используется только при вызове посредством COM-взаимодействия. При этом обрабатываются только параметры, переданные по ссылке. Связыватель по умолчанию не обрабатывает этот параметр.</param>
        <summary>Ищет метод с параметрами, соответствующими указанным модификаторам и типам аргументов, с учетом заданных ограничений привязки и соглашений о вызовах.</summary>
        <returns>Если поиск выполнен удачно, возвращается объект, предоставляющий метод, который соответствует указанным требованиям; в противном случае возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то что связыватель по умолчанию не обрабатывает <xref:System.Reflection.ParameterModifier> ( `modifiers` параметр), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс, чтобы написать собственный связыватель, обрабатывающий `modifiers`. `ParameterModifier` используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `GetXXX` методов при отражении в типе.  
  
|Тип члена|Static|Нестатический|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события, которые по имени и подписи. Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.  
  
3.  Пользовательские атрибуты не являются частью системы общих типов.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения методов, включаемых в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` для получения возврата.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых методов.  
  
-   Укажите `BindingFlags.NonPublic` для включения закрытых методов (то есть, закрытые, внутренние и защищенные методы) в поиск.  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверх по иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> модификатор флаги можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только методы, объявленные на <xref:System.Type>, не методы, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Необходимо указывать все параметры при поиске конструкторов и методов. Параметры можно опустить только в том случае, при вызове метода.  
  
 Если текущий объект T:System.Type представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MethodInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object> при наличии без ограничения класса.  
  
> [!NOTE]
>  Универсальные методы не включать аргументы типа в `name`. Например, код C# `GetMember("MyMethod<int>")` ищет элемент с именем текст «`MyMethod<int>`», а не для метода с именем `MyMethod` , имеет один аргумент универсального типа `int`.  
  
   
  
## Examples  
 В следующем примере вычисляется заданной перегрузки метода `MethodA`, указав ограничениям привязки, соглашения о вызовах и различных типов аргументов.  
  
> [!NOTE]
>  [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Примера требуется `/unsafe` параметр компилятора.  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько методов с указанным именем и соответствующих указанным ограничениям привязки.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="types" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Массив <paramref name="types" /> является многомерным.  
  
 - или -  
  
 Массив <paramref name="modifiers" /> является многомерным.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого метода.</param>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Нуль, чтобы было возвращено значение <see langword="null" />.</param>
        <param name="binder">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.  
  
 - или -  
  
 Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Объект, который задает набор правил, используемых в зависимости от порядка и расположения аргументов, способа передачи возвращаемого значения, регистров, используемых для аргументов, и процесса очистки стека.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого метода.  
  
 - или -  
  
 Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить метод, который не имеет параметров.  
  
 - или -  
  
 <see langword="null" />. Если значение параметра <c>types</c> равно <see langword="null" />, аргументы не проверяются на соответствие условиям.</param>
        <param name="modifiers">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <c>types</c>. Связыватель по умолчанию не обрабатывает этот параметр.</param>
        <summary>При переопределении в производном классе ищет указанный метод, параметры которого соответствуют указанным типам аргументов и модификаторам, используя для этого заданные ограничения привязки и соглашение о вызовах.</summary>
        <returns>Если поиск выполнен удачно, возвращается объект, предоставляющий метод, который соответствует указанным требованиям; в противном случае возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то что связыватель по умолчанию не обрабатывает <xref:System.Reflection.ParameterModifier> ( `modifiers` параметр), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс, чтобы написать собственный связыватель, обрабатывающий `modifiers`. `ParameterModifier` используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.  
  
 Если значение параметра `types` равно `null`, аргументы метода не проверяются на соответствие условиям.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения методов, включаемых в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` для получения возврата.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых методов.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск неоткрытые методы (то есть, закрытые, внутренние и защищенные методы).  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверх по иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> модификатор флаги можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только методы, объявленные на <xref:System.Type>, не методы, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько методов с указанным именем и соответствующих указанным ограничениям привязки.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Массив <paramref name="types" /> является многомерным.  
  
 - или -  
  
 Массив <paramref name="modifiers" /> является многомерным.  
  
 - или -  
  
 <paramref name="types" /> и <paramref name="modifiers" /> имеют разную длину.</exception>
        <exception cref="T:System.NotSupportedException">Текущий тип является объектом <see cref="T:System.Reflection.Emit.TypeBuilder" /> или <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает методы текущего объекта <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает все открытые методы текущего объекта <see cref="T:System.Type" />.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.MethodInfo" />, представляющий все открытые методы, определенные для текущего объекта <see cref="T:System.Type" />.  
  
 - или -  
  
 Пустой массив типа <see cref="T:System.Reflection.MethodInfo" />, если для текущего типа <see cref="T:System.Type" /> открытые методы не определены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetMethods%2A> Метод не возвращает методы в определенном порядке, например алфавитном или в порядке объявления. Код не должен зависеть от порядка, в котором возвращаются методы, так как этот порядок меняется.  
  
 Конструкторы не включаются в массив методов, возвращаемый при вызове этого метода. Убедитесь в отдельный вызов `GetConstructors()` для получения методов конструктора.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методов при отражении в типе.  
  
|Тип члена|Static|Нестатический|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события, которые по имени и подписи. Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.  
  
3.  Пользовательские атрибуты не являются частью системы общих типов.  
  
> [!NOTE]
>  Необходимо указывать все параметры при поиске конструкторов и методов. Параметры можно опустить только в том случае, при вызове метода.  
  
 Если текущий объект T:System.Type представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MethodInfo> объекты с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object> при наличии без ограничения класса.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Нуль, чтобы было возвращено значение <see langword="null" />.</param>
        <summary>При переопределении в производном классе ищет методы, определенные для текущего объекта <see cref="T:System.Type" />, используя указанные ограничения привязки.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.MethodInfo" />, представляющий все методы, определенные для текущего типа <see cref="T:System.Type" /> и удовлетворяющие указанным ограничениям привязки.  
  
 - или -  
  
 Пустой массив типа <see cref="T:System.Reflection.MethodInfo" />, если для текущего объекта <see cref="T:System.Type" /> не определены методы или ни один из определенных методов не удовлетворяет ограничениям привязки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetMethods%2A> Метод не возвращает методы в определенном порядке, например алфавитном или в порядке объявления. Код не должен зависеть от порядка, в котором возвращаются методы, так как этот порядок меняется.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения методов, включаемых в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` для получения возврата.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых методов.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск неоткрытые методы (то есть, закрытые, внутренние и защищенные методы). Только защищенные и внутренние методы базовых классов, возвращаются; закрытые методы базовых классов не возвращаются.  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверх по иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> модификатор флаги можно использовать для изменения условий поиска:  
  
-   `BindingFlags.DeclaredOnly` для поиска только методы, объявленные на <xref:System.Type>, не методы, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Необходимо указывать все параметры при поиске конструкторов и методов. Параметры можно опустить только в том случае, при вызове метода.  
  
 Если текущий объект T:System.Type представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.MethodInfo> объекты с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод ищет методы ограничения класса или методы <xref:System.Object> при наличии без ограничения класса.  
  
   
  
## Examples  
 Следующий пример создает класс с два открытых метода и один защищенный метод, создает `Type` объект, соответствующий `MyTypeClass`, возвращает все открытые и неоткрытые методы и отображаются их имена.  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает определенный тип, вложенный в текущий объект <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого вложенного типа.</param>
        <summary>Выполняет поиск открытого вложенного типа с заданным именем.</summary>
        <returns>Объект, представляющий открытый вложенный тип с указанным именем, если тип есть, и <see langword="null" />, если такого типа нет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск `name` учитывается регистр.  
  
 Можно использовать простое имя вложенного класса для `name`. Не уточните его, указав имя внешнего класса. Для универсального вложенного класса следует использовать искаженное имя — то есть присоединения грависом и число универсальных аргументов. Например, используйте строку «внутреннее\`1» для получения универсального вложенных классов `Inner<T>` (`Inner(Of T)` в Visual Basic). Не включайте особый синтаксис для параметров типа.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методов при отражении в типе.  
  
|Тип члена|Static|Нестатический|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события, которые по имени и подписи. Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.  
  
3.  Пользовательские атрибуты не являются частью системы общих типов.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет вложенные типы ограничения класса.  
  
 Если вложенный тип является универсальным, этот метод возвращает определение универсального типа. Это верно, даже если включающий универсальный тип является закрытым сконструированным типом.  
  
> [!NOTE]
>  Если текущий <xref:System.Type> представляет универсальный тип, определенный в C#, Visual Basic или C++, его вложенные типы являются универсальными, даже если они не имеют своих собственных имеет тех универсальных параметров. Это не всегда справедливо для вложенных типов, определенных в динамических сборках или скомпилированных с [Ilasm.exe (ассемблер IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Сведения о вложенных универсальных типов и конструировании вложенных универсальных типов из их определений универсальных типов см. в разделе <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя искомого вложенного типа.</param>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Нуль, чтобы было возвращено значение <see langword="null" />.</param>
        <summary>При переопределении в производном классе ищет указанный вложенный тип, используя заданные ограничения привязки.</summary>
        <returns>Если поиск выполнен успешно, возвращается объект, предоставляющий вложенный тип, который соответствует указанным требованиям; в противном случае возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать простое имя вложенного класса для `name`. Не уточните его, указав имя внешнего класса. Для универсального вложенного класса следует использовать искаженное имя — то есть присоединения грависом и число универсальных параметров. Например, используйте строку «внутреннее\`1» для получения универсального вложенных классов `Inner<T>` (`Inner(Of T)` в Visual Basic). Не включайте особый синтаксис для параметров типа.  
  
 Следующие <xref:System.Reflection.BindingFlags> фильтра флаги, которые можно использовать для определения, какие вложенные типы будут включены в поиск:  
  
-   Необходимо указать либо <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> или <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> для получения возврата.  
  
-   Укажите <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> для включения в поиск открытые вложенные типы.  
  
-   Укажите <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> для включения при поиске не являющиеся открытыми вложенные типы (то есть, закрытые, внутренние и защищенные вложенные типы).  
  
 Этот метод возвращает только вложенные типы текущего типа. Он не выполняет поиск базовые классы для текущего типа. Чтобы найти типы, вложенные в базовых классах, необходимо пройти в иерархии наследования, вызов <xref:System.Type.GetNestedType%2A> на каждом уровне.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> игнорируются.  
  
 Вызов этого метода только с <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> флаг или только <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> флаг возвратит все указанные вложенные типы и другие флаги не требуются.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет вложенные типы ограничения класса.  
  
 Если вложенный тип является универсальным, этот метод возвращает определение универсального типа. Это верно, даже если включающий универсальный тип является закрытым сконструированным типом.  
  
> [!NOTE]
>  Если текущий <xref:System.Type> представляет универсальный тип, определенный в C#, Visual Basic или C++, его вложенные типы являются универсальными, даже если они не имеют своих собственных имеет тех универсальных параметров. Это не всегда справедливо для вложенных типов, определенных в динамических сборках или скомпилированных с [Ilasm.exe (ассемблер IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Сведения о вложенных универсальных типов и конструировании вложенных универсальных типов из их определений универсальных типов см. в разделе <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает типы, вложенные в текущий объект <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает открытые типы, вложенные в текущий объект <see cref="T:System.Type" />.</summary>
        <returns>Массив объектов <see cref="T:System.Type" />, представляющий открытые типы, вложенные в текущий объект <see cref="T:System.Type" /> (нерекурсивный поиск), или пустой массив типа <see cref="T:System.Type" />, если в текущий объект <see cref="T:System.Type" /> не вложен ни один открытый тип.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetNestedTypes%2A> Метод не возвращает типы в определенном порядке, например алфавитном или в порядке объявления. Код не должен зависеть от порядка, в котором возвращаются типы, так как этот порядок меняется.  
  
 Возвращаются только открытые типы, непосредственно вложенные в текущий тип; Поиск не является рекурсивным.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методов при отражении в типе.  
  
|Тип члена|Static|Нестатический|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события, которые по имени и подписи. Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.  
  
3.  Пользовательские атрибуты не являются частью системы общих типов.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет вложенные типы ограничения класса.  
  
 Если вложенный тип является универсальным, этот метод возвращает определение универсального типа. Это верно, даже если включающий универсальный тип является закрытым сконструированным типом.  
  
> [!NOTE]
>  Если текущий <xref:System.Type> представляет универсальный тип, определенный в C#, Visual Basic или C++, его вложенные типы являются универсальными, даже если они не имеют своих собственных имеет тех универсальных параметров. Это не всегда справедливо для вложенных типов, определенных в динамических сборках или скомпилированных с [Ilasm.exe (ассемблер IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Сведения о вложенных универсальных типов и конструировании вложенных универсальных типов из их определений универсальных типов см. в разделе <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 В следующем примере определяется класс является вложенным и `struct` в `MyClass`, а затем происходит получение объектов из вложенных типов, с использованием типа `MyClass`.  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Нуль, чтобы было возвращено значение <see langword="null" />.</param>
        <summary>При переопределении в производном классе ищет типы, вложенные в текущий объект <see cref="T:System.Type" />, используя заданные ограничения привязки.</summary>
        <returns>Массив объектов <see cref="T:System.Type" />, представляющий все типы, вложенные в текущий объект <see cref="T:System.Type" />, удовлетворяющий заданным ограничениям привязки (нерекурсивный поиск), или пустой массив типа <see cref="T:System.Type" />, если вложенные типы, удовлетворяющие ограничениям привязки, не найдены.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск вложенных типов не является рекурсивным.  
  
 <xref:System.Type.GetNestedTypes%2A> Метод не возвращает типы в определенном порядке, например алфавитном или в порядке объявления. Код не должен зависеть от порядка, в котором возвращаются типы, так как этот порядок меняется.  
  
 Следующие <xref:System.Reflection.BindingFlags> фильтра флаги, которые можно использовать для определения, какие вложенные типы будут включены в поиск:  
  
-   Необходимо указать либо <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> или <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> для получения возврата.  
  
-   Укажите <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> для включения в поиск открытые вложенные типы.  
  
-   Укажите <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> для включения при поиске не являющиеся открытыми вложенные типы (то есть, закрытые, внутренние и защищенные вложенные типы).  
  
 Этот метод возвращает только вложенные типы текущего типа. Он не выполняет поиск базовые классы для текущего типа. Чтобы найти типы, вложенные в базовых классах, необходимо пройти в иерархии наследования, вызов <xref:System.Type.GetNestedTypes%2A> на каждом уровне.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> и <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> игнорируются.  
  
 Вызов этого метода только с <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> флаг или только <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> флаг возвратит все указанные вложенные типы и другие флаги не требуются.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет вложенные типы ограничения класса.  
  
 Если вложенный тип является универсальным, этот метод возвращает определение универсального типа. Это верно, даже если включающий универсальный тип является закрытым сконструированным типом.  
  
> [!NOTE]
>  Если текущий <xref:System.Type> представляет универсальный тип, определенный в C#, Visual Basic или C++, его вложенные типы являются универсальными, даже если они не имеют своих собственных имеет тех универсальных параметров. Это не всегда справедливо для вложенных типов, определенных в динамических сборках или скомпилированных с [Ilasm.exe (ассемблер IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Сведения о вложенных универсальных типов и конструировании вложенных универсальных типов из их определений универсальных типов см. в разделе <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 Следующий пример создает два вложенных открытых классов и два вложенных защищенных класса и выводятся сведения о классах, которые соответствуют указанным ограничениям привязки.  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает свойства текущего объекта <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает все открытые свойства текущего объекта <see cref="T:System.Type" />.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.PropertyInfo" />, представляющий все открытые свойства текущего типа <see cref="T:System.Type" />.  
  
 - или -  
  
 Пустой массив типа <see cref="T:System.Reflection.PropertyInfo" />, если у текущего типа <see cref="T:System.Type" /> нет открытых свойств.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этой перегрузки, аналогичен вызову <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> перегрузка с `bindingAttr` аргумент равен `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` в C# и `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` в Visual Basic. Возвращает все открытые экземпляры и статических свойств, как те, которые определены по типу, представленному текущим <xref:System.Type> объекта, а также те, унаследованных из его базовых типов.  
  
 Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения. В противном случае свойство считается закрытым, а должны использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединять значения с использованием `Or`) для его получения.  
  
 <xref:System.Type.GetProperties%2A> Метод не возвращает свойства определенного порядка, например алфавитного или в порядке объявления. Код не должен зависеть от порядка, в котором возвращаются свойства, так как этот порядок меняется.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методов при отражении в типе.  
  
|Тип члена|Static|Нестатический|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события, которые по имени и подписи. Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.  
  
3.  Пользовательские атрибуты не являются частью системы общих типов.  
  
 Если текущий объект T:System.Type представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> объекты с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.  
  
   
  
## Examples  
 В следующем примере иллюстрируется использование метода `GetProperties`.  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Нуль, чтобы было возвращено значение <see langword="null" />.</param>
        <summary>При переопределении в производном классе ищет свойства текущего объекта <see cref="T:System.Type" />, используя указанные ограничения привязки.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.PropertyInfo" />, представляющий все свойства текущего типа <see cref="T:System.Type" />, которые удовлетворяют указанным ограничениям привязки.  
  
 - или -  
  
 Пустой массив типа <see cref="T:System.Reflection.PropertyInfo" />, если у текущего типа <see cref="T:System.Type" /> нет свойств или ни одно свойство не удовлетворяет ограничениям привязки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения. В противном случае свойство считается закрытым, а должны использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединять значения с использованием `Or`) для его получения.  
  
 <xref:System.Type.GetProperties%2A> Метод не возвращает свойства определенного порядка, например алфавитного или в порядке объявления. Код не должен зависеть от порядка, в котором возвращаются свойства, так как этот порядок меняется.  
  
 Следующие <xref:System.Reflection.BindingFlags> фильтра флаги, которые можно использовать для определения, какие вложенные типы будут включены в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` для получения возврата.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытые свойства.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск закрытые свойства (то есть, закрытые, внутренние и защищенные). Только защищенные и внутренние свойства базовых классов, возвращаются; частные свойства базовых классов не возвращаются.  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверх по иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> модификатор флаги можно использовать для изменения условий поиска:  
  
-   `BindingFlags.DeclaredOnly` для поиска только свойства, объявленные в <xref:System.Type>, не те свойства, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения. В противном случае свойство считается закрытым, а должны использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединять значения с использованием `Or`) для его получения.  
  
 Если текущий объект T:System.Type представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> объекты с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.  
  
   
  
## Examples  
 В следующем примере определяется класс с именем `PropertyClass` , включает шесть свойств: два являются открытыми, один является закрытым, один защищен, один внутренний (`Friend` в Visual Basic), и один protected internal (`Protected Friend` в Visual Basic). Отобразятся сведения о некоторых основных свойств (имя свойства и тип, следует ли — чтение и запись и видимость его `get` и `set` методы доступа) для свойства, которые соответствуют указанным ограничениям привязки.  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает указанное свойство текущего класса <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая искомое имя открытого свойства.</param>
        <summary>Выполняет поиск открытого свойства с заданным именем.</summary>
        <returns>Объект, представляющий открытое свойство с заданным именем, если такое свойство есть, и <see langword="null" />, если такого свойства нет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поиск `name` учитывается регистр. При поиске учитываются открытые статические и открытые свойства экземпляра.  
  
 Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения. В противном случае свойство считается закрытым, а должны использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединять значения с использованием `Or`) для его получения.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.  
  
 В ситуациях, когда <xref:System.Reflection.AmbiguousMatchException> происходит включают следующее:  
  
-   Тип содержит два индексированные свойства, имеющие одинаковое имя, но различное число параметров. Для устранения неоднозначности, используйте перегрузку <xref:System.Type.GetProperty%2A> метод, который задает типы параметров.  
  
-   Производный тип объявляет свойство, которое скрывает унаследованное свойство с тем же именем, используя `new` модификатор (`Shadows` в Visual Basic). Для устранения неоднозначности используйте <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> перегрузки метода и добавьте <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> флаг для ограничения поиска к элементам, которые не наследуются.  
  
## <a name="indexers-and-default-properties"></a>Индексаторы и свойства по умолчанию  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], и [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] обладают упрощенным синтаксисом для доступа к индексированным свойствам и разрешить индексированного свойства по умолчанию, для его типа. Например если переменная `myList` ссылается на <xref:System.Collections.ArrayList>, синтаксис `myList[3]` (`myList(3)` в Visual Basic) извлекает элемент с индексом 3. Данное свойство можно перегрузить.  
  
 В C# эта функция вызывается индексатором и нельзя ссылаться по имени. По умолчанию индексатор C# отображается в метаданных как индексированное свойство с именем «Item». Тем не менее, можно использовать класс библиотеки разработчик <xref:System.Runtime.CompilerServices.IndexerNameAttribute> атрибут, чтобы изменить имя индексатора в метаданных. Например <xref:System.String> класс имеет индекс с именем <xref:System.String.Chars%2A>. Индексированные свойства, созданные с помощью языков, отличных от C# могут иметь имена отличные от элемента, а также.  
  
 Чтобы определить, является ли тип имеет свойство по умолчанию, используйте <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> метод для проверки на наличие <xref:System.Reflection.DefaultMemberAttribute> атрибута. Если тип имеет <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> свойство возвращает имя свойства по умолчанию.  
  
   
  
## Examples  
 В следующем примере извлекается `Type` объекта пользовательский класс, извлекается свойство этого класса и отображается имя этого свойства.  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 Это свойство имеет внутреннее в метаданных с именем «Item». Любая попытка получить `PropertyInfo` с помощью отражения необходимо указать это внутреннее имя, чтобы правильно возвращает `PropertyInfo` свойство.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько свойств с указанным именем.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащий имя искомого свойства.</param>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Нуль, чтобы было возвращено значение <see langword="null" />.</param>
        <summary>Ищет указанное свойство, используя заданные ограничения привязки.</summary>
        <returns>Объект, предоставляющий свойство, которое соответствует указанным требованиям, если такое свойство найдено; в противном случае возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения. В противном случае свойство считается закрытым, а должны использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединять значения с использованием `Or`) для его получения.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения, какие свойства будут включены в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` для получения возврата.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытые свойства.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск закрытые свойства (то есть, закрытые, внутренние и защищенные).  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверх по иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> модификатор флаги можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только свойства, объявленные в <xref:System.Type>, не те свойства, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.  
  
 В ситуациях, когда <xref:System.Reflection.AmbiguousMatchException> происходит включают следующее:  
  
-   Тип содержит два индексированные свойства, имеющие одинаковое имя, но различное число параметров. Для устранения неоднозначности, используйте перегрузку <xref:System.Type.GetProperty%2A> метод, который задает типы параметров.  
  
-   Производный тип объявляет свойство, которое скрывает унаследованное свойство с тем же именем, используя `new` модификатор (`Shadows` в Visual Basic). Чтобы устранить неоднозначность, включите <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> для ограничения поиска к элементам, которые не наследуются.  
  
## <a name="indexers-and-default-properties"></a>Индексаторы и свойства по умолчанию  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], и [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] обладают упрощенным синтаксисом для доступа к индексированным свойствам и разрешить индексированного свойства по умолчанию, для его типа. Например если переменная `myList` ссылается на <xref:System.Collections.ArrayList>, синтаксис `myList[3]` (`myList(3)` в Visual Basic) извлекает элемент с индексом 3. Данное свойство можно перегрузить.  
  
 В C# эта функция вызывается индексатором и нельзя ссылаться по имени. По умолчанию индексатор C# отображается в метаданных как индексированное свойство с именем «Item». Тем не менее, можно использовать класс библиотеки разработчик <xref:System.Runtime.CompilerServices.IndexerNameAttribute> атрибут, чтобы изменить имя индексатора в метаданных. Например <xref:System.String> класс имеет индекс с именем <xref:System.String.Chars%2A>. Индексированные свойства, созданные с помощью языков, отличных от C# могут иметь имена отличные от элемента, а также.  
  
 Чтобы определить, является ли тип имеет свойство по умолчанию, используйте <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> метод для проверки на наличие <xref:System.Reflection.DefaultMemberAttribute> атрибута. Если тип имеет <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> свойство возвращает имя свойства по умолчанию.  
  
   
  
## Examples  
 В следующем примере извлекается тип пользовательского класса, извлекается свойство этого класса и отображается имя этого свойства в соответствии с учетом заданных ограничений привязки.  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько свойств с указанным именем, соответствующих указанным ограничениям привязки.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая искомое имя открытого свойства.</param>
        <param name="returnType">Тип возвращаемого значения свойства.</param>
        <summary>Выполняет поиск открытого свойства с заданным именем и типом возвращаемого значения.</summary>
        <returns>Объект, представляющий открытое свойство с заданным именем, если такое свойство есть, и <see langword="null" />, если такого свойства нет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения. В противном случае свойство считается закрытым, а должны использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединять значения с использованием `Or`) для его получения.  
  
 Поиск `name` учитывается регистр. При поиске учитываются открытые статические и открытые свойства экземпляра.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.  
  
## <a name="indexers-and-default-properties"></a>Индексаторы и свойства по умолчанию  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], и [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] обладают упрощенным синтаксисом для доступа к индексированным свойствам и разрешить индексированного свойства по умолчанию, для его типа. Например если переменная `myList` ссылается на <xref:System.Collections.ArrayList>, синтаксис `myList[3]` (`myList(3)` в Visual Basic) извлекает элемент с индексом 3. Данное свойство можно перегрузить.  
  
 В C# эта функция вызывается индексатором и нельзя ссылаться по имени. По умолчанию индексатор C# отображается в метаданных как индексированное свойство с именем «Item». Тем не менее, можно использовать класс библиотеки разработчик <xref:System.Runtime.CompilerServices.IndexerNameAttribute> атрибут, чтобы изменить имя индексатора в метаданных. Например <xref:System.String> класс имеет индекс с именем <xref:System.String.Chars%2A>. Индексированные свойства, созданные с помощью языков, отличных от C# могут иметь имена отличные от элемента, а также.  
  
 Чтобы определить, является ли тип имеет свойство по умолчанию, используйте <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> метод для проверки на наличие <xref:System.Reflection.DefaultMemberAttribute> атрибута. Если тип имеет <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> свойство возвращает имя свойства по умолчанию.  
  
   
  
## Examples  
 В следующем примере определяется класс с одним свойством и извлекаются имя и тип свойства.  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько свойств с указанным именем.</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="name" /> имеет значение <see langword="null" />, или параметр <paramref name="returnType" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая искомое имя открытого свойства.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого индексированного свойства.  
  
 - или -  
  
 Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить неиндексированное свойство.</param>
        <summary>Ищет указанное открытое свойство, параметры которого соответствуют указанным типам аргументов.</summary>
        <returns>Объект, представляющий открытое свойство, параметры которого соответствуют указанным условиям, если такое свойство существует, и <see langword="null" />, если такого свойства нет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения. В противном случае свойство считается закрытым, а должны использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединять значения с использованием `Or`) для его получения.  
  
 Поиск `name` учитывается регистр. При поиске учитываются открытые статические и открытые свойства экземпляра.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.  
  
## <a name="indexers-and-default-properties"></a>Индексаторы и свойства по умолчанию  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], и [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] обладают упрощенным синтаксисом для доступа к индексированным свойствам и разрешить индексированного свойства по умолчанию, для его типа. Например если переменная `myList` ссылается на <xref:System.Collections.ArrayList>, синтаксис `myList[3]` (`myList(3)` в Visual Basic) извлекает элемент с индексом 3. Данное свойство можно перегрузить.  
  
 В C# эта функция вызывается индексатором и нельзя ссылаться по имени. По умолчанию индексатор C# отображается в метаданных как индексированное свойство с именем «Item». Тем не менее, можно использовать класс библиотеки разработчик <xref:System.Runtime.CompilerServices.IndexerNameAttribute> атрибут, чтобы изменить имя индексатора в метаданных. Например <xref:System.String> класс имеет индекс с именем <xref:System.String.Chars%2A>. Индексированные свойства, созданные с помощью языков, отличных от C# могут иметь имена отличные от элемента, а также.  
  
 Чтобы определить, является ли тип имеет свойство по умолчанию, используйте <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> метод для проверки на наличие <xref:System.Reflection.DefaultMemberAttribute> атрибута. Если тип имеет <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> свойство возвращает имя свойства по умолчанию.  
  
   
  
## Examples  
 В следующем примере извлекается `Type` объекта пользовательский класс, извлекается свойство этого класса и отображается имя свойства и тип свойства, заданные аргументы, передаваемые `GetProperty`.  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько свойств с указанным именем и соответствующих указанным типам аргументов.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Массив <paramref name="types" /> является многомерным.</exception>
        <exception cref="T:System.NullReferenceException">Элемент <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая искомое имя открытого свойства.</param>
        <param name="returnType">Тип возвращаемого значения свойства.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого индексированного свойства.  
  
 - или -  
  
 Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить неиндексированное свойство.</param>
        <summary>Ищет указанное открытое свойство, параметры которого соответствуют указанным типам аргументов.</summary>
        <returns>Объект, представляющий открытое свойство, параметры которого соответствуют указанным условиям, если такое свойство существует, и <see langword="null" />, если такого свойства нет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения. В противном случае свойство считается закрытым, а должны использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединять значения с использованием `Or`) для его получения.  
  
 Поиск `name` учитывается регистр. При поиске учитываются открытые статические и открытые свойства экземпляра.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.  
  
## <a name="indexers-and-default-properties"></a>Индексаторы и свойства по умолчанию  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], и [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] обладают упрощенным синтаксисом для доступа к индексированным свойствам и разрешить индексированного свойства по умолчанию, для его типа. Например если переменная `myList` ссылается на <xref:System.Collections.ArrayList>, синтаксис `myList[3]` (`myList(3)` в Visual Basic) извлекает элемент с индексом 3. Данное свойство можно перегрузить.  
  
 В C# эта функция вызывается индексатором и нельзя ссылаться по имени. По умолчанию индексатор C# отображается в метаданных как индексированное свойство с именем «Item». Тем не менее, можно использовать класс библиотеки разработчик <xref:System.Runtime.CompilerServices.IndexerNameAttribute> атрибут, чтобы изменить имя индексатора в метаданных. Например <xref:System.String> класс имеет индекс с именем <xref:System.String.Chars%2A>. Индексированные свойства, созданные с помощью языков, отличных от C# могут иметь имена отличные от элемента, а также.  
  
 Чтобы определить, является ли тип имеет свойство по умолчанию, используйте <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> метод для проверки на наличие <xref:System.Reflection.DefaultMemberAttribute> атрибута. Если тип имеет <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> свойство возвращает имя свойства по умолчанию.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько свойств с указанным именем и соответствующих указанным типам аргументов.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Массив <paramref name="types" /> является многомерным.</exception>
        <exception cref="T:System.NullReferenceException">Элемент <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая искомое имя открытого свойства.</param>
        <param name="returnType">Тип возвращаемого значения свойства.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого индексированного свойства.  
  
 - или -  
  
 Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить неиндексированное свойство.</param>
        <param name="modifiers">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <c>types</c>. Связыватель по умолчанию не обрабатывает этот параметр.</param>
        <summary>Ищет заданное открытое свойство, параметры которого соответствуют указанным типам аргументов и модификаторам.</summary>
        <returns>Объект, представляющий открытое свойство, которое соответствует указанным требованиям, если такое свойство найдено; в противном случае возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения. В противном случае свойство считается закрытым, а должны использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединять значения с использованием `Or`) для его получения.  
  
 Несмотря на то что связыватель по умолчанию не обрабатывает <xref:System.Reflection.ParameterModifier> ( `modifiers` параметр), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс, чтобы написать собственный связыватель, обрабатывающий `modifiers`. `ParameterModifier` используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.  
  
 Поиск `name` учитывается регистр. При поиске учитываются открытые статические и открытые свойства экземпляра.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.  
  
## <a name="indexers-and-default-properties"></a>Индексаторы и свойства по умолчанию  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], и [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] обладают упрощенным синтаксисом для доступа к индексированным свойствам и разрешить индексированного свойства по умолчанию, для его типа. Например если переменная `myList` ссылается на <xref:System.Collections.ArrayList>, синтаксис `myList[3]` (`myList(3)` в Visual Basic) извлекает элемент с индексом 3. Данное свойство можно перегрузить.  
  
 В C# эта функция вызывается индексатором и нельзя ссылаться по имени. По умолчанию индексатор C# отображается в метаданных как индексированное свойство с именем «Item». Тем не менее, можно использовать класс библиотеки разработчик <xref:System.Runtime.CompilerServices.IndexerNameAttribute> атрибут, чтобы изменить имя индексатора в метаданных. Например <xref:System.String> класс имеет индекс с именем <xref:System.String.Chars%2A>. Индексированные свойства, созданные с помощью языков, отличных от C# могут иметь имена отличные от элемента, а также.  
  
 Чтобы определить, является ли тип имеет свойство по умолчанию, используйте <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> метод для проверки на наличие <xref:System.Reflection.DefaultMemberAttribute> атрибута. Если тип имеет <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> свойство возвращает имя свойства по умолчанию.  
  
   
  
## Examples  
 В следующем примере извлекается `Type` объект, соответствующий `MyPropertyClass`, и индексированного свойства этого класса, извлекаются с помощью аргументы, передаваемые `GetProperty` метод.  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько свойств с указанным именем и соответствующих указанным типам аргументов и модификаторам.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Массив <paramref name="types" /> является многомерным.  
  
 - или -  
  
 Массив <paramref name="modifiers" /> является многомерным.  
  
 - или -  
  
 <paramref name="types" /> и <paramref name="modifiers" /> имеют разную длину.</exception>
        <exception cref="T:System.NullReferenceException">Элемент <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащий имя искомого свойства.</param>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Нуль, чтобы было возвращено значение <see langword="null" />.</param>
        <param name="binder">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.  
  
 - или -  
  
 Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="returnType">Тип возвращаемого значения свойства.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого индексированного свойства.  
  
 - или -  
  
 Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить неиндексированное свойство.</param>
        <param name="modifiers">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <c>types</c>. Связыватель по умолчанию не обрабатывает этот параметр.</param>
        <summary>Ищет свойство с параметрами, соответствующими указанным модификаторам и типам аргументов, с учетом заданных ограничений привязки.</summary>
        <returns>Объект, предоставляющий свойство, которое соответствует указанным требованиям, если такое свойство найдено; в противном случае возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если у него есть хотя бы один открытый метод доступа, свойство считается открытым для отражения. В противном случае свойство считается закрытым, а должны использовать <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (в Visual Basic, объединять значения с использованием `Or`) для его получения.  
  
 Несмотря на то что связыватель по умолчанию не обрабатывает <xref:System.Reflection.ParameterModifier> ( `modifiers` параметр), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс, чтобы написать собственный связыватель, обрабатывающий `modifiers`. `ParameterModifier` используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методов при отражении в типе.  
  
|Тип члена|Static|Нестатический|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события, которые по имени и подписи. Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.  
  
3.  Пользовательские атрибуты не являются частью системы общих типов.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения, какие свойства будут включены в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` для получения возврата.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытые свойства.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск закрытые свойства (то есть, закрытые, внутренние и защищенные).  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверх по иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> модификатор флаги можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только свойства, объявленные в <xref:System.Type>, не те свойства, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, этот метод возвращает <xref:System.Reflection.PropertyInfo> с параметрами типа, заменены соответствующими аргументами типа.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, этот метод ищет свойства ограничения класса.  
  
## <a name="indexers-and-default-properties"></a>Индексаторы и свойства по умолчанию  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], и [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] обладают упрощенным синтаксисом для доступа к индексированным свойствам и разрешить индексированного свойства по умолчанию, для его типа. Например если переменная `myList` ссылается на <xref:System.Collections.ArrayList>, синтаксис `myList[3]` (`myList(3)` в Visual Basic) извлекает элемент с индексом 3. Данное свойство можно перегрузить.  
  
 В C# эта функция вызывается индексатором и нельзя ссылаться по имени. По умолчанию индексатор C# отображается в метаданных как индексированное свойство с именем «Item». Тем не менее, можно использовать класс библиотеки разработчик <xref:System.Runtime.CompilerServices.IndexerNameAttribute> атрибут, чтобы изменить имя индексатора в метаданных. Например <xref:System.String> класс имеет индекс с именем <xref:System.String.Chars%2A>. Индексированные свойства, созданные с помощью языков, отличных от C# могут иметь имена отличные от элемента, а также.  
  
 Чтобы определить, является ли тип имеет свойство по умолчанию, используйте <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> метод для проверки на наличие <xref:System.Reflection.DefaultMemberAttribute> атрибута. Если тип имеет <xref:System.Reflection.DefaultMemberAttribute>, <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> свойство возвращает имя свойства по умолчанию.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько свойств с указанным именем, соответствующих указанным ограничениям привязки.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Массив <paramref name="types" /> является многомерным.  
  
 - или -  
  
 Массив <paramref name="modifiers" /> является многомерным.  
  
 - или -  
  
 <paramref name="types" /> и <paramref name="modifiers" /> имеют разную длину.</exception>
        <exception cref="T:System.NullReferenceException">Элемент <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащий имя искомого свойства.</param>
        <param name="bindingAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск.  
  
 - или -  
  
 Нуль, чтобы было возвращено значение <see langword="null" />.</param>
        <param name="binder">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженного члена, приведение типов аргументов и вызов члена с помощью отражения.  
  
 - или -  
  
 Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="returnType">Тип возвращаемого значения свойства.</param>
        <param name="types">Массив объектов <see cref="T:System.Type" />, предоставляющий число, порядок и тип параметров искомого индексированного свойства.  
  
 - или -  
  
 Пустой массив объектов типа <see cref="T:System.Type" /> (то есть Type[] types = new Type[0]), если требуется получить неиндексированное свойство.</param>
        <param name="modifiers">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <c>types</c>. Связыватель по умолчанию не обрабатывает этот параметр.</param>
        <summary>При переопределении в производном классе выполняет поиск заданного свойства, параметры которого соответствуют типам и модификаторам заданных аргументов, с использованием заданных ограничений привязки.</summary>
        <returns>Объект, предоставляющий свойство, которое соответствует указанным требованиям, если такое свойство найдено; в противном случае возвращается <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то что связыватель по умолчанию не обрабатывает <xref:System.Reflection.ParameterModifier> ( `modifiers` параметр), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс, чтобы написать собственный связыватель, обрабатывающий `modifiers`. `ParameterModifier` используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения, какие свойства будут включены в поиск:  
  
-   Необходимо указать либо `BindingFlags.Instance` или `BindingFlags.Static` для получения возврата.  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытые свойства.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск закрытые свойства (то есть, закрытые, внутренние и защищенные).  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения `public` и `protected` статические члены вверх по иерархии; `private` статические члены в наследуемых классах не включаются.  
  
 Следующие <xref:System.Reflection.BindingFlags> модификатор флаги можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только свойства, объявленные в <xref:System.Type>, не те свойства, унаследованные.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Найдено несколько свойств с указанным именем, соответствующих указанным ограничениям привязки.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="types" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Один из элементов в <paramref name="types" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Массив <paramref name="types" /> является многомерным.  
  
 - или -  
  
 Массив <paramref name="modifiers" /> является многомерным.  
  
 - или -  
  
 <paramref name="types" /> и <paramref name="modifiers" /> имеют разную длину.</exception>
        <exception cref="T:System.NotSupportedException">Текущий тип является объектом <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" /> или <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Type" />, предоставляющий указанный тип.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает текущий <see cref="T:System.Type" />.</summary>
        <returns>Текущий контекст <see cref="T:System.Type" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Инициализатор класса вызывается и создает исключение.</exception>
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">Имя искомого типа с указанием сборки. См. раздел <see cref="P:System.Type.AssemblyQualifiedName" />. Если тип находится в выполняемой в данный момент сборке или библиотеке Mscorlib.dll, достаточно предоставить имя типа с указанием пространства имен.</param>
        <summary>Возвращает объект <see cref="T:System.Type" /> с указанным именем, учитывая при поиске регистр.</summary>
        <returns>Тип с указанным именем, если он существует; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать <xref:System.Type.GetType%2A> метод, чтобы получить <xref:System.Type> объекта для типа в другой сборке, если известно его имя, уточненное пространством имен. <xref:System.Type.GetType%2A> включает загрузку сборки, указанной в `typeName`. Можно также загрузить сборку с помощью <xref:System.Reflection.Assembly.Load%2A> метода, а затем использовать <xref:System.Type.GetType%2A> или <xref:System.Reflection.Assembly.GetTypes%2A> методы <xref:System.Reflection.Assembly> класса, чтобы получить <xref:System.Type> объектов. Если тип находится в сборке, во время компиляции неизвестен программу, это более эффективно использовать в C# <xref:System.Type.GetType%2A> Visual Basic или C++.  
  
> [!NOTE]
>  Если `typeName` не удается найти, вызов <xref:System.Type.GetType%28System.String%29> возвращает `null`. Он не вызывает исключение. Для управления ли исключение, вызовите перегрузку <xref:System.Type.GetType%2A> метода, имеющего `throwOnError` параметра.  
  
 <xref:System.Type.GetType%2A> работает только для сборок, загруженных с диска. При вызове метода <xref:System.Type.GetType%2A> для поиска типа, определенного в динамической сборке, определяются с помощью <xref:System.Reflection.Emit> службы, могут быть неверными. Поведение зависит от динамической сборке постоянно, то есть, созданные с помощью `RunAndSave` или `Save` режимов доступа <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> перечисления. Если динамическая сборка является постоянным и была записана на диск перед `GetType` — вызывается, загрузчик найдет сохраненную сборку на диске, загрузит ее и извлекает тип из этой сборки. Если сборка не были сохранены на диск, когда `GetType` вызывается, метод возвращает `null`. `GetType` не распознает временные динамические сборки; Таким образом, вызов `GetType` для извлечения типа в нерегулярная Возвращает динамическую сборку `null`.  
  
 Для использования `GetType` на динамический модуль, Подпишитесь на <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> событий и вызовов `GetType` перед сохранением. В противном случае вы получите две копии сборки в памяти.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методов при отражении в типе.  
  
|Тип члена|Static|Нестатический|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события, которые по имени и подписи. Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.  
  
3.  Пользовательские атрибуты не являются частью системы общих типов.  
  
 Массивы или COM-типов не производится, если они уже были загружены в таблицу доступных классов.  
  
 `typeName` может быть имя типа с указанием его пространство имен или имя с указанием сборки, которая включает спецификацию имени сборки. См. раздел <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Если `typeName` включает пространство имен, но не имя сборки, этот метод выполняет поиск только в сборке вызывающего объекта и библиотеки Mscorlib.dll, в указанном порядке. Если полное имя сборки частичную или полную typeName, этот метод ищет в указанной сборке. Если сборка имеет строгое имя, требуется указать полное имя сборки.  
  
 <xref:System.Type.AssemblyQualifiedName%2A> Свойство возвращает имя полного имени типа, включая вложенные типы, имя сборки и аргументы универсального типа. Все компиляторы, поддерживающие общеязыковая среда выполнения будет выдавать простое имя вложенного класса, а отражение создает искаженное имя, если запрос, в соответствии со следующими соглашениями.  
  
> [!NOTE]
>  В .NET Framework версии 2.0 архитектура процессора добавляется удостоверение сборки и может быть указан как часть строки имени сборки. Например «ProcessorArchitecture = msil». Однако он не включен в строку, возвращаемую <xref:System.Type.AssemblyQualifiedName%2A> свойства для обеспечения совместимости. Можно также загрузить типы путем создания <xref:System.Reflection.AssemblyName> объекта и передачи его в соответствующую перегрузку <xref:System.Reflection.Assembly.Load%2A> метод. Затем можно использовать <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> метод, чтобы загрузить типы из сборки. См. также раздел <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|разделитель|Значение|  
|---------------|-------------|  
|Обратная косая черта (\\)|Escape-символ.|  
|Обратный апостроф (')|Предшествует одной или нескольких цифр, представляющее число параметров типа, расположенное в конце имени универсального типа.|  
|квадратные скобки ([])|Заключите список аргументов универсального типа для сконструированного универсального типа; в список аргументов типа заключите типа с указанием сборки.|  
|Запятая ()|Предшествует имени сборки.|  
|Точка (.)|Определяет идентификаторы пространства имен.|  
|Знак плюс (+)|Перед вложенным классом.|  
  
 Например полное имя класса может выглядеть следующим образом:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Если было TopNamespace.Sub+Namespace, то строка будет иметь предшествовать знак плюс (+) с escape-символом (\\), чтобы он не будет интерпретироваться как разделитель вложения. Отражение преобразует эту строку следующим образом:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Объект «++» становится «\\+\\+» и»\\«становится»\\\\».  
  
 Это полное имя можно сохранить и впоследствии использовано для загрузки <xref:System.Type>. Чтобы найти и загрузить <xref:System.Type>, используйте <xref:System.Type.GetType%2A> либо с типом имени, либо только имя типа с указанием сборки. <xref:System.Type.GetType%2A> с типом имя только будет искать <xref:System.Type> в сборке вызывающего, а затем в системе сборки. <xref:System.Type.GetType%2A> в сборке будет искать имя типа с указанием <xref:System.Type> в любой сборке.  
  
 Имена типов могут включать конечные символы, определяющие дополнительные сведения о типе, например, является ли тип ссылочным типом, типом указателя или тип массива. Чтобы получить имя типа без этих конечных символов, используйте `t.GetElementType().ToString()`, где `t` тип.  
  
 Пробелы учитываются во всех компонентах имени типа, за исключением имени сборки. В имени сборки пробелы перед разделителем ',' учитываются, но пробелы после разделителя «,» игнорируются.  
  
 Имя универсального типа заканчивается обратной кавычкой (\`) следуют цифры, представляющее число аргументов универсального типа. Искажение имени предназначено для обеспечения поддержки универсальных типов с тем же именем, но с различным количеством параметров типа, выполняемых в той же области. Например, отражения возвращает поврежденных имен `Tuple`1` and `кортежа`2` из универсальных методах `Tuple(Of T)` и `Tuple(Of T0, T1)` в Visual Basic или `Tuple<T>` и кортежа`\<T0, T1>` в Visual C#.  
  
 Для универсальных типов список аргументов типа заключается в квадратные скобки и аргументы типа разделяются запятыми. Например, универсальный <xref:System.Collections.Generic.Dictionary%602> имеет два параметра типа. Объект <xref:System.Collections.Generic.Dictionary%602> из `MyType` с ключами типа <xref:System.String> может быть представлен следующим образом:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Для указания типа с указанием сборки в список аргументов типа, заключите тип сборки в квадратные скобки. Запятые, разделяющие части имени сборки, в противном случае интерпретируются как разделители дополнительных аргументов типа. Например <xref:System.Collections.Generic.Dictionary%602> из `MyType` fromMyAssembly.dll с ключами типа <xref:System.String>, может быть указан следующим образом:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Тип с указанием сборки можно заключать в скобки, только в том случае, когда он появится в списке параметров типа. Правила для поиска в сборках уточненных и неуточненных типы в списках параметров типа совпадают правилам для уточненных и неуточненных неуниверсальных типов.  
  
 Типы, допускающие значения NULL являются особыми случаями универсальных типов. Например, для типа <xref:System.Int32> представленный строкой «System.Nullable'1[System.Int32]».  
  
> [!NOTE]
>  В C#, C++ и Visual Basic можно также получить с помощью операторов типов типы nullable. Например, типа <xref:System.Boolean> возвращаемый тип `typeof(Nullable<bool>)` в C#, `Nullable<Boolean>::typeid` в C++ и по `GetType(Nullable(Of Boolean))` в Visual Basic.  
  
 В следующей таблице показаны синтаксис, можно использовать с `GetType` для различных типов.  
  
|Для получения|Использовать|  
|------------|---------|  
|Допускающие значения NULL <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|Неуправляемый указатель `MyType`|`Type.GetType("MyType*")`|  
|Неуправляемый указатель на указатель на `MyType`|`Type.GetType("MyType**")`|  
|Управляемый указатель или ссылка на `MyType`|`Type.GetType("MyType&")`. Обратите внимание, что ссылки, в отличие от указателей, ограничены одним уровнем.|  
|Родительский класс и вложенного класса|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Одномерный массив с нижней границей, равной 0|`Type.GetType("MyType[]")`|  
|Одномерный массив с неизвестной нижней границей|`Type.GetType("MyType[*]")`|  
|N мерный массив|Запятая (,) внутри квадратных скобок n-1 раз. Например `System.Object[,,]` представляет трехмерный массив `Object` массива.|  
|Массив одномерные массивы|`Type.GetType("MyType[][]")`|  
|Прямоугольный двухмерный массив с неизвестными нижними границами|`Type.GetType("MyType[,]")`|  
|Универсальный тип с одним аргументом типа|`Type.GetType("MyGenericType`1[MyType]")"|  
|Универсальный тип с двумя аргументами типа|`Type.GetType("MyGenericType`2[MyType,AnotherType]")`|  
|Универсальный тип с двумя аргументами типа сборки|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`|  
|Сборки универсального типа с аргументом типа сборки|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`|  
|Универсальный тип, имеющий аргумент типа является универсальным типом с двумя аргументами типа|`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 В следующем примере извлекается тип `System.Int32` и используется для отображения этого объекта <xref:System.Type.FullName%2A> свойство `System.Int32`.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Инициализатор класса вызывается и создает исключение.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> представляет универсальный тип, имеющий тип указателя, тип <see langword="ByRef" /> или <see cref="T:System.Void" /> в качестве одного из его аргументов типа.  
  
 - или -  
  
 <paramref name="typeName" /> представляет универсальный тип, который содержит неправильное количество аргументов типа.  
  
 - или -  
  
 <paramref name="typeName" /> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> представляет массив <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 Вместо этого в [.NET для приложений Магазина Windows](http://go.microsoft.com/fwlink/?LinkID=247912) или в [переносимой библиотеке классов](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) перехватите исключение базового класса <see cref="T:System.IO.IOException" />.  
  
</para>
          </block>  
  
 Сборка или одна из ее зависимостей найдена, но не может быть загружена.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка или одна из ее зависимостей является недопустимой.  
  
 - или -  
  
 В текущий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка была скомпилирована в более поздней версии.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Имя искомого типа с указанием сборки. См. раздел <see cref="P:System.Type.AssemblyQualifiedName" />. Если тип находится в выполняемой в данный момент сборке или библиотеке Mscorlib.dll, достаточно предоставить имя типа с указанием пространства имен.</param>
        <param name="throwOnError">
          Значение <see langword="true" />, чтобы создать исключение, если тип не удается найти; значение <see langword="false" />, чтобы вернуть значение <see langword="null" />. Кроме того, при указании значения <see langword="false" /> подавляются некоторые другие условия возникновения исключений, но не все из них. См. раздел "Исключения".</param>
        <summary>Возвращает объект <see cref="T:System.Type" /> с заданным именем, выполняя поиск с учетом регистра и указывая, будет ли создаваться исключение в случае невозможности найти тип.</summary>
        <returns>Тип с указанным именем. Если тип не найден, параметр <paramref name="throwOnError" /> определяет дальнейшее действие — возврат значения <see langword="null" /> или создание исключения. В некоторых случаях исключение создается независимо от значения параметра <paramref name="throwOnError" />. См. раздел "Исключения".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать <xref:System.Type.GetType%2A> метод, чтобы получить <xref:System.Type> объекта для типа в другой сборке, если известно его имя, уточненное пространством имен. <xref:System.Type.GetType%2A> включает загрузку сборки, указанной в `typeName`. Можно также загрузить сборку с помощью <xref:System.Reflection.Assembly.Load%2A> метода, а затем использовать <xref:System.Type.GetType%2A> или <xref:System.Reflection.Assembly.GetTypes%2A> методы <xref:System.Reflection.Assembly> класса, чтобы получить <xref:System.Type> объектов. Если тип находится в сборке, во время компиляции неизвестен программу, это более эффективно использовать `typeof` в C# <xref:System.Type.GetType%2A> в Visual Basic или `typeid` в C++.  
  
 `GetType` работает только для сборок, загруженных с диска. При вызове метода `GetType` для поиска типа, определенного в динамической сборке, определяются с помощью <xref:System.Reflection.Emit> службы, могут быть неверными. Поведение зависит от динамической сборке постоянно, то есть, созданные с помощью `RunAndSave` или `Save` режимов доступа <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> перечисления. Если динамическая сборка является постоянным и была записана на диск перед `GetType` — вызывается, загрузчик найдет сохраненную сборку на диске, загрузит ее и извлекает тип из этой сборки. Если сборка не были сохранены на диск, когда `GetType` вызывается, метод возвращает `null`. `GetType` не распознает временные динамические сборки; Таким образом, вызов `GetType` для извлечения типа в нерегулярная Возвращает динамическую сборку `null`.  
  
 Для использования `GetType` на динамический модуль, Подпишитесь на <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> событий и вызовов `GetType` перед сохранением. В противном случае вы получите две копии сборки в памяти.  
  
 `throwOnError` Параметр указывает, что произойдет, если тип не найден, а также подавляются некоторые другие условия возникновения исключений, как описано в раздел "исключения". Некоторые исключения выдаются независимо от значения `throwOnError`. Например, если тип присутствует, но не может быть загружена <xref:System.TypeLoadException> возникает, даже если `throwOnError` — `false`.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методов при отражении в типе.  
  
|Тип члена|Static|Нестатический|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события, которые по имени и подписи. Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.  
  
3.  Пользовательские атрибуты не являются частью системы общих типов.  
  
 Массивы или COM-типов не производится, если они уже были загружены в таблицу доступных классов.  
  
 `typeName` может быть имя типа с указанием его пространство имен или имя с указанием сборки, которая включает спецификацию имени сборки. См. раздел <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Если `typeName` включает пространство имен, но не имя сборки, этот метод выполняет поиск только в сборке вызывающего объекта и библиотеки Mscorlib.dll, в указанном порядке. Если полное имя сборки частичную или полную typeName, этот метод ищет в указанной сборке. Если сборка имеет строгое имя, требуется указать полное имя сборки.  
  
 <xref:System.Type.AssemblyQualifiedName%2A> Свойство возвращает полное имя, включая вложенные типы, имя сборки и универсальные аргументы. Все компиляторы, поддерживающие общеязыковая среда выполнения будет выдавать простое имя вложенного класса, а отражение создает искаженное имя, если запрос, в соответствии со следующими соглашениями.  
  
> [!NOTE]
>  В .NET Framework версии 2.0 архитектура процессора добавляется удостоверение сборки и может быть указан как часть строки имени сборки. Например «ProcessorArchitecture = msil». Однако он не включен в строку, возвращаемую <xref:System.Type.AssemblyQualifiedName%2A> свойства для обеспечения совместимости. Можно также загрузить типы путем создания <xref:System.Reflection.AssemblyName> объекта и передачи его в соответствующую перегрузку <xref:System.Reflection.Assembly.Load%2A> метод. Затем можно использовать <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> метод, чтобы загрузить типы из сборки. См. также раздел <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|разделитель|Значение|  
|---------------|-------------|  
|Обратная косая черта (\\)|Escape-символ.|  
|Обратный апостроф (')|Предшествует одной или нескольких цифр, представляющее число параметров типа, расположенное в конце имени универсального типа.|  
|квадратные скобки ([])|Заключите список аргументов универсального типа для сконструированного универсального типа; в список аргументов типа заключите типа с указанием сборки.|  
|Запятая ()|Предшествует имени сборки.|  
|Точка (.)|Определяет идентификаторы пространства имен.|  
|Знак плюс (+)|Перед вложенным классом.|  
  
 Например полное имя класса может выглядеть следующим образом:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Если было TopNamespace.Sub+Namespace, то строка будет иметь предшествовать знак плюс (+) с escape-символом (\\), чтобы он не будет интерпретироваться как разделитель вложения. Отражение преобразует эту строку следующим образом:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Объект «++» становится «\\+\\+» и»\\«становится»\\\\».  
  
 Это полное имя можно сохранить и впоследствии использовано для загрузки <xref:System.Type>. Чтобы найти и загрузить <xref:System.Type>, используйте <xref:System.Type.GetType%2A> либо с типом имени, либо только имя типа с указанием сборки. <xref:System.Type.GetType%2A> с типом имя только будет искать <xref:System.Type> в сборке вызывающего, а затем в системе сборки. <xref:System.Type.GetType%2A> в сборке будет искать имя типа с указанием <xref:System.Type> в любой сборке.  
  
 Имена типов могут включать конечные символы, определяющие дополнительные сведения о типе, например, является ли тип ссылочным типом, типом указателя или тип массива. Чтобы получить имя типа без этих конечных символов, используйте `t.GetElementType().ToString()`, где `t` тип.  
  
 Пробелы учитываются во всех компонентах имени типа, за исключением имени сборки. В имени сборки пробелы перед разделителем ',' учитываются, но пробелы после разделителя «,» игнорируются.  
  
 Имя универсального типа заканчивается обратной кавычкой (\`) следуют цифры, представляющее число аргументов универсального типа. Искажение имени предназначено для обеспечения поддержки универсальных типов с тем же именем, но с различным количеством параметров типа, выполняемых в той же области. Например, отражения возвращает поврежденных имен `Tuple`1` and `кортежа`2` из универсальных методах `Tuple(Of T)` и `Tuple(Of T0, T1)` в Visual Basic или `Tuple<T>` и кортежа`\<T0, T1>` в Visual C#.  
  
 Для универсальных типов список аргументов типа заключается в квадратные скобки и аргументы типа разделяются запятыми. Например, универсальный <xref:System.Collections.Generic.Dictionary%602> имеет два параметра типа. Объект <xref:System.Collections.Generic.Dictionary%602> из `MyType` с ключами типа <xref:System.String> может быть представлен следующим образом:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Для указания типа с указанием сборки в список аргументов типа, заключите тип сборки в квадратные скобки. Запятые, разделяющие части имени сборки, в противном случае интерпретируются как разделители дополнительных аргументов типа. Например <xref:System.Collections.Generic.Dictionary%602> из `MyType` из MyAssembly.dll с ключами типа <xref:System.String>, может быть указан следующим образом:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Тип с указанием сборки можно заключать в скобки, только в том случае, когда он появится в списке параметров типа. Правила для поиска в сборках уточненных и неуточненных типы в списках параметров типа совпадают правилам для уточненных и неуточненных неуниверсальных типов.  
  
 Типы, допускающие значения NULL являются особыми случаями универсальных типов. Например, для типа <xref:System.Int32> представленный строкой «System.Nullable'1[System.Int32]».  
  
> [!NOTE]
>  В C#, C++ и Visual Basic можно также получить с помощью операторов типов типы nullable. Например, типа <xref:System.Boolean> возвращаемый тип `typeof(Nullable<bool>)` в C#, `Nullable<Boolean>::typeid` в C++ и по `GetType(Nullable(Of Boolean))` в Visual Basic.  
  
 В следующей таблице показаны синтаксис, можно использовать с `GetType` для различных типов.  
  
|Для получения|Использовать|  
|------------|---------|  
|Допускающие значения NULL <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|Неуправляемый указатель `MyType`|`Type.GetType("MyType*")`|  
|Неуправляемый указатель на указатель на `MyType`|`Type.GetType("MyType**")`|  
|Управляемый указатель или ссылка на `MyType`|`Type.GetType("MyType&")`. Обратите внимание, что ссылки, в отличие от указателей, ограничены одним уровнем.|  
|Родительский класс и вложенного класса|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Одномерный массив с нижней границей, равной 0|`Type.GetType("MyArray[]")`|  
|Одномерный массив с неизвестной нижней границей|`Type.GetType("MyArray[*]")`|  
|N мерный массив|Запятая (,) внутри квадратных скобок n-1 раз. Например `System.Object[,,]` представляет трехмерный массив `Object` массива.|  
|Двумерный массив массивов|`Type.GetType("MyArray[][]")`|  
|Прямоугольный двухмерный массив с неизвестными нижними границами|`Type.GetType("MyArray[,]")`|  
|Универсальный тип с одним аргументом типа|`Type.GetType("MyGenericType`1[MyType]")"|  
|Универсальный тип с двумя аргументами типа|`Type.GetType("MyGenericType`2[MyType,AnotherType]")`|  
|Универсальный тип с двумя аргументами типа сборки|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`|  
|Сборки универсального типа с аргументом типа сборки|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`|  
|Универсальный тип, имеющий аргумент типа является универсальным типом с двумя аргументами типа|`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 В следующем примере извлекается тип `System.Int32` и используется для отображения этого объекта <xref:System.Type.FullName%2A> свойство `System.Int32`. Если тип объекта содержит ссылку на сборку, которая не существует, этот пример создает исключение.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Инициализатор класса вызывается и создает исключение.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> имеет значение <see langword="true" />, и тип не найден.  
  
 - или -  
  
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимые знаки, например внедренные табуляции.  
  
 - или -  
  
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> является пустой строкой.  
  
 - или -  
  
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> представляет тип массива с недопустимым размером.  
  
 - или -  
  
 <paramref name="typeName" /> представляет массив <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимый синтаксис. Например, "MyType[,*,]".  
  
 - или -  
  
 <paramref name="typeName" /> представляет универсальный тип, имеющий тип указателя, тип <see langword="ByRef" /> или <see cref="T:System.Void" /> в качестве одного из его аргументов типа.  
  
 - или -  
  
 <paramref name="typeName" /> представляет универсальный тип, который содержит неправильное количество аргументов типа.  
  
 - или -  
  
 <paramref name="typeName" /> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> имеет значение <see langword="true" />, и не удалось найти сборку либо одну из ее зависимостей.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 Вместо этого в [.NET для приложений Магазина Windows](http://go.microsoft.com/fwlink/?LinkID=247912) или в [переносимой библиотеке классов](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) перехватите исключение базового класса <see cref="T:System.IO.IOException" />.  
  
</para>
          </block>  
  
 Сборка или одна из ее зависимостей найдена, но не может быть загружена.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка или одна из ее зависимостей является недопустимой.  
  
 - или -  
  
 В текущий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка была скомпилирована в более поздней версии.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Имя искомого типа с указанием сборки. См. раздел <see cref="P:System.Type.AssemblyQualifiedName" />. Если тип находится в выполняемой в данный момент сборке или библиотеке Mscorlib.dll, достаточно предоставить имя типа с указанием пространства имен.</param>
        <param name="throwOnError">
          Значение <see langword="true" />, чтобы при невозможности найти тип создавалось исключение; значение <see langword="false" />, чтобы возвращалось значение <see langword="null" />. При задании значения <see langword="false" /> также подавляются некоторые другие условия исключения, однако не все. См. раздел "Исключения".</param>
        <param name="ignoreCase">
          Значение <see langword="true" />, чтобы не учитывать регистр при поиске <c>typeName</c>; значение <see langword="false" />, чтобы учитывать регистр при поиске <c>typeName</c>.</param>
        <summary>Возвращает объект <see cref="T:System.Type" /> с указанным именем, позволяющий определить, будет ли создаваться исключение в случае невозможности найти тип и будет ли учитываться регистр при поиске.</summary>
        <returns>Тип с указанным именем. Если тип не найден, параметр <paramref name="throwOnError" /> определяет дальнейшее действие — возврат значения <see langword="null" /> или создание исключения. В некоторых случаях исключение создается независимо от значения параметра <paramref name="throwOnError" />. См. раздел "Исключения".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать <xref:System.Type.GetType%2A> метод, чтобы получить <xref:System.Type> объекта для типа в другой сборке, если известно его имя, уточненное пространством имен. <xref:System.Type.GetType%2A> включает загрузку сборки, указанной в `typeName`. Можно также загрузить сборку с помощью <xref:System.Reflection.Assembly.Load%2A> метода, а затем использовать <xref:System.Type.GetType%2A> или <xref:System.Reflection.Assembly.GetTypes%2A> методы <xref:System.Reflection.Assembly> класса, чтобы получить <xref:System.Type> объектов. Если тип находится в сборке, во время компиляции неизвестен программу, это более эффективно использовать `typeof` в C# <xref:System.Type.GetType%2A> в Visual Basic или `typeid` в C++.  
  
 `GetType` работает только для сборок, загруженных с диска. При вызове метода `GetType` для поиска типа, определенного в динамической сборке, определяются с помощью <xref:System.Reflection.Emit> службы, могут быть неверными. Поведение зависит от динамической сборке постоянно, то есть, созданные с помощью `RunAndSave` или `Save` режимов доступа <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> перечисления. Если динамическая сборка является постоянным и была записана на диск перед `GetType` — вызывается, загрузчик найдет сохраненную сборку на диске, загрузит ее и извлекает тип из этой сборки. Если сборка не были сохранены на диск, когда `GetType` вызывается, метод возвращает `null`. `GetType` не распознает временные динамические сборки; Таким образом, вызов `GetType` для извлечения типа в нерегулярная Возвращает динамическую сборку `null`.  
  
 Для использования `GetType` на динамический модуль, Подпишитесь на <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> событий и вызовов `GetType` перед сохранением. В противном случае вы получите две копии сборки в памяти.  
  
 `throwOnError` Параметр указывает, что произойдет, если тип не найден, а также подавляются некоторые другие условия возникновения исключений, как описано в раздел "исключения". Некоторые исключения выдаются независимо от значения `throwOnError`. Например, если тип присутствует, но не может быть загружена <xref:System.TypeLoadException> возникает, даже если `throwOnError` — `false`.  
  
 В следующей таблице показаны, какие члены базового класса возвращаются `Get` методов при отражении в типе.  
  
|Тип члена|Static|Нестатический|  
|-----------------|------------|-----------------|  
|Конструктор|Нет|Нет|  
|Поле|Нет|Да. Поле всегда равно по имени и подписи.|  
|событие|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
|Метод|Нет|Да. Метод (виртуальные и невиртуальные) можно скрыть по имени или по имени и подписи.|  
|Вложенный тип|Нет|Нет|  
|Свойство.|Неприменимо|Правило системы общих типов является наследование же, что методы, которые реализуют свойство. Отражении свойства по имени и подписи. См. Примечание 2 ниже.|  
  
1.  По имени и подписи считает, что все части сигнатуры, включая настраиваемые модификаторы, возвращают типы, типы параметров, сигнальные метки и соглашения о неуправляемых вызовах. Это двоичное сравнение.  
  
2.  Для отражения свойства и события, которые по имени и подписи. Если имеется свойство с get и set в базовом классе, но производный класс имеет только метод доступа get, свойство производного класса скрывает свойство базового класса, и вы не сможете для доступа к методу set в базовом классе.  
  
3.  Пользовательские атрибуты не являются частью системы общих типов.  
  
 Массивы или COM-типов не производится, если они уже были загружены в таблицу доступных классов.  
  
 `typeName` может быть имя типа с указанием его пространство имен или имя с указанием сборки, которая включает спецификацию имени сборки. См. раздел <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Если `typeName` включает пространство имен, но не имя сборки, этот метод выполняет поиск только в сборке вызывающего объекта и библиотеки Mscorlib.dll, в указанном порядке. Если полное имя сборки частичную или полную typeName, этот метод ищет в указанной сборке. Если сборка имеет строгое имя, требуется указать полное имя сборки.  
  
 <xref:System.Type.AssemblyQualifiedName%2A> Свойство возвращает имя полного имени типа, включая вложенные типы, имя сборки и аргументы типа. Все компиляторы, поддерживающие общеязыковая среда выполнения будет выдавать простое имя вложенного класса, а отражение создает искаженное имя, если запрос, в соответствии со следующими соглашениями.  
  
> [!NOTE]
>  В .NET Framework версии 2.0 архитектура процессора добавляется удостоверение сборки и может быть указан как часть строки имени сборки. Например «ProcessorArchitecture = msil». Однако он не включен в строку, возвращаемую <xref:System.Type.AssemblyQualifiedName%2A> свойства для обеспечения совместимости. Можно также загрузить типы путем создания <xref:System.Reflection.AssemblyName> объекта и передачи его в соответствующую перегрузку <xref:System.Reflection.Assembly.Load%2A> метод. Затем можно использовать <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> метод, чтобы загрузить типы из сборки. См. также раздел <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|разделитель|Значение|  
|---------------|-------------|  
|Обратная косая черта (\\)|Escape-символ.|  
|Обратный апостроф (')|Предшествует одной или нескольких цифр, представляющее число параметров типа, расположенное в конце имени универсального типа.|  
|квадратные скобки ([])|Заключите список аргументов универсального типа для сконструированного универсального типа; в список аргументов типа заключите типа с указанием сборки.|  
|Запятая ()|Предшествует имени сборки.|  
|Точка (.)|Определяет идентификаторы пространства имен.|  
|Знак плюс (+)|Перед вложенным классом.|  
  
 Например полное имя класса может выглядеть следующим образом:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Если было TopNamespace.Sub+Namespace, то строка будет иметь предшествовать знак плюс (+) с escape-символом (\\), чтобы он не будет интерпретироваться как разделитель вложения. Отражение преобразует эту строку следующим образом:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Объект «++» становится «\\+\\+» и»\\«становится»\\\\».  
  
 Это полное имя можно сохранить и впоследствии использовано для загрузки <xref:System.Type>. Чтобы найти и загрузить <xref:System.Type>, используйте <xref:System.Type.GetType%2A> либо с типом имени, либо только имя типа с указанием сборки. <xref:System.Type.GetType%2A> с типом имя только будет искать <xref:System.Type> в сборке вызывающего, а затем в системе сборки. <xref:System.Type.GetType%2A> в сборке будет искать имя типа с указанием <xref:System.Type> в любой сборке.  
  
 Имена типов могут включать конечные символы, определяющие дополнительные сведения о типе, например, является ли тип ссылочным типом, типом указателя или тип массива. Чтобы получить имя типа без этих конечных символов, используйте `t.GetElementType().ToString()`, где `t` тип.  
  
 Пробелы учитываются во всех компонентах имени типа, за исключением имени сборки. В имени сборки пробелы перед разделителем ',' учитываются, но пробелы после разделителя «,» игнорируются.  
  
 Имя универсального типа заканчивается обратной кавычкой (\`) следуют цифры, представляющее число аргументов универсального типа. Искажение имени предназначено для обеспечения поддержки универсальных типов с тем же именем, но с различным количеством параметров типа, выполняемых в той же области. Например, отражения возвращает поврежденных имен `Tuple`1` and `кортежа`2` из универсальных методах `Tuple(Of T)` и `Tuple(Of T0, T1)` в Visual Basic или `Tuple<T>` и кортежа`\<T0, T1>` в Visual C#.  
  
 Для универсальных типов список аргументов типа заключается в квадратные скобки и аргументы типа разделяются запятыми. Например, универсальный <xref:System.Collections.Generic.Dictionary%602> имеет два параметра типа. Объект <xref:System.Collections.Generic.Dictionary%602> из `MyType` с ключами типа <xref:System.String> может быть представлен следующим образом:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Для указания типа с указанием сборки в список аргументов типа, заключите тип сборки в квадратные скобки. Запятые, разделяющие части имени сборки, в противном случае интерпретируются как разделители дополнительных аргументов типа. Например <xref:System.Collections.Generic.Dictionary%602> из `MyType` из MyAssembly.dll с ключами типа <xref:System.String>, может быть указан следующим образом:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Тип с указанием сборки можно заключать в скобки, только в том случае, когда он появится в списке параметров типа. Правила для поиска в сборках уточненных и неуточненных типы в списках параметров типа совпадают правилам для уточненных и неуточненных неуниверсальных типов.  
  
 Типы, допускающие значения NULL являются особыми случаями универсальных типов. Например, для типа <xref:System.Int32> представленный строкой «System.Nullable'1[System.Int32]».  
  
> [!NOTE]
>  В C#, C++ и Visual Basic можно также получить с помощью операторов типов типы nullable. Например, типа <xref:System.Boolean> возвращаемый тип `typeof(Nullable<bool>)` в C#, `Nullable<Boolean>::typeid` в C++ и по `GetType(Nullable(Of Boolean))` в Visual Basic.  
  
 В следующей таблице показаны синтаксис, можно использовать с `GetType` для различных типов.  
  
|Для получения|Использовать|  
|------------|---------|  
|Допускающие значения NULL <xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")`|  
|Неуправляемый указатель `MyType`|`Type.GetType("MyType*")`|  
|Неуправляемый указатель на указатель на `MyType`|`Type.GetType("MyType**")`|  
|Управляемый указатель или ссылка на `MyType`|`Type.GetType("MyType&")`. Обратите внимание, что ссылки, в отличие от указателей, ограничены одним уровнем.|  
|Родительский класс и вложенного класса|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Одномерный массив с нижней границей, равной 0|`Type.GetType("MyArray[]")`|  
|Одномерный массив с неизвестной нижней границей|`Type.GetType("MyArray[*]")`|  
|N мерный массив|Запятая (,) внутри квадратных скобок n-1 раз. Например `System.Object[,,]` представляет трехмерный массив `Object` массива.|  
|Двумерный массив массивов|`Type.GetType("MyArray[][]")`|  
|Прямоугольный двухмерный массив с неизвестными нижними границами|`Type.GetType("MyArray[,]")`|  
|Универсальный тип с одним аргументом типа|`Type.GetType("MyGenericType`1[MyType]")"|  
|Универсальный тип с двумя аргументами типа|`Type.GetType("MyGenericType`2[MyType,AnotherType]")`|  
|Универсальный тип с двумя аргументами типа сборки|`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`|  
|Сборки универсального типа с аргументом типа сборки|`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`|  
|Универсальный тип, имеющий аргумент типа является универсальным типом с двумя аргументами типа|`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Инициализатор класса вызывается и создает исключение.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> имеет значение <see langword="true" />, и тип не найден.  
  
 - или -  
  
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимые знаки, например внедренные табуляции.  
  
 - или -  
  
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> является пустой строкой.  
  
 - или -  
  
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> представляет тип массива с недопустимым размером.  
  
 - или -  
  
 <paramref name="typeName" /> представляет массив <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимый синтаксис. Например, "MyType[,*,]".  
  
 - или -  
  
 <paramref name="typeName" /> представляет универсальный тип, имеющий тип указателя, тип <see langword="ByRef" /> или <see cref="T:System.Void" /> в качестве одного из его аргументов типа.  
  
 - или -  
  
 <paramref name="typeName" /> представляет универсальный тип, который содержит неправильное количество аргументов типа.  
  
 - или -  
  
 <paramref name="typeName" /> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> имеет значение <see langword="true" />, и не удалось найти сборку либо одну из ее зависимостей.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или одна из ее зависимостей найдена, но не может быть загружена.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка или одна из ее зависимостей является недопустимой.  
  
 - или -  
  
 В текущий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка была скомпилирована в более поздней версии.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">Имя получаемого типа. Если задан параметр <c>typeResolver</c>, имя типа может быть любой строкой, которую может разрешить <c>typeResolver</c>. Если задан параметр <c>assemblyResolver</c> или используется стандартное разрешение типов, параметр <c>typeName</c> должен быть именем с указанием сборки (см. описание свойства <see cref="P:System.Type.AssemblyQualifiedName" />), кроме случаев, когда этот тип находится в текущей выполняемой сборке или в библиотеке Mscorlib.dll — тогда достаточно задать имя типа с указанием пространства имен.</param>
        <param name="assemblyResolver">Метод, находящий и возвращающий сборку, заданную в параметре <c>typeName</c>. Имя сборки передается методу <c>assemblyResolver</c> в виде объекта <see cref="T:System.Reflection.AssemblyName" />. Если параметр <c>typeName</c> не содержит имя сборки, метод <c>assemblyResolver</c> не вызывается. Если метод <c>assemblyResolver</c> не указан, выполняется стандартное разрешение сборки.  
  
 Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей. В противном случае возможно повышение привилегий для вредоносного кода. Рекомендуется использовать только методы, предоставленные пользователями или знакомые им.</param>
        <param name="typeResolver">Метод, находящий и возвращающий тип, заданный в параметре <c>typeName</c>, из сборки, возвращенной методом <c>assemblyResolver</c> или стандартным методом разрешения сборки. Если сборка не предоставлена, метод <c>typeResolver</c> может предоставить ее. Метод также принимает параметр, указывающий, следует ли выполнять поиск без учета регистра; этому параметру передается значение <see langword="false" />.  
  
 Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей.</param>
        <summary>Возвращает тип с указанным именем; дополнительно может предоставлять настраиваемые методы для разрешения сборки и типа.</summary>
        <returns>Тип с указанным именем или значение <see langword="null" />, если тип не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сценарии использования для этого метода и сведения о `assemblyResolver` и `typeResolver` параметры можно найти в <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> перегрузки метода.  
  
> [!NOTE]
>  Если `typeName` не удается найти, вызов <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> возвращает `null`. Он не вызывает исключение. Для управления ли исключение, вызовите перегрузку <xref:System.Type.GetType%2A> метода, имеющего `throwOnError` параметра.  
  
 Вызов этой перегрузки метода является таким же, как вызов <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> перегруженный метод и указывая `false` для `throwOnError` и `ignoreCase` параметров.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Инициализатор класса вызывается и создает исключение.</exception>
        <exception cref="T:System.ArgumentException">Ошибка происходит при разборе <paramref name="typeName" /> в имя типа и имя сборки (например, если простое имя типа содержит не преобразованный в escape-последовательность специальный знак).  
  
 - или -  
  
 <paramref name="typeName" /> представляет универсальный тип, имеющий тип указателя, тип <see langword="ByRef" /> или <see cref="T:System.Void" /> в качестве одного из его аргументов типа.  
  
 - или -  
  
 <paramref name="typeName" /> представляет универсальный тип, который содержит неправильное количество аргументов типа.  
  
 - или -  
  
 <paramref name="typeName" /> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> представляет массив <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или одна из ее зависимостей найдена, но не может быть загружена.  
  
 - или -  
  
 <paramref name="typeName" /> содержит недопустимое имя сборки.  
  
 - или -  
  
 <paramref name="typeName" /> является допустимым именем сборки без типа имени.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка или одна из ее зависимостей является недопустимой.  
  
 - или -  
  
 Сборка была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Имя получаемого типа. Если задан параметр <c>typeResolver</c>, имя типа может быть любой строкой, которую может разрешить <c>typeResolver</c>. Если задан параметр <c>assemblyResolver</c> или используется стандартное разрешение типов, параметр <c>typeName</c> должен быть именем с указанием сборки (см. описание свойства <see cref="P:System.Type.AssemblyQualifiedName" />), кроме случаев, когда этот тип находится в текущей выполняемой сборке или в библиотеке Mscorlib.dll — тогда достаточно задать имя типа с указанием пространства имен.</param>
        <param name="assemblyResolver">Метод, находящий и возвращающий сборку, заданную в параметре <c>typeName</c>. Имя сборки передается методу <c>assemblyResolver</c> в виде объекта <see cref="T:System.Reflection.AssemblyName" />. Если параметр <c>typeName</c> не содержит имя сборки, метод <c>assemblyResolver</c> не вызывается. Если метод <c>assemblyResolver</c> не указан, выполняется стандартное разрешение сборки.  
  
 Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей. В противном случае возможно повышение привилегий для вредоносного кода. Рекомендуется использовать только методы, предоставленные пользователями или знакомые им.</param>
        <param name="typeResolver">Метод, находящий и возвращающий тип, заданный в параметре <c>typeName</c>, из сборки, возвращенной методом <c>assemblyResolver</c> или стандартным методом разрешения сборки. Если сборка не предоставлена, этот метод может предоставить ее. Метод также принимает параметр, указывающий, следует ли выполнять поиск без учета регистра; этому параметру передается значение <see langword="false" />.  
  
 Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей.</param>
        <param name="throwOnError">
          Значение <see langword="true" />, чтобы создать исключение, если тип не удается найти; значение <see langword="false" />, чтобы вернуть значение <see langword="null" />. Кроме того, при указании значения <see langword="false" /> подавляются некоторые другие условия возникновения исключений, но не все из них. См. раздел "Исключения".</param>
        <summary>Возвращает тип с заданным именем и указывает, следует ли создавать исключение в случае невозможности найти тип, а также может предоставлять настраиваемые методы для разрешения сборки и типа.</summary>
        <returns>Тип с указанным именем. Если тип не найден, параметр <paramref name="throwOnError" /> определяет дальнейшее действие — возврат значения <see langword="null" /> или создание исключения. В некоторых случаях исключение создается независимо от значения параметра <paramref name="throwOnError" />. См. раздел "Исключения".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сценарии использования для этого метода и сведения о `assemblyResolver` и `typeResolver` параметры можно найти в <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> перегрузки метода.  
  
 Вызов этой перегрузки метода является таким же, как вызов <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> перегруженный метод и указывая `false` для `ignoreCase` параметра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Инициализатор класса вызывается и создает исключение.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> имеет значение <see langword="true" />, и тип не найден.  
  
 - или -  
  
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимые знаки, например внедренные табуляции.  
  
 - или -  
  
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> является пустой строкой.  
  
 - или -  
  
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> представляет тип массива с недопустимым размером.  
  
 - или -  
  
 <paramref name="typeName" /> представляет массив <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">Ошибка происходит при разборе <paramref name="typeName" /> в имя типа и имя сборки (например, если простое имя типа содержит не преобразованный в escape-последовательность специальный знак).  
  
 - или -  
  
 <paramref name="throwOnError" /> равно <see langword="true" />, а <paramref name="typeName" /> содержит недопустимый синтаксис (например, «MyType[,*,]»).  
  
 - или -  
  
 <paramref name="typeName" /> представляет универсальный тип, имеющий тип указателя, тип <see langword="ByRef" /> или <see cref="T:System.Void" /> в качестве одного из его аргументов типа.  
  
 - или -  
  
 <paramref name="typeName" /> представляет универсальный тип, который содержит неправильное количество аргументов типа.  
  
 - или -  
  
 <paramref name="typeName" /> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> имеет значение <see langword="true" />, и не удалось найти сборку либо одну из ее зависимостей.  
  
 - или -  
  
 <paramref name="typeName" /> содержит недопустимое имя сборки.  
  
 - или -  
  
 <paramref name="typeName" /> является допустимым именем сборки без типа имени.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или одна из ее зависимостей найдена, но не может быть загружена.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка или одна из ее зависимостей является недопустимой.  
  
 - или -  
  
 Сборка была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Имя получаемого типа. Если задан параметр <c>typeResolver</c>, имя типа может быть любой строкой, которую может разрешить <c>typeResolver</c>. Если задан параметр <c>assemblyResolver</c> или используется стандартное разрешение типов, параметр <c>typeName</c> должен быть именем с указанием сборки (см. описание свойства <see cref="P:System.Type.AssemblyQualifiedName" />), кроме случаев, когда этот тип находится в текущей выполняемой сборке или в библиотеке Mscorlib.dll — тогда достаточно задать имя типа с указанием пространства имен.</param>
        <param name="assemblyResolver">Метод, находящий и возвращающий сборку, заданную в параметре <c>typeName</c>. Имя сборки передается методу <c>assemblyResolver</c> в виде объекта <see cref="T:System.Reflection.AssemblyName" />. Если параметр <c>typeName</c> не содержит имя сборки, метод <c>assemblyResolver</c> не вызывается. Если метод <c>assemblyResolver</c> не указан, выполняется стандартное разрешение сборки.  
  
 Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей. В противном случае возможно повышение привилегий для вредоносного кода. Рекомендуется использовать только методы, предоставленные пользователями или знакомые им.</param>
        <param name="typeResolver">Метод, находящий и возвращающий тип, заданный в параметре <c>typeName</c>, из сборки, возвращенной методом <c>assemblyResolver</c> или стандартным методом разрешения сборки. Если сборка не предоставлена, этот метод может предоставить ее. Метод также принимает параметр, указывающий, следует ли выполнять поиск без учета регистра; этому параметру передается значение <c>ignoreCase</c>.  
  
 Внимание. Не передавайте методы от неизвестных или недоверенных вызывающих модулей.</param>
        <param name="throwOnError">
          Значение <see langword="true" />, чтобы создать исключение, если тип не удается найти; значение <see langword="false" />, чтобы вернуть значение <see langword="null" />. Кроме того, при указании значения <see langword="false" /> подавляются некоторые другие условия возникновения исключений, но не все из них. См. раздел "Исключения".</param>
        <param name="ignoreCase">
          Значение <see langword="true" />, чтобы не учитывать регистр при поиске <c>typeName</c>; значение <see langword="false" />, чтобы учитывать регистр при поиске <c>typeName</c>.</param>
        <summary>Возвращает тип с заданным именем и указывает, следует ли выполнять поиск без учета регистра и следует ли создавать исключение в случае невозможности найти тип, а также может предоставлять настраиваемые методы для разрешения сборки и типа.</summary>
        <returns>Тип с указанным именем. Если тип не найден, параметр <paramref name="throwOnError" /> определяет дальнейшее действие — возврат значения <see langword="null" /> или создание исключения. В некоторых случаях исключение создается независимо от значения параметра <paramref name="throwOnError" />. См. раздел "Исключения".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте перегрузку этого метода и связанные перегрузки (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> и <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) для замены реализация по умолчанию <xref:System.Type.GetType%2A> метод с более гибкой реализации. Предоставляя свои собственные методы, которые разрешаются имена типов и сборок, содержащих их, можно сделать следующее:  
  
-   Какие версия сборки тип загружается из элемента управления.  
  
-   Укажите другое место для поиска имени типа, который не включает имя сборки.  
  
-   Загрузить сборки с помощью частичных имен сборок.  
  
-   Вернуть подклассы <xref:System.Type?displayProperty=nameWithType> , созданных без общеязыковой среды выполнения (CLR).  
  
 Например в независимой от версий сериализации этот метод позволяет найти для сборки «оптимальных параметров» с использованием частичного имени. Другие перегрузки <xref:System.Type.GetType%2A> метода требуется имя типа с указанием сборки, которое включает номер версии.  
  
 Альтернативные реализации системы типов может потребоваться вернуть подклассы <xref:System.Type?displayProperty=nameWithType> , не созданы CLR; все типы, которые возвращаются другие перегрузки <xref:System.Type.GetType%2A> метод являются типами среды выполнения.  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>Примечания об использовании  
 Эта перегрузка метода и связанные перегрузки проанализировать `typeName` в имя типа и имя сборки и затем разрешения имен. Разрешение имени сборки предшествует разрешению имени типа, так как имя типа должно быть разрешено в контексте сборки.  
  
> [!NOTE]
>  Если вы не знакомы с концепцией имен типов с указанием сборки, см. раздел <xref:System.Type.AssemblyQualifiedName%2A> свойство.  
  
 Если `typeName` не является именем с указанием сборки, разрешение сборки пропускается. Неполные имена типов может быть разрешен в контексте Mscorlib.dll или текущей выполняемой сборке или при необходимости можно предоставить сборку в `typeResolver` параметра. Эффекты включая или исключая имя сборки для различных видов разрешение имен отображаются в виде таблицы [разрешение смешанных имен](#mixed_name_resolution) раздела.  
  
 Общие примечания по использованию:  
  
-   Не передавайте методы для `assemblyResolver` или `typeResolver` полученные из неизвестных или ненадежных вызывающих объектов. Рекомендуется использовать только методы, предоставленные пользователями или знакомые им.  
  
    > [!CAUTION]
    >  С помощью методов из неизвестных или ненадежных вызывающих объектов может привести к повышение привилегий для вредоносного кода.  
  
-   Если не указан `assemblyResolver` и/или `typeResolver` параметров, значение `throwOnError` параметр передается методу, выполнять разрешение по умолчанию.  
  
-   Если `throwOnError` — `true`, этот метод создает исключение <xref:System.TypeLoadException> при `typeResolver` возвращает `null`и <xref:System.IO.FileNotFoundException> при `assemblyResolver` возвращает `null`.  
  
-   Этот метод не перехватывает исключения, вызванные `assemblyResolver` и `typeResolver`. Вы несете ответственность за любые исключения, вызванные методами распознавателя.  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>Разрешение сборок  
 `assemblyResolver` Метод получает <xref:System.Reflection.AssemblyName> объекта, который создается путем синтаксического анализа строковое имя сборки, включенный в `typeName`. Если `typeName` не содержит имени сборки `assemblyResolver` не вызывается и `null` передается `typeResolver`.  
  
 Если `assemblyResolver` не указан, стандартная сборкой проверка используется для обнаружения сборки. Если `assemblyResolver` предоставляется, <xref:System.Type.GetType%2A> метод не выполняет стандартные проверки; в этом случае необходимо убедиться, что ваш `assemblyResolver` может обрабатывать все сборки, передайте в него.  
  
 `assemblyResolver` Метод должен возвращать `null` если сборку не удается разрешить. Если `assemblyResolver` возвращает `null`, `typeResolver` не вызывается и дальнейшая обработка происходит; Кроме того, если `throwOnError` — `true`, <xref:System.IO.FileNotFoundException> возникает исключение.  
  
 Если <xref:System.Reflection.AssemblyName> , передаваемое в `assemblyResolver` является частичным имя для одного или нескольких частей, `null`. Например, если он не имеет версии <xref:System.Reflection.AssemblyName.Version%2A> свойство `null`. Если <xref:System.Reflection.AssemblyName.Version%2A> свойства <xref:System.Reflection.AssemblyName.CultureInfo%2A> свойство и <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> метод возвращают `null`, то простое имя сборки был предоставлен. `assemblyResolver` Метод может использовать или игнорировать все части имени сборки.  
  
 Эффекты различных параметров разрешения сборок, отображаются в виде таблицы [разрешение смешанных имен](#mixed_name_resolution) раздел для имен типов простых и сборки.  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>Разрешение типов  
 Если `typeName` не соответствует имени сборки `typeResolver` всегда вызываются. Если `typeName` указывает имя сборки, `typeResolver` вызывается только в том случае, когда имя сборки успешно разрешен. Если `assemblyResolver` или проверка возвращает стандартные сборки `null`, `typeResolver` не вызывается.  
  
 `typeResolver` Метод принимает три аргумента:  
  
-   Сборка для поиска или `null` Если `typeName` не содержит имя сборки.  
  
-   Простое имя типа. В случае вложенный тип это внешнего содержащего типа. В случае универсального типа это простое имя универсального типа.  
  
-   Логическое значение, которое является `true` Если нужно игнорировать регистр имен типов.  
  
 Реализация определяет способ использования этих аргументов. `typeResolver` Метод должен возвращать `null` при невозможности разрешить тип. Если `typeResolver` возвращает `null` и `throwOnError` — `true`, эта перегрузка <xref:System.Type.GetType%2A> вызывает <xref:System.TypeLoadException>.  
  
 Эффекты различных параметров разрешения типов отображены в виде таблицы [разрешение смешанных имен](#mixed_name_resolution) раздел для имен типов простых и сборки.  
  
#### <a name="resolving-nested-types"></a>Разрешение вложенных типов  
 Если `typeName` является вложенным типом, только имя самой внешней содержащий тип передается `typeResolver`. Когда `typeResolver` возвращаемый тип, <xref:System.Type.GetNestedType%2A> метод вызывается рекурсивно, пока не будет устранена внутренней вложенного типа.  
  
#### <a name="resolving-generic-types"></a>Разрешение универсальных типов  
 <xref:System.Type.GetType%2A> Вызывается рекурсивно для разрешения универсальных типов: сначала разрешается сам универсальный тип, а затем его аргументов типа. Если аргумент типа является универсальным, <xref:System.Type.GetType%2A> вызывается рекурсивно для разрешения его аргументов типа и т. д.  
  
 Сочетание `assemblyResolver` и `typeResolver` предоставить должен быть может разрешить все уровни Косвенная рекурсия. Например, предположим, что указывается `assemblyResolver` загрузки, который управляет `MyAssembly`. Предположим, что нужно определить общий тип `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` в Visual Basic). Можно передать следующее имя универсального типа:  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 Обратите внимание, что `MyType` — это аргумент только типа сборки. Имена <xref:System.Collections.Generic.Dictionary%602> и <xref:System.String> классы не являются сборки. Ваш `typeResolver` должны быть способны выполнять обработку либо сборки или `null`, так как он будет получать `null` для <xref:System.Collections.Generic.Dictionary%602> и <xref:System.String>. Он может обрабатывать этот случай путем вызова перегрузки <xref:System.Type.GetType%2A> метод, который принимает строку, так как оба неполные имена типов в библиотеке Mscorlib.dll:  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 `assemblyResolver` Метод не вызывается для типа словаря и строкового типа, так как эти имена типов не сборки.  
  
 Теперь предположим, что вместо `System.String`, первого аргумента универсального типа `YourType`, из `YourAssembly`:  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 Так как эта сборка не Mscorlib.dll текущей выполняемой сборке, не удается разрешить `YourType` без имени сборки. Так как ваш `assemblyResolve` будет вызывается рекурсивно, он должен иметь возможность этот случай. Вместо возвращения `null` для сборок, отличных от `MyAssembly`, она теперь выполняет загрузку сборки с помощью предоставленного <xref:System.Reflection.AssemblyName> объекта.  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 К [заметки по использованию](#usage_notes).  
  
#### <a name="resolving-type-names-with-special-characters"></a>Разрешение имен типов, содержащий специальные символы  
 Некоторые символы имеют специальное значение в именах с указанием сборки. Если имя простого типа содержит эти символы, они вызовут ошибки синтаксического анализа при простое имя является частью имени сборки. Во избежание ошибок синтаксического анализа, необходимо экранировать специальные символы, обратную косую черту, прежде чем можно передать имя с указанием сборки для <xref:System.Type.GetType%2A> метод. Например, если тип имеет имя `Strange]Type`, escape-символ должны добавляться раньше квадратная скобка следующим образом: `Strange\]Type`.  
  
> [!NOTE]
>  Имена с такими специальными символами нельзя создать в Visual Basic или C#, но можно создать с помощью промежуточного языка Майкрософт (MSIL) или путем создания динамических сборок.  
  
 В следующей таблице показаны специальные символы для имен типов.  
  
|Знак|Значение|  
|---------------|-------------|  
|`,` (запятая)|Разделитель для имен сборки.|  
|`[]` (квадратные скобки)|Как пара суффиксов указывает тип массива; как пара разделителей заключает списки универсальных аргументов и имена с указанием сборки.|  
|`&` (амперсанд)|Как суффикс указывает, что тип является ссылочным типом.|  
|`*` (звездочка)|Как суффикс указывает, что тип является типом указателя.|  
|`+` (плюс)|Разделитель для вложенных типов.|  
|`\` (обратная косая черта)|Escape-символ.|  
  
 Такие свойства, как <xref:System.Type.AssemblyQualifiedName%2A> возвращают правильно escape-строк. Необходимо передать правильно escape-строк для <xref:System.Type.GetType%2A> метод. В свою очередь <xref:System.Type.GetType%2A> метод передает правильно дублирующие имена для `typeResolver` и методы разрешения типа по умолчанию. Если необходимо сравнить имя с escape-последовательность имя в `typeResolver`, необходимо удалить escape-символы.  
  
 К [заметки по использованию](#usage_notes).  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>Разрешение смешанных имен  
 В следующей таблице перечислены взаимодействия между `assemblyResolver`, `typeResolver`и разрешение имен по умолчанию, для всех сочетаний имени типа и имя сборки в `typeName`:  
  
|Имя типа содержимого|Метод распознавателя сборок|Метод сопоставления имен типа|Результат|  
|---------------------------|------------------------------|--------------------------|------------|  
|тип сборки|null|null|Аналогичен вызову <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> перегрузки метода.|  
|тип сборки|предоставленный|null|`assemblyResolver` Возвращает сборку, или возвращает `null` при невозможности разрешить сборку. Если сборка не будет разрешена, <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> должен быть загружен тип из сборки используется перегрузка метода; в противном случае — нет не пытается разрешить тип.|  
|тип сборки|null|предоставленный|Эквивалентен преобразованию имя сборки в <xref:System.Reflection.AssemblyName> объекта и вызывая метод <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> перегрузка метода для получения сборки. Если сборка разрешается, оно передается `typeResolver`; в противном случае `typeResolver` не вызывается и дальнейшая попытка разрешить тип.|  
|тип сборки|предоставленный|предоставленный|`assemblyResolver` Возвращает сборку, или возвращает `null` при невозможности разрешить сборку. Если сборка разрешается, оно передается `typeResolver`; в противном случае `typeResolver` не вызывается и дальнейшая попытка разрешить тип.|  
|тип|значение NULL, в который|null|Аналогичен вызову <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> перегрузки метода. Поскольку имя сборки не указан, поиск только библиотеки Mscorlib.dll и текущей выполняемой сборке. Если `assemblyResolver` не предоставлен, он игнорируется.|  
|type|значение NULL, в который|предоставленный|`typeResolver` вызывается, и `null` передается для сборки. `typeResolver` можно предоставить тип из любой сборки, включая сборки, загружаемые для этой цели. Если `assemblyResolver` не предоставлен, он игнорируется.|  
|сборка|значение NULL, в который|значение NULL, в который|Объект <xref:System.IO.FileLoadException> создается исключение, так как имя сборки проанализировать, как если бы оно является именем типа с указанием сборки. Это приводит к недопустимое имя сборки.|  
  
 Обратно: [заметки по использованию](#usage_notes), [разрешении сборок](#resolving_assemblies), [разрешения типов](#resolving_types).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Инициализатор класса вызывается и создает исключение.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> имеет значение <see langword="true" />, и тип не найден.  
  
 - или -  
  
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимые знаки, например внедренные табуляции.  
  
 - или -  
  
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> является пустой строкой.  
  
 - или -  
  
 <paramref name="throwOnError" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> представляет тип массива с недопустимым размером.  
  
 - или -  
  
 <paramref name="typeName" /> представляет массив <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">Ошибка происходит при разборе <paramref name="typeName" /> в имя типа и имя сборки (например, если простое имя типа содержит не преобразованный в escape-последовательность специальный знак).  
  
 - или -  
  
 <paramref name="throwOnError" /> равно <see langword="true" />, а <paramref name="typeName" /> содержит недопустимый синтаксис (например, «MyType[,*,]»).  
  
 - или -  
  
 <paramref name="typeName" /> представляет универсальный тип, имеющий тип указателя, тип <see langword="ByRef" /> или <see cref="T:System.Void" /> в качестве одного из его аргументов типа.  
  
 - или -  
  
 <paramref name="typeName" /> представляет универсальный тип, который содержит неправильное количество аргументов типа.  
  
 - или -  
  
 <paramref name="typeName" /> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> имеет значение <see langword="true" />, и не удалось найти сборку либо одну из ее зависимостей.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или одна из ее зависимостей найдена, но не может быть загружена.  
  
 - или -  
  
 <paramref name="typeName" /> содержит недопустимое имя сборки.  
  
 - или -  
  
 <paramref name="typeName" /> является допустимым именем сборки без типа имени.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка или одна из ее зависимостей является недопустимой.  
  
 - или -  
  
 Сборка была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">Массив объектов, типы которых нужно определить.</param>
        <summary>Возвращает типы объектов в указанном массиве.</summary>
        <returns>Массив объектов <see cref="T:System.Type" />, представляющих типы соответствующих элементов в массиве <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Type.GetTypeArray%2A> метод, чтобы вывести список элементов массива.  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="args" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Один или несколько элементов в <paramref name="args" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Вызываются инициализаторы класса, и по крайней мере один из них создает исключение.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Тип, код базового типа которого требуется получить.</param>
        <summary>Возвращает код базового типа указанного объекта <see cref="T:System.Type" />.</summary>
        <returns>Код базового типа или <see cref="F:System.TypeCode.Empty" />, если <paramref name="type" /> — <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При наследовании от <xref:System.Type>, поведение этого метода можно изменить путем переопределения <xref:System.Type.GetTypeCodeImpl%2A> метод.  
  
   
  
## Examples  
 В следующем примере кода показано, как <xref:System.TypeCode> перечисления может использоваться. В блоке принятия решений внутри `WriteObjectInfo` метода <xref:System.TypeCode> из <xref:System.Object> параметр проверяется, и в соответствующее сообщение записывается в консоль.  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает код базового типа этого экземпляра <see cref="T:System.Type" />.</summary>
        <returns>Код типа базового типа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод обеспечивает реализацию `static` (в C#) или `Shared` (в Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> метод. При наследовании от <xref:System.Type>, можно переопределить этот метод, чтобы предоставить свою собственную реализацию <xref:System.Type.GetTypeCode%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает тип, связанный с заданным кодом CLSID.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">Код CLSID извлекаемого типа.</param>
        <summary>Возвращает тип, связанный с заданным кодом CLSID.</summary>
        <returns>
          <see langword="System.__ComObject" /> вне зависимости от того, допустим ли код CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> Метод поддерживает доступ с поздним связыванием неуправляемый COM-объекты из приложения .NET Framework, когда вы знаете идентификатор класса COM-объекта (CLSID).  Идентификатор класса для COM-классов, определяется в разделе реестра HKEY_CLASSES_ROOT\CLSID. Можно извлечь значение <xref:System.Type.IsCOMObject%2A> свойства, чтобы определить, является ли тип, возвращаемый этим методом COM-объекта.  
  
> [!TIP]
>  Можно вызвать <xref:System.Type.GetTypeFromProgID%2A> метод для доступа с поздней привязкой для COM объектов которого программный идентификатор (ProgID) известно.  
  
 При создании экземпляра неуправляемый COM-объект, из идентификатора CLSID состоит из двух этапов:  
  
1.  Получить <xref:System.Type> , представляющий`__ComObject` , соответствующий идентификатор CLSID, вызвав <xref:System.Type.GetTypeFromCLSID%2A> метод.  
  
2.  Вызовите <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> метод для создания экземпляра COM-объекта.  
  
 См. пример для иллюстрации.  
  
 <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> Перегрузки не обрабатывает любое исключение, которое возникает при создании экземпляра <xref:System.Type> объекта, основанного на `clsid` аргумент. Обратите внимание, что исключение не возникает, если `clsid` не найден в реестре.  
  
   
  
## Examples  
 В следующем примере используется код CLSID Microsoft Word [объект приложения](http://msdn.microsoft.com/library/office/ff838565.aspx) для получения модели COM тип, представляющий приложение Microsoft Word. Тип создается путем вызова <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> метода и закрывает его, вызвав [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) метод.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Этот метод предназначен для использования при работе с COM-объектами, а не с объектами .NET Framework. Все управляемые объекты, включая те, которые являются видимыми для COM (то есть их <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> атрибут <see langword="true" />) имеют идентификатор GUID, который возвращается методом <see cref="P:System.Type.GUID" /> свойство. Несмотря на то, что метод возвращает <see cref="T:System.Type" /> объектов объекта, который соответствует идентификатору GUID для .NET Framework, нельзя использовать, <see cref="T:System.Type" /> объекта создаваемого экземпляра типа путем вызова <see cref="M:System.Activator.CreateInstance(System.Type)" /> метода, как показано в следующем примере.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 Вместо этого <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> следует использовать только для получения GUID неуправляемый COM-объект и итоговый <see cref="T:System.Type" /> объект, передаваемый <see cref="M:System.Activator.CreateInstance(System.Type)" /> метод должен представлять неуправляемый COM-объект.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">Код CLSID извлекаемого типа.</param>
        <param name="throwOnError">
          Значение <see langword="true" /> для вызова любого возникшего исключения.  
  
 - или -  
  
 Значение <see langword="false" /> для игнорирования всех происходящих исключений.</param>
        <summary>Возвращает тип, связанный с заданным кодом CLSID, позволяющий определить, будет ли выбрасываться исключение в случае происхождения ошибки при загрузке типа.</summary>
        <returns>
          <see langword="System.__ComObject" /> вне зависимости от того, допустим ли код CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> Метод поддерживает доступ с поздним связыванием неуправляемый COM-объекты из приложения .NET Framework, когда вы знаете идентификатор класса COM-объекта (CLSID).  Идентификатор класса для COM-классов, определяется в разделе реестра HKEY_CLASSES_ROOT\CLSID. Можно извлечь значение <xref:System.Type.IsCOMObject%2A> свойства, чтобы определить, является ли тип, возвращаемый этим методом COM-объекта.  
  
> [!TIP]
>  Можно вызвать <xref:System.Type.GetTypeFromProgID%2A> метод для доступа с поздней привязкой для COM объектов которого программный идентификатор (ProgID) известно.  
  
 При создании экземпляра неуправляемый COM-объект, из идентификатора CLSID состоит из двух этапов:  
  
1.  Получить <xref:System.Type> , представляющий `__ComObject` , соответствующий идентификатор CLSID, вызвав <xref:System.Type.GetTypeFromCLSID%2A> метод.  
  
2.  Вызовите <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> метод для создания экземпляра COM-объекта.  
  
 См. пример для иллюстрации.  
  
 Такие исключения, как <xref:System.OutOfMemoryException> будет создано при указании `true` для `throwOnError`, но он не будет работать для незарегистрированных идентификаторов CLSID.  
  
   
  
## Examples  
 В следующем примере используется код CLSID Microsoft Word [объект приложения](http://msdn.microsoft.com/library/office/ff838565.aspx) для получения модели COM тип, представляющий приложение Microsoft Word. Тип создается путем вызова <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> метода и закрывает его, вызвав [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) метод. Исключение при возникновении ошибки при загрузке типа.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Этот метод предназначен для использования при работе с COM-объектами, а не с объектами .NET Framework. Все управляемые объекты, включая те, которые являются видимыми для COM (то есть их <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> атрибут <see langword="true" />) имеют идентификатор GUID, который возвращается методом <see cref="P:System.Type.GUID" /> свойство. Несмотря на то, что метод возвращает <see cref="T:System.Type" /> объектов объекта, который соответствует идентификатору GUID для .NET Framework, нельзя использовать, <see cref="T:System.Type" /> объекта создаваемого экземпляра типа путем вызова <see cref="M:System.Activator.CreateInstance(System.Type)" /> метода, как показано в следующем примере.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 Вместо этого <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> следует использовать только для получения GUID неуправляемый COM-объект и итоговый <see cref="T:System.Type" /> объект, передаваемый <see cref="M:System.Activator.CreateInstance(System.Type)" /> метод должен представлять неуправляемый COM-объект.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">Код CLSID извлекаемого типа.</param>
        <param name="server">Сервер, с которого должен быть загружен тип. Если в качестве имени сервера задано значение <see langword="null" />, этот метод автоматически перейдет к поиску на локальном компьютере.</param>
        <summary>Возвращает с указанного сервера тип, связанный с заданным кодом CLSID.</summary>
        <returns>
          <see langword="System.__ComObject" /> вне зависимости от того, допустим ли код CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> Метод поддерживает доступ с поздним связыванием неуправляемый COM-объекты из приложения .NET Framework, когда вы знаете идентификатор класса COM-объекта (CLSID).  Идентификатор класса для COM-классов, определяется в разделе реестра HKEY_CLASSES_ROOT\CLSID. Можно извлечь значение <xref:System.Type.IsCOMObject%2A> свойства, чтобы определить, является ли тип, возвращаемый этим методом COM-объекта.  
  
> [!TIP]
>  Можно вызвать <xref:System.Type.GetTypeFromProgID%2A> метод для доступа с поздней привязкой для COM объектов которого программный идентификатор (ProgID) известно.  
  
 При создании экземпляра неуправляемый COM-объект, из идентификатора CLSID состоит из двух этапов:  
  
1.  Получить <xref:System.Type> , представляющий `__ComObject` , соответствующий идентификатор CLSID, вызвав <xref:System.Type.GetTypeFromCLSID%2A> метод.  
  
2.  Вызовите <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> метод для создания экземпляра COM-объекта.  
  
   
  
## Examples  
 В следующем примере используется код CLSID Microsoft Word [объект приложения](http://msdn.microsoft.com/library/office/ff838565.aspx) для получения модели COM тип, представляющий приложение Microsoft Word на сервере с именем computer17.central.contoso.com. Тип создается путем вызова <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> метода и закрывает его, вызвав [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) метод.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Этот метод предназначен для использования при работе с COM-объектами, а не с объектами .NET Framework. Все управляемые объекты, включая те, которые являются видимыми для COM (то есть их <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> атрибут <see langword="true" />) имеют идентификатор GUID, который возвращается методом <see cref="P:System.Type.GUID" /> свойство. Несмотря на то, что метод возвращает <see cref="T:System.Type" /> объектов объекта, который соответствует идентификатору GUID для .NET Framework, нельзя использовать, <see cref="T:System.Type" /> объекта создаваемого экземпляра типа путем вызова <see cref="M:System.Activator.CreateInstance(System.Type)" /> метода, как показано в следующем примере.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 Вместо этого <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> следует использовать только для получения GUID неуправляемый COM-объект и итоговый <see cref="T:System.Type" /> объект, передаваемый <see cref="M:System.Activator.CreateInstance(System.Type)" /> метод должен представлять неуправляемый COM-объект.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">Код CLSID извлекаемого типа.</param>
        <param name="server">Сервер, с которого должен быть загружен тип. Если в качестве имени сервера задано значение <see langword="null" />, этот метод автоматически перейдет к поиску на локальном компьютере.</param>
        <param name="throwOnError">
          Значение <see langword="true" /> для вызова любого возникшего исключения.  
  
 - или -  
  
 Значение <see langword="false" /> для игнорирования всех происходящих исключений.</param>
        <summary>Возвращает с указанного сервера тип, связанный с заданным кодом CLSID, позволяющий определить, будет ли выбрасываться исключение при происхождении ошибки во время загрузки типа.</summary>
        <returns>
          <see langword="System.__ComObject" /> вне зависимости от того, допустим ли код CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetTypeFromCLSID%2A> Метод поддерживает доступ с поздним связыванием неуправляемый COM-объекты из приложения .NET Framework, когда вы знаете идентификатор класса COM-объекта (CLSID).  Идентификатор класса для COM-классов, определяется в разделе реестра HKEY_CLASSES_ROOT\CLSID. Можно извлечь значение <xref:System.Type.IsCOMObject%2A> свойства, чтобы определить, является ли тип, возвращаемый этим методом COM-объекта.  
  
> [!TIP]
>  Можно вызвать <xref:System.Type.GetTypeFromProgID%2A> метод для доступа с поздней привязкой для COM объектов которого программный идентификатор (ProgID) известно.  
  
 При создании экземпляра неуправляемый COM-объект, из идентификатора CLSID состоит из двух этапов:  
  
1.  Получить <xref:System.Type> , представляющий `__ComObject` , соответствующий идентификатор CLSID, вызвав <xref:System.Type.GetTypeFromCLSID%2A> метод.  
  
2.  Вызовите <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> метод для создания экземпляра COM-объекта.  
  
 Такие исключения, как <xref:System.OutOfMemoryException> будет создано при указании `true` для `throwOnError`, но он не будет работать для незарегистрированных идентификаторов CLSID.  
  
   
  
## Examples  
 В следующем примере используется код CLSID Microsoft Word [объект приложения](http://msdn.microsoft.com/library/office/ff838565.aspx) для получения модели COM тип, представляющий приложение Microsoft Word на сервере с именем computer17.central.contoso.com. Тип создается путем вызова <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> метода и закрывает его, вызвав [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) метод. Исключение при возникновении ошибки при загрузке типа.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Этот метод предназначен для использования при работе с COM-объектами, а не с объектами .NET Framework. Все управляемые объекты, включая те, которые являются видимыми для COM (то есть их <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> атрибут <see langword="true" />) имеют идентификатор GUID, который возвращается методом <see cref="P:System.Type.GUID" /> свойство. Несмотря на то что <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> возвращает <see cref="T:System.Type" /> объекта, который соответствует идентификатору GUID для конкретного управляемого объекта, нельзя использовать <see cref="T:System.Type" /> объекта создаваемого экземпляра типа путем вызова <see cref="M:System.Activator.CreateInstance(System.Type)" /> метода, как в следующем примере Показывает.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 Вместо этого <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> следует использовать только для получения GUID неуправляемый COM-объект и итоговый <see cref="T:System.Type" /> объект, передаваемый <see cref="M:System.Activator.CreateInstance(System.Type)" /> метод должен представлять неуправляемый COM-объект.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Объект, который ссылается на тип.</param>
        <summary>Возвращает тип, на который ссылается указанный дескриптор типа.</summary>
        <returns>Тип, на который ссылается заданный дескриптор <see cref="T:System.RuntimeTypeHandle" />, или значение <see langword="null" />, если значение свойства <see cref="P:System.RuntimeTypeHandle.Value" /> параметра <paramref name="handle" /> равно <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дескрипторы доступны только в домене приложения, в котором они были получены.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Type.GetTypeFromHandle%2A> метод, чтобы получить <xref:System.Type> объекта из <xref:System.RuntimeTypeHandle> , предоставляемые <xref:System.Type.GetTypeHandle%2A> метод.  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Инициализатор класса вызывается и создает исключение.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает тип, связанный с заданным идентификатором ProgID.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">Идентификатор ProgID извлекаемого типа.</param>
        <summary>Возвращает тип, связанный с указанным идентификатором ProgID, и возвращает значение NULL, если при загрузке объекта <see cref="T:System.Type" /> возникла ошибка.</summary>
        <returns>Тип, связанный с указанным идентификатором ProgID, если идентификатор <paramref name="progID" /> является допустимой записью в реестре и с ним связан определенный тип; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для поддержки модели COM. Идентификаторы ProgID не используются в Microsoft .NET Framework, так как они были заменены концепции пространства имен.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Свойство <paramref name="progID" /> имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">Идентификатор ProgID извлекаемого типа.</param>
        <param name="throwOnError">
          Значение <see langword="true" /> для вызова любого возникшего исключения.  
  
 - или -  
  
 Значение <see langword="false" /> для игнорирования всех происходящих исключений.</param>
        <summary>Возвращает тип, связанный с заданным идентификатором ProgID, позволяющим определить, будет ли выбрасываться исключение при происхождении ошибки во время загрузки типа.</summary>
        <returns>Тип, связанный с указанным идентификатором ProgID, если идентификатор <paramref name="progID" /> является допустимой записью в реестре и с ним связан определенный тип; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для поддержки модели COM. Идентификаторы не используются в Microsoft .NET Framework, так как они были заменены концепции пространства имен.  
  
   
  
## Examples  
 В следующем примере извлекается тип путем передачи идентификатора ProgID, будет ли выбрасываться исключение при недопустимости идентификатор ProgID. Затем отображается идентификатор ClassID, связанный с ProgID, а также любые соответствующее сообщение об ошибке.  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Свойство <paramref name="progID" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Указанный идентификатор ProgID не зарегистрирован.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">Идентификатор ProgID извлекаемого типа.</param>
        <param name="server">Сервер, с которого должен быть загружен тип. Если в качестве имени сервера задано значение <see langword="null" />, этот метод автоматически перейдет к поиску на локальном компьютере.</param>
        <summary>Возвращает с указанного сервера тип, связанный с заданным идентификатором ProgID, и возвращает значение NULL, если при загрузке типа произошла ошибка.</summary>
        <returns>Тип, связанный с заданным идентификатором ProgID, если идентификатор <paramref name="progID" /> является допустимой записью в реестре и с ним связан определенный тип; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для поддержки модели COM. Идентификаторы не используются в Microsoft .NET Framework, так как они были заменены концепции пространства имен.  
  
   
  
## Examples  
 В следующем примере извлекается тип путем передачи идентификатора ProgID и имени сервера. В примере отображается идентификатор ClassID, связанный с ProgID или вызывает исключение, если идентификатор ProgID или имя сервера является недопустимым.  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Свойство <paramref name="prodID" /> имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">Идентификатор ProgID извлекаемого типа <see cref="T:System.Type" />.</param>
        <param name="server">Сервер, с которого должен быть загружен тип. Если в качестве имени сервера задано значение <see langword="null" />, этот метод автоматически перейдет к поиску на локальном компьютере.</param>
        <param name="throwOnError">
          Значение <see langword="true" /> для вызова любого возникшего исключения.  
  
 - или -  
  
 Значение <see langword="false" /> для игнорирования всех происходящих исключений.</param>
        <summary>Возвращает с указанного сервера тип, связанный с заданным идентификатором progID, который позволяет определить, будет ли выбрасываться исключение при происхождении ошибки во время загрузки типа.</summary>
        <returns>Тип, связанный с заданным идентификатором ProgID, если идентификатор <paramref name="progID" /> является допустимой записью в реестре и с ним связан определенный тип; в противном случае — значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для поддержки модели COM. Идентификаторы не используются в Microsoft .NET Framework, так как они были заменены концепции пространства имен.  
  
   
  
## Examples  
 В следующем примере извлекается тип путем передачи идентификатора ProgID и имени сервера. Затем отображается идентификатор ClassID, связанный с ProgID, будет ли выбрасываться исключение при недопустимости идентификатор ProgID или имя сервера.  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Свойство <paramref name="progID" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Указанный идентификатор progID не зарегистрирован.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Объект, для которого требуется получить дескриптор типа.</param>
        <summary>Возвращает дескриптор <see cref="T:System.Type" /> для указанного объекта.</summary>
        <returns>Дескриптор типа <see cref="T:System.Type" /> для указанного объекта <see cref="T:System.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дескрипторы доступны только в домене приложения, в котором они были получены.  
  
   
  
## Examples  
 В следующем примере определяется класс `MyClass1`, возвращает его экземпляр и извлекается дескриптор среды выполнения объекта.  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="o" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает идентификатор GUID, связанный с объектом <see cref="T:System.Type" />.</summary>
        <value>Идентификатор GUID, связанный с объектом <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификатор GUID связан с типом с помощью <xref:System.Runtime.InteropServices.GuidAttribute> атрибута.  
  
   
  
## Examples  
 В следующем примере создается класс `MyClass1` в открытый метод создает `Type` объект, соответствующий `MyClass1`и возвращает <xref:System.Guid> структуры с помощью `GUID` свойство `Type` класса.  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, содержит ли текущий объект <see cref="T:System.Type" /> в себе другой тип или ссылку на другой тип (иными словами, является ли текущий объект <see cref="T:System.Type" /> массивом, указателем либо параметром или же он передается по ссылке).</summary>
        <value>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является массивом, указателем или параметром, переданным по ссылке; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Например, Type.GetType("Int32[]"). Возвращает HasElementType `true`, но Type.GetType("Int32"). Возвращает HasElementType `false`. Также возвращает HasElementType `true` для «Int32 *» и «Int32 &».  
  
 Если текущий <xref:System.Type> представляет универсальный тип или параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
   
  
## Examples  
 В следующем примере возвращается `true` или `false` в зависимости от того, является ли объект является массив, указатель или ссылочным типом.  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе реализует свойство <see cref="P:System.Type.HasElementType" /> и определяет, что содержится в текущем объекте <see cref="T:System.Type" />: непосредственно другой тип или же указывающая на него ссылка (иными словами, является ли текущий объект <see cref="T:System.Type" /> массивом, указателем или параметром или же он передается по ссылке).</summary>
        <returns>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является массивом, указателем или параметром, переданным по ссылке; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Например, Type.GetType("Int32[]"). Возвращает HasElementTypeImpl `true`, но Type.GetType("Int32"). Возвращает HasElementTypeImpl `false`. Также возвращает HasElementTypeImpl `true` для «Int32 *» и «Int32 &».  
  
   
  
## Examples  
 В следующем примере определяется класс `MyTypeDelegator`, перезаписав `HasElementTypeImpl` метод. Главный класс проверяет `HasElementType` свойства и отображает тип элемента.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вызывает определенный член текущего объекта <see cref="T:System.Type" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя вызываемого элемента — конструктора, метода, свойства или поля.  
  
 - или -  
  
 Пустая строка ("") — в этом случае будет вызван член по умолчанию.  
  
 - или -  
  
 Для членов <see langword="IDispatch" /> — строка, представляющая идентификатор DispID, например "[DispID=3]".</param>
        <param name="invokeAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск. Тип доступа может быть обозначен одним из флагов <see langword="BindingFlags" />, например <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> и т.д. Тип поиска указывать необязательно. Если тип поиска не указан, используются флаги <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />.</param>
        <param name="binder">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.  
  
 - или -  
  
 Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />. Обратите внимание, что для успешного вызова перегруженных версий метода с переменными аргументами может потребоваться явное объявление объекта <see cref="T:System.Reflection.Binder" />.</param>
        <param name="target">Объект, для которого следует вызвать указанный член.</param>
        <param name="args">Массив с аргументами, передаваемыми вызываемому члену.</param>
        <summary>Вызывает указанный член, соответствующий заданным ограничениям привязки и указанному списку аргументов.</summary>
        <returns>Объект, представляющий возвращаемое значение вызываемого элемента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Нельзя использовать <xref:System.Type.InvokeMember%2A> в вызове универсального метода.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения члены, которые нужно включить в поиск:  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых членов.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск закрытым членам (то есть, закрытые и защищенные члены).  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения статические члены вверх по иерархии.  
  
 Следующие <xref:System.Reflection.BindingFlags> модификатор флаги можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только члены, объявленные в <xref:System.Type>, не унаследованные члены группы.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги вызова можно использовать для указания действия, выполняемого с членом:  
  
-   `CreateInstance` для вызова конструктора. `name` учитывается. Не является допустимым с другими флагами вызова.  
  
-   `InvokeMethod` для вызова метода, но не конструктор или инициализатор типа. Не является допустимым с `SetField` или `SetProperty`. Если `InvokeMethod` указан сам по себе `BindingFlags.Public`, `BindingFlags.Instance`, и `BindingFlags.Static` включаются автоматически.  
  
-   `GetField` Для получения значения поля. Не является допустимым с `SetField`.  
  
-   `SetField` Чтобы задать значение поля. Не является допустимым с `GetField`.  
  
-   `GetProperty` Для получения свойства. Не является допустимым с `SetProperty`.  
  
-   `SetProperty` Чтобы задать свойство. Не является допустимым с `GetProperty`.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Метод будет вызван, если выполняются оба следующих условия:  
  
-   Число параметров в объявлении метода равно количеству аргументов в `args` массив (если для члена не определены аргументы по умолчанию и `BindingFlags.OptionalParamBinding` указан).  
  
-   Тип каждого аргумента может преобразовываться связывателем тип параметра.  
  
 Связыватель найдет все подходящие методы. Эти методы находятся в зависимости от типа связывания (<xref:System.Reflection.BindingFlags> значения `InvokeMethod`, `GetProperty`и так далее). Набор методов фильтруется по имени, количество аргументов и набор модификаторов поиска, определенных в модуле привязки.  
  
 После выбора метода он вызывается. На этом этапе проверяется доступность. Средство поиска может управлять поиском определения набора методов на основе связанного с методом атрибута доступности. <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Метод <xref:System.Reflection.Binder> класс отвечает за выбор вызываемого метода. Связыватель по умолчанию выбирает наиболее точное соответствие.  
  
 Ограничения доступа игнорируются для полностью доверенный код; то есть, закрытые конструкторы, методы, поля и свойства можно получить доступ к и вызывать с помощью <xref:System.Reflection> каждый раз, когда код имеет полное доверие.  
  
 Можно использовать `Type.InvokeMember` присвоено конкретное значение в поле, указав <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Например, если вы хотите задать полю открытого экземпляра F класса C, а F — `String`, можно использовать код, например:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 Если F- `String[]`, можно использовать код, например:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 который будет инициализировать поля F новым массивом. Можно также использовать `Type.InvokeMember` Чтобы установить позиции в массиве, указав его индекс значения, и затем следующего значения с помощью кода примерно следующего вида:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 Это приведет к изменению строка «z» в массиве F строку «b».  
  
 При вызове `IDispatch` member, укажите идентификатор DispID, вместо имени элемента с помощью строки формата «[DispID = ##]». Например, если DispID MyComMethod равно 3, можно указать строку «[DispID = 3]» вместо «MyComMethod». Вызов члена по идентификатору DispID выполняется быстрее, чем поиск элемента по имени. В сложных сценариях агрегирования DispID иногда является единственным способом вызова необходимого члена.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым членам, если вызывающему объекту предоставлены <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и отметки Если набор прав, не являющиеся открытыми члены ограничена вызывающего набором разрешений или подмножество его. (См. [рекомендации по безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
   
  
## Examples  
 В следующем примере используется `InvokeMember` для доступа к членам типа.  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> не содержит <see langword="CreateInstance" />, а <paramref name="name" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" /> не является допустимым атрибутом <see cref="T:System.Reflection.BindingFlags" />.  
  
 - или -  
  
 <paramref name="invokeAttr" /> не содержит одного из следующих флагов привязки: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> или <see langword="SetProperty" />.  
  
 - или -  
  
 <paramref name="invokeAttr" /> содержит <see langword="CreateInstance" /> в сочетании с <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> или <see langword="SetProperty" />.  
  
 - или -  
  
 <paramref name="invokeAttr" /> содержит как <see langword="GetField" />, так и <see langword="SetField" />.  
  
 - или -  
  
 <paramref name="invokeAttr" /> содержит как <see langword="GetProperty" />, так и <see langword="SetProperty" />.  
  
 - или -  
  
 <paramref name="invokeAttr" /> содержит <see langword="InvokeMethod" /> в сочетании с <see langword="SetField" /> или <see langword="SetProperty" />.  
  
 - или -  
  
 <paramref name="invokeAttr" /> содержит <see langword="SetField" />, а <paramref name="args" /> содержит более одного элемента.  
  
 - или -  
  
 Этот метод вызывается для объекта COM, и один из следующих флагов привязки не был передан: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> или <see langword="BindingFlags.PutRefDispProperty" />.  
  
 - или -  
  
 Один из массивов именованных параметров содержит строку, имеющую значение <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">Указанный член является инициализатором класса.</exception>
        <exception cref="T:System.MissingFieldException">Невозможно найти поле или свойство.</exception>
        <exception cref="T:System.MissingMethodException">Невозможно найти метод, который соответствует аргументам в <paramref name="args" />.  
  
 - или -  
  
 Текущий объект <see cref="T:System.Type" /> представляет тип, содержащий параметры открытого типа, то есть <see cref="P:System.Type.ContainsGenericParameters" /> возвращает <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">Невозможно вызвать указанный член для <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Несколько методов соответствуют критериям привязки.</exception>
        <exception cref="T:System.NotSupportedException">Платформа .NET Compact Framework сейчас не поддерживает этот метод.</exception>
        <exception cref="T:System.InvalidOperationException">Метод, представленный <paramref name="name" />, имеет один или несколько незаданных параметров универсального типа. То есть свойство <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> метода возвращает <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым членам независимо от их разрешений набора. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя вызываемого элемента — конструктора, метода, свойства или поля.  
  
 - или -  
  
 Пустая строка ("") — в этом случае будет вызван член по умолчанию.  
  
 - или -  
  
 Для членов <see langword="IDispatch" /> — строка, представляющая идентификатор DispID, например "[DispID=3]".</param>
        <param name="invokeAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск. Тип доступа может быть обозначен одним из флагов <see langword="BindingFlags" />, например <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> и т.д. Тип поиска указывать необязательно. Если тип поиска не указан, используются флаги <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />.</param>
        <param name="binder">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.  
  
 - или -  
  
 Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />. Обратите внимание, что для успешного вызова перегруженных версий метода с переменными аргументами может потребоваться явное объявление объекта <see cref="T:System.Reflection.Binder" />.</param>
        <param name="target">Объект, для которого следует вызвать указанный член.</param>
        <param name="args">Массив с аргументами, передаваемыми вызываемому члену.</param>
        <param name="culture">Объект, представляющий используемые языковые стандарты глобализации. Его задание может понадобиться для выполнения преобразований, зависящих от языкового стандарта, например преобразования числовой строки <see cref="T:System.String" /> к типу <see cref="T:System.Double" />.  
  
 - или -  
  
 Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования объекта <see cref="T:System.Globalization.CultureInfo" /> текущего потока.</param>
        <summary>Вызывает указанный член, соответствующий заданным ограничениям привязки, списку аргументов, а также языку и региональным параметрам.</summary>
        <returns>Объект, представляющий возвращаемое значение вызываемого элемента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Несмотря на то что связыватель по умолчанию не обрабатывает <xref:System.Globalization.CultureInfo> ( `culture` параметр), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс, чтобы написать собственный связыватель, обрабатывающий `culture`.  
  
> [!NOTE]
>  Нельзя использовать <xref:System.Type.InvokeMember%2A> в вызове универсального метода.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения члены, которые нужно включить в поиск:  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых членов.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск закрытым членам (то есть частных, внутренних и защищенные члены).  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения статические члены вверх по иерархии.  
  
 Следующие <xref:System.Reflection.BindingFlags> модификатор флаги можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только члены, объявленные в <xref:System.Type>, не унаследованные члены группы.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги вызова можно использовать для указания действия, выполняемого с членом:  
  
-   `CreateInstance` для вызова конструктора. `name` учитывается. Не является допустимым с другими флагами вызова.  
  
-   `InvokeMethod` для вызова метода, но не конструктор или инициализатор типа. Не является допустимым с `SetField` или `SetProperty`. Если `InvokeMethod` указан сам по себе `BindingFlags.Public`, `BindingFlags.Instance`, и `BindingFlags.Static` включаются автоматически.  
  
-   `GetField` Для получения значения поля. Не является допустимым с `SetField`.  
  
-   `SetField` Чтобы задать значение поля. Не является допустимым с `GetField`.  
  
-   `GetProperty` Для получения свойства. Не является допустимым с `SetProperty`.  
  
-   `SetProperty` Чтобы задать свойство. Не является допустимым с `GetProperty`.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Метод будет вызван, если выполняются оба следующих условия:  
  
-   Число параметров в объявлении метода равно количеству аргументов в `args` массив (если для члена не определены аргументы по умолчанию и `BindingFlags.OptionalParamBinding` указан).  
  
-   Тип каждого аргумента может преобразовываться связывателем тип параметра.  
  
 Связыватель найдет все подходящие методы. Эти методы находятся в зависимости от типа связывания (<xref:System.Reflection.BindingFlags> значения `InvokeMethod`, `GetProperty`и так далее). Набор методов фильтруется по имени, количество аргументов и набор модификаторов поиска, определенных в модуле привязки.  
  
 После выбора метода он вызывается. На этом этапе проверяется доступность. Средство поиска может управлять поиском определения набора методов на основе связанного с методом атрибута доступности. <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Метод <xref:System.Reflection.Binder> класс отвечает за выбор вызываемого метода. Связыватель по умолчанию выбирает наиболее точное соответствие.  
  
 Ограничения доступа игнорируются для полностью доверенный код; то есть закрытые конструкторы, методы, поля и свойства можно получить доступ к и вызываемыми средствами отражения, если полностью доверенный код.  
  
 Можно использовать `Type.InvokeMember` присвоено конкретное значение в поле, указав <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Например, если вы хотите задать полю открытого экземпляра F класса C, а F — `String` можно использовать код, например:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 Если F- `String[]`, можно использовать код, например:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 который будет инициализировать поля F новым массивом. Можно также использовать `Type.InvokeMember` Чтобы установить позиции в массиве, указав его индекс значения, и затем следующего значения с помощью кода примерно следующего вида:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 Это приведет к изменению строка «z» в массиве F строку «b».  
  
 При вызове `IDispatch` элемента, можно указать DispID вместо имени элемента с помощью строки формата «[DispID = ##]». Например, если DispID MyComMethod равно 3, можно указать строку «[DispID = 3]» вместо «MyComMethod». Вызов члена по идентификатору DispID выполняется быстрее, чем поиск элемента по имени. В сложных сценариях агрегирования DispID иногда является единственным способом вызова необходимого члена.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым членам, если вызывающему объекту предоставлены <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и отметки Если набор прав, не являющиеся открытыми члены ограничена вызывающего набором разрешений или подмножество его. (См. [рекомендации по безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> не содержит <see langword="CreateInstance" />, а <paramref name="name" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" /> не является допустимым атрибутом <see cref="T:System.Reflection.BindingFlags" />.  
  
 - или -  
  
 <paramref name="invokeAttr" /> не содержит одного из следующих флагов привязки: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> или <see langword="SetProperty" />.  
  
 - или -  
  
 <paramref name="invokeAttr" /> содержит <see langword="CreateInstance" /> в сочетании с <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> или <see langword="SetProperty" />.  
  
 - или -  
  
 <paramref name="invokeAttr" /> содержит как <see langword="GetField" />, так и <see langword="SetField" />.  
  
 - или -  
  
 <paramref name="invokeAttr" /> содержит как <see langword="GetProperty" />, так и <see langword="SetProperty" />.  
  
 - или -  
  
 <paramref name="invokeAttr" /> содержит <see langword="InvokeMethod" /> в сочетании с <see langword="SetField" /> или <see langword="SetProperty" />.  
  
 - или -  
  
 <paramref name="invokeAttr" /> содержит <see langword="SetField" />, а <paramref name="args" /> содержит более одного элемента.  
  
 - или -  
  
 Этот метод вызывается для объекта COM, и один из следующих флагов привязки не был передан: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> или <see langword="BindingFlags.PutRefDispProperty" />.  
  
 - или -  
  
 Один из массивов именованных параметров содержит строку, имеющую значение <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">Указанный член является инициализатором класса.</exception>
        <exception cref="T:System.MissingFieldException">Невозможно найти поле или свойство.</exception>
        <exception cref="T:System.MissingMethodException">Невозможно найти метод, который соответствует аргументам в <paramref name="args" />.  
  
 - или -  
  
 Текущий объект <see cref="T:System.Type" /> представляет тип, содержащий параметры открытого типа, то есть <see cref="P:System.Type.ContainsGenericParameters" /> возвращает <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">Невозможно вызвать указанный член для <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Несколько методов соответствуют критериям привязки.</exception>
        <exception cref="T:System.InvalidOperationException">Метод, представленный <paramref name="name" />, имеет один или несколько незаданных параметров универсального типа. То есть свойство <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> метода возвращает <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым членам независимо от их разрешений набора. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая имя вызываемого элемента — конструктора, метода, свойства или поля.  
  
 - или -  
  
 Пустая строка ("") — в этом случае будет вызван член по умолчанию.  
  
 - или -  
  
 Для членов <see langword="IDispatch" /> — строка, представляющая идентификатор DispID, например "[DispID=3]".</param>
        <param name="invokeAttr">Битовая маска, составленная из одного или нескольких объектов <see cref="T:System.Reflection.BindingFlags" /> и указывающая, как ведется поиск. Тип доступа может быть обозначен одним из флагов <see langword="BindingFlags" />, например <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> и т.д. Тип поиска указывать необязательно. Если тип поиска не указан, используются флаги <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />.</param>
        <param name="binder">Объект, определяющий набор свойств и разрешающий привязку, что может включать выбор перегруженных методов, приведение типов аргументов и вызов члена с помощью отражения.  
  
 - или -  
  
 Пустая ссылка (Nothing в Visual Basic) для использования свойства <see cref="P:System.Type.DefaultBinder" />. Обратите внимание, что для успешного вызова перегруженных версий метода с переменными аргументами может потребоваться явное объявление объекта <see cref="T:System.Reflection.Binder" />.</param>
        <param name="target">Объект, для которого следует вызвать указанный член.</param>
        <param name="args">Массив с аргументами, передаваемыми вызываемому члену.</param>
        <param name="modifiers">Массив объектов <see cref="T:System.Reflection.ParameterModifier" />, представляющих атрибуты, связанные с соответствующим элементом в массиве <c>args</c>. Атрибуты, связанные с параметром, хранятся в сигнатуре члена.  
  
 Связыватель по умолчанию обрабатывает этот параметр только при вызове COM-компонента.</param>
        <param name="culture">Объект <see cref="T:System.Globalization.CultureInfo" />, представляющий используемый языковой стандарт глобализации. Он может понадобиться для выполнения преобразований, зависящих от языкового стандарта, например приведения числа в строковом формате к типу Double.  
  
 - или -  
  
 Пустая ссылка (<see langword="Nothing" /> в Visual Basic) для использования объекта <see cref="T:System.Globalization.CultureInfo" /> текущего потока.</param>
        <param name="namedParameters">Массив, содержащий имена параметров, в которые передаются значения элементов массива <c>args</c>.</param>
        <summary>При переопределении в производном классе вызывает указанный член, соответствующий заданным ограничениям привязки, списку аргументов, модификаторов, а также языку и региональным параметрам.</summary>
        <returns>Объект, представляющий возвращаемое значение вызываемого элемента.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember` вызывает член конструктор или метод, возвращает или устанавливает значение свойства, возвращает или задает элемент поля данных, или возвращает или задает элемент массива.  
  
> [!NOTE]
>  Нельзя использовать <xref:System.Type.InvokeMember%2A> в вызове универсального метода.  
  
 При вызове `IDispatch` элемента, можно указать DispID вместо имени элемента с помощью строки формата «[DispID = ##]». Например, если DispID MyComMethod равно 3, можно указать строку «[DispID = 3]» вместо «MyComMethod». Вызов члена по идентификатору DispID выполняется быстрее, чем поиск элемента по имени. В сложных сценариях агрегирования DispID иногда является единственным способом вызова необходимого члена.  
  
 Несмотря на то что связыватель по умолчанию не обрабатывает <xref:System.Reflection.ParameterModifier> или <xref:System.Globalization.CultureInfo> ( `modifiers` и `culture` параметров), можно использовать абстрактный <xref:System.Reflection.Binder?displayProperty=nameWithType> класс, чтобы написать собственный связыватель, обрабатывающий `modifiers` и `culture`. `ParameterModifier` используется только при вызове посредством COM-взаимодействия и обрабатываются только те параметры, которые передаются по ссылке.  
  
 Каждый параметр в массиве `namedParameters` получает значение от соответствующего элемента массива `args`. Если длина `args` больше, чем длина `namedParameters`, оставшиеся значения аргументов передаются по порядку.  
  
 `namedParameters` Массива можно использовать для изменения порядка аргументов в входного массива. Например, если метод `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` в Visual Basic) и входного массива `{ 42, "x" }`, входного массива могут передаваться в неизмененном виде `args` Если массив `{ "b", "a" }` предоставляется для `namedParameters`.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги фильтра можно использовать для определения члены, которые нужно включить в поиск:  
  
-   Укажите `BindingFlags.Public` для включения в поиск открытых членов.  
  
-   Укажите `BindingFlags.NonPublic` для включения в поиск закрытым членам (то есть частных, внутренних и защищенные члены).  
  
-   Укажите `BindingFlags.FlattenHierarchy` для включения статические члены вверх по иерархии.  
  
 Следующие <xref:System.Reflection.BindingFlags> модификатор флаги можно использовать для изменения условий поиска:  
  
-   `BindingFlags.IgnoreCase` Чтобы игнорировать регистр `name`.  
  
-   `BindingFlags.DeclaredOnly` для поиска только члены, объявленные в <xref:System.Type>, не унаследованные члены группы.  
  
 Следующие <xref:System.Reflection.BindingFlags> флаги вызова можно использовать для указания действия, выполняемого с членом:  
  
-   `CreateInstance` для вызова конструктора. `name` учитывается. Не является допустимым с другими флагами вызова.  
  
-   `InvokeMethod` для вызова метода, но не конструктор или инициализатор типа. Не является допустимым с `SetField` или `SetProperty`. Если `InvokeMethod` указан сам по себе `BindingFlags.Public`, `BindingFlags.Instance`, и `BindingFlags.Static` включаются автоматически.  
  
-   `GetField` Для получения значения поля. Не является допустимым с `SetField`.  
  
-   `SetField` Чтобы задать значение поля. Не является допустимым с `GetField`.  
  
-   `GetProperty` Для получения свойства. Не является допустимым с `SetProperty`.  
  
-   `SetProperty` Чтобы задать свойство. Не является допустимым с `GetProperty`.  
  
 Дополнительные сведения см. в разделе <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Метод будет вызван, если выполняются оба следующих условия:  
  
-   Число параметров в объявлении метода равно количеству аргументов в `args` массив (если для члена не определены аргументы по умолчанию и `BindingFlags.OptionalParamBinding` указан).  
  
-   Тип каждого аргумента может преобразовываться связывателем тип параметра.  
  
 Связыватель найдет все подходящие методы. Эти методы находятся в зависимости от типа связывания (<xref:System.Reflection.BindingFlags> значения `InvokeMethod`, `GetProperty`и так далее). Набор методов фильтруется по имени, количество аргументов и набор модификаторов поиска, определенных в модуле привязки.  
  
 После выбора метода он вызывается. На этом этапе проверяется доступность. Средство поиска может управлять поиском определения набора методов на основе связанного с методом атрибута доступности. <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Метод <xref:System.Reflection.Binder> класс отвечает за выбор вызываемого метода. Связыватель по умолчанию выбирает наиболее точное соответствие.  
  
 `InvokeMember` можно использовать для вызова методов с параметрами, имеющими значения по умолчанию. Чтобы связать эти методы, требуется отражения <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> должен быть задан. Для параметра, имеющего значение по умолчанию, можно указать другое значение, или указать <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> использовать значение по умолчанию.  
  
 Например, рассмотрим метод, например MyMethod (int, x, float y = 2.0). Чтобы вызвать этот метод только с первым аргументом как MyMethod(4), передать один из упомянутых выше флагов привязки и два аргумента, а именно, 4 для первого аргумента и `Missing.Value` второго аргумента. Если вы не используете `Missing.Value`, не менее опускать необязательные параметры с `Invoke` метод. Если необходимо сделать это, используйте `InvokeMember` вместо него.  
  
 Ограничения доступа игнорируются для полностью доверенный код; то есть, закрытые конструкторы, методы, поля и свойства можно получить доступ к и вызывать с помощью <xref:System.Reflection> каждый раз, когда код имеет полное доверие.  
  
 Можно использовать `Type.InvokeMember` присвоено конкретное значение в поле, указав <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Например, если вы хотите задать полю открытого экземпляра F класса C, а F — `String`, можно использовать код, например:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 Если F- `String[]`, можно использовать код, например:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 который будет инициализировать поля F новым массивом. Можно также использовать `Type.InvokeMember` Чтобы установить позиции в массиве, указав его индекс значения, и затем следующего значения с помощью кода примерно следующего вида:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 Это приведет к изменению строка «z» в массиве F строку «b».  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к закрытым членам, если вызывающему объекту предоставлены <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> и отметки Если набор прав, не являющиеся открытыми члены ограничена вызывающего набором разрешений или подмножество его. (См. [рекомендации по безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" /> не содержит <see langword="CreateInstance" />, а <paramref name="name" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="args" /> и <paramref name="modifiers" /> имеют разную длину.  
  
 - или -  
  
 <paramref name="invokeAttr" /> не является допустимым атрибутом <see cref="T:System.Reflection.BindingFlags" />.  
  
 - или -  
  
 <paramref name="invokeAttr" /> не содержит одного из следующих флагов привязки: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> или <see langword="SetProperty" />.  
  
 - или -  
  
 <paramref name="invokeAttr" /> содержит <see langword="CreateInstance" /> в сочетании с <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> или <see langword="SetProperty" />.  
  
 - или -  
  
 <paramref name="invokeAttr" /> содержит как <see langword="GetField" />, так и <see langword="SetField" />.  
  
 - или -  
  
 <paramref name="invokeAttr" /> содержит как <see langword="GetProperty" />, так и <see langword="SetProperty" />.  
  
 - или -  
  
 <paramref name="invokeAttr" /> содержит <see langword="InvokeMethod" /> в сочетании с <see langword="SetField" /> или <see langword="SetProperty" />.  
  
 - или -  
  
 <paramref name="invokeAttr" /> содержит <see langword="SetField" />, а <paramref name="args" /> содержит более одного элемента.  
  
 - или -  
  
 Массив именованных параметров больше, чем массив аргументов.  
  
 - или -  
  
 Этот метод вызывается для объекта COM, и один из следующих флагов привязки не был передан: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> или <see langword="BindingFlags.PutRefDispProperty" />.  
  
 - или -  
  
 Один из массивов именованных параметров содержит строку, имеющую значение <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">Указанный член является инициализатором класса.</exception>
        <exception cref="T:System.MissingFieldException">Невозможно найти поле или свойство.</exception>
        <exception cref="T:System.MissingMethodException">Невозможно найти метод, который соответствует аргументам в <paramref name="args" />.  
  
 - или -  
  
 Невозможно найти члены с именами аргументов, указанными в <paramref name="namedParameters" />.  
  
 - или -  
  
 Текущий объект <see cref="T:System.Type" /> представляет тип, содержащий параметры открытого типа, то есть <see cref="P:System.Type.ContainsGenericParameters" /> возвращает <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">Невозможно вызвать указанный член для <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Несколько методов соответствуют критериям привязки.</exception>
        <exception cref="T:System.InvalidOperationException">Метод, представленный <paramref name="name" />, имеет один или несколько незаданных параметров универсального типа. То есть свойство <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> метода возвращает <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для доступа к закрытым членам независимо от их разрешений набора. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, является ли данный объект <see cref="T:System.Type" /> абстрактным объектом, который должен быть переопределен.</summary>
        <value>
          Значение <see langword="true" />, если класс <see cref="T:System.Type" /> является абстрактным; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAbstract%2A> Возвращает `true` в следующих случаях:  
  
-   Текущий тип является абстрактным. то есть он не может быть создан, но только можно использовать в качестве базового класса для производных классов. В C#, абстрактные классы отмечены [абстрактный](~/docs/csharp/language-reference/keywords/abstract.md) ключевого слова; в Visual Basic, они отмечены [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) ключевое слово.  
  
-   Текущий тип является интерфейсом.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
   
  
## Examples  
 В следующем примере создается массив <xref:System.Type> объекты, представляющие следующие типы: содержит возвращаемые значения типа `true` , если указанный объект `abstract`; в противном случае он возвращает `false`.  
  
-   `AbstractClass`, абстрактного класса (класс, помеченный как `abstract` в C# и `MustInherit` в Visual Basic).  
  
-   `DerivedClass`, который наследует от класса `AbstractClass`.  
  
-   `SingleClass`, класс не наследуется. Он определяется как `sealed` в C# и `NotInheritable` в Visual Basic.  
  
-   `ITypeInfo`, интерфейс.  
  
-   `ImplementingClass`, класс, реализующий `ITypeInfo` интерфейса.  
  
 Метод возвращает `true` только для `AbstractClass`, абстрактного класса, и `ITypeInfo`, интерфейс.  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, выбран ли для объекта <see langword="AnsiClass" /> атрибут формата строки <see cref="T:System.Type" />.</summary>
        <value>
          Значение <see langword="true" />, если для данного объекта <see langword="AnsiClass" /> выбран атрибут формата строки <see cref="T:System.Type" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> Выбирает атрибутов формата строки. Атрибуты формата строки расширяют возможности взаимодействия, определение того, как должны интерпретироваться строки.  
  
 Если текущий <xref:System.Type> представляет универсальный тип, это свойство относится к определению универсального типа, тип был создан. Например если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.  
  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.  
  
   
  
## Examples  
 В следующем примере возвращаются сведения и проверяет наличие `AnsiClass` атрибута.  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, является ли тип массивом.</summary>
        <value>
          Значение <see langword="true" />, если текущий тип является массивом; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsArray%2A> Возвращает `false` для <xref:System.Array> класса. Он также возвращает `false` , если текущий экземпляр является <xref:System.Type> объект, представляющий тип коллекции или интерфейс предназначен для работы с коллекциями, таких как <xref:System.Collections.IEnumerable> или <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Чтобы проверить наличие массив, можно используйте следующий код:  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 Если текущий тип представляет универсальный тип или параметр типа в определении универсального типа или универсального метода, это свойство всегда возвращает `false`.  
  
 Это свойство доступно только для чтения.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Type.IsArray%2A> свойство.  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе реализует свойство <see cref="P:System.Type.IsArray" /> и определяет, является ли данный объект <see cref="T:System.Type" /> массивом.</summary>
        <returns>
          Значение <see langword="true" />, если <see cref="T:System.Type" /> является массивом; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Экземпляр <xref:System.Array> должны возвращать класс `false` , так как он является объектом, не массив.  
  
   
  
## Examples  
 В следующем примере переопределяется `IsArrayImpl` метод `MyTypeDelegator` класса, проверяется, если переменная является массивом и отображается результат.  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">Тип для сравнения с текущим типом.</param>
        <summary>Определяет, можно ли присвоить экземпляр указанного типа экземпляру текущего типа.</summary>
        <returns>
          <see langword="true" />, если истинно любое из следующих условий:  
  
-   Параметр <paramref name="c" /> и текущий экземпляр принадлежат к одному типу.  
  
-   Параметр <paramref name="c" /> унаследован прямо или косвенно от текущего экземпляра. Параметр <paramref name="c" /> является производным непосредственно от текущего экземпляра, если он наследуется от него. Параметр <paramref name="c" /> является косвенно производным от текущего экземпляра, если он наследуется от последовательности одного или нескольких классов, наследуемых от текущего экземпляра.  
  
-   Текущий экземпляр является интерфейсом, который реализуется параметром <paramref name="c" />.  
  
-   <paramref name="c" /> является параметром универсального типа, а текущий экземпляр представляет одно из ограничений, наложенных на параметр <paramref name="c" />.  
  
     В приведенном ниже примере текущий экземпляр является объектом <see cref="T:System.Type" />, который представляет класс <see cref="T:System.IO.Stream" />. <c>GenericWithConstraint</c> — это универсальный тип, параметр универсального типа которого должен иметь тип <see cref="T:System.IO.Stream" />. Передача этого параметра универсального типа в <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> означает, что экземпляр параметра универсального типа можно присвоить объекту <see cref="T:System.IO.Stream" />.  
  
     [!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)]
     [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]  
  
-   <paramref name="c" /> представляет тип значения, а текущий экземпляр представляет <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> в Visual Basic).  
  
 Значение <see langword="false" />, если не выполняется ни одно из этих условий или значение параметра <paramref name="c" /> равно <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsAssignableFrom%2A> Метод может использоваться, чтобы определить, является ли экземпляр `c` можно назначить к экземпляру текущего типа, метод особенно полезен при работе с объектами, типы которых не известны во время разработки и обеспечивает условный Показывает назначений, в следующем примере.  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 Этот метод таким образом гарантирует, что строка кода, как следующие будет выполняться во время выполнения, не вызывая <xref:System.InvalidCastException> или аналогичные исключений:  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 Этот метод может быть переопределен в производном классе.  
  
> [!NOTE]
>  Определение универсального типа не может быть назначен из закрытым сконструированным типом. То есть нельзя назначить закрытым сконструированным типом `MyGenericList<int>` (`MyGenericList(Of Integer)` в Visual Basic) для переменной типа `MyGenericList<T>`.  
  
 Если `c` параметр имеет тип <xref:System.Reflection.Emit.TypeBuilder>, результат зависит от типа, который должен быть построен. В следующем примере кода это демонстрируется использование типа сборки с именем `B`.  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 В следующем примере демонстрируется `IsAssignableFrom` метода с помощью определенных классов, целое число со знаком массивы и универсальные шаблоны.  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, выбран ли для объекта <see langword="AutoClass" /> атрибут формата строки <see cref="T:System.Type" />.</summary>
        <value>
          Значение <see langword="true" />, если для данного объекта <see langword="AutoClass" /> выбран атрибут формата строки <see cref="T:System.Type" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> Выбирает атрибутов формата строки. Атрибуты формата строки расширяют возможности взаимодействия, определение того, как должны интерпретироваться строки.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, тип был создан. Например если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.  
  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, выкладываются ли поля текущего типа автоматически средой CLR.</summary>
        <value>
          Значение <see langword="true" />, если свойство <see cref="P:System.Type.Attributes" /> текущего типа включает <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предоставляется для удобства. Кроме того, можно использовать <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> значение перечисления, чтобы выбрать атрибуты макета типа и проверки ли <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> имеет значение. <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, И <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> значения перечисления указывают способ поля типа располагаются в памяти.  
  
 Для динамических типов, можно указать <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> при создании типа. В коде, применить <xref:System.Runtime.InteropServices.StructLayoutAttribute> атрибутом <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> значение перечисления в тип, позволяющий определить подходящий способ размещения класса среды выполнения.  
  
> [!NOTE]
>  Нельзя использовать <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> метод, чтобы определить, является ли <xref:System.Runtime.InteropServices.StructLayoutAttribute> был применен к типу.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, тип был создан. Например если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>.`  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
   
  
## Examples  
 В следующем примере создается экземпляр типа и отображает <xref:System.Type.IsAutoLayout%2A> свойство.  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, передан ли объект <see cref="T:System.Type" /> по ссылке.</summary>
        <value>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> передан по ссылке; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы получить фактический тип, разыменования тип, который был передан по ссылке, а затем вызвать <xref:System.Type.GetElementType%2A> этого типа.  
  
   
  
## Examples  
 В следующем примере показано использование `IsByRef` свойство, чтобы проверить, передается ли указанный тип по ссылке. В примере определяется класс `MyTypeDelegator`, перезаписав `HasElementTypeImpl` метод. Главный класс проверяет `HasElementType` свойства и отображает тип элемента.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе реализует свойство <see cref="P:System.Type.IsByRef" /> и определяет, передается ли данный объект <see cref="T:System.Type" /> по ссылке.</summary>
        <returns>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> передан по ссылке; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, позволяющее определить, является объект <see cref="T:System.Type" /> классом или делегатом (иными словами, не является типом значения или интерфейсом).</summary>
        <value>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является классом; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает `true` для классов, а также делегаты. Он возвращает `false` для типов значений (для структур и перечислений) даже в том случае, если упакованы.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `true`. Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство возвращает `true` Если определение универсального типа является определением класса; то есть, он не определяет интерфейсом или типом значения.  
  
> [!NOTE]
>  Это свойство возвращает `true` для `Type` экземпляров, представляющего <xref:System.Enum> и <xref:System.ValueType> классы. Эти классы являются базовые типы перечисления и типы значений, соответственно, но они не являются перечисления или тип значения, сами. Дополнительные сведения см. в разделе <xref:System.Type.IsValueType%2A> и <xref:System.Type.IsEnum%2A> свойства.  
  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> Значение перечисления, являющийся отличительным признаком объявление типа, как класс или интерфейс. Тем не менее, классов и типов значений, помечены <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> атрибута. Если извлечь значение свойства атрибуты и использовать тип <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> значение, чтобы определить, является ли тип классом вместо типа значения, необходимо вызвать <xref:System.Type.IsValueType%2A> свойство. Пример для <xref:System.Reflection.TypeAttributes> перечисление содержит дополнительные сведения, а также anexample.  
  
 Это свойство доступно только для чтения.  
  
   
  
## Examples  
 Следующий пример создает экземпляр типа и указывает, является ли тип классом.  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, является ли объект <see cref="T:System.Type" /> COM-объектом.</summary>
        <value>
          Значение <see langword="true" />, если <see cref="T:System.Type" /> является COM-объектом, в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает `false` для интерфейсов COM, так как они не являются объектами. Интерфейсы COM, могут быть реализованы объектами Microsoft .NET Framework.  
  
 Можно также загрузить класс COM и получить `Type` объект для этого класса COM с помощью [Tlbimp.exe (программа импорта библиотек типов)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) средства.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, тип был создан. Например если текущий <xref:System.Type> представляет `MyGenericType<int`> (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе реализует свойство <see cref="P:System.Type.IsCOMObject" /> и определяет, является ли объект <see cref="T:System.Type" /> COM-объектом.</summary>
        <returns>
          Значение <see langword="true" />, если <see cref="T:System.Type" /> является COM-объектом, в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает `false` для интерфейсов COM, так как они не являются объектами. Интерфейсы COM, могут быть реализованы объектами Microsoft .NET Framework.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, представляет ли этот данный объект сконструированный универсальный тип. Можно создать экземпляры сконструированного универсального типа.</summary>
        <value>
          Значение <see langword="true" />, если этот объект представляет сконструированный универсальный тип; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сконструированный универсальный тип был явно типы, предоставленный для всех параметров универсального типа. Его также называют закрытого универсального типа.  
  
 Если этому свойству присвоено `true`, когда это, можно создать экземпляры текущего типа `false`, невозможно.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, можно ли поместить в контекст объект <see cref="T:System.Type" />.</summary>
        <value>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> может быть помещен в контекст; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Контекст перехватывает вызовы к членам класса и принудительно применяет политики, применяемые к классу, например синхронизации. Более подробные сведения о контекстах удаленного взаимодействия см. в разделе <xref:System.Runtime.Remoting.Contexts.Context>.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
   
  
## Examples  
 В следующем примере демонстрируется `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, и <xref:System.Type.IsPrimitive%2A> свойства <xref:System.Type> класса. Проверяется ли данный тип может размещаться в контексте ли он может быть маршалирован по ссылке и является ли тип примитивный тип данных.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Реализует свойство <see cref="P:System.Type.IsContextful" /> и определяет, можно ли поместить в контекст данный объект <see cref="T:System.Type" />.</summary>
        <returns>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> может быть помещен в контекст; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен в производном классе.  
  
 Контекст перехватывает вызовы к членам класса и применять политики, которые применяются к классу, например синхронизации.  
  
   
  
## Examples  
 В следующем примере показано использование `IsContextfulImpl` метода.  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, представляет ли текущий объект <see cref="T:System.Type" /> перечисление.</summary>
        <value>
          Значение <see langword="true" />, если текущий объект <see cref="T:System.Type" /> представляет перечисление; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает `true` для перечисления, но не для <xref:System.Enum> сами типы.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, тип был создан. Например если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
 Это свойство доступно только для чтения.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование `IsEnum` свойство.  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Проверяемое значение.</param>
        <summary>Возвращает значение, показывающее, имеется ли в текущем типе перечисления указанное значение.</summary>
        <returns>
          Значение <see langword="true" />, если указанное значение является членом текущего типа перечисления; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Текущий тип не является перечислением.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="value" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> не является типом и не может быть основным типом для перечисления.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">Тип модели COM, который проверяется на эквивалентность текущему типу.</param>
        <summary>Определяет, имеют ли два типа модели COM одинаковые удостоверения и могут ли они считаться эквивалентными.</summary>
        <returns>
          Значение <see langword="true" />, если типы модели COM эквивалентны; в противном случае — значение <see langword="false" />. Этот метод также возвращает значение <see langword="false" />, если один тип находится в сборке, загружаемой для исполнения, а другой — в сборке, загружаемой в контекст, предназначенный только для отражения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начиная с версии [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], общеязыковая среда выполнения поддерживает внедрение сведений о типах COM непосредственно в управляемые сборки, не требуя управляемые сборки для получения сведений о типах COM из взаимодействия сборки. Так как внедренные сведения о типах включают в себя только типы и члены, которые действительно используются в управляемой сборке, в двух управляемых сборках могут быть очень разные представления одного типа COM. Все управляемые сборки имеют разные объекты <xref:System.Type> для обозначения представления типа COM. Среда CLR поддерживает эквивалентность типов между этими разными представлениями для интерфейсов, структур, перечислений и делегатов.  
  
 Эквивалентность типов означает, что COM-объект, передаваемый из одной управляемой сборки в другую, можно привести к соответствующему управляемому типу в принимающей сборке. <xref:System.Type.IsEquivalentTo%2A> Метод включает сборку определить, что COM-объект, полученный из другой сборки имеет то же удостоверение COM, как один из типов взаимодействия первой сборки собственные внедренных и таким образом, может быть приведен к этому типу.  
  
 Дополнительные сведения см. в разделе [эквивалентности типов и внедренных типов взаимодействия](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, выкладываются ли поля текущего типа с явно заданными смещениями.</summary>
        <value>
          Значение <see langword="true" />, если свойство <see cref="P:System.Type.Attributes" /> текущего типа включает <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предоставляется для удобства. Кроме того, можно использовать <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> значение перечисления, чтобы выбрать атрибуты макета типа и проверки ли <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> имеет значение. <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, И <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> значения перечисления указывают способ поля типа располагаются в памяти.  
  
 Для динамических типов, можно указать <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> при создании типа. В коде, применить <xref:System.Runtime.InteropServices.StructLayoutAttribute> атрибутом <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> значение перечисления в тип, чтобы указать смещение, с которого начинается поля указаны явным образом.  
  
> [!NOTE]
>  Нельзя использовать <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> метод, чтобы определить, является ли <xref:System.Runtime.InteropServices.StructLayoutAttribute> был применен к типу.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, тип был создан. Например если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
   
  
## Examples  
 В следующем примере создается экземпляр типа и выводится значение его <xref:System.Type.IsExplicitLayout%2A> свойство. Она использует `MySystemTime` класс, который также находится в примере кода для <xref:System.Runtime.InteropServices.StructLayoutAttribute>.  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, представляет ли текущий объект <see cref="T:System.Type" /> параметр типа в определении универсального типа или метода.</summary>
        <value>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> представляет параметр определения универсального типа; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type> объекты, представляющие параметры универсального типа можно получить, вызвав <xref:System.Type.GetGenericArguments%2A> метод <xref:System.Type> , представляющий определение универсального типа или <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> метод <xref:System.Reflection.MethodInfo> объекта, который представляет универсальный метод Определение.  
  
-   Для универсального типа или определение метода <xref:System.Type.IsGenericParameter%2A> возвращает `true` для каждого элемента результирующего массива.  
  
-   Для закрытого универсального типа или метода <xref:System.Type.IsGenericParameter%2A> возвращает `false` для каждого элемента массива, возвращаемого <xref:System.Type.GetGenericArguments%2A> метод.  
  
-   Для открытого сконструированного типа или метода некоторые элементы массива могут принадлежать к определенным типам, а другие могут быть параметрами типа. <xref:System.Type.IsGenericParameter%2A> Возвращает `false` для типов и `true` для параметров типа. В примере кода для <xref:System.Type.ContainsGenericParameters%2A> свойства демонстрирует универсального класса со сочетание типов и их параметров.  
  
 Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Type.IsGenericParameter%2A> свойство для проверки параметров универсального типа в универсальном типе.  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, является ли текущий тип универсальным.</summary>
        <value>
          <see langword="true" /> Если текущий тип является универсальным типом; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Type.IsGenericType%2A> свойство, чтобы определить, является ли <xref:System.Type> объект представляет универсальный тип. Используйте <xref:System.Type.ContainsGenericParameters%2A> свойства, чтобы определить ли <xref:System.Type> представляет открытого сконструированного типа или закрытым сконструированным типом.  
  
> [!NOTE]
>  <xref:System.Type.IsGenericType%2A> Возвращает `false` при интерпретации тип не является универсальным. Например, массив, элементы которого имеют тип `A<int>` (`A(Of Integer)` в Visual Basic) является сам по себе не является универсальным типом.  
  
 В следующей таблице перечислены неизменяемых условий для общих терминов, используемых в универсальном отражении.  
  
|Термин|Инвариант|  
|----------|---------------|  
|определение универсального типа|Значение свойства <xref:System.Type.IsGenericTypeDefinition%2A> — `true`.<br /><br /> Определяет универсальный тип. Сконструированный тип создается путем вызова <xref:System.Type.MakeGenericType%2A> метод <xref:System.Type> объект, представляющий определение универсального типа и указав массив аргументов типа.<br /><br /> <xref:System.Type.MakeGenericType%2A> может вызываться только для определений универсального типа.<br /><br /> Любое определение универсального типа является универсальным типом ( <xref:System.Type.IsGenericType%2A> свойство `true`), но не верно обратное.|  
|универсальный тип|Значение свойства <xref:System.Type.IsGenericType%2A> — `true`.<br /><br /> Может быть определением универсального типа, открытого сконструированного типа или закрытым сконструированным типом.<br /><br /> Обратите внимание, что тип массива, тип элементов которого является универсальным сам по себе не является универсальным типом. То же самое справедливо для <xref:System.Type> объект, представляющий указатель на универсальный тип.|  
|открытый сконструированный тип|Значение свойства <xref:System.Type.ContainsGenericParameters%2A> — `true`.<br /><br /> Примеры: универсальный тип, который неназначенные параметры типа, тип, вложенный в определении универсального типа или в виде открытого сконструированного типа или универсального типа с аргументом типа, для которого <xref:System.Type.ContainsGenericParameters%2A> свойство `true`.<br /><br /> Создайте экземпляр открытого сконструированного типа невозможна.<br /><br /> Обратите внимание, что не все открытые сконструированные типы являются универсальными. Например массива, тип элементов которого является определением универсального типа, не является универсальным, и указатель на открытый сконструированный тип не является универсальным.|  
|закрытым сконструированным типом|Значение свойства <xref:System.Type.ContainsGenericParameters%2A> — `false`.<br /><br /> При рекурсивном тип не имеет неназначенные универсальных параметров.|  
|параметр универсального типа|Значение свойства <xref:System.Type.IsGenericParameter%2A> — `true`.<br /><br /> Значение свойства <xref:System.Type.ContainsGenericParameters%2A> — `true`.<br /><br /> В определении универсального типа это заполнитель для типа, который будет назначен позже.|  
|аргумент универсального типа|Может быть любого типа, включая параметр универсального типа.<br /><br /> Аргументы типа задаются как массив <xref:System.Type> объекты передавать <xref:System.Type.MakeGenericType%2A> метод при создании сконструированного универсального типа. Если экземпляры результирующего типа создаваемой <xref:System.Type.ContainsGenericParameters%2A> свойство должно быть `false` для всех аргументов типа.|  
  
 Следующий пример кода и таблица иллюстрируют некоторые из этих условий и инварианты. `Derived` Класс является особенно интересны, так как его базовый тип является сконструированный тип, который содержит как типы и параметры типа в списке аргументов.  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 В следующей таблице показаны примеры, использовать и построить его в классах `Base`, `Derived`, и `G`. Когда код C++ и C# зависит от того, отображается только одна запись.  
  
|Пример|Инварианты|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|Для этого типа:<br /><br /> Свойство <xref:System.Type.IsGenericType%2A> имеет значение `true`.<br /><br /> Свойство <xref:System.Type.IsGenericTypeDefinition%2A> имеет значение `true`.<br /><br /> Свойство <xref:System.Type.ContainsGenericParameters%2A> имеет значение `true`.|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|Для этого типа:<br /><br /> Свойство <xref:System.Type.IsGenericType%2A> имеет значение `true`.<br /><br /> Свойство <xref:System.Type.IsGenericTypeDefinition%2A> имеет значение `false`.<br /><br /> Свойство <xref:System.Type.ContainsGenericParameters%2A> имеет значение `true`.|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|Для типа переменной `d`:<br /><br /> <xref:System.Type.IsGenericType%2A> — `false` поскольку `d` является массивом.<br /><br /> Свойство <xref:System.Type.IsGenericTypeDefinition%2A> имеет значение `false`.<br /><br /> Свойство <xref:System.Type.ContainsGenericParameters%2A> имеет значение `false`.|  
|`T`, `U`, и `V` (где они перечислены)|Свойство <xref:System.Type.IsGenericParameter%2A> имеет значение `true`.<br /><br /> <xref:System.Type.IsGenericType%2A> — `false` , так как нет возможности ограничить параметр типа для универсальных типов.<br /><br /> Свойство <xref:System.Type.IsGenericTypeDefinition%2A> имеет значение `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> — `true` из-за `T`, `U`, и `V` сами являются параметрами универсального типа. Это не означает, что-либо аргументы, которые им назначены более поздней версии.|  
|Тип поля `F`|Свойство <xref:System.Type.IsGenericType%2A> имеет значение `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> — `false` , так как параметр типа был назначен тип `G`. Обратите внимание, что это эквивалентно вызову <xref:System.Type.MakeGenericType%2A> метод.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> — `true` так как тип поля `F` имеет аргумент типа, который является открытым сконструированным типом. Сконструированный тип открыт из-за аргумента типа (то есть `Base`) является определением универсального типа. Это иллюстрирует характер рекурсивные <xref:System.Type.IsGenericType%2A> свойство.|  
|Вложенный класс `Nested`|<xref:System.Type.IsGenericType%2A> — `true`, даже если `Nested` класса не имеет универсальный тип параметров свои собственные, так как оно является вложенным в универсальный тип.<br /><br /> Свойство <xref:System.Type.IsGenericTypeDefinition%2A> имеет значение `true`. То есть, можно вызвать <xref:System.Type.MakeGenericType%2A> метод и задать параметр типа включающего типа `Derived`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> — `true` так как включающий тип, `Derived`, имеет параметры универсального типа. Это иллюстрирует характер рекурсивные <xref:System.Type.ContainsGenericParameters%2A> свойство.|  
  
   
  
## Examples  
 В следующем примере кода отображает значение <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, и <xref:System.Type.ContainsGenericParameters%2A> свойства для типов, описанных в разделе "Примечания". Объяснение значений свойств см в разделе Примечания.  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, представляет ли текущий объект <see cref="T:System.Type" /> определение универсального типа, на основе которого можно сконструировать другие универсальные типы.</summary>
        <value>
          Значение <see langword="true" />, если этот объект <see cref="T:System.Type" /> представляет определение универсального типа; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Определение универсального типа — это шаблон, из которого можно сконструировать другие типы. Например, в определении универсального типа `G<T>` (выраженная в синтаксис C#; `G(Of T)` в Visual Basic или `generic <typename T> ref class G` в C++) можно создать и создать экземпляр типа `G<int>` (`G(Of Integer)` в Visual Basic), путем вызова <xref:System.Type.MakeGenericType%2A> метод с универсальным аргументом список, содержащий <xref:System.Int32> типа. Получает <xref:System.Type> объект, представляющий это сконструированный тип, <xref:System.Type.GetGenericTypeDefinition%2A> метод возвращает определение универсального типа и обратно еще раз.  
  
 Используйте <xref:System.Type.IsGenericTypeDefinition%2A> свойство, чтобы определить, можно ли создавать новые типы из текущего типа. Если <xref:System.Type.IsGenericTypeDefinition%2A> возвращает `true`, можно вызвать <xref:System.Type.MakeGenericType%2A> метод, чтобы создать новые универсальные типы.  
  
 Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Следующий пример отображает сведения о типе, включая ли это определение универсального типа. Сведения отображаются для сконструированного типа, его определения универсального типа и обычный тип.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, есть ли у объекта <see cref="T:System.Type" /> атрибут <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />, свидетельствующий о том, что объект был импортирован из библиотеки COM-типов.</summary>
        <value>
          Значение <see langword="true" />, если у <see cref="T:System.Type" /> есть атрибут <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, тип был создан. Например если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>.`  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Объект, который требуется сравнить с текущим типом.</param>
        <summary>Определяет, является ли указанный объект экземпляром текущего типа <see cref="T:System.Type" />.</summary>
        <returns>
          Значение <see langword="true" />, если текущий объект <see langword="Type" /> входит в иерархию наследования объекта, представленного параметром <paramref name="o" /> или если текущий объект <see langword="Type" /> является интерфейсом, реализуемым параметром <paramref name="o" />. Значение <see langword="false" />, если не выполняется ни одно из перечисленных условий, параметр <paramref name="o" /> имеет значение <see langword="null" /> или текущий объект <see langword="Type" /> является открытым универсальным типом (то есть свойство <see cref="P:System.Type.ContainsGenericParameters" /> возвращает значение <see langword="true" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен в производном классе.  
  
> [!NOTE]
>  Сконструированный тип не является экземпляром определения универсального типа. То есть `MyGenericList<int>` (`MyGenericList(Of Integer)` в Visual Basic) не является экземпляром `MyGenericList<T>` (`MyGenericList(Of T)` в Visual Basic).  
  
   
  
## Examples  
 В следующем примере иллюстрируется использование метода `IsInstanceOfType`.  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, является ли объект <see cref="T:System.Type" /> интерфейсом (иными словами, не является классом или типом значения).</summary>
        <value>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является интерфейсом; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> Отличает объявление типа как класса, интерфейса или типа значения.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
 Это свойство доступно только для чтения.  
  
   
  
## Examples  
 Следующий пример создает интерфейс, проверяет тип интерфейса и указывает, имеет ли класс `IsInterface` набор свойств.  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, выкладываются ли поля текущего типа последовательно, в том порядке, в котором они были определены, или выдаются в метаданные.</summary>
        <value>
          Значение <see langword="true" />, если свойство <see cref="P:System.Type.Attributes" /> текущего типа включает <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предоставляется для удобства. Кроме того, можно использовать <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> значение перечисления, чтобы выбрать атрибуты макета типа и проверки ли <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> имеет значение. <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, И <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> значения перечисления указывают способ поля типа располагаются в памяти.  
  
 Для динамических типов, можно указать <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> при создании типа. В коде, применить <xref:System.Runtime.InteropServices.StructLayoutAttribute> атрибутом <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> значение перечисления в тип, для указания макета выполняются последовательно.  
  
> [!NOTE]
>  Нельзя использовать <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> метод, чтобы определить, является ли <xref:System.Runtime.InteropServices.StructLayoutAttribute> был применен к типу.  
  
 Дополнительные сведения см. раздел 9.1.2 спецификации Common Language Infrastructure (CLI) документацию по «Раздел II: определение метаданных и семантика». Документация доступна в Интернете; см. страницы [ECMAC# и стандарты Common Language Infrastructure](http://go.microsoft.com/fwlink/?LinkID=99212) на сайте MSDN и [Стандарт ECMA-335 — общеязыковая инфраструктура (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) на международном веб-сайте организации ECMA.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, тип был создан. Например если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
   
  
## Examples  
 В следующем примере создается экземпляр класса, для которого <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> значения перечисления в <xref:System.Runtime.InteropServices.StructLayoutAttribute> класса было установлено, проверьте наличие <xref:System.Type.IsLayoutSequential%2A> свойства и отображается результат.  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, маршалирован ли объект <see cref="T:System.Type" /> по ссылке.</summary>
        <value>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> маршалируется по ссылке; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере демонстрируется `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, и <xref:System.Type.IsPrimitive%2A> свойства <xref:System.Type> класса. Проверяется ли данный тип может размещаться в контексте ли он может быть маршалирован по ссылке и является ли тип примитивный тип данных.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Реализует свойство <see cref="P:System.Type.IsMarshalByRef" /> и определяет, маршалируется ли объект <see cref="T:System.Type" /> по ссылке.</summary>
        <returns>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> маршалируется по ссылке; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть переопределен в производном классе.  
  
   
  
## Examples  
 В следующем примере определяется, является ли данный тип маршалируется по ссылке и отображает результат.  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, представляет ли текущий объект <see cref="T:System.Type" /> тип, определение которого вложено в определение другого типа.</summary>
        <value>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> вложен в другой тип; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsNested%2A> Возвращает `true` для всех вложенных типов, независимо от видимости. Чтобы проверить вложение и видимость в то же время, используйте связанные свойства <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, или <xref:System.Type.IsNestedPublic%2A>.  
  
> [!NOTE]
>  <xref:System.Reflection.TypeAttributes.VisibilityMask> Член перечисления выбирает атрибуты видимости типа.  
  
   
  
## Examples  
 В следующем примере создается внешнего класса с количеством вложенных классов, имеющих различные виды видимость. Затем извлекается значение из нескольких связанных с видимостью <xref:System.Type> свойства для родительского типа и каждый из вложенных типов.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, является ли объект <see cref="T:System.Type" /> вложенным и видимым только в своей сборке.</summary>
        <value>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является вложенным и видимым только в своей сборке; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> выбирает атрибуты видимости.  
  
   
  
## Examples  
 В следующем примере создается внешнего класса с количеством вложенных классов, имеющих различные виды видимость. Затем извлекается значение из нескольких связанных с видимостью <xref:System.Type> свойства для родительского типа и каждый из вложенных типов.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, является ли объект <see cref="T:System.Type" /> вложенным и видимым только для классов, принадлежащих одновременно к семейству и сборке этого объекта.</summary>
        <value>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является вложенным и видимым только классам, принадлежащим одновременно к семейству и сборке этого объекта; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> выбирает атрибуты видимости.  
  
> [!NOTE]
>  В языках C# и Visual Basic, не включайте семантику, позволяют определить вложенный тип, который является видимым только для защищенные типы в сборке. `protected internal` видимость в C# и `Protected Friend` видимости в Visual Basic определить вложенный тип, который является видимым для защищенные типы и типы в той же сборке.  
  
 Объект <xref:System.Type> семейство объекта определяется как все объекты в одной и той же <xref:System.Type> и из его подтипов.  
  
   
  
## Examples  
 В следующем примере создается внешнего класса с количеством вложенных классов, имеющих различные виды видимость. Затем извлекается значение из нескольких связанных с видимостью <xref:System.Type> свойства для родительского типа и каждый из вложенных типов.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, является ли объект <see cref="T:System.Type" /> вложенным и видимым только в своем семействе.</summary>
        <value>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является вложенным и видимым только внутри собственного семейства; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> выбирает атрибуты видимости.  
  
 Объект <xref:System.Type> семейство объекта — это все объекты типа, представленного данным же <xref:System.Type> и из его подтипов.  
  
   
  
## Examples  
 В следующем примере создается внешнего класса с количеством вложенных классов, имеющих различные виды видимость. Затем извлекается значение из нескольких связанных с видимостью <xref:System.Type> свойства для родительского типа и каждый из вложенных типов.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, является ли данный объект <see cref="T:System.Type" /> вложенным и видимым только для классов, принадлежащих либо к его семейству, либо к его сборке.</summary>
        <value>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является вложенным и видимым только классам, принадлежащим его семейству или его сборке; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если видимость типа `protected internal` в C# или `Protected Friend` в Visual Basic <xref:System.Type.IsNestedFamORAssem%2A> возвращает `true`.  
  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> выбирает атрибуты видимости.  
  
 Объект <xref:System.Type> семейство объекта — это все объекты типа, представленного данным же <xref:System.Type> и из его подтипов.  
  
   
  
## Examples  
 В следующем примере создается внешнего класса с количеством вложенных классов, имеющих различные виды видимость. Затем извлекается значение из нескольких связанных с видимостью <xref:System.Type> свойства для родительского типа и каждый из вложенных типов.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, является ли объект <see cref="T:System.Type" /> вложенным и объявленным как закрытый.</summary>
        <value>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является вложенным и объявленным как закрытый; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> выбирает атрибуты видимости.  
  
   
  
## Examples  
 В следующем примере создается внешнего класса с количеством вложенных классов, имеющих различные виды видимость. Затем извлекается значение из нескольких связанных с видимостью <xref:System.Type> свойства для родительского типа и каждый из вложенных типов.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, является ли класс вложенным и объявленным как открытый.</summary>
        <value>
          Значение <see langword="true" />, если данный класс является вложенным и объявленным как открытый; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> выбирает атрибуты видимости.  
  
   
  
## Examples  
 В следующем примере создается внешнего класса с количеством вложенных классов, имеющих различные виды видимость. Затем извлекается значение из нескольких связанных с видимостью <xref:System.Type> свойства для родительского типа и каждый из вложенных типов.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, не был ли объект <see cref="T:System.Type" /> объявлен как открытый.</summary>
        <value>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> не объявлен как открытый и не является вложенным типом; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не используйте это свойство для вложенных типов. Используйте <xref:System.Type.IsNestedPublic%2A> свойство вместо него.  
  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство возвращает `false`.  
  
   
  
## Examples  
 Этот пример usesthe `IsNotPublic` свойство видимости типа.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 В следующем примере кода показано, почему не удается использовать `IsPublic` и `IsNotPublic` для вложенных классов.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 Для вложенных классов игнорировать результаты `IsPublic` и `IsNotPublic` и уделить внимание только результаты `IsNestedPublic` и `IsNestedPrivate`. Выходные данные отражения для этот фрагмент кода будет выглядеть следующим образом:  
  
|Класс|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|А|false|true|false|false|  
|С|false|false|true|false|  
|C|false|false|false|true|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, является ли объект <see cref="T:System.Type" /> указателем.</summary>
        <value>
          Значение <see langword="true" />, если <see cref="T:System.Type" /> является указателем; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий <xref:System.Type> представляет универсальный тип или параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
 Это свойство доступно только для чтения.  
  
   
  
## Examples  
 В следующем примере показано использование `IsPointer` свойство.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе реализует свойство <see cref="P:System.Type.IsPointer" /> и определяет, является ли объект <see cref="T:System.Type" /> указателем.</summary>
        <returns>
          Значение <see langword="true" />, если <see cref="T:System.Type" /> является указателем; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, является ли <see cref="T:System.Type" /> одним из типов-примитивов.</summary>
        <value>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является одним из типов-примитивов; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Примитивные типы являются <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, и <xref:System.Single>.  
  
 Если текущий <xref:System.Type> представляет универсальный тип или параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
   
  
## Examples  
 В следующем примере демонстрируется `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, и <xref:System.Type.IsPrimitive%2A> свойства <xref:System.Type> класса. Проверяется ли данный тип может размещаться в контексте ли он может быть маршалирован по ссылке и является ли тип примитивный тип данных.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе реализует свойство <see cref="P:System.Type.IsPrimitive" /> и определяет, является ли объект <see cref="T:System.Type" /> одним из типов-примитивов.</summary>
        <returns>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является одним из типов-примитивов; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Примитивные типы являются <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, и <xref:System.Single>.  
  
   
  
## Examples  
 В следующем примере определяется, является ли данный тип типом-примитивом и отображается результат.  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, был ли объект <see cref="T:System.Type" /> объявлен как открытый.</summary>
        <value>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> объявлен как открытый и не является вложенным типом; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не используйте для вложенных типов. Используйте <xref:System.Type.IsNestedPublic%2A> вместо него.  
  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство возвращает `true`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> выбирает атрибуты видимости.  
  
   
  
## Examples  
 В следующем примере создается экземпляр `MyTestClass`, проверяет наличие `IsPublic` свойства и отображается результат.  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 Для вложенных классов игнорировать результаты `IsPublic` и `IsNotPublic` и уделить внимание только результаты <xref:System.Type.IsNestedPublic%2A> и <xref:System.Type.IsNestedPrivate%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, был ли объект <see cref="T:System.Type" /> объявлен как запечатанный.</summary>
        <value>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> объявлен как запечатанный; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий <xref:System.Type> представляет параметр типа универсального типа, это свойство всегда возвращает `true`.  
  
   
  
## Examples  
 В следующем примере создается экземпляр `sealed` класса, проверяется `IsSealed` свойство и отображается результат.  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, которое указывает, является ли текущий тип критически важным для безопасности или защищенным критически важным для безопасности на данном уровне доверия и, следовательно, может ли он выполнять критические операции.</summary>
        <value>
          Значение <see langword="true" />, если текущий тип является критически важным для безопасности или защищенным критически важным для безопасности на текущем уровне доверия; значение <see langword="false" />, если он является прозрачным.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, И <xref:System.Type.IsSecurityTransparent%2A> свойства отчетов уровень прозрачности типа в его текущем уровне доверия, что определяется общеязыковой среды выполнения (CLR). В следующей таблице показаны сочетания этих свойств.  
  
|Уровень безопасности|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critical|`true`|`false`|`false`|  
|Надежным с точки зрения|`true`|`true`|`false`|  
|Прозрачный|`false`|`false`|`true`|  
  
 Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.  
  
> [!IMPORTANT]
>  Для сборок с частичным доверием значение этого свойства зависит от текущего уровня доверия сборки. Если сборка загружается в домен приложения с частичным доверием (например, в изолированном домене приложения), среда выполнения игнорирует примечания безопасности сборки. Сборка и все типы считаются прозрачными. Среда выполнения уделяет внимание заметки безопасности сборки с частичным доверием, только в том случае, если эта сборка загружается в домен приложения с полным доверием (например, в домене приложения по умолчанию для настольного приложения). В отличие от этого доверенной сборке (то есть сборки строгим именем, установленной в глобальном кэше сборок) всегда является загружена с полным доверием независимо от уровня доверия домена приложения, поэтому ее текущий уровень доверия всегда является полностью доверенным. Можно определить текущие уровни доверия сборок и доменов приложений с помощью <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> и <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> свойства.  
  
 Дополнительные сведения о отражение и прозрачность см. в разделе [рекомендации по безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Сведения о прозрачности см. в разделе [изменения системы безопасности](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, которое указывает, является ли текущий тип защищенным критически важным для безопасности на текущем уровне доверия и, следовательно, может ли он выполнять критические операции и предоставлять доступ прозрачному коду.</summary>
        <value>
          Значение <see langword="true" />, если текущий тип является защищенным критически важным для безопасности на текущем уровне доверия; значение <see langword="false" />, если он является критически важным для безопасности или прозрачным.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, И <xref:System.Type.IsSecurityTransparent%2A> свойства отчетов уровень прозрачности типа в его текущем уровне доверия, что определяется общеязыковой среды выполнения (CLR). В следующей таблице показаны сочетания этих свойств.  
  
|Уровень безопасности|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critical|`true`|`false`|`false`|  
|Надежным с точки зрения|`true`|`true`|`false`|  
|Прозрачный|`false`|`false`|`true`|  
  
 Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.  
  
> [!IMPORTANT]
>  Для сборок с частичным доверием значение этого свойства зависит от текущего уровня доверия сборки. Если сборка загружается в домен приложения с частичным доверием (например, в изолированном домене приложения), среда выполнения игнорирует примечания безопасности сборки. Сборка и все типы считаются прозрачными. Среда выполнения уделяет внимание заметки безопасности сборки с частичным доверием, только в том случае, если эта сборка загружается в домен приложения с полным доверием (например, в домене приложения по умолчанию для настольного приложения). В отличие от этого доверенной сборке (то есть сборки строгим именем, установленной в глобальном кэше сборок) всегда является загружена с полным доверием независимо от уровня доверия домена приложения, поэтому ее текущий уровень доверия всегда является полностью доверенным. Можно определить текущие уровни доверия сборок и доменов приложений с помощью <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> и <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> свойства.  
  
 Дополнительные сведения о отражение и прозрачность см. в разделе [рекомендации по безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Сведения о прозрачности см. в разделе [изменения системы безопасности](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, которое указывает, является ли текущий тип прозрачным на текущем уровне доверия и, следовательно, не может выполнять критические операции.</summary>
        <value>
          Значение <see langword="true" />, если текущий тип является прозрачным на текущем уровне доверия; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если это свойство возвращает `true`, <xref:System.Type.IsSecurityCritical%2A> и <xref:System.Type.IsSecuritySafeCritical%2A> возвращаемого свойства `false`.  
  
 <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, И <xref:System.Type.IsSecurityTransparent%2A> свойства отчетов уровень прозрачности типа в его текущем уровне доверия, что определяется общеязыковой среды выполнения (CLR). Использовать эти свойства гораздо проще, чем просматривать заметки о безопасности для сборки и ее типов, проверять текущий уровень доверия и пытаться дублировать правила среды выполнения.  
  
> [!IMPORTANT]
>  Для сборок с частичным доверием значение этого свойства зависит от текущего уровня доверия сборки. Если сборка загружается в домен приложения с частичным доверием (например, в изолированном домене приложения), среда выполнения игнорирует примечания безопасности сборки. Сборка и все типы считаются прозрачными. Среда выполнения уделяет внимание заметки безопасности сборки с частичным доверием, только в том случае, если эта сборка загружается в домен приложения с полным доверием (например, в домене приложения по умолчанию для настольного приложения). В отличие от этого доверенной сборке (то есть сборки строгим именем, установленной в глобальном кэше сборок) всегда является загружена с полным доверием независимо от уровня доверия домена приложения, поэтому ее текущий уровень доверия всегда является полностью доверенным. Можно определить текущие уровни доверия сборок и доменов приложений с помощью <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> и <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> свойства.  
  
 Дополнительные сведения о отражение и прозрачность см. в разделе [рекомендации по безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Сведения о прозрачности см. в разделе [изменения системы безопасности](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, сериализуем ли объект <see cref="T:System.Type" />.</summary>
        <value>
          Значение <see langword="true" />, если объект <see cref="T:System.Type" /> является сериализуемым; в противным случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Типы, которые определены в .NET Standard не отмечены ни <xref:System.SerializableAttribute>. Вместо этого каждая реализация .NET определяет, является ли сериализуемый тип. Во время выполнения, можно использовать <xref:System.Type.IsSerializable%2A> свойства, чтобы определить, поддерживает ли эта реализация сериализации экземпляра типа. Дополнительные сведения и пример см. в разделе [как определить, является ли сериализуемый объект .NET Standard](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, тип был создан. Например если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
   
  
## Examples  
 В следующем примере создается экземпляр `MyTestClass` классе, задает атрибут [Serializable] и проверяет `IsSerializable` свойство `true` или `false`.  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, требует ли имя данного объекта специальной обработки.</summary>
        <value>
          Значение <see langword="true" />, если имя типа требует специальной обработки; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Имена, которые начинаются с или содержать знак подчеркивания (_), к свойствам и методы перегрузки операторов являются примерами типов, которые могут потребовать специальной обработки в некоторых компиляторах.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, тип был создан. Например если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">Тип для сравнения с текущим типом.</param>
        <summary>Определяет, является ли текущий <see cref="T:System.Type" /> производным от указанного <see cref="T:System.Type" />.</summary>
        <returns>
          Значение <see langword="true" />, если текущий объект <see langword="Type" /> является производным от <paramref name="c" />; в противном случае — <see langword="false" />. Этот метод также возвращает значение <see langword="false" />, если параметр <paramref name="c" /> и текущий объект <see langword="Type" /> равны.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно вызвать <xref:System.Type.IsSubclassOf%2A> метод, чтобы определить следующее:  
  
-   Является ли один класс является производным от другого.  
  
-   Является ли тип наследуется от <xref:System.ValueType>. Тем не менее <xref:System.Type.IsValueType%2A> — более эффективный способ определить, является ли тип типом значения.  
  
-   Является ли тип наследуется от <xref:System.Enum>. Однако <xref:System.Type.IsEnum%2A> метода является более эффективный способ определить, является ли тип перечислением.  
  
-   Является ли тип является делегатом, т. е ли он является производным от либо <xref:System.Delegate> или <xref:System.MulticastDelegate>.  
  
 <xref:System.Type.IsSubclassOf%2A> Метод не может использоваться для определения, является ли интерфейс производным от другого интерфейса или ли класс реализует интерфейс. Используйте <xref:System.Type.IsAssignableFrom%2A> метод для этой цели, как показано в следующем примере.  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, он является производным от ограничения своего класса или из <xref:System.Object?displayProperty=nameWithType> , если он не имеет ограничения класса.  
  
> [!NOTE]
>  За исключением случаев использования с интерфейсами, <xref:System.Type.IsSubclassOf%2A> имеет противоположное <xref:System.Type.IsAssignableFrom%2A>. То есть если `t1.IsSubclassOf(t2)` — `true`, затем `t2.IsAssignableFrom(t1)` также `true`.  
  
 Этот метод может быть переопределен в производном классе.  
  
   
  
## Examples  
 В следующем примере создается класс с именем `Class1` и производный класс с именем `DerivedC1`. Он вызывает <xref:System.Type.IsSubclassOf%2A> метод, чтобы показать, что `DerivedC1` является подклассом `Class1`.  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="c" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, выбран ли для объекта <see langword="UnicodeClass" /> атрибут формата строки <see cref="T:System.Type" />.</summary>
        <value>
          Значение <see langword="true" />, если для данного объекта <see langword="UnicodeClass" /> выбран атрибут формата строки <see cref="T:System.Type" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask> Используется для выбора атрибутов формата строки. Атрибуты формата строки расширяют возможности взаимодействия, определение того, как должны интерпретироваться строки.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, тип был создан. Например если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, является ли объект <see cref="T:System.Type" /> типом значения.</summary>
        <value>
          Значение <see langword="true" />, если тип <see cref="T:System.Type" /> является типом значения; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Типы значений — это типы, которые представлены в виде последовательности битов; типы значений не являются классами или интерфейсами. Типы значений, называются «структуры» в некоторых языках программирования. Перечисления являются особым случаем типов значений.  
  
 Это свойство возвращает `false` для <xref:System.ValueType> класса, так как <xref:System.ValueType> не является типом значения, сам. Это базовый класс для всех типов значений, и поэтому к нему можно присвоить значения любого типа. Это нельзя сделать Если <xref:System.ValueType> сам был типом значения. Типы значений, упаковываются при назначении поле типа <xref:System.ValueType>.  
  
 Это свойство возвращает `true` для перечислений, но не для <xref:System.Enum> сами типы. Пример, демонстрирующий это см. в разделе <xref:System.Type.IsEnum%2A>.  
  
 Это свойство доступно только для чтения.  
  
   
  
## Examples  
 В следующем примере создается переменная типа `MyEnum`, проверяет наличие `IsValueType` свойства и отображается результат.  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Реализует свойство <see cref="P:System.Type.IsValueType" /> и определяет, является ли объект <see cref="T:System.Type" /> типом значения (иными словами, не является классом или интерфейсом).</summary>
        <returns>
          Значение <see langword="true" />, если тип <see cref="T:System.Type" /> является типом значения; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется для обеспечения реализации систем альтернативный тип. Обычно оно не используется в коде приложения.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, можно ли получить доступ к объекту <see cref="T:System.Type" /> из кода за пределами сборки.</summary>
        <value>
          Значение <see langword="true" />, если текущий объект <see cref="T:System.Type" /> является открытым типом или открытым вложенным типом, все включающие типы которого также являются открытыми; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте это свойство, чтобы определить, является ли тип частью открытого интерфейса сборки компонентов.  
  
   
  
## Examples  
 В следующем примере кода проверяются два класса, только один из которых отображается за пределами сборки.  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Type" />, который представляет массив текущего типа.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Type" />, представляющий одномерный массив текущего типа с нижней границей, равной нулю.</summary>
        <returns>Объект <see cref="T:System.Type" />, представляющий одномерный массив текущего типа с нижней границей, равной нулю.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A> Метод предоставляет способ создания типов массивов, типы элементов которых вычисляются во время выполнения.  
  
 **Примечание** общеязыковая среда выполнения различает векторов (то есть одномерные массивы, всегда отсчитываемый от нуля) и многомерных массивов. Вектор, который всегда имеет только одно измерение, не совпадает с многомерного массива, которая имеет только одно измерение. Эта перегрузка метода может использоваться только для создания векторных типов, и это единственный способ создания векторных типов. Используйте <xref:System.Type.MakeArrayType%28System.Int32%29> перегрузка метода для создания многомерных массивов.  
  
   
  
## Examples  
 В следующем примере кода создается массив, `ref` (`ByRef` в Visual Basic) и типы указателей для `Test` класса.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Вызванный метод не поддерживается в базовом классе. Реализацию должны обеспечивать производные классы.</exception>
        <exception cref="T:System.TypeLoadException">Текущий тип — <see cref="T:System.TypedReference" />.  
  
 - или -  
  
 Текущий тип — <see langword="ByRef" />. То есть <see cref="P:System.Type.IsByRef" /> возвращает <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">Размерность массива. Это число должно быть меньше либо равно 32.</param>
        <summary>Возвращает объект <see cref="T:System.Type" />, представляющий массив текущего типа указанной размерности.</summary>
        <returns>Объект, представляющий массив текущего типа указанной размерности.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A> Метод предоставляет способ создания типов массивов, типы элементов которых вычисляются во время выполнения.  
  
> [!NOTE]
>  Общеязыковая среда выполнения различает векторов (то есть одномерные массивы, всегда отсчитываемый от нуля) и многомерных массивов. Вектор, который всегда имеет только одно измерение, не совпадает с многомерного массива, которая имеет только одно измерение. Эта перегрузка метода нельзя использовать для создания векторного типа; Если `rank` имеет значение 1, эта перегрузка метода возвращает тип многомерного массива, который имеет одно измерение. Используйте <xref:System.Type.MakeArrayType> перегрузка метода для создания векторных типов.  
  
   
  
## Examples  
 В следующем примере кода создается массив, `ref` (`ByRef` в Visual Basic) и типы указателей для `Test` класса.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="rank" /> недопустим. Например, 0 или отрицательное число.</exception>
        <exception cref="T:System.NotSupportedException">Вызванный метод не поддерживается в базовом классе.</exception>
        <exception cref="T:System.TypeLoadException">Текущий тип — <see cref="T:System.TypedReference" />.  
  
 - или -  
  
 Текущий тип — <see langword="ByRef" />. То есть <see cref="P:System.Type.IsByRef" /> возвращает <see langword="true" />.  
  
 - или -  
  
 Значение <paramref name="rank" /> больше 32.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Type" />, который представляет текущий тип при передаче в качестве параметра <see langword="ref" /> (параметра <see langword="ByRef" /> в Visual Basic).</summary>
        <returns>Объект <see cref="T:System.Type" />, который представляет текущий тип при передаче в качестве параметра <see langword="ref" /> (параметра <see langword="ByRef" /> в Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeByRefType%2A> Метод предоставляет способ создания `ref` типов (`ByRef` в Visual Basic) для параметра перечислены.  
  
 С помощью синтаксиса кода промежуточного языка Майкрософт (MSIL), если текущий <xref:System.Type> представляет <xref:System.Int32>, этот метод возвращает <xref:System.Type> , представляющий `Int32&`.  
  
   
  
## Examples  
 В следующем примере кода создается массив, `ref` (`ByRef` в Visual Basic) и типы указателей для `Test` класса.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Вызванный метод не поддерживается в базовом классе.</exception>
        <exception cref="T:System.TypeLoadException">Текущий тип — <see cref="T:System.TypedReference" />.  
  
 - или -  
  
 Текущий тип — <see langword="ByRef" />. То есть <see cref="P:System.Type.IsByRef" /> возвращает <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">Массив типов, который должен быть замещен параметрами типа текущего универсального типа.</param>
        <summary>Замещает элементы массива типов для параметров определения текущего универсального типа и возвращает объект <see cref="T:System.Type" />, представляющий сконструированный результирующий тип.</summary>
        <returns>
          <see cref="T:System.Type" /> представляет сконструированный тип, сформированный путем замещения элементов объекта <paramref name="typeArguments" /> параметрами текущего универсального типа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeGenericType%2A> Метод позволяет написать код, который назначает определенные типы параметров типа определения универсального типа, тем самым создавая <xref:System.Type> , представляющий определенный сконструированный тип. Эту функцию можно использовать <xref:System.Type> для создания экземпляров во время выполнения сконструированного типа.  
  
 Созданы типы с <xref:System.Type.MakeGenericType%2A> может быть открыт, то есть некоторые их аргументы могут быть параметры типа заключающих универсальных методов или типов. Такие открытые сконструированные типы можно использовать, когда порождение динамических сборок. Например, рассмотрим классы `Base` и `Derived` в следующем коде.  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 Для создания `Derived` в динамической сборке, необходимо построить его базовый тип. Чтобы сделать это, вызовите <xref:System.Type.MakeGenericType%2A> метод <xref:System.Type> объект, представляющий класс `Base`, с помощью аргументов универсального типа <xref:System.Int32> и параметр типа `V` из `Derived`. Поскольку типы и параметры универсального типа представлены по <xref:System.Type> объектов, можно передать массив, содержащий оба <xref:System.Type.MakeGenericType%2A> метод.  
  
> [!NOTE]
>  Сконструированный тип, такой как `Base<int, V>` удобно при выпуске кода, но не может вызывать <xref:System.Type.MakeGenericType%2A> метода для данного типа, так как он не является определением универсального типа. Чтобы создать закрытым сконструированным типом может быть создан, сначала вызовите <xref:System.Type.GetGenericTypeDefinition%2A> метод, чтобы получить <xref:System.Type> объект, представляющий определение универсального типа, а затем вызвать <xref:System.Type.MakeGenericType%2A> с аргументами нужного типа.  
  
 <xref:System.Type> Объект, возвращаемый <xref:System.Type.MakeGenericType%2A> совпадает со значением <xref:System.Type> получается вызовом <xref:System.Object.GetType%2A> метод итоговый сконструированный тип, или <xref:System.Object.GetType%2A> метод любого сконструированный тип, который был создан из того же универсального Определение типа, используя те же аргументы типа.  
  
> [!NOTE]
>  Массив универсальных типов сам по себе не является универсальным типом. Не удается вызвать <xref:System.Type.MakeGenericType%2A> на массив типов, такие как `C<T>[]` (`Dim ac() As C(Of T)` в Visual Basic). Для создания закрытого универсального типа из `C<T>[]`, вызовите <xref:System.Type.GetElementType%2A> для получения определения универсального типа `C<T>`; вызвать <xref:System.Type.MakeGenericType%2A> в определении универсального типа для создания сконструированного типа; Наконец вызовите <xref:System.Type.MakeArrayType%2A> метод сконструированный тип, чтобы создать тип массива. То же самое справедливо для типов указателей и `ref` типов (`ByRef` в Visual Basic).  
  
 Список неизменяемых условий для терминов, используемых в отражении универсальных типов, см. в примечаниях к описанию свойства <xref:System.Type.IsGenericType%2A>.  
  
## <a name="nested-types"></a>Вложенные типы  
 Если универсальный тип определен с помощью C#, C++ или Visual Basic, его вложенные типы являются универсальными. Это верно, даже если вложенные типы не имеют тип параметров своих собственных, так как все три языка включать параметры типа заключающих типов в список параметров вложенных типов. Рассмотрим следующие классы:  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 Список параметров типа вложенного класса `Inner` имеет два параметра типа, `T` и `U`, первый из которых представляет собой параметр типа включающего класса. Аналогичным образом, список параметров типа вложенного класса `Innermost1` имеет три параметра типа `T`, `U`, и `V`, с `T` и `U` поступающих классами. Вложенный класс `Innermost2` имеет два параметра типа, `T` и `U`, которой принадлежат классами.  
  
 Если список параметров типа включающего более одного параметра типа, все параметры типа в порядке включаются в списке параметров типа вложенного типа.  
  
 Для создания универсального типа в определении универсального типа для вложенного типа, вызовите <xref:System.Type.MakeGenericType%2A> метод с массивом, сформированном путем объединения массивов аргументов всех заключающих типов, начиная с внешней универсального типа, и заканчивая Массив аргументов типа вложенного типа, если он имеет свои собственные параметры типов. Чтобы создать экземпляр `Innermost1`, вызовите <xref:System.Type.MakeGenericType%2A> метод с массив, содержащий три типа, присваиваемое T, U и V. Чтобы создать экземпляр `Innermost2`, вызовите <xref:System.Type.MakeGenericType%2A> метод с массив, содержащий два типа, присваиваемое T и U.  
  
 Языки программирования распространяют параметры типа заключающих типов таким образом, чтобы можно было использовать для определения полей вложенных типов, параметры типа вмещающего типа. В противном случае параметров типа не будут находиться в области внутри тела вложенных типов. Можно определить без распространения параметров включающего типа, с помощью выпуска кода в динамических сборках или с помощью вложенных типов [Ilasm.exe (ассемблер IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md). Рассмотрим следующий код для обработки ассемблером MSIL.  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 В этом примере не удается определить тип поля `T` или `U` в классе `Innermost`, так как эти параметры типов находятся вне области. В следующем примере кода ассемблера определяет вложенные классы, которые ведут себя так, определенных в C++, Visual Basic и C#:  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 Можно использовать [Ildasm.exe (дизассемблер IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) для Изучите вложенные классы, определенные в высокоуровневых языках и посмотрите, такая схема именования.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Type.MakeGenericType%2A> метод для создания сконструированного типа определения универсального типа для <xref:System.Collections.Generic.Dictionary%602> типа. Представляет сконструированный тип <xref:System.Collections.Generic.Dictionary%602> из `Test` объектов, содержащих строковые ключи.  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Текущий тип не представляет определение универсального типа. То есть <see cref="P:System.Type.IsGenericTypeDefinition" /> возвращает <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="typeArguments" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Любой элемент <paramref name="typeArguments" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Число элементов объекта <paramref name="typeArguments" /> не совпадает с числом параметров типа в текущем определении универсального типа.  
  
 - или -  
  
 Ни в одном из элементов объекта <paramref name="typeArguments" /> не соблюдаются ограничения, заданные для соответствующего параметра текущего универсального типа.  
  
 - или -  
  
 <paramref name="typeArguments" /> содержит элемент, представляющий собой тип указателя (<see cref="P:System.Type.IsPointer" /> возвращает <see langword="true" />), тип ByRef (<see cref="P:System.Type.IsByRef" /> возвращает <see langword="true" />) или <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.NotSupportedException">Вызванный метод не поддерживается в базовом классе. Реализацию должны обеспечивать производные классы.</exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Type" />, который представляет указатель на текущий тип.</summary>
        <returns>Объект <see cref="T:System.Type" />, который представляет указатель на текущий тип.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakePointerType%2A> Метод предоставляет способ создания типов указателей для списки параметров.  
  
 С помощью синтаксиса кода промежуточного языка Майкрософт (MSIL), если текущий <xref:System.Type> представляет <xref:System.Int32>, этот метод возвращает <xref:System.Type> , представляющий `Int32*`.  
  
   
  
## Examples  
 В следующем примере кода создается массив, `ref` (`ByRef` в Visual Basic) и типы указателей для `Test` класса.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Вызванный метод не поддерживается в базовом классе.</exception>
        <exception cref="T:System.TypeLoadException">Текущий тип — <see cref="T:System.TypedReference" />.  
  
 - или -  
  
 Текущий тип — <see langword="ByRef" />. То есть <see cref="P:System.Type.IsByRef" /> возвращает <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение <see cref="T:System.Reflection.MemberTypes" />, позволяющее определить, каким типом является этот член: обычным или вложенным.</summary>
        <value>Значение <see cref="T:System.Reflection.MemberTypes" />, позволяющее определить, каким типом является этот член: обычным или вложенным.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство переопределяет <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>. Таким образом, при рассмотрении набор <xref:System.Reflection.MemberInfo> объектов — например, массив, возвращаемый методом <xref:System.Type.GetMembers%2A>— <xref:System.Reflection.MemberInfo.MemberType%2A> возвращает <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> Если данный элемент является вложенным типом.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство применяется к определению универсального типа, тип был создан. Например если текущий <xref:System.Type> представляет `MyGenericType<int>` (`MyGenericType(Of Integer)` в Visual Basic), значение этого свойства определяется `MyGenericType<T>`.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство всегда возвращает <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере кода показан `MemberType` поля в качестве параметра `GetMember` метод:  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Представляет отсутствующее значение в данных объекта <see cref="T:System.Type" />. Это поле доступно только для чтения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте `Missing` для вызова через отражение для получения значения параметра по умолчанию. Если `Missing` передается в качестве значения параметра, и нет значения по умолчанию для этого параметра <xref:System.ArgumentException> возникает исключение.  
  
   
  
## Examples  
 В следующем примере кода показано использование `Missing` поля для вызова метода с аргументами по умолчанию.  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 Этот код выводит следующие результаты:  
  
 = 10, b = 55.3 c = 12  
  
 = 10, b = 1.3 c = 1  
  
 = 10, b = 1.2 c = 1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает модуль (DLL), в котором определен текущий объект <see cref="T:System.Type" />.</summary>
        <value>Модуль, в котором определен текущий объект <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство возвращает модуль, в котором определен определение универсального типа. Например, если создать экземпляр `MyGenericStack<int>`, <xref:System.Type.Module%2A> свойство для сконструированного типа возвращает модуль, в котором `MyGenericStack<T>` определен.  
  
 Аналогично Если текущий <xref:System.Type> представляет универсальный параметр `T`, это свойство возвращает сборку, которая содержит универсальный тип, определяющий `T`.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Type.Namespace%2A> и `Module` свойства и <xref:System.Type.ToString%2A> метод <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает пространство имен объекта <see cref="T:System.Type" />.</summary>
        <value>Пространство имен <see cref="T:System.Type" /> или значение <see langword="null" />, если текущий экземпляр не имеет пространства имен или представляет универсальный параметр.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пространство имен — логические разработки именования удобства используются главным образом для определения области в приложении и организовать классов и других типов в одну иерархическую структуру. С точки зрения среды выполнения отсутствуют пространства имен.  
  
 Если текущий <xref:System.Type> представляет сконструированный универсальный тип, это свойство возвращает пространство имен, содержащее определение универсального типа. Аналогично Если текущий <xref:System.Type> представляет универсальный параметр `T`, это свойство возвращает пространство имен, содержащее определение универсального типа, который определяет `T`.  
  
 Если текущий <xref:System.Type> объект представляет универсальный параметр, это свойство возвращает `null`.  
  
   
  
## Examples  
 В следующем примере показано использование `Namespace` и <xref:System.Type.Module%2A> свойства и <xref:System.Type.ToString%2A> метод <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">Первый из сравниваемых объектов.</param>
        <param name="right">Второй из сравниваемых объектов.</param>
        <summary>Определение равенства двух объектов <see cref="T:System.Type" />.</summary>
        <returns>
          <see langword="true" />, если значения параметров <paramref name="left" /> и <paramref name="right" /> равны; в противном случае — <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">Первый из сравниваемых объектов.</param>
        <param name="right">Второй из сравниваемых объектов.</param>
        <summary>Определяет неравенство двух объектов <see cref="T:System.Type" />.</summary>
        <returns>
          <see langword="true" />, если значения <paramref name="left" /> и <paramref name="right" /> не равны; в противном случае — <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект класса, который использовался для получения этого члена.</summary>
        <value>Объект <see langword="Type" />, с помощью которого был получен данный объект <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для <xref:System.Type> объекты, значение этого свойства всегда является таким же, как значение <xref:System.Type.DeclaringType%2A> свойства.  
  
   
  
## Examples  
 Этот пример отображает отраженный тип вложенного класса.  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Имя искомого типа <see cref="T:System.Type" /> с указанием сборки.</param>
        <param name="throwIfNotFound">
          Значение <see langword="true" />, чтобы в случае невозможности найти тип создавалось исключение <see cref="T:System.TypeLoadException" />; значение <see langword="false" />, чтобы при невозможности найти тип возвращалось значение <see langword="null" />. Кроме того, при указании значения <see langword="false" /> подавляются некоторые другие условия возникновения исключений, но не все из них. См. раздел "Исключения".</param>
        <param name="ignoreCase">
          Значение <see langword="true" />, чтобы не учитывать регистр при поиске <c>typeName</c>; значение <see langword="false" />, чтобы учитывать регистр при поиске <c>typeName</c>.</param>
        <summary>Возвращает объект <see cref="T:System.Type" /> с заданным именем, позволяющий определить, будет ли учитываться регистр при поиске, и будет ли создаваться исключение в случае невозможности найти тип. Тип загружается не для выполнения, а только для отражения.</summary>
        <returns>Тип с указанным именем, если он существует; в противном случае — значение <see langword="null" />. Если тип не найден, параметр <paramref name="throwIfNotFound" /> определяет дальнейшее действие — возврат значения <see langword="null" /> или создание исключения. В некоторых случаях исключение создается независимо от значения параметра <paramref name="throwIfNotFound" />. См. раздел "Исключения".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если сборка, содержащая тип еще не загружена в контекст только для отражения, с помощью <xref:System.Type.ReflectionOnlyGetType%2A> метод является эквивалентно первой загрузки сборки, а только для отражения с помощью <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> метода и затем загружать тип путем вызова сборки <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> метод. Сведения об именах с указанием сборки см. в разделе <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> свойство. Дополнительные сведения об указании имен типа <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> перегрузки метода.  
  
 Если сборка уже загружена для выполнения, другая копия загружается в контекст только для отражения.  
  
 `throwIfNotFound` Параметр указывает, что произойдет, если тип не найден, а также подавляются некоторые другие условия возникновения исключений, как описано в раздел "исключения". Некоторые исключения выдаются независимо от значения `throwIfNotFound`. Например, если сборка не является допустимым <xref:System.BadImageFormatException> возникает, даже если `throwIfNotFound` — `false`.  
  
 Дополнительные сведения об использовании в контексте только для отражения см. в разделе [как: загрузка сборки контекста, предназначенного](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Инициализатор класса вызывается и создает исключение.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwIfNotFound" /> имеет значение <see langword="true" />, и тип не найден.  
  
 - или -  
  
 <paramref name="throwIfNotFound" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимые знаки, например внедренные табуляции.  
  
 - или -  
  
 <paramref name="throwIfNotFound" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> является пустой строкой.  
  
 - или -  
  
 <paramref name="throwIfNotFound" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> представляет тип массива с недопустимым размером.  
  
 - или -  
  
 <paramref name="typeName" /> представляет массив объектов <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> не включает имя сборки.  
  
 - или -  
  
 <paramref name="throwIfNotFound" /> имеет значение <see langword="true" />, и <paramref name="typeName" /> содержит недопустимый синтаксис (например, "MyType[,*,]").  
  
 - или -  
  
 <paramref name="typeName" /> представляет универсальный тип, имеющий тип указателя, тип <see langword="ByRef" /> или <see cref="T:System.Void" /> в качестве одного из его аргументов типа.  
  
 - или -  
  
 <paramref name="typeName" /> представляет универсальный тип, который содержит неправильное количество аргументов типа.  
  
 - или -  
  
 <paramref name="typeName" /> представляет универсальный тип, и один из его аргументов типа не удовлетворяет ограничениям для соответствующего параметра типа.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwIfNotFound" /> имеет значение <see langword="true" />, и не удалось найти сборку либо одну из ее зависимостей.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или одна из ее зависимостей найдена, но не может быть загружена.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка или одна из ее зависимостей является недопустимой.  
  
 - или -  
  
 Сборка была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает атрибут <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />, описывающий структуру текущего типа.</summary>
        <value>Возвращает атрибут <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />, описывающий общие особенности структуры текущего типа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute> не возвращается <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> метод. Используйте это свойство для получения его.  
  
   
  
## Examples  
 В следующем примере сначала определяется класс, структура и структура с особыми атрибутами размещения (структуры вложены в пределах класса). Затем в примере используется <xref:System.Type.StructLayoutAttribute%2A> , чтобы получить <xref:System.Runtime.InteropServices.StructLayoutAttribute> для каждого типа и отображает свойства атрибутов.  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Вызванный метод не поддерживается в базовом классе.</exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Зарезервировано для будущего использования. Должно быть равным IID_NULL.</param>
        <param name="rgszNames">Переданный массив имен, которые необходимо сопоставить.</param>
        <param name="cNames">Количество сопоставляемых имен.</param>
        <param name="lcid">Контекст языкового стандарта для интерпретации имен.</param>
        <param name="rgDispId">Массив, зарезервированный вызывающим объектом, куда помещаются идентификаторы, соответствующие именам.</param>
        <summary>Сопоставляет набор имен соответствующему набору идентификаторов диспетчеризации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetIDsOfNames`, см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Возвращаемые сведения о типе.</param>
        <param name="lcid">Идентификатор языкового стандарта для сведений о типе.</param>
        <param name="ppTInfo">Указатель на объект с запрошенными сведениями о типе.</param>
        <summary>Возвращает сведения о типе объекта, которые затем могут использоваться для получения сведений о типе интерфейса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetTypeInfo`, см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Указатель, по которому записывается число предоставляемых объектом интерфейсов, предназначенных для получения сведений о типе.</param>
        <summary>Возвращает количество предоставляемых объектом интерфейсов для доступа к сведениям о типе (0 или 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetTypeInfoCount`, см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Идентифицирует член.</param>
        <param name="riid">Зарезервировано для будущего использования. Должно быть равным IID_NULL.</param>
        <param name="lcid">Контекст языкового стандарта, в котором следует интерпретировать аргументы.</param>
        <param name="wFlags">Флаги, описывающие контекст вызова.</param>
        <param name="pDispParams">Указатель на структуру, содержащую массив аргументов, массив DISPID для именованных аргументов, а также счетчики количества элементов в массивах.</param>
        <param name="pVarResult">Указатель, по которому будет сохранен результат.</param>
        <param name="pExcepInfo">Указатель на структуру, содержащую сведения об исключении.</param>
        <param name="puArgErr">Индекс первого аргумента, вызвавшего ошибку.</param>
        <summary>Предоставляет доступ к открытым свойствам и методам объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::Invoke`, см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает объект типа <see langword="String" />, представляющий имя текущего объекта <see langword="Type" />.</summary>
        <returns>Объект типа <see cref="T:System.String" />, представляющий имя текущего объекта <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает полное имен среды CLR и имя для всех типов-примитивов. Например, C# инструкция `(long)0.Type().ToString()` возвращает «System.Int64», а не просто «Int64».  
  
 Если текущий <xref:System.Type> представляет универсальный тип, тип и его аргументов типа квалифицируются пространством имен и вложенных типов, но не в сборке. Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или универсального метода, этот метод возвращает неполное имя параметра типа.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Type.Namespace%2A> и <xref:System.Type.Module%2A> свойства и `ToString` метод <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 В следующем примере сравниваются строки, возвращаемые <xref:System.Type.ToString%2A> метод и `Name`, <xref:System.Type.FullName%2A>, и <xref:System.Type.AssemblyQualifiedName%2A> свойства.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает дескриптор текущего объекта <see cref="T:System.Type" />.</summary>
        <value>Дескриптор текущего объекта <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle` Инкапсулирует указатель на внутреннюю структуру данных, представляющий тип. Этот дескриптор является уникальным во время существования процесса. Дескриптор действителен только в домене приложения, в котором они были получены.  
  
   
  
## Examples  
 Следующий пример возвращает дескриптор соответствующего типа и передает дескриптор метода, который возвращает тип из дескриптора и отображает его.  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Платформа .NET Compact Framework в настоящее время не поддерживает это свойство.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает инициализатор типа.</summary>
        <value>Объект, содержащий имя конструктора класса <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Инициализаторы класса, также доступны через <xref:System.Type.FindMembers%2A> метод, или с помощью перегрузки <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, и <xref:System.Type.GetConstructors%2A> методов, которые принимают <xref:System.Reflection.BindingFlags> как параметр.  
  
 Если текущий <xref:System.Type> представляет параметр типа в определении универсального типа или метода, это свойство возвращает `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Указывает на тип, предоставляемый средой CLR, представляющей этот тип.</summary>
        <value>Базовый системный тип текущего типа <see cref="T:System.Type" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>