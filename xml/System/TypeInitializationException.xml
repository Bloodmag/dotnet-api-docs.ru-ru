<Type Name="TypeInitializationException" FullName="System.TypeInitializationException">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="2f794ef69f9e93c12a84b385905444466972f9b5" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36427673" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class TypeInitializationException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit TypeInitializationException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.TypeInitializationException" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class TypeInitializationException&#xA;Inherits SystemException" />
  <TypeSignature Language="C++ CLI" Value="public ref class TypeInitializationException sealed : SystemException" />
  <TypeSignature Language="F#" Value="type TypeInitializationException = class&#xA;    inherit SystemException" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Исключение, которое выбрасывается как оболочка для исключения, выброшенного инициализатором класса. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если инициализация типа инициализатором класса завершилась сбоем, то будет создан объект <xref:System.TypeInitializationException>, которому будет передана ссылка на исключение, созданное инициализатором класса этого типа. <xref:System.Exception.InnerException%2A> Свойство <xref:System.TypeInitializationException> базовое исключение заносится.  
  
 Как правило <xref:System.TypeInitializationException> исключение отражает катастрофический условие (среда выполнения не удается создать экземпляр типа), не позволяет приложению продолжать.  Чаще всего <xref:System.TypeInitializationException> вызывается в ответ на некоторые изменения в среде выполнения приложения. Следовательно, отличных от возможно для устранения неполадок отладки кода, исключение должно обрабатываться в `try` / `catch` блока. Вместо этого необходимо изучить и устранить причину исключения.  
  
 <xref:System.TypeInitializationException> использует COR_E_TYPEINITIALIZATION HRESULT, который имеет значение 0x80131534.  
  
 Список начальных значений свойств для экземпляра <xref:System.TypeInitializationException>, в разделе <xref:System.TypeInitializationException.%23ctor%2A> конструкторы.  
  
 В следующих разделах описаны некоторые из ситуаций, в котором <xref:System.TypeInitializationException> исключения.  
  
 [Статические конструкторы и TypeInitializationException-исключение](#Static)   
 [Значения времени ожидания совпадения регулярного выражения](#Timeout)   
 [Календари и региональные данные](#Calendars)  
  
<a name="Static"></a>   
## <a name="static-constructors-and-the-typeinitializationexception-exception"></a>Статические конструкторы и TypeInitializationException-исключение  
 Статический конструктор, если оно существует, вызывается автоматически средой выполнения до создания экземпляра типа. Статические конструкторы могут явно определены разработчиком. Если статический конструктор не определена явно, компиляторы автоматически создать для инициализации любой `static` (в C#) или `Shared` (в Visual Basic) члены типа.  Дополнительные сведения о статических конструкторов см. в разделе [статические конструкторы](~/docs/csharp/programming-guide/classes-and-structs/static-constructors.md).  
  
 Чаще всего <xref:System.TypeInitializationException> исключение вызывается, когда статический конструктор не удается создать экземпляр типа.  <xref:System.Exception.InnerException%2A> Свойство указывает, почему статический конструктор не удалось создать экземпляр типа. Некоторые из наиболее распространенных причин <xref:System.TypeInitializationException> в список исключений:  
  
 Необработанное исключение в статическом конструкторе  
 Если исключение в статическом конструкторе, это исключение заключается в <xref:System.TypeInitializationException> исключение и тип не может быть создан.  
  
 Что часто делает это исключение затруднено Устранение неполадок — что всегда явно статические конструкторы не определены в исходном коде. Статический конструктор существует в типе, если:  
  
-   Он был явно определен как члена типа.  
  
-   Тип имеет `static` (в C#) или `Shared` (в Visual Basic) переменных, которые объявляются и инициализируются в одной инструкции. В этом случае компилятор языка создает статический конструктор для типа. Вы можете проверить при помощи программы, такие как [дизассемблер IL](~/docs/framework/tools/ildasm-exe-il-disassembler.md). К примеру при компиляции приведенный ниже, компиляторы C# и VB, они создания IL для статический конструктор, подобный следующему:  
  
    ```  
  
    .method private specialname rtspecialname static   
            void  .cctor() cil managed  
    {  
      // Code size       12 (0xc)  
      .maxstack  8  
      IL_0000:  ldc.i4.3  
      IL_0001:  newobj     instance void TestClass::.ctor(int32)  
      IL_0006:  stsfld     class TestClass Example::test  
      IL_000b:  ret  
    } // end of method Example::.cctor  
  
    ```  
  
 В следующем примере показан <xref:System.TypeInitializationException> исключение, вызванное статический конструктор, созданный компилятором. `Example` Класс включает `static` (в C#) или `Shared` (в Visual Basic) поля типа `TestClass` , создается путем передачи его конструктору класса значение 3.  Это значение, тем не менее, недопустимо; разрешены только значения 0 или 1. В результате `TestClass` вызывает конструктор класса <xref:System.ArgumentOutOfRangeException>. Так как это исключение не обработано, оно помещается в <xref:System.TypeInitializationException> исключение.  
  
 [!code-csharp[System.TypeInitializationException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.TypeInitializationException/cs/ctorException1.cs#3)]
 [!code-vb[System.TypeInitializationException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.TypeInitializationException/vb/CtorException1.vb#3)]  
  
 Обратите внимание, что сообщение об исключении отображаются сведения о <xref:System.Exception.InnerException%2A> свойство.  
  
 Отсутствующий файл сборки или данных  
 Наиболее распространенной причиной <xref:System.TypeInitializationException> исключение, что файл сборки или данных, который присутствовал в средах разработки и тестирования приложения отсутствует его средой выполнения. Например, можно скомпилировать в следующем примере сборка с именем Missing1a.dll с помощью этого синтаксиса командной строки:  
  
```csharp  
csc /t:library Missing1a.cs  
```  
  
```vb  
vbc Missing1a.vb /t:library  
```  
  
 [!code-csharp[System.TypeInitializationException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.TypeInitializationException/cs/Missing1a.cs#1)]
 [!code-vb[System.TypeInitializationException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.TypeInitializationException/vb/Missing1a.vb#1)]  
  
 Затем можно скомпилировать в следующем примере исполняемый файл с именем Missing1.exe, включая ссылку на Missing1a.dll:  
  
```csharp  
csc Missing1.cs /r:Missing1a.dll  
```  
  
```vb  
vbc Missing1.vb /r:Missing1a.dll  
```  
  
 Однако если переименовать, переместить, или удалить Missing1a.dll и выполнения примера создается <xref:System.TypeInitializationException> исключение и отображает выходные данные, показанные в примере.  Обратите внимание, что сообщение об исключении включает сведения о <xref:System.Exception.InnerException%2A> свойство. В этом случае является внутренним исключением <xref:System.IO.FileNotFoundException> , создается исключение, так как среда выполнения не удается найти зависимые сборки.  
  
 [!code-csharp[System.TypeInitializationException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.TypeInitializationException/cs/Missing1.cs#2)]
 [!code-vb[System.TypeInitializationException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.TypeInitializationException/vb/Missing1.vb#2)]  
  
> [!NOTE]
>  В этом примере <xref:System.TypeInitializationException> возникло исключение, так как не удалось загрузить сборку. Если статический конструктор пытается открыть файл данных, таких как файл конфигурации, в XML-файл или файл, содержащий сериализованные данные, который ему не удается найти, можно также вызывается исключение.  
  
<a name="Timeout"></a>   
## <a name="regular-expression-match-timeout-values"></a>Значения времени ожидания совпадения регулярного выражения  
 Можно задать значение времени ожидания по умолчанию для операции на основе на уровне домена приложения сопоставления шаблона регулярного выражения. Время ожидания определяется путем указания <xref:System.TimeSpan> значение для свойства «REGEX_DEFAULT_MATCH_TIMEOUT» для <xref:System.AppDomain.SetData%2A?displayProperty=nameWithType> метод. Интервал времени должен быть допустимым <xref:System.TimeSpan> объекта, который больше нуля и меньше, чем приблизительно 24 дня. Если эти требования не выполнены, попытка установить значение времени ожидания по умолчанию вызывает <xref:System.ArgumentOutOfRangeException>, который, в свою очередь, упаковывается в <xref:System.TypeInitializationException> исключение.  
  
 В следующем примере показан <xref:System.TypeInitializationException> , возникает, когда значение присваивается свойству «REGEX_DEFAULT_MATCH_TIMEOUT» является недопустимым. Чтобы устранить исключение, свойство имеет значение «REGEX_DEFAULT_MATCH_TIMEOUT» <xref:System.TimeSpan> значение, которое больше нуля и меньше, чем приблизительно 24 дня.  
  
 [!code-csharp[System.TypeInitializationException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.TypeInitializationException/cs/Regex1.cs#4)]
 [!code-vb[System.TypeInitializationException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.TypeInitializationException/vb/Regex1.vb#4)]  
  
<a name="Calendars"></a>   
## <a name="calendars-and-cultural-data"></a>Календари и региональные данные  
 При попытке создать календарь, но среда выполнения не удается создать экземпляр <xref:System.Globalization.CultureInfo> объект, соответствующий календарь, он выдает <xref:System.TypeInitializationException> исключение. Это исключение может возникнуть конструкторами следующих классов календаря:  
  
-   Конструктор по умолчанию для <xref:System.Globalization.JapaneseCalendar> класса.  
  
-   Конструктор по умолчанию для <xref:System.Globalization.KoreanCalendar> класса.  
  
-   Конструктор по умолчанию для <xref:System.Globalization.TaiwanCalendar> класса.  
  
 Поскольку региональные данные для этих языков и региональных параметров, должны быть доступны во всех системах, возникает редко, если когда-либо, это исключение.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Exception" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TypeInitializationException (string fullTypeName, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fullTypeName, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TypeInitializationException.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fullTypeName As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TypeInitializationException(System::String ^ fullTypeName, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new TypeInitializationException : string * Exception -&gt; TypeInitializationException" Usage="new System.TypeInitializationException (fullTypeName, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fullTypeName" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="fullTypeName">Полное имя типа, который не удалось инициализировать.</param>
        <param name="innerException">Исключение, которое является причиной текущего исключения. Если параметр <c>innerException</c> не является пустой ссылкой (<see langword="Nothing" /> в Visual Basic), текущее исключение создается в блоке <see langword="catch" />, обрабатывающем внутреннее исключение.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.TypeInitializationException" /> используемым по умолчанию сообщением об ошибке, указанным именем типа и ссылкой на внутреннее исключение, которое является основной причиной возникновения данного исключения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Исключение, созданное как прямой результат предыдущего исключения, может содержать в свойстве <xref:System.Exception.InnerException%2A> ссылку на предыдущее исключение. Свойство <xref:System.Exception.InnerException%2A> возвращает то же значение, которое передается конструктору, или пустую ссылку (`Nothing` в Visual Basic), если свойство <xref:System.Exception.InnerException%2A> не предоставляет конструктору значение внутреннего исключения.  
  
 В следующей таблице представлены исходные значения свойств экземпляра класса <xref:System.TypeInitializationException>.  
  
|Свойство.|Значение|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Ссылка на внутреннее исключение.|  
|<xref:System.Exception.Message%2A>|Строка локализованного сообщения об ошибке.|  
|<xref:System.TypeInitializationException.TypeName%2A>|Имя типа.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Exception" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public override void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.TypeInitializationException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="typeInitializationException.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" />, хранящий сериализованные данные объекта, относящиеся к выдаваемому исключению.</param>
        <param name="context">Объект <see cref="T:System.Runtime.Serialization.StreamingContext" />, содержащий контекстные сведения об источнике или назначении.</param>
        <summary>Задает имя типа и дополнительные сведения об исключении для объекта <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="TypeName">
      <MemberSignature Language="C#" Value="public string TypeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TypeName" />
      <MemberSignature Language="DocId" Value="P:System.TypeInitializationException.TypeName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TypeName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeName : string" Usage="System.TypeInitializationException.TypeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает полное имя типа, который не удалось инициализировать.</summary>
        <value>Полное имя типа, который не удалось инициализировать.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>